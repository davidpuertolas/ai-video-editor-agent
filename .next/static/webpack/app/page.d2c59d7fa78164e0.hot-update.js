"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./features/editor/timeline/ruler.tsx":
/*!********************************************!*\
  !*** ./features/editor/timeline/ruler.tsx ***!
  \********************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _constants_constants__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../constants/constants */ \"(app-pages-browser)/./features/editor/constants/constants.ts\");\n/* harmony import */ var _utils_format__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/format */ \"(app-pages-browser)/./features/editor/utils/format.ts\");\n/* harmony import */ var _store_use_store__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../store/use-store */ \"(app-pages-browser)/./features/editor/store/use-store.ts\");\n/* harmony import */ var lodash_debounce__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! lodash/debounce */ \"(app-pages-browser)/./node_modules/lodash/debounce.js\");\n/* harmony import */ var lodash_debounce__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(lodash_debounce__WEBPACK_IMPORTED_MODULE_5__);\n\nvar _s = $RefreshSig$();\n\n\n\n\n\nconst Ruler = (props)=>{\n    _s();\n    const { height = 42, longLineSize = 14, shortLineSize = 8, offsetX = _constants_constants__WEBPACK_IMPORTED_MODULE_2__.TIMELINE_OFFSET_X + _constants_constants__WEBPACK_IMPORTED_MODULE_2__.TIMELINE_OFFSET_CANVAS_LEFT, textOffsetY = 12, textFormat = _utils_format__WEBPACK_IMPORTED_MODULE_3__.formatTimelineUnit, scrollLeft: scrollPos = 0, onClick } = props;\n    const { scale } = (0,_store_use_store__WEBPACK_IMPORTED_MODULE_4__[\"default\"])();\n    const canvasRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const [canvasContext, setCanvasContext] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [canvasSize, setCanvasSize] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)({\n        width: 0,\n        height: height\n    });\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        const canvas = canvasRef.current;\n        if (canvas) {\n            const context = canvas.getContext(\"2d\");\n            setCanvasContext(context);\n            resize(canvas, context, scrollPos);\n        }\n    }, []);\n    const handleResize = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(()=>{\n        resize(canvasRef.current, canvasContext, scrollPos);\n    }, [\n        canvasContext,\n        scrollPos\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        const resizeHandler = lodash_debounce__WEBPACK_IMPORTED_MODULE_5___default()(handleResize, 200);\n        window.addEventListener(\"resize\", resizeHandler);\n        return ()=>{\n            window.removeEventListener(\"resize\", resizeHandler);\n        };\n    }, [\n        handleResize\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (canvasContext) {\n            resize(canvasRef.current, canvasContext, scrollPos);\n        }\n    }, [\n        canvasContext,\n        scrollPos,\n        scale\n    ]);\n    const resize = (canvas, context, scrollPos)=>{\n        if (!canvas || !context) return;\n        const offsetParent = canvas.offsetParent;\n        var _offsetParent_offsetWidth;\n        const width = (_offsetParent_offsetWidth = offsetParent === null || offsetParent === void 0 ? void 0 : offsetParent.offsetWidth) !== null && _offsetParent_offsetWidth !== void 0 ? _offsetParent_offsetWidth : canvas.offsetWidth;\n        const height = canvasSize.height;\n        // Set actual size in memory (scaled to account for extra pixel density)\n        const scale = window.devicePixelRatio;\n        canvas.width = width * scale;\n        canvas.height = height * scale;\n        // Normalize coordinate system to use CSS pixels\n        context.scale(scale, scale);\n        // Set display size (CSS pixels)\n        canvas.style.width = width + \"px\";\n        canvas.style.height = height + \"px\";\n        draw(context, scrollPos, width, height);\n        setCanvasSize({\n            width,\n            height\n        });\n    };\n    const draw = (context, scrollPos, width, height)=>{\n        const zoom = scale.zoom;\n        const unit = scale.unit;\n        const segments = scale.segments;\n        context.clearRect(0, 0, width, height);\n        context.save();\n        // Draw ruler background with gradient\n        const gradient = context.createLinearGradient(0, 0, 0, height);\n        gradient.addColorStop(0, \"#1a1625\"); // Wands purple dark at top\n        gradient.addColorStop(1, \"#211a2c\"); // Slightly lighter at bottom\n        context.fillStyle = gradient;\n        context.fillRect(0, 0, width, height);\n        // Draw bottom border\n        context.beginPath();\n        context.moveTo(0, height - 0.5);\n        context.lineTo(width, height - 0.5);\n        context.strokeStyle = \"#422e6d\"; // Wands purple border\n        context.lineWidth = 1;\n        context.stroke();\n        // Draw text settings\n        context.fillStyle = \"#ab68ff\"; // Wands purple for text\n        context.font = \"bold \".concat(_constants_constants__WEBPACK_IMPORTED_MODULE_2__.SMALL_FONT_SIZE, \"px \").concat(_constants_constants__WEBPACK_IMPORTED_MODULE_2__.SECONDARY_FONT);\n        context.textBaseline = \"top\";\n        context.translate(0.5, 0);\n        context.beginPath();\n        const zoomUnit = unit * zoom * _constants_constants__WEBPACK_IMPORTED_MODULE_2__.PREVIEW_FRAME_WIDTH;\n        const minRange = Math.floor(scrollPos / zoomUnit);\n        const maxRange = Math.ceil((scrollPos + width) / zoomUnit);\n        const length = maxRange - minRange;\n        // Draw major markers and their text\n        for(let i = 0; i <= length; ++i){\n            const value = i + minRange;\n            if (value < 0) continue;\n            const startValue = value * zoomUnit / zoom;\n            const startPos = (startValue - scrollPos / zoom) * zoom;\n            if (startPos < -zoomUnit || startPos >= width + zoomUnit) continue;\n            const text = textFormat(startValue);\n            // Calculate text position\n            const textWidth = context.measureText(text).width;\n            const textOffsetX = -textWidth / 2;\n            // Draw label background\n            if (value % 5 === 0) {\n                context.fillStyle = \"rgba(171, 104, 255, 0.1)\"; // Semi-transparent purple\n                context.fillRect(startPos + offsetX - 15, 0, 30, 28);\n                context.fillStyle = \"#ab68ff\"; // Reset text color\n            }\n            // Draw the time text\n            context.fillText(text, startPos + textOffsetX + offsetX, textOffsetY);\n        }\n        // Draw tick marks\n        for(let i = 0; i <= length; ++i){\n            const value = i + minRange;\n            if (value < 0) continue;\n            const startValue = value * zoomUnit;\n            const startPos = startValue - scrollPos + offsetX;\n            for(let j = 0; j < segments; ++j){\n                const pos = startPos + j / segments * zoomUnit;\n                if (pos < 0 || pos >= width) continue;\n                const isMainMark = j % segments === 0;\n                const lineSize = isMainMark ? longLineSize : shortLineSize;\n                // Different colors for different tick sizes\n                if (isMainMark) {\n                    context.strokeStyle = value % 5 === 0 ? \"#ab68ff\" : \"#6e45a0\"; // Bolder purple for main marks, special for each 5s\n                    context.lineWidth = value % 5 === 0 ? 1.5 : 1;\n                } else {\n                    context.strokeStyle = \"rgba(110, 69, 160, 0.5)\"; // Subtle for minor marks\n                    context.lineWidth = 0.8;\n                }\n                const origin = 28; // Start lines below the text\n                const [x1, y1] = [\n                    pos,\n                    origin\n                ];\n                const [x2, y2] = [\n                    x1,\n                    y1 + lineSize\n                ];\n                context.beginPath();\n                context.moveTo(x1, y1);\n                context.lineTo(x2, y2);\n                context.stroke();\n            }\n        }\n        context.restore();\n    };\n    const handleClick = (event)=>{\n        const canvas = canvasRef.current;\n        if (!canvas) return;\n        // Get the bounding box of the canvas to calculate the relative click position\n        const rect = canvas.getBoundingClientRect();\n        const clickX = event.clientX - rect.left;\n        // Calculate total x position, including scrollPos\n        const totalX = clickX + scrollPos - _constants_constants__WEBPACK_IMPORTED_MODULE_2__.TIMELINE_OFFSET_X - _constants_constants__WEBPACK_IMPORTED_MODULE_2__.TIMELINE_OFFSET_CANVAS_LEFT;\n        onClick === null || onClick === void 0 ? void 0 : onClick(totalX);\n    };\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: \"border-t border-border/80\",\n        style: {\n            position: \"relative\",\n            width: \"100%\",\n            height: \"\".concat(canvasSize.height, \"px\"),\n            background: \"#1a1625\"\n        },\n        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"canvas\", {\n            onMouseUp: handleClick,\n            ref: canvasRef,\n            height: canvasSize.height,\n            style: {\n                display: \"block\"\n            }\n        }, void 0, false, {\n            fileName: \"C:\\\\Users\\\\david\\\\Desktop\\\\ai-video-agent\\\\react-video-editor\\\\features\\\\editor\\\\timeline\\\\ruler.tsx\",\n            lineNumber: 234,\n            columnNumber: 7\n        }, undefined)\n    }, void 0, false, {\n        fileName: \"C:\\\\Users\\\\david\\\\Desktop\\\\ai-video-agent\\\\react-video-editor\\\\features\\\\editor\\\\timeline\\\\ruler.tsx\",\n        lineNumber: 225,\n        columnNumber: 5\n    }, undefined);\n};\n_s(Ruler, \"aN+WB/8Xd7Skq6vEzJ6ZUc408xA=\", false, function() {\n    return [\n        _store_use_store__WEBPACK_IMPORTED_MODULE_4__[\"default\"]\n    ];\n});\n_c = Ruler;\n/* harmony default export */ __webpack_exports__[\"default\"] = (Ruler);\nvar _c;\n$RefreshReg$(_c, \"Ruler\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2ZlYXR1cmVzL2VkaXRvci90aW1lbGluZS9ydWxlci50c3giLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBaUU7QUFRakM7QUFDcUI7QUFDWDtBQUNSO0FBY2xDLE1BQU1ZLFFBQVEsQ0FBQ0M7O0lBQ2IsTUFBTSxFQUNKQyxTQUFTLEVBQUUsRUFDWEMsZUFBZSxFQUFFLEVBQ2pCQyxnQkFBZ0IsQ0FBQyxFQUNqQkMsVUFBVVQsbUVBQWlCQSxHQUFHRCw2RUFBMkIsRUFDekRXLGNBQWMsRUFBRSxFQUNoQkMsYUFBYVYsNkRBQWtCLEVBQy9CVyxZQUFZQyxZQUFZLENBQUMsRUFDekJDLE9BQU8sRUFDUixHQUFHVDtJQUNKLE1BQU0sRUFBRVUsS0FBSyxFQUFFLEdBQUdiLDREQUFRQTtJQUMxQixNQUFNYyxZQUFZdEIsNkNBQU1BLENBQTJCO0lBQ25ELE1BQU0sQ0FBQ3VCLGVBQWVDLGlCQUFpQixHQUNyQ3ZCLCtDQUFRQSxDQUFrQztJQUM1QyxNQUFNLENBQUN3QixZQUFZQyxjQUFjLEdBQUd6QiwrQ0FBUUEsQ0FBQztRQUMzQzBCLE9BQU87UUFDUGYsUUFBUUE7SUFDVjtJQUVBYixnREFBU0EsQ0FBQztRQUNSLE1BQU02QixTQUFTTixVQUFVTyxPQUFPO1FBQ2hDLElBQUlELFFBQVE7WUFDVixNQUFNRSxVQUFVRixPQUFPRyxVQUFVLENBQUM7WUFDbENQLGlCQUFpQk07WUFDakJFLE9BQU9KLFFBQVFFLFNBQVNYO1FBQzFCO0lBQ0YsR0FBRyxFQUFFO0lBRUwsTUFBTWMsZUFBZW5DLGtEQUFXQSxDQUFDO1FBQy9Ca0MsT0FBT1YsVUFBVU8sT0FBTyxFQUFFTixlQUFlSjtJQUMzQyxHQUFHO1FBQUNJO1FBQWVKO0tBQVU7SUFFN0JwQixnREFBU0EsQ0FBQztRQUNSLE1BQU1tQyxnQkFBZ0J6QixzREFBUUEsQ0FBQ3dCLGNBQWM7UUFDN0NFLE9BQU9DLGdCQUFnQixDQUFDLFVBQVVGO1FBRWxDLE9BQU87WUFDTEMsT0FBT0Us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UTs7Ozs7Ozs7Ozs7QUFJbEM7R0F4Tk01Rjs7UUFXY0Ysd0RBQVFBOzs7S0FYdEJFO0FBME5OLCtEQUFlQSxLQUFLQSxFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL2ZlYXR1cmVzL2VkaXRvci90aW1lbGluZS9ydWxlci50c3g/MDY5NCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyB1c2VDYWxsYmFjaywgdXNlRWZmZWN0LCB1c2VSZWYsIHVzZVN0YXRlIH0gZnJvbSBcInJlYWN0XCI7XG5cbmltcG9ydCB7XG4gIFBSRVZJRVdfRlJBTUVfV0lEVEgsXG4gIFNFQ09OREFSWV9GT05ULFxuICBTTUFMTF9GT05UX1NJWkUsXG4gIFRJTUVMSU5FX09GRlNFVF9DQU5WQVNfTEVGVCxcbiAgVElNRUxJTkVfT0ZGU0VUX1gsXG59IGZyb20gXCIuLi9jb25zdGFudHMvY29uc3RhbnRzXCI7XG5pbXBvcnQgeyBmb3JtYXRUaW1lbGluZVVuaXQgfSBmcm9tIFwiLi4vdXRpbHMvZm9ybWF0XCI7XG5pbXBvcnQgdXNlU3RvcmUgZnJvbSBcIi4uL3N0b3JlL3VzZS1zdG9yZVwiO1xuaW1wb3J0IHsgZGVib3VuY2UgfSBmcm9tIFwibG9kYXNoXCI7XG5cbmludGVyZmFjZSBSdWxlclByb3BzIHtcbiAgaGVpZ2h0PzogbnVtYmVyO1xuICBsb25nTGluZVNpemU/OiBudW1iZXI7XG4gIHNob3J0TGluZVNpemU/OiBudW1iZXI7XG4gIG9mZnNldFg/OiBudW1iZXI7XG4gIHRleHRPZmZzZXRZPzogbnVtYmVyO1xuICBzY3JvbGxQb3M/OiBudW1iZXI7XG4gIHRleHRGb3JtYXQ/OiAoc2NhbGU6IG51bWJlcikgPT4gc3RyaW5nO1xuICBzY3JvbGxMZWZ0PzogbnVtYmVyO1xuICBvbkNsaWNrPzogKHVuaXRzOiBudW1iZXIpID0+IHZvaWQ7XG59XG5cbmNvbnN0IFJ1bGVyID0gKHByb3BzOiBSdWxlclByb3BzKSA9PiB7XG4gIGNvbnN0IHtcbiAgICBoZWlnaHQgPSA0MiwgLy8gSW5jcmVhc2VkIGhlaWdodCBmb3IgbW9yZSBzcGFjZVxuICAgIGxvbmdMaW5lU2l6ZSA9IDE0LCAvLyBJbmNyZWFzZWQgbGVuZ3RoIG9mIGxvbmcgbGluZXNcbiAgICBzaG9ydExpbmVTaXplID0gOCwgLy8gRGVjcmVhc2VkIGZvciBjb250cmFzdFxuICAgIG9mZnNldFggPSBUSU1FTElORV9PRkZTRVRfWCArIFRJTUVMSU5FX09GRlNFVF9DQU5WQVNfTEVGVCxcbiAgICB0ZXh0T2Zmc2V0WSA9IDEyLCAvLyBQbGFjZSB0aGUgdGV4dCBoaWdoZXIgZm9yIGJldHRlciBzcGFjaW5nXG4gICAgdGV4dEZvcm1hdCA9IGZvcm1hdFRpbWVsaW5lVW5pdCxcbiAgICBzY3JvbGxMZWZ0OiBzY3JvbGxQb3MgPSAwLFxuICAgIG9uQ2xpY2ssXG4gIH0gPSBwcm9wcztcbiAgY29uc3QgeyBzY2FsZSB9ID0gdXNlU3RvcmUoKTtcbiAgY29uc3QgY2FudmFzUmVmID0gdXNlUmVmPEhUTUxDYW52YXNFbGVtZW50IHwgbnVsbD4obnVsbCk7XG4gIGNvbnN0IFtjYW52YXNDb250ZXh0LCBzZXRDYW52YXNDb250ZXh0XSA9XG4gICAgdXNlU3RhdGU8Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEIHwgbnVsbD4obnVsbCk7XG4gIGNvbnN0IFtjYW52YXNTaXplLCBzZXRDYW52YXNTaXplXSA9IHVzZVN0YXRlKHtcbiAgICB3aWR0aDogMCxcbiAgICBoZWlnaHQ6IGhlaWdodCxcbiAgfSk7XG5cbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCBjYW52YXMgPSBjYW52YXNSZWYuY3VycmVudDtcbiAgICBpZiAoY2FudmFzKSB7XG4gICAgICBjb25zdCBjb250ZXh0ID0gY2FudmFzLmdldENvbnRleHQoXCIyZFwiKTtcbiAgICAgIHNldENhbnZhc0NvbnRleHQoY29udGV4dCk7XG4gICAgICByZXNpemUoY2FudmFzLCBjb250ZXh0LCBzY3JvbGxQb3MpO1xuICAgIH1cbiAgfSwgW10pO1xuXG4gIGNvbnN0IGhhbmRsZVJlc2l6ZSA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICByZXNpemUoY2FudmFzUmVmLmN1cnJlbnQsIGNhbnZhc0NvbnRleHQsIHNjcm9sbFBvcyk7XG4gIH0sIFtjYW52YXNDb250ZXh0LCBzY3JvbGxQb3NdKTtcblxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGNvbnN0IHJlc2l6ZUhhbmRsZXIgPSBkZWJvdW5jZShoYW5kbGVSZXNpemUsIDIwMCk7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJyZXNpemVcIiwgcmVzaXplSGFuZGxlcik7XG5cbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJyZXNpemVcIiwgcmVzaXplSGFuZGxlcik7XG4gICAgfTtcbiAgfSwgW2hhbmRsZVJlc2l6ZV0pO1xuXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKGNhbnZhc0NvbnRleHQpIHtcbiAgICAgIHJlc2l6ZShjYW52YXNSZWYuY3VycmVudCwgY2FudmFzQ29udGV4dCwgc2Nyb2xsUG9zKTtcbiAgICB9XG4gIH0sIFtjYW52YXNDb250ZXh0LCBzY3JvbGxQb3MsIHNjYWxlXSk7XG5cbiAgY29uc3QgcmVzaXplID0gKFxuICAgIGNhbnZhczogSFRNTENhbnZhc0VsZW1lbnQgfCBudWxsLFxuICAgIGNvbnRleHQ6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCB8IG51bGwsXG4gICAgc2Nyb2xsUG9zOiBudW1iZXIsXG4gICkgPT4ge1xuICAgIGlmICghY2FudmFzIHx8ICFjb250ZXh0KSByZXR1cm47XG5cbiAgICBjb25zdCBvZmZzZXRQYXJlbnQgPSBjYW52YXMub2Zmc2V0UGFyZW50IGFzIEhUTUxEaXZFbGVtZW50O1xuICAgIGNvbnN0IHdpZHRoID0gb2Zmc2V0UGFyZW50Py5vZmZzZXRXaWR0aCA/PyBjYW52YXMub2Zmc2V0V2lkdGg7XG4gICAgY29uc3QgaGVpZ2h0ID0gY2FudmFzU2l6ZS5oZWlnaHQ7XG5cbiAgICAvLyBTZXQgYWN0dWFsIHNpemUgaW4gbWVtb3J5IChzY2FsZWQgdG8gYWNjb3VudCBmb3IgZXh0cmEgcGl4ZWwgZGVuc2l0eSlcbiAgICBjb25zdCBzY2FsZSA9IHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvO1xuICAgIGNhbnZhcy53aWR0aCA9IHdpZHRoICogc2NhbGU7XG4gICAgY2FudmFzLmhlaWdodCA9IGhlaWdodCAqIHNjYWxlO1xuXG4gICAgLy8gTm9ybWFsaXplIGNvb3JkaW5hdGUgc3lzdGVtIHRvIHVzZSBDU1MgcGl4ZWxzXG4gICAgY29udGV4dC5zY2FsZShzY2FsZSwgc2NhbGUpO1xuXG4gICAgLy8gU2V0IGRpc3BsYXkgc2l6ZSAoQ1NTIHBpeGVscylcbiAgICBjYW52YXMuc3R5bGUud2lkdGggPSB3aWR0aCArICdweCc7XG4gICAgY2FudmFzLnN0eWxlLmhlaWdodCA9IGhlaWdodCArICdweCc7XG5cbiAgICBkcmF3KGNvbnRleHQsIHNjcm9sbFBvcywgd2lkdGgsIGhlaWdodCk7XG4gICAgc2V0Q2FudmFzU2l6ZSh7IHdpZHRoLCBoZWlnaHQgfSk7XG4gIH07XG5cbiAgY29uc3QgZHJhdyA9IChcbiAgICBjb250ZXh0OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQsXG4gICAgc2Nyb2xsUG9zOiBudW1iZXIsXG4gICAgd2lkdGg6IG51bWJlcixcbiAgICBoZWlnaHQ6IG51bWJlcixcbiAgKSA9PiB7XG4gICAgY29uc3Qgem9vbSA9IHNjYWxlLnpvb207XG4gICAgY29uc3QgdW5pdCA9IHNjYWxlLnVuaXQ7XG4gICAgY29uc3Qgc2VnbWVudHMgPSBzY2FsZS5zZWdtZW50cztcbiAgICBjb250ZXh0LmNsZWFyUmVjdCgwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICBjb250ZXh0LnNhdmUoKTtcblxuICAgIC8vIERyYXcgcnVsZXIgYmFja2dyb3VuZCB3aXRoIGdyYWRpZW50XG4gICAgY29uc3QgZ3JhZGllbnQgPSBjb250ZXh0LmNyZWF0ZUxpbmVhckdyYWRpZW50KDAsIDAsIDAsIGhlaWdodCk7XG4gICAgZ3JhZGllbnQuYWRkQ29sb3JTdG9wKDAsIFwiIzFhMTYyNVwiKTsgIC8vIFdhbmRzIHB1cnBsZSBkYXJrIGF0IHRvcFxuICAgIGdyYWRpZW50LmFkZENvbG9yU3RvcCgxLCBcIiMyMTFhMmNcIik7ICAvLyBTbGlnaHRseSBsaWdodGVyIGF0IGJvdHRvbVxuICAgIGNvbnRleHQuZmlsbFN0eWxlID0gZ3JhZGllbnQ7XG4gICAgY29udGV4dC5maWxsUmVjdCgwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcblxuICAgIC8vIERyYXcgYm90dG9tIGJvcmRlclxuICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XG4gICAgY29udGV4dC5tb3ZlVG8oMCwgaGVpZ2h0IC0gMC41KTtcbiAgICBjb250ZXh0LmxpbmVUbyh3aWR0aCwgaGVpZ2h0IC0gMC41KTtcbiAgICBjb250ZXh0LnN0cm9rZVN0eWxlID0gXCIjNDIyZTZkXCI7IC8vIFdhbmRzIHB1cnBsZSBib3JkZXJcbiAgICBjb250ZXh0LmxpbmVXaWR0aCA9IDE7XG4gICAgY29udGV4dC5zdHJva2UoKTtcblxuICAgIC8vIERyYXcgdGV4dCBzZXR0aW5nc1xuICAgIGNvbnRleHQuZmlsbFN0eWxlID0gXCIjYWI2OGZmXCI7IC8vIFdhbmRzIHB1cnBsZSBmb3IgdGV4dFxuICAgIGNvbnRleHQuZm9udCA9IGBib2xkICR7U01BTExfRk9OVF9TSVpFfXB4ICR7U0VDT05EQVJZX0ZPTlR9YDtcbiAgICBjb250ZXh0LnRleHRCYXNlbGluZSA9IFwidG9wXCI7XG5cbiAgICBjb250ZXh0LnRyYW5zbGF0ZSgwLjUsIDApO1xuICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XG5cbiAgICBjb25zdCB6b29tVW5pdCA9IHVuaXQgKiB6b29tICogUFJFVklFV19GUkFNRV9XSURUSDtcbiAgICBjb25zdCBtaW5SYW5nZSA9IE1hdGguZmxvb3Ioc2Nyb2xsUG9zIC8gem9vbVVuaXQpO1xuICAgIGNvbnN0IG1heFJhbmdlID0gTWF0aC5jZWlsKChzY3JvbGxQb3MgKyB3aWR0aCkgLyB6b29tVW5pdCk7XG4gICAgY29uc3QgbGVuZ3RoID0gbWF4UmFuZ2UgLSBtaW5SYW5nZTtcblxuICAgIC8vIERyYXcgbWFqb3IgbWFya2VycyBhbmQgdGhlaXIgdGV4dFxuICAgIGZvciAobGV0IGkgPSAwOyBpIDw9IGxlbmd0aDsgKytpKSB7XG4gICAgICBjb25zdCB2YWx1ZSA9IGkgKyBtaW5SYW5nZTtcblxuICAgICAgaWYgKHZhbHVlIDwgMCkgY29udGludWU7XG5cbiAgICAgIGNvbnN0IHN0YXJ0VmFsdWUgPSAodmFsdWUgKiB6b29tVW5pdCkgLyB6b29tO1xuICAgICAgY29uc3Qgc3RhcnRQb3MgPSAoc3RhcnRWYWx1ZSAtIHNjcm9sbFBvcyAvIHpvb20pICogem9vbTtcblxuICAgICAgaWYgKHN0YXJ0UG9zIDwgLXpvb21Vbml0IHx8IHN0YXJ0UG9zID49IHdpZHRoICsgem9vbVVuaXQpIGNvbnRpbnVlO1xuICAgICAgY29uc3QgdGV4dCA9IHRleHRGb3JtYXQoc3RhcnRWYWx1ZSk7XG5cbiAgICAgIC8vIENhbGN1bGF0ZSB0ZXh0IHBvc2l0aW9uXG4gICAgICBjb25zdCB0ZXh0V2lkdGggPSBjb250ZXh0Lm1lYXN1cmVUZXh0KHRleHQpLndpZHRoO1xuICAgICAgY29uc3QgdGV4dE9mZnNldFggPSAtdGV4dFdpZHRoIC8gMjtcblxuICAgICAgLy8gRHJhdyBsYWJlbCBiYWNrZ3JvdW5kXG4gICAgICBpZiAodmFsdWUgJSA1ID09PSAwKSB7IC8vIEV2ZXJ5IDUgc2Vjb25kcyBnZXRzIGEgc3BlY2lhbCBtYXJrZXJcbiAgICAgICAgY29udGV4dC5maWxsU3R5bGUgPSBcInJnYmEoMTcxLCAxMDQsIDI1NSwgMC4xKVwiOyAvLyBTZW1pLXRyYW5zcGFyZW50IHB1cnBsZVxuICAgICAgICBjb250ZXh0LmZpbGxSZWN0KHN0YXJ0UG9zICsgb2Zmc2V0WCAtIDE1LCAwLCAzMCwgMjgpO1xuICAgICAgICBjb250ZXh0LmZpbGxTdHlsZSA9IFwiI2FiNjhmZlwiOyAvLyBSZXNldCB0ZXh0IGNvbG9yXG4gICAgICB9XG5cbiAgICAgIC8vIERyYXcgdGhlIHRpbWUgdGV4dFxuICAgICAgY29udGV4dC5maWxsVGV4dCh0ZXh0LCBzdGFydFBvcyArIHRleHRPZmZzZXRYICsgb2Zmc2V0WCwgdGV4dE9mZnNldFkpO1xuICAgIH1cblxuICAgIC8vIERyYXcgdGljayBtYXJrc1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDw9IGxlbmd0aDsgKytpKSB7XG4gICAgICBjb25zdCB2YWx1ZSA9IGkgKyBtaW5SYW5nZTtcblxuICAgICAgaWYgKHZhbHVlIDwgMCkgY29udGludWU7XG5cbiAgICAgIGNvbnN0IHN0YXJ0VmFsdWUgPSB2YWx1ZSAqIHpvb21Vbml0O1xuICAgICAgY29uc3Qgc3RhcnRQb3MgPSBzdGFydFZhbHVlIC0gc2Nyb2xsUG9zICsgb2Zmc2V0WDtcblxuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBzZWdtZW50czsgKytqKSB7XG4gICAgICAgIGNvbnN0IHBvcyA9IHN0YXJ0UG9zICsgKGogLyBzZWdtZW50cykgKiB6b29tVW5pdDtcblxuICAgICAgICBpZiAocG9zIDwgMCB8fCBwb3MgPj0gd2lkdGgpIGNvbnRpbnVlO1xuXG4gICAgICAgIGNvbnN0IGlzTWFpbk1hcmsgPSBqICUgc2VnbWVudHMgPT09IDA7XG4gICAgICAgIGNvbnN0IGxpbmVTaXplID0gaXNNYWluTWFyayA/IGxvbmdMaW5lU2l6ZSA6IHNob3J0TGluZVNpemU7XG5cbiAgICAgICAgLy8gRGlmZmVyZW50IGNvbG9ycyBmb3IgZGlmZmVyZW50IHRpY2sgc2l6ZXNcbiAgICAgICAgaWYgKGlzTWFpbk1hcmspIHtcbiAgICAgICAgICBjb250ZXh0LnN0cm9rZVN0eWxlID0gdmFsdWUgJSA1ID09PSAwID8gXCIjYWI2OGZmXCIgOiBcIiM2ZTQ1YTBcIjsgLy8gQm9sZGVyIHB1cnBsZSBmb3IgbWFpbiBtYXJrcywgc3BlY2lhbCBmb3IgZWFjaCA1c1xuICAgICAgICAgIGNvbnRleHQubGluZVdpZHRoID0gdmFsdWUgJSA1ID09PSAwID8gMS41IDogMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb250ZXh0LnN0cm9rZVN0eWxlID0gXCJyZ2JhKDExMCwgNjksIDE2MCwgMC41KVwiOyAvLyBTdWJ0bGUgZm9yIG1pbm9yIG1hcmtzXG4gICAgICAgICAgY29udGV4dC5saW5lV2lkdGggPSAwLjg7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBvcmlnaW4gPSAyODsgLy8gU3RhcnQgbGluZXMgYmVsb3cgdGhlIHRleHRcblxuICAgICAgICBjb25zdCBbeDEsIHkxXSA9IFtwb3MsIG9yaWdpbl07XG4gICAgICAgIGNvbnN0IFt4MiwgeTJdID0gW3gxLCB5MSArIGxpbmVTaXplXTtcblxuICAgICAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xuICAgICAgICBjb250ZXh0Lm1vdmVUbyh4MSwgeTEpO1xuICAgICAgICBjb250ZXh0LmxpbmVUbyh4MiwgeTIpO1xuICAgICAgICBjb250ZXh0LnN0cm9rZSgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnRleHQucmVzdG9yZSgpO1xuICB9O1xuXG4gIGNvbnN0IGhhbmRsZUNsaWNrID0gKGV2ZW50OiBSZWFjdC5Nb3VzZUV2ZW50PEhUTUxDYW52YXNFbGVtZW50PikgPT4ge1xuICAgIGNvbnN0IGNhbnZhcyA9IGNhbnZhc1JlZi5jdXJyZW50O1xuICAgIGlmICghY2FudmFzKSByZXR1cm47XG5cbiAgICAvLyBHZXQgdGhlIGJvdW5kaW5nIGJveCBvZiB0aGUgY2FudmFzIHRvIGNhbGN1bGF0ZSB0aGUgcmVsYXRpdmUgY2xpY2sgcG9zaXRpb25cbiAgICBjb25zdCByZWN0ID0gY2FudmFzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIGNvbnN0IGNsaWNrWCA9IGV2ZW50LmNsaWVudFggLSByZWN0LmxlZnQ7XG5cbiAgICAvLyBDYWxjdWxhdGUgdG90YWwgeCBwb3NpdGlvbiwgaW5jbHVkaW5nIHNjcm9sbFBvc1xuICAgIGNvbnN0IHRvdGFsWCA9XG4gICAgICBjbGlja1ggKyBzY3JvbGxQb3MgLSBUSU1FTElORV9PRkZTRVRfWCAtIFRJTUVMSU5FX09GRlNFVF9DQU5WQVNfTEVGVDtcblxuICAgIG9uQ2xpY2s/Lih0b3RhbFgpO1xuICB9O1xuXG4gIHJldHVybiAoXG4gICAgPGRpdlxuICAgICAgY2xhc3NOYW1lPVwiYm9yZGVyLXQgYm9yZGVyLWJvcmRlci84MFwiXG4gICAgICBzdHlsZT17e1xuICAgICAgICBwb3NpdGlvbjogXCJyZWxhdGl2ZVwiLFxuICAgICAgICB3aWR0aDogXCIxMDAlXCIsXG4gICAgICAgIGhlaWdodDogYCR7Y2FudmFzU2l6ZS5oZWlnaHR9cHhgLFxuICAgICAgICBiYWNrZ3JvdW5kOiBcIiMxYTE2MjVcIixcbiAgICAgIH19XG4gICAgPlxuICAgICAgPGNhbnZhc1xuICAgICAgICBvbk1vdXNlVXA9e2hhbmRsZUNsaWNrfVxuICAgICAgICByZWY9e2NhbnZhc1JlZn1cbiAgICAgICAgaGVpZ2h0PXtjYW52YXNTaXplLmhlaWdodH1cbiAgICAgICAgc3R5bGU9e3sgZGlzcGxheTogXCJibG9ja1wiIH19XG4gICAgICAvPlxuICAgIDwvZGl2PlxuICApO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgUnVsZXI7XG4iXSwibmFtZXMiOlsidXNlQ2FsbGJhY2siLCJ1c2VFZmZlY3QiLCJ1c2VSZWYiLCJ1c2VTdGF0ZSIsIlBSRVZJRVdfRlJBTUVfV0lEVEgiLCJTRUNPTkRBUllfRk9OVCIsIlNNQUxMX0ZPTlRfU0laRSIsIlRJTUVMSU5FX09GRlNFVF9DQU5WQVNfTEVGVCIsIlRJTUVMSU5FX09GRlNFVF9YIiwiZm9ybWF0VGltZWxpbmVVbml0IiwidXNlU3RvcmUiLCJkZWJvdW5jZSIsIlJ1bGVyIiwicHJvcHMiLCJoZWlnaHQiLCJsb25nTGluZVNpemUiLCJzaG9ydExpbmVTaXplIiwib2Zmc2V0WCIsInRleHRPZmZzZXRZIiwidGV4dEZvcm1hdCIsInNjcm9sbExlZnQiLCJzY3JvbGxQb3MiLCJvbkNsaWNrIiwic2NhbGUiLCJjYW52YXNSZWYiLCJjYW52YXNDb250ZXh0Iiwic2V0Q2FudmFzQ29udGV4dCIsImNhbnZhc1NpemUiLCJzZXRDYW52YXNTaXplIiwid2lkdGgiLCJjYW52YXMiLCJjdXJyZW50IiwiY29udGV4dCIsImdldENvbnRleHQiLCJyZXNpemUiLCJoYW5kbGVSZXNpemUiLCJyZXNpemVIYW5kbGVyIiwid2luZG93IiwiYWRkRXZlbnRMaXN0ZW5lciIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJvZmZzZXRQYXJlbnQiLCJvZmZzZXRXaWR0aCIsImRldmljZVBpeGVsUmF0aW8iLCJzdHlsZSIsImRyYXciLCJ6b29tIiwidW5pdCIsInNlZ21lbnRzIiwiY2xlYXJSZWN0Iiwic2F2ZSIsImdyYWRpZW50IiwiY3JlYXRlTGluZWFyR3JhZGllbnQiLCJhZGRDb2xvclN0b3AiLCJmaWxsU3R5bGUiLCJmaWxsUmVjdCIsImJlZ2luUGF0aCIsIm1vdmVUbyIsImxpbmVUbyIsInN0cm9rZVN0eWxlIiwibGluZVdpZHRoIiwic3Ryb2tlIiwiZm9udCIsInRleHRCYXNlbGluZSIsInRyYW5zbGF0ZSIsInpvb21Vbml0IiwibWluUmFuZ2UiLCJNYXRoIiwiZmxvb3IiLCJtYXhSYW5nZSIsImNlaWwiLCJsZW5ndGgiLCJpIiwidmFsdWUiLCJzdGFydFZhbHVlIiwic3RhcnRQb3MiLCJ0ZXh0IiwidGV4dFdpZHRoIiwibWVhc3VyZVRleHQiLCJ0ZXh0T2Zmc2V0WCIsImZpbGxUZXh0IiwiaiIsInBvcyIsImlzTWFpbk1hcmsiLCJsaW5lU2l6ZSIsIm9yaWdpbiIsIngxIiwieTEiLCJ4MiIsInkyIiwicmVzdG9yZSIsImhhbmRsZUNsaWNrIiwiZXZlbnQiLCJyZWN0IiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0IiwiY2xpY2tYIiwiY2xpZW50WCIsImxlZnQiLCJ0b3RhbFgiLCJkaXYiLCJjbGFzc05hbWUiLCJwb3NpdGlvbiIsImJhY2tncm91bmQiLCJvbk1vdXNlVXAiLCJyZWYiLCJkaXNwbGF5Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./features/editor/timeline/ruler.tsx\n"));

/***/ })

});
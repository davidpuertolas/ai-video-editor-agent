"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./features/editor/services/ai-service.ts":
/*!************************************************!*\
  !*** ./features/editor/services/ai-service.ts ***!
  \************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AIService: function() { return /* binding */ AIService; }\n/* harmony export */ });\n/**\n * Servicio para manejar la comunicación con la IA.\n * Esta es una implementación base que simula respuestas.\n * En el futuro, se conectará con una API real.\n */ class AIService {\n    /**\n   * Analiza los elementos seleccionados para buscar URLs\n   */ static async analyzeItems(request) {\n        try {\n            // Simulamos un tiempo de respuesta de la API\n            await new Promise((resolve)=>setTimeout(resolve, 1000));\n            console.log(\"AI Service - Request:\", request);\n            // Extraer el texto relevante de los elementos seleccionados\n            const elementsText = this.extractTextFromElements(request.items);\n            // Mensaje explícito o texto extraído de los elementos\n            const textToAnalyze = request.message || elementsText;\n            // Analizar si el texto contiene URLs\n            const urlAnalysis = this.detectURLs(textToAnalyze);\n            // Si hay URLs, generar información de screenshots\n            if (urlAnalysis.containsURLs) {\n                urlAnalysis.screenshots = this.getScreenshotsForUrls(urlAnalysis.urls);\n            }\n            // Analizar la intención del usuario si hay un mensaje explícito\n            let intentAnalysis = null;\n            if (request.message) {\n                intentAnalysis = this.analyzeIntent(request.message, urlAnalysis);\n            }\n            // Simulación de respuesta de la IA\n            // En un entorno real, esto enviaría la solicitud a un endpoint de API\n            return {\n                success: true,\n                message: \"An\\xe1lisis completado con \\xe9xito\",\n                analysis: {\n                    summary: this.generateURLAnalysisSummary(urlAnalysis, request.items.length),\n                    urlAnalysis: urlAnalysis,\n                    itemsAnalyzed: request.items.length,\n                    analyzedText: textToAnalyze,\n                    recommendations: this.generateRecommendations(urlAnalysis),\n                    intentAnalysis: intentAnalysis,\n                    confidence: 0.95\n                }\n            };\n        } catch (error) {\n            console.error(\"Error in AI service:\", error);\n            return {\n                success: false,\n                message: \"Error al procesar la solicitud\",\n                error: error instanceof Error ? error.message : String(error)\n            };\n        }\n    }\n    /**\n   * Analiza la intención del usuario en su mensaje\n   */ static analyzeIntent(message, urlAnalysis) {\n        // Convertir a minúsculas para facilitar la comparación\n        const lowerMessage = message.toLowerCase();\n        // Patrones para detectar la intención de ver una captura de pantalla\n        const screenshotPatterns = [\n            \"muestra\",\n            \"mostrar\",\n            \"ver\",\n            \"screenshot\",\n            \"captura\",\n            \"imagen\",\n            \"previsualizaci\\xf3n\",\n            \"preview\",\n            \"visualiza\",\n            \"ense\\xf1a\",\n            \"foto\",\n            \"screen\",\n            \"pantalla\"\n        ];\n        // Verificar si hay algún patrón de screenshot en el mensaje\n        const hasScreenshotIntent = screenshotPatterns.some((pattern)=>lowerMessage.includes(pattern));\n        // Si no hay intención de screenshot, devolver null o un resultado básico\n        if (!hasScreenshotIntent) {\n            return {\n                hasIntent: false,\n                intent: \"unknown\",\n                confidence: 0.1\n            };\n        }\n        // Si hay URLs y hay intención de ver screenshots\n        if (urlAnalysis.containsURLs) {\n            // Intentar identificar qué URL específica quiere ver\n            let targetUrl = urlAnalysis.urls[0]; // Por defecto, la primera URL\n            // Comprobar si el mensaje menciona específicamente alguna de las URLs\n            for (const url of urlAnalysis.urls){\n                if (lowerMessage.includes(url.toLowerCase())) {\n                    targetUrl = url;\n                    break;\n                }\n            }\n            return {\n                hasIntent: true,\n                intent: \"view_screenshot\",\n                confidence: 0.9,\n                target: targetUrl,\n                action: \"show_screenshot\"\n            };\n        }\n        return {\n            hasIntent: true,\n            intent: \"view_screenshot\",\n            confidence: 0.7,\n            action: \"request_url\"\n        };\n    }\n    /**\n   * Obtiene las capturas de pantalla para las URLs detectadas\n   * (Como es un demo, utilizamos la misma imagen para todas las URLs)\n   */ static getScreenshotsForUrls(urls) {\n        // En un entorno real, esta función realizaría una llamada a un servicio\n        // que generaría capturas de pantalla para cada URL\n        // Por ahora, usamos una imagen de demostración para todas las URLs\n        return urls.map((url)=>({\n                url,\n                screenshotPath: \"/screenshots/screenshot1.png\"\n            }));\n    }\n    /**\n   * Extrae texto de los elementos seleccionados\n   */ static extractTextFromElements(items) {\n        // Aquí extraemos el texto de los elementos seleccionados\n        // En un caso real, esto dependería de la estructura de tus elementos\n        let extractedText = \"\";\n        for (const item of items){\n            var _item_details, _item_details1, _item_details2;\n            // Intentar extraer texto de diferentes propiedades comunes\n            // Esto es un ejemplo y debería adaptarse a tu estructura de datos real\n            if (item.text) {\n                extractedText += \" \" + item.text;\n            } else if ((_item_details = item.details) === null || _item_details === void 0 ? void 0 : _item_details.text) {\n                extractedText += \" \" + item.details.text;\n            } else if (item.name) {\n                extractedText += \" \" + item.name;\n            } else if (item.title) {\n                extractedText += \" \" + item.title;\n            } else if (item.description) {\n                extractedText += \" \" + item.description;\n            } else if ((_item_details1 = item.details) === null || _item_details1 === void 0 ? void 0 : _item_details1.description) {\n                extractedText += \" \" + item.details.description;\n            } else if ((_item_details2 = item.details) === null || _item_details2 === void 0 ? void 0 : _item_details2.src) {\n                extractedText += \" \" + item.details.src;\n            } else if (item.src) {\n                extractedText += \" \" + item.src;\n            } else if (item.content) {\n                extractedText += \" \" + item.content;\n            } else if (item.label) {\n                extractedText += \" \" + item.label;\n            } else if (item.value) {\n                extractedText += \" \" + item.value;\n            } else if (typeof item === \"string\") {\n                extractedText += \" \" + item;\n            }\n            // También podemos buscar en atributos anidados\n            if (item.props && typeof item.props === \"object\") {\n                for(const key in item.props){\n                    if (typeof item.props[key] === \"string\") {\n                        extractedText += \" \" + item.props[key];\n                    }\n                }\n            }\n            // Si todavía no hemos encontrado texto, intentamos convertir el objeto a string\n            if (extractedText.trim() === \"\" && item.toString) {\n                const str = item.toString();\n                if (str !== \"[object Object]\") {\n                    extractedText += \" \" + str;\n                }\n            }\n        }\n        return extractedText.trim();\n    }\n    /**\n   * Detecta URLs en un texto\n   */ static detectURLs(text) {\n        // Expresión regular mejorada para capturar una variedad más amplia de URLs\n        // Esta regex busca URLs con diversos dominios de nivel superior (.com, .org, .ai, etc.)\n        const urlRegex = /(?:https?:\\/\\/)?(?:www\\.)?[-a-zA-Z0-9@:%._\\+~#=]{1,256}\\.[a-zA-Z0-9()]{1,6}\\b(?:[-a-zA-Z0-9()@:%_\\+.~#?&//=]*)/gi;\n        const matches = text.match(urlRegex) || [];\n        // Filtrar posibles falsos positivos (como números de versión: 1.0, etc.)\n        const validUrls = matches.filter((url)=>{\n            // Verificar que el dominio tenga al menos un punto y caracteres alfanuméricos\n            const domainParts = url.split(\".\");\n            // Debe tener al menos un punto y el TLD debe tener al menos 2 caracteres\n            return domainParts.length >= 2 && domainParts[domainParts.length - 1].length >= 2;\n        });\n        return {\n            containsURLs: validUrls.length > 0,\n            urls: validUrls\n        };\n    }\n    /**\n   * Genera un resumen basado en el análisis de URLs\n   */ static generateURLAnalysisSummary(analysis, itemCount) {\n        if (analysis.containsURLs) {\n            const urlCount = analysis.urls.length;\n            return \"He analizado el contenido de \".concat(itemCount, \" elemento\").concat(itemCount !== 1 ? \"s\" : \"\", \" y encontrado \").concat(urlCount, \" URL\").concat(urlCount !== 1 ? \"s\" : \"\", \".\");\n        } else {\n            return \"He analizado el contenido de \".concat(itemCount, \" elemento\").concat(itemCount !== 1 ? \"s\" : \"\", \" y no he encontrado ninguna URL.\");\n        }\n    }\n    /**\n   * Genera recomendaciones basadas en el análisis de URLs\n   */ static generateRecommendations(analysis) {\n        if (analysis.containsURLs) {\n            return [\n                \"Considere verificar si las URLs son seguras antes de utilizarlas.\",\n                \"Aseg\\xfarese de que las URLs est\\xe9n activas y funcionen correctamente.\",\n                \"Considere revisar si los enlaces apuntan a los recursos deseados.\"\n            ];\n        } else {\n            return [\n                \"El contenido no contiene URLs. Si necesita incluir referencias web, considere a\\xf1adirlas.\",\n                \"Puede a\\xf1adir enlaces a recursos adicionales para enriquecer el contenido.\"\n            ];\n        }\n    }\n}\n/* harmony default export */ __webpack_exports__[\"default\"] = (AIService);\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2ZlYXR1cmVzL2VkaXRvci9zZXJ2aWNlcy9haS1zZXJ2aWNlLnRzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTs7OztDQUlDLEdBa0NNLE1BQU1BO0lBQ1g7O0dBRUMsR0FDRCxhQUFvQkMsYUFBYUMsT0FBMEIsRUFBK0I7UUFDeEYsSUFBSTtZQUNGLDZDQUE2QztZQUM3QyxNQUFNLElBQUlDLFFBQVFDLENBQUFBLFVBQVdDLFdBQVdELFNBQVM7WUFFakRFLFFBQVFDLEdBQUcsQ0FBQyx5QkFBeUJMO1lBRXJDLDREQUE0RDtZQUM1RCxNQUFNTSxlQUFlLElBQUksQ0FBQ0MsdUJBQXVCLENBQUNQLFFBQVFRLEtBQUs7WUFFL0Qsc0RBQXNEO1lBQ3RELE1BQU1DLGdCQUFnQlQsUUFBUVUsT0FBTyxJQUFJSjtZQUV6QyxxQ0FBcUM7WUFDckMsTUFBTUssY0FBYyxJQUFJLENBQUNDLFVBQVUsQ0FBQ0g7WUFFcEMsa0RBQWtEO1lBQ2xELElBQUlFLFlBQVlFLFlBQVksRUFBRTtnQkFDNUJGLFlBQVlHLFdBQVcsR0FBRyxJQUFJLENBQUNDLHFCQUFxQixDQUFDSixZQUFZSyxJQUFJO1lBQ3ZFO1lBRUEsZ0VBQWdFO1lBQ2hFLElBQUlDLGlCQUFpQjtZQUNyQixJQUFJakIsUUFBUVUsT0FBTyxFQUFFO2dCQUNuQk8saUJBQWlCLElBQUksQ0FBQ0MsYUFBYSxDQUFDbEIsUUFBUVUsT0FBTyxFQUFFQztZQUN2RDtZQUVBLG1DQUFtQztZQUNuQyxzRUFBc0U7WUFDdEUsT0FBTztnQkFDTFEsU0FBUztnQkFDVFQsU0FBUztnQkFDVFUsVUFBVTtvQkFDUkMsU0FBUyxJQUFJLENBQUNDLDBCQUEwQixDQUFDWCxhQUFhWCxRQUFRUSxLQUFLLENBQUNlLE1BQU07b0JBQzFFWixhQUFhQTtvQkFDYmEsZUFBZXhCLFFBQVFRLEtBQUssQ0FBQ2UsTUFBTTtvQkFDbkNFLGNBQWNoQjtvQkFDZGlCLGlCQUFpQixJQUFJLENBQUNDLHVCQUF1QixDQUFDaEI7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UUFFMUMseUVBQXlFO1FBQ3pFLE1BQU1HLFlBQVlGLFFBQVFHLE1BQU0sQ0FBQ3pCLENBQUFBO1lBQy9CLDhFQUE4RTtZQUM5RSxNQUFNMEIsY0FBYzFCLElBQUkyQixLQUFLLENBQUM7WUFDOUIseUVBQXlFO1lBQ3pFLE9BQU9ELFlBQVk3QyxNQUFNLElBQUksS0FBSzZDLFdBQVcsQ0FBQ0EsWUFBWTdDLE1BQU0sR0FBRyxFQUFFLENBQUNBLE1BQU0sSUFBSTtRQUNsRjtRQUVBLE9BQU87WUFDTFYsY0FBY3FELFVBQVUzQyxNQUFNLEdBQUc7WUFDakNQLE1BQU1rRDtRQUNSO0lBQ0Y7SUFFQTs7R0FFQyxHQUNELE9BQWU1QywyQkFBMkJGLFFBQTJCLEVBQUVrRCxTQUFpQixFQUFVO1FBQ2hHLElBQUlsRCxTQUFTUCxZQUFZLEVBQUU7WUFDekIsTUFBTTBELFdBQVduRCxTQUFTSixJQUFJLENBQUNPLE1BQU07WUFDckMsT0FBTyxnQ0FBcUQrQyxPQUFyQkEsV0FBVSxhQUFzREMsT0FBM0NELGNBQWMsSUFBSSxNQUFNLElBQUcsa0JBQStCQyxPQUFmQSxVQUFTLFFBQWdDLE9BQTFCQSxhQUFhLElBQUksTUFBTSxJQUFHO1FBQ2xKLE9BQU87WUFDTCxPQUFPLGdDQUFxREQsT0FBckJBLFdBQVUsYUFBc0MsT0FBM0JBLGNBQWMsSUFBSSxNQUFNLElBQUc7UUFDekY7SUFDRjtJQUVBOztHQUVDLEdBQ0QsT0FBZTNDLHdCQUF3QlAsUUFBMkIsRUFBWTtRQUM1RSxJQUFJQSxTQUFTUCxZQUFZLEVBQUU7WUFDekIsT0FBTztnQkFDTDtnQkFDQTtnQkFDQTthQUNEO1FBQ0gsT0FBTztZQUNMLE9BQU87Z0JBQ0w7Z0JBQ0E7YUFDRDtRQUNIO0lBQ0Y7QUFDRjtBQUVBLCtEQUFlZixTQUFTQSxFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL2ZlYXR1cmVzL2VkaXRvci9zZXJ2aWNlcy9haS1zZXJ2aWNlLnRzPzBhZTIiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBTZXJ2aWNpbyBwYXJhIG1hbmVqYXIgbGEgY29tdW5pY2FjacOzbiBjb24gbGEgSUEuXG4gKiBFc3RhIGVzIHVuYSBpbXBsZW1lbnRhY2nDs24gYmFzZSBxdWUgc2ltdWxhIHJlc3B1ZXN0YXMuXG4gKiBFbiBlbCBmdXR1cm8sIHNlIGNvbmVjdGFyw6EgY29uIHVuYSBBUEkgcmVhbC5cbiAqL1xuXG5pbnRlcmZhY2UgQUlBbmFseXNpc1JlcXVlc3Qge1xuICBtZXNzYWdlPzogc3RyaW5nO1xuICBpdGVtczogYW55W107IC8vIExvcyBlbGVtZW50b3Mgc2VsZWNjaW9uYWRvcyBlbiBsYSB0aW1lbGluZVxuICBjb250ZXh0PzogYW55OyAvLyBJbmZvcm1hY2nDs24gZGUgY29udGV4dG8gYWRpY2lvbmFsXG59XG5cbmludGVyZmFjZSBBSUFuYWx5c2lzUmVzcG9uc2Uge1xuICBzdWNjZXNzOiBib29sZWFuO1xuICBtZXNzYWdlOiBzdHJpbmc7XG4gIGFuYWx5c2lzPzogYW55OyAvLyBBbsOhbGlzaXMgZGV0YWxsYWRvIGRlIGxhIElBXG4gIGVycm9yPzogc3RyaW5nO1xufVxuXG5pbnRlcmZhY2UgVVJMQW5hbHlzaXNSZXN1bHQge1xuICBjb250YWluc1VSTHM6IGJvb2xlYW47XG4gIHVybHM6IHN0cmluZ1tdO1xuICBzY3JlZW5zaG90cz86IFVSTFNjcmVlbnNob3RJbmZvW107IC8vIEluZm9ybWFjacOzbiBkZSBzY3JlZW5zaG90cyBwYXJhIGxhcyBVUkxzXG59XG5cbmludGVyZmFjZSBVUkxTY3JlZW5zaG90SW5mbyB7XG4gIHVybDogc3RyaW5nO1xuICBzY3JlZW5zaG90UGF0aDogc3RyaW5nO1xufVxuXG5pbnRlcmZhY2UgSW50ZW50QW5hbHlzaXNSZXN1bHQge1xuICBoYXNJbnRlbnQ6IGJvb2xlYW47XG4gIGludGVudDogc3RyaW5nO1xuICBjb25maWRlbmNlOiBudW1iZXI7XG4gIHRhcmdldD86IHN0cmluZzsgLy8gUG9yIGVqZW1wbG8sIHVuYSBVUkwgZXNwZWPDrWZpY2FcbiAgYWN0aW9uPzogc3RyaW5nOyAvLyBBY2Npw7NuIGEgcmVhbGl6YXJcbn1cblxuZXhwb3J0IGNsYXNzIEFJU2VydmljZSB7XG4gIC8qKlxuICAgKiBBbmFsaXphIGxvcyBlbGVtZW50b3Mgc2VsZWNjaW9uYWRvcyBwYXJhIGJ1c2NhciBVUkxzXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIGFzeW5jIGFuYWx5emVJdGVtcyhyZXF1ZXN0OiBBSUFuYWx5c2lzUmVxdWVzdCk6IFByb21pc2U8QUlBbmFseXNpc1Jlc3BvbnNlPiB7XG4gICAgdHJ5IHtcbiAgICAgIC8vIFNpbXVsYW1vcyB1biB0aWVtcG8gZGUgcmVzcHVlc3RhIGRlIGxhIEFQSVxuICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDEwMDApKTtcblxuICAgICAgY29uc29sZS5sb2coJ0FJIFNlcnZpY2UgLSBSZXF1ZXN0OicsIHJlcXVlc3QpO1xuXG4gICAgICAvLyBFeHRyYWVyIGVsIHRleHRvIHJlbGV2YW50ZSBkZSBsb3MgZWxlbWVudG9zIHNlbGVjY2lvbmFkb3NcbiAgICAgIGNvbnN0IGVsZW1lbnRzVGV4dCA9IHRoaXMuZXh0cmFjdFRleHRGcm9tRWxlbWVudHMocmVxdWVzdC5pdGVtcyk7XG5cbiAgICAgIC8vIE1lbnNhamUgZXhwbMOtY2l0byBvIHRleHRvIGV4dHJhw61kbyBkZSBsb3MgZWxlbWVudG9zXG4gICAgICBjb25zdCB0ZXh0VG9BbmFseXplID0gcmVxdWVzdC5tZXNzYWdlIHx8IGVsZW1lbnRzVGV4dDtcblxuICAgICAgLy8gQW5hbGl6YXIgc2kgZWwgdGV4dG8gY29udGllbmUgVVJMc1xuICAgICAgY29uc3QgdXJsQW5hbHlzaXMgPSB0aGlzLmRldGVjdFVSTHModGV4dFRvQW5hbHl6ZSk7XG5cbiAgICAgIC8vIFNpIGhheSBVUkxzLCBnZW5lcmFyIGluZm9ybWFjacOzbiBkZSBzY3JlZW5zaG90c1xuICAgICAgaWYgKHVybEFuYWx5c2lzLmNvbnRhaW5zVVJMcykge1xuICAgICAgICB1cmxBbmFseXNpcy5zY3JlZW5zaG90cyA9IHRoaXMuZ2V0U2NyZWVuc2hvdHNGb3JVcmxzKHVybEFuYWx5c2lzLnVybHMpO1xuICAgICAgfVxuXG4gICAgICAvLyBBbmFsaXphciBsYSBpbnRlbmNpw7NuIGRlbCB1c3VhcmlvIHNpIGhheSB1biBtZW5zYWplIGV4cGzDrWNpdG9cbiAgICAgIGxldCBpbnRlbnRBbmFseXNpcyA9IG51bGw7XG4gICAgICBpZiAocmVxdWVzdC5tZXNzYWdlKSB7XG4gICAgICAgIGludGVudEFuYWx5c2lzID0gdGhpcy5hbmFseXplSW50ZW50KHJlcXVlc3QubWVzc2FnZSwgdXJsQW5hbHlzaXMpO1xuICAgICAgfVxuXG4gICAgICAvLyBTaW11bGFjacOzbiBkZSByZXNwdWVzdGEgZGUgbGEgSUFcbiAgICAgIC8vIEVuIHVuIGVudG9ybm8gcmVhbCwgZXN0byBlbnZpYXLDrWEgbGEgc29saWNpdHVkIGEgdW4gZW5kcG9pbnQgZGUgQVBJXG4gICAgICByZXR1cm4ge1xuICAgICAgICBzdWNjZXNzOiB0cnVlLFxuICAgICAgICBtZXNzYWdlOiBcIkFuw6FsaXNpcyBjb21wbGV0YWRvIGNvbiDDqXhpdG9cIixcbiAgICAgICAgYW5hbHlzaXM6IHtcbiAgICAgICAgICBzdW1tYXJ5OiB0aGlzLmdlbmVyYXRlVVJMQW5hbHlzaXNTdW1tYXJ5KHVybEFuYWx5c2lzLCByZXF1ZXN0Lml0ZW1zLmxlbmd0aCksXG4gICAgICAgICAgdXJsQW5hbHlzaXM6IHVybEFuYWx5c2lzLFxuICAgICAgICAgIGl0ZW1zQW5hbHl6ZWQ6IHJlcXVlc3QuaXRlbXMubGVuZ3RoLFxuICAgICAgICAgIGFuYWx5emVkVGV4dDogdGV4dFRvQW5hbHl6ZSxcbiAgICAgICAgICByZWNvbW1lbmRhdGlvbnM6IHRoaXMuZ2VuZXJhdGVSZWNvbW1lbmRhdGlvbnModXJsQW5hbHlzaXMpLFxuICAgICAgICAgIGludGVudEFuYWx5c2lzOiBpbnRlbnRBbmFseXNpcyxcbiAgICAgICAgICBjb25maWRlbmNlOiAwLjk1XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGluIEFJIHNlcnZpY2U6JywgZXJyb3IpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgIG1lc3NhZ2U6IFwiRXJyb3IgYWwgcHJvY2VzYXIgbGEgc29saWNpdHVkXCIsXG4gICAgICAgIGVycm9yOiBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6IFN0cmluZyhlcnJvcilcbiAgICAgIH07XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEFuYWxpemEgbGEgaW50ZW5jacOzbiBkZWwgdXN1YXJpbyBlbiBzdSBtZW5zYWplXG4gICAqL1xuICBwcml2YXRlIHN0YXRpYyBhbmFseXplSW50ZW50KG1lc3NhZ2U6IHN0cmluZywgdXJsQW5hbHlzaXM6IFVSTEFuYWx5c2lzUmVzdWx0KTogSW50ZW50QW5hbHlzaXNSZXN1bHQgfCBudWxsIHtcbiAgICAvLyBDb252ZXJ0aXIgYSBtaW7DunNjdWxhcyBwYXJhIGZhY2lsaXRhciBsYSBjb21wYXJhY2nDs25cbiAgICBjb25zdCBsb3dlck1lc3NhZ2UgPSBtZXNzYWdlLnRvTG93ZXJDYXNlKCk7XG5cbiAgICAvLyBQYXRyb25lcyBwYXJhIGRldGVjdGFyIGxhIGludGVuY2nDs24gZGUgdmVyIHVuYSBjYXB0dXJhIGRlIHBhbnRhbGxhXG4gICAgY29uc3Qgc2NyZWVuc2hvdFBhdHRlcm5zID0gW1xuICAgICAgJ211ZXN0cmEnLCAnbW9zdHJhcicsICd2ZXInLCAnc2NyZWVuc2hvdCcsICdjYXB0dXJhJywgJ2ltYWdlbicsICdwcmV2aXN1YWxpemFjacOzbicsXG4gICAgICAncHJldmlldycsICd2aXN1YWxpemEnLCAnZW5zZcOxYScsICdmb3RvJywgJ3NjcmVlbicsICdwYW50YWxsYSdcbiAgICBdO1xuXG4gICAgLy8gVmVyaWZpY2FyIHNpIGhheSBhbGfDum4gcGF0csOzbiBkZSBzY3JlZW5zaG90IGVuIGVsIG1lbnNhamVcbiAgICBjb25zdCBoYXNTY3JlZW5zaG90SW50ZW50ID0gc2NyZWVuc2hvdFBhdHRlcm5zLnNvbWUocGF0dGVybiA9PiBsb3dlck1lc3NhZ2UuaW5jbHVkZXMocGF0dGVybikpO1xuXG4gICAgLy8gU2kgbm8gaGF5IGludGVuY2nDs24gZGUgc2NyZWVuc2hvdCwgZGV2b2x2ZXIgbnVsbCBvIHVuIHJlc3VsdGFkbyBiw6FzaWNvXG4gICAgaWYgKCFoYXNTY3JlZW5zaG90SW50ZW50KSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBoYXNJbnRlbnQ6IGZhbHNlLFxuICAgICAgICBpbnRlbnQ6IFwidW5rbm93blwiLFxuICAgICAgICBjb25maWRlbmNlOiAwLjFcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gU2kgaGF5IFVSTHMgeSBoYXkgaW50ZW5jacOzbiBkZSB2ZXIgc2NyZWVuc2hvdHNcbiAgICBpZiAodXJsQW5hbHlzaXMuY29udGFpbnNVUkxzKSB7XG4gICAgICAvLyBJbnRlbnRhciBpZGVudGlmaWNhciBxdcOpIFVSTCBlc3BlY8OtZmljYSBxdWllcmUgdmVyXG4gICAgICBsZXQgdGFyZ2V0VXJsID0gdXJsQW5hbHlzaXMudXJsc1swXTsgLy8gUG9yIGRlZmVjdG8sIGxhIHByaW1lcmEgVVJMXG5cbiAgICAgIC8vIENvbXByb2JhciBzaSBlbCBtZW5zYWplIG1lbmNpb25hIGVzcGVjw61maWNhbWVudGUgYWxndW5hIGRlIGxhcyBVUkxzXG4gICAgICBmb3IgKGNvbnN0IHVybCBvZiB1cmxBbmFseXNpcy51cmxzKSB7XG4gICAgICAgIGlmIChsb3dlck1lc3NhZ2UuaW5jbHVkZXModXJsLnRvTG93ZXJDYXNlKCkpKSB7XG4gICAgICAgICAgdGFyZ2V0VXJsID0gdXJsO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGhhc0ludGVudDogdHJ1ZSxcbiAgICAgICAgaW50ZW50OiBcInZpZXdfc2NyZWVuc2hvdFwiLFxuICAgICAgICBjb25maWRlbmNlOiAwLjksXG4gICAgICAgIHRhcmdldDogdGFyZ2V0VXJsLFxuICAgICAgICBhY3Rpb246IFwic2hvd19zY3JlZW5zaG90XCJcbiAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGhhc0ludGVudDogdHJ1ZSxcbiAgICAgIGludGVudDogXCJ2aWV3X3NjcmVlbnNob3RcIixcbiAgICAgIGNvbmZpZGVuY2U6IDAuNyxcbiAgICAgIGFjdGlvbjogXCJyZXF1ZXN0X3VybFwiXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBPYnRpZW5lIGxhcyBjYXB0dXJhcyBkZSBwYW50YWxsYSBwYXJhIGxhcyBVUkxzIGRldGVjdGFkYXNcbiAgICogKENvbW8gZXMgdW4gZGVtbywgdXRpbGl6YW1vcyBsYSBtaXNtYSBpbWFnZW4gcGFyYSB0b2RhcyBsYXMgVVJMcylcbiAgICovXG4gIHByaXZhdGUgc3RhdGljIGdldFNjcmVlbnNob3RzRm9yVXJscyh1cmxzOiBzdHJpbmdbXSk6IFVSTFNjcmVlbnNob3RJbmZvW10ge1xuICAgIC8vIEVuIHVuIGVudG9ybm8gcmVhbCwgZXN0YSBmdW5jacOzbiByZWFsaXphcsOtYSB1bmEgbGxhbWFkYSBhIHVuIHNlcnZpY2lvXG4gICAgLy8gcXVlIGdlbmVyYXLDrWEgY2FwdHVyYXMgZGUgcGFudGFsbGEgcGFyYSBjYWRhIFVSTFxuICAgIC8vIFBvciBhaG9yYSwgdXNhbW9zIHVuYSBpbWFnZW4gZGUgZGVtb3N0cmFjacOzbiBwYXJhIHRvZGFzIGxhcyBVUkxzXG4gICAgcmV0dXJuIHVybHMubWFwKHVybCA9PiAoe1xuICAgICAgdXJsLFxuICAgICAgc2NyZWVuc2hvdFBhdGg6ICcvc2NyZWVuc2hvdHMvc2NyZWVuc2hvdDEucG5nJ1xuICAgIH0pKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBFeHRyYWUgdGV4dG8gZGUgbG9zIGVsZW1lbnRvcyBzZWxlY2Npb25hZG9zXG4gICAqL1xuICBwcml2YXRlIHN0YXRpYyBleHRyYWN0VGV4dEZyb21FbGVtZW50cyhpdGVtczogYW55W10pOiBzdHJpbmcge1xuICAgIC8vIEFxdcOtIGV4dHJhZW1vcyBlbCB0ZXh0byBkZSBsb3MgZWxlbWVudG9zIHNlbGVjY2lvbmFkb3NcbiAgICAvLyBFbiB1biBjYXNvIHJlYWwsIGVzdG8gZGVwZW5kZXLDrWEgZGUgbGEgZXN0cnVjdHVyYSBkZSB0dXMgZWxlbWVudG9zXG4gICAgbGV0IGV4dHJhY3RlZFRleHQgPSBcIlwiO1xuXG4gICAgZm9yIChjb25zdCBpdGVtIG9mIGl0ZW1zKSB7XG4gICAgICAvLyBJbnRlbnRhciBleHRyYWVyIHRleHRvIGRlIGRpZmVyZW50ZXMgcHJvcGllZGFkZXMgY29tdW5lc1xuICAgICAgLy8gRXN0byBlcyB1biBlamVtcGxvIHkgZGViZXLDrWEgYWRhcHRhcnNlIGEgdHUgZXN0cnVjdHVyYSBkZSBkYXRvcyByZWFsXG4gICAgICBpZiAoaXRlbS50ZXh0KSB7XG4gICAgICAgIGV4dHJhY3RlZFRleHQgKz0gXCIgXCIgKyBpdGVtLnRleHQ7XG4gICAgICB9IGVsc2UgaWYgKGl0ZW0uZGV0YWlscz8udGV4dCkge1xuICAgICAgICBleHRyYWN0ZWRUZXh0ICs9IFwiIFwiICsgaXRlbS5kZXRhaWxzLnRleHQ7XG4gICAgICB9IGVsc2UgaWYgKGl0ZW0ubmFtZSkge1xuICAgICAgICBleHRyYWN0ZWRUZXh0ICs9IFwiIFwiICsgaXRlbS5uYW1lO1xuICAgICAgfSBlbHNlIGlmIChpdGVtLnRpdGxlKSB7XG4gICAgICAgIGV4dHJhY3RlZFRleHQgKz0gXCIgXCIgKyBpdGVtLnRpdGxlO1xuICAgICAgfSBlbHNlIGlmIChpdGVtLmRlc2NyaXB0aW9uKSB7XG4gICAgICAgIGV4dHJhY3RlZFRleHQgKz0gXCIgXCIgKyBpdGVtLmRlc2NyaXB0aW9uO1xuICAgICAgfSBlbHNlIGlmIChpdGVtLmRldGFpbHM/LmRlc2NyaXB0aW9uKSB7XG4gICAgICAgIGV4dHJhY3RlZFRleHQgKz0gXCIgXCIgKyBpdGVtLmRldGFpbHMuZGVzY3JpcHRpb247XG4gICAgICB9IGVsc2UgaWYgKGl0ZW0uZGV0YWlscz8uc3JjKSB7XG4gICAgICAgIGV4dHJhY3RlZFRleHQgKz0gXCIgXCIgKyBpdGVtLmRldGFpbHMuc3JjO1xuICAgICAgfSBlbHNlIGlmIChpdGVtLnNyYykge1xuICAgICAgICBleHRyYWN0ZWRUZXh0ICs9IFwiIFwiICsgaXRlbS5zcmM7XG4gICAgICB9IGVsc2UgaWYgKGl0ZW0uY29udGVudCkge1xuICAgICAgICBleHRyYWN0ZWRUZXh0ICs9IFwiIFwiICsgaXRlbS5jb250ZW50O1xuICAgICAgfSBlbHNlIGlmIChpdGVtLmxhYmVsKSB7XG4gICAgICAgIGV4dHJhY3RlZFRleHQgKz0gXCIgXCIgKyBpdGVtLmxhYmVsO1xuICAgICAgfSBlbHNlIGlmIChpdGVtLnZhbHVlKSB7XG4gICAgICAgIGV4dHJhY3RlZFRleHQgKz0gXCIgXCIgKyBpdGVtLnZhbHVlO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgaXRlbSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgZXh0cmFjdGVkVGV4dCArPSBcIiBcIiArIGl0ZW07XG4gICAgICB9XG5cbiAgICAgIC8vIFRhbWJpw6luIHBvZGVtb3MgYnVzY2FyIGVuIGF0cmlidXRvcyBhbmlkYWRvc1xuICAgICAgaWYgKGl0ZW0ucHJvcHMgJiYgdHlwZW9mIGl0ZW0ucHJvcHMgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIGl0ZW0ucHJvcHMpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIGl0ZW0ucHJvcHNba2V5XSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGV4dHJhY3RlZFRleHQgKz0gXCIgXCIgKyBpdGVtLnByb3BzW2tleV07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFNpIHRvZGF2w61hIG5vIGhlbW9zIGVuY29udHJhZG8gdGV4dG8sIGludGVudGFtb3MgY29udmVydGlyIGVsIG9iamV0byBhIHN0cmluZ1xuICAgICAgaWYgKGV4dHJhY3RlZFRleHQudHJpbSgpID09PSBcIlwiICYmIGl0ZW0udG9TdHJpbmcpIHtcbiAgICAgICAgY29uc3Qgc3RyID0gaXRlbS50b1N0cmluZygpO1xuICAgICAgICBpZiAoc3RyICE9PSBcIltvYmplY3QgT2JqZWN0XVwiKSB7XG4gICAgICAgICAgZXh0cmFjdGVkVGV4dCArPSBcIiBcIiArIHN0cjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBleHRyYWN0ZWRUZXh0LnRyaW0oKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXRlY3RhIFVSTHMgZW4gdW4gdGV4dG9cbiAgICovXG4gIHByaXZhdGUgc3RhdGljIGRldGVjdFVSTHModGV4dDogc3RyaW5nKTogVVJMQW5hbHlzaXNSZXN1bHQge1xuICAgIC8vIEV4cHJlc2nDs24gcmVndWxhciBtZWpvcmFkYSBwYXJhIGNhcHR1cmFyIHVuYSB2YXJpZWRhZCBtw6FzIGFtcGxpYSBkZSBVUkxzXG4gICAgLy8gRXN0YSByZWdleCBidXNjYSBVUkxzIGNvbiBkaXZlcnNvcyBkb21pbmlvcyBkZSBuaXZlbCBzdXBlcmlvciAoLmNvbSwgLm9yZywgLmFpLCBldGMuKVxuICAgIGNvbnN0IHVybFJlZ2V4ID0gLyg/Omh0dHBzPzpcXC9cXC8pPyg/Ond3d1xcLik/Wy1hLXpBLVowLTlAOiUuX1xcK34jPV17MSwyNTZ9XFwuW2EtekEtWjAtOSgpXXsxLDZ9XFxiKD86Wy1hLXpBLVowLTkoKUA6JV9cXCsufiM/Ji8vPV0qKS9naTtcblxuICAgIGNvbnN0IG1hdGNoZXMgPSB0ZXh0Lm1hdGNoKHVybFJlZ2V4KSB8fCBbXTtcblxuICAgIC8vIEZpbHRyYXIgcG9zaWJsZXMgZmFsc29zIHBvc2l0aXZvcyAoY29tbyBuw7ptZXJvcyBkZSB2ZXJzacOzbjogMS4wLCBldGMuKVxuICAgIGNvbnN0IHZhbGlkVXJscyA9IG1hdGNoZXMuZmlsdGVyKHVybCA9PiB7XG4gICAgICAvLyBWZXJpZmljYXIgcXVlIGVsIGRvbWluaW8gdGVuZ2EgYWwgbWVub3MgdW4gcHVudG8geSBjYXJhY3RlcmVzIGFsZmFudW3DqXJpY29zXG4gICAgICBjb25zdCBkb21haW5QYXJ0cyA9IHVybC5zcGxpdCgnLicpO1xuICAgICAgLy8gRGViZSB0ZW5lciBhbCBtZW5vcyB1biBwdW50byB5IGVsIFRMRCBkZWJlIHRlbmVyIGFsIG1lbm9zIDIgY2FyYWN0ZXJlc1xuICAgICAgcmV0dXJuIGRvbWFpblBhcnRzLmxlbmd0aCA+PSAyICYmIGRvbWFpblBhcnRzW2RvbWFpblBhcnRzLmxlbmd0aCAtIDFdLmxlbmd0aCA+PSAyO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIGNvbnRhaW5zVVJMczogdmFsaWRVcmxzLmxlbmd0aCA+IDAsXG4gICAgICB1cmxzOiB2YWxpZFVybHNcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYSB1biByZXN1bWVuIGJhc2FkbyBlbiBlbCBhbsOhbGlzaXMgZGUgVVJMc1xuICAgKi9cbiAgcHJpdmF0ZSBzdGF0aWMgZ2VuZXJhdGVVUkxBbmFseXNpc1N1bW1hcnkoYW5hbHlzaXM6IFVSTEFuYWx5c2lzUmVzdWx0LCBpdGVtQ291bnQ6IG51bWJlcik6IHN0cmluZyB7XG4gICAgaWYgKGFuYWx5c2lzLmNvbnRhaW5zVVJMcykge1xuICAgICAgY29uc3QgdXJsQ291bnQgPSBhbmFseXNpcy51cmxzLmxlbmd0aDtcbiAgICAgIHJldHVybiBgSGUgYW5hbGl6YWRvIGVsIGNvbnRlbmlkbyBkZSAke2l0ZW1Db3VudH0gZWxlbWVudG8ke2l0ZW1Db3VudCAhPT0gMSA/ICdzJyA6ICcnfSB5IGVuY29udHJhZG8gJHt1cmxDb3VudH0gVVJMJHt1cmxDb3VudCAhPT0gMSA/ICdzJyA6ICcnfS5gO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gYEhlIGFuYWxpemFkbyBlbCBjb250ZW5pZG8gZGUgJHtpdGVtQ291bnR9IGVsZW1lbnRvJHtpdGVtQ291bnQgIT09IDEgPyAncycgOiAnJ30geSBubyBoZSBlbmNvbnRyYWRvIG5pbmd1bmEgVVJMLmA7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYSByZWNvbWVuZGFjaW9uZXMgYmFzYWRhcyBlbiBlbCBhbsOhbGlzaXMgZGUgVVJMc1xuICAgKi9cbiAgcHJpdmF0ZSBzdGF0aWMgZ2VuZXJhdGVSZWNvbW1lbmRhdGlvbnMoYW5hbHlzaXM6IFVSTEFuYWx5c2lzUmVzdWx0KTogc3RyaW5nW10ge1xuICAgIGlmIChhbmFseXNpcy5jb250YWluc1VSTHMpIHtcbiAgICAgIHJldHVybiBbXG4gICAgICAgIFwiQ29uc2lkZXJlIHZlcmlmaWNhciBzaSBsYXMgVVJMcyBzb24gc2VndXJhcyBhbnRlcyBkZSB1dGlsaXphcmxhcy5cIixcbiAgICAgICAgXCJBc2Vnw7pyZXNlIGRlIHF1ZSBsYXMgVVJMcyBlc3TDqW4gYWN0aXZhcyB5IGZ1bmNpb25lbiBjb3JyZWN0YW1lbnRlLlwiLFxuICAgICAgICBcIkNvbnNpZGVyZSByZXZpc2FyIHNpIGxvcyBlbmxhY2VzIGFwdW50YW4gYSBsb3MgcmVjdXJzb3MgZGVzZWFkb3MuXCJcbiAgICAgIF07XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBbXG4gICAgICAgIFwiRWwgY29udGVuaWRvIG5vIGNvbnRpZW5lIFVSTHMuIFNpIG5lY2VzaXRhIGluY2x1aXIgcmVmZXJlbmNpYXMgd2ViLCBjb25zaWRlcmUgYcOxYWRpcmxhcy5cIixcbiAgICAgICAgXCJQdWVkZSBhw7FhZGlyIGVubGFjZXMgYSByZWN1cnNvcyBhZGljaW9uYWxlcyBwYXJhIGVucmlxdWVjZXIgZWwgY29udGVuaWRvLlwiXG4gICAgICBdO1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBBSVNlcnZpY2U7XG4iXSwibmFtZXMiOlsiQUlTZXJ2aWNlIiwiYW5hbHl6ZUl0ZW1zIiwicmVxdWVzdCIsIlByb21pc2UiLCJyZXNvbHZlIiwic2V0VGltZW91dCIsImNvbnNvbGUiLCJsb2ciLCJlbGVtZW50c1RleHQiLCJleHRyYWN0VGV4dEZyb21FbGVtZW50cyIsIml0ZW1zIiwidGV4dFRvQW5hbHl6ZSIsIm1lc3NhZ2UiLCJ1cmxBbmFseXNpcyIsImRldGVjdFVSTHMiLCJjb250YWluc1VSTHMiLCJzY3JlZW5zaG90cyIsImdldFNjcmVlbnNob3RzRm9yVXJscyIsInVybHMiLCJpbnRlbnRBbmFseXNpcyIsImFuYWx5emVJbnRlbnQiLCJzdWNjZXNzIiwiYW5hbHlzaXMiLCJzdW1tYXJ5IiwiZ2VuZXJhdGVVUkxBbmFseXNpc1N1bW1hcnkiLCJsZW5ndGgiLCJpdGVtc0FuYWx5emVkIiwiYW5hbHl6ZWRUZXh0IiwicmVjb21tZW5kYXRpb25zIiwiZ2VuZXJhdGVSZWNvbW1lbmRhdGlvbnMiLCJjb25maWRlbmNlIiwiZXJyb3IiLCJFcnJvciIsIlN0cmluZyIsImxvd2VyTWVzc2FnZSIsInRvTG93ZXJDYXNlIiwic2NyZWVuc2hvdFBhdHRlcm5zIiwiaGFzU2NyZWVuc2hvdEludGVudCIsInNvbWUiLCJwYXR0ZXJuIiwiaW5jbHVkZXMiLCJoYXNJbnRlbnQiLCJpbnRlbnQiLCJ0YXJnZXRVcmwiLCJ1cmwiLCJ0YXJnZXQiLCJhY3Rpb24iLCJtYXAiLCJzY3JlZW5zaG90UGF0aCIsImV4dHJhY3RlZFRleHQiLCJpdGVtIiwidGV4dCIsImRldGFpbHMiLCJuYW1lIiwidGl0bGUiLCJkZXNjcmlwdGlvbiIsInNyYyIsImNvbnRlbnQiLCJsYWJlbCIsInZhbHVlIiwicHJvcHMiLCJrZXkiLCJ0cmltIiwidG9TdHJpbmciLCJzdHIiLCJ1cmxSZWdleCIsIm1hdGNoZXMiLCJtYXRjaCIsInZhbGlkVXJscyIsImZpbHRlciIsImRvbWFpblBhcnRzIiwic3BsaXQiLCJpdGVtQ291bnQiLCJ1cmxDb3VudCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./features/editor/services/ai-service.ts\n"));

/***/ })

});
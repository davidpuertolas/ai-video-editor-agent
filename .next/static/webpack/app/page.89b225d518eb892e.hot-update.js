"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./features/editor/services/ai-service.ts":
/*!************************************************!*\
  !*** ./features/editor/services/ai-service.ts ***!
  \************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AIService: function() { return /* binding */ AIService; }\n/* harmony export */ });\n/**\r\n * Servicio para manejar la comunicación con la IA.\r\n * Esta es una implementación base que simula respuestas.\r\n * En el futuro, se conectará con una API real.\r\n */ class AIService {\n    /**\r\n   * Analiza los elementos seleccionados para buscar URLs\r\n   */ static async analyzeItems(request) {\n        try {\n            // Simulamos un tiempo de respuesta de la API\n            await new Promise((resolve)=>setTimeout(resolve, 1000));\n            console.log(\"AI Service - Request:\", request);\n            // Extraer el texto relevante de los elementos seleccionados\n            const elementsText = this.extractTextFromElements(request.items);\n            // Mensaje explícito o texto extraído de los elementos\n            const textToAnalyze = request.message || elementsText;\n            // Analizar si el texto contiene URLs\n            const urlAnalysis = this.detectURLs(textToAnalyze);\n            // Si hay URLs, obtener capturas de pantalla\n            if (urlAnalysis.containsURLs && urlAnalysis.urls.length > 0) {\n                urlAnalysis.screenshots = await this.fetchScreenshotsForUrls(urlAnalysis.urls);\n            }\n            // Simulación de respuesta de la IA\n            // En un entorno real, esto enviaría la solicitud a un endpoint de API\n            return {\n                success: true,\n                message: \"An\\xe1lisis completado con \\xe9xito\",\n                analysis: {\n                    summary: this.generateURLAnalysisSummary(urlAnalysis, request.items.length),\n                    urlAnalysis: urlAnalysis,\n                    itemsAnalyzed: request.items.length,\n                    analyzedText: textToAnalyze,\n                    recommendations: this.generateRecommendations(urlAnalysis),\n                    confidence: 0.95\n                }\n            };\n        } catch (error) {\n            console.error(\"Error in AI service:\", error);\n            return {\n                success: false,\n                message: \"Error al procesar la solicitud\",\n                error: error instanceof Error ? error.message : String(error)\n            };\n        }\n    }\n    /**\r\n   * Extrae texto de los elementos seleccionados\r\n   */ static extractTextFromElements(items) {\n        // Aquí extraemos el texto de los elementos seleccionados\n        // En un caso real, esto dependería de la estructura de tus elementos\n        let extractedText = \"\";\n        for (const item of items){\n            var _item_details, _item_details1, _item_details2;\n            // Intentar extraer texto de diferentes propiedades comunes\n            // Esto es un ejemplo y debería adaptarse a tu estructura de datos real\n            if (item.text) {\n                extractedText += \" \" + item.text;\n            } else if ((_item_details = item.details) === null || _item_details === void 0 ? void 0 : _item_details.text) {\n                extractedText += \" \" + item.details.text;\n            } else if (item.name) {\n                extractedText += \" \" + item.name;\n            } else if (item.title) {\n                extractedText += \" \" + item.title;\n            } else if (item.description) {\n                extractedText += \" \" + item.description;\n            } else if ((_item_details1 = item.details) === null || _item_details1 === void 0 ? void 0 : _item_details1.description) {\n                extractedText += \" \" + item.details.description;\n            } else if ((_item_details2 = item.details) === null || _item_details2 === void 0 ? void 0 : _item_details2.src) {\n                extractedText += \" \" + item.details.src;\n            } else if (item.src) {\n                extractedText += \" \" + item.src;\n            } else if (item.content) {\n                extractedText += \" \" + item.content;\n            } else if (item.label) {\n                extractedText += \" \" + item.label;\n            } else if (item.value) {\n                extractedText += \" \" + item.value;\n            } else if (typeof item === \"string\") {\n                extractedText += \" \" + item;\n            }\n            // También podemos buscar en atributos anidados\n            if (item.props && typeof item.props === \"object\") {\n                for(const key in item.props){\n                    if (typeof item.props[key] === \"string\") {\n                        extractedText += \" \" + item.props[key];\n                    }\n                }\n            }\n            // Si todavía no hemos encontrado texto, intentamos convertir el objeto a string\n            if (extractedText.trim() === \"\" && item.toString) {\n                const str = item.toString();\n                if (str !== \"[object Object]\") {\n                    extractedText += \" \" + str;\n                }\n            }\n        }\n        return extractedText.trim();\n    }\n    /**\r\n   * Detecta URLs en un texto\r\n   */ static detectURLs(text) {\n        // Expresión regular mejorada para capturar una variedad más amplia de URLs\n        // Esta regex busca URLs con diversos dominios de nivel superior (.com, .org, .ai, etc.)\n        const urlRegex = /(?:https?:\\/\\/)?(?:www\\.)?[-a-zA-Z0-9@:%._\\+~#=]{1,256}\\.[a-zA-Z0-9()]{1,6}\\b(?:[-a-zA-Z0-9()@:%_\\+.~#?&//=]*)/gi;\n        const matches = text.match(urlRegex) || [];\n        // Filtrar posibles falsos positivos (como números de versión: 1.0, etc.)\n        const validUrls = matches.filter((url)=>{\n            // Verificar que el dominio tenga al menos un punto y caracteres alfanuméricos\n            const domainParts = url.split(\".\");\n            // Debe tener al menos un punto y el TLD debe tener al menos 2 caracteres\n            return domainParts.length >= 2 && domainParts[domainParts.length - 1].length >= 2;\n        });\n        return {\n            containsURLs: validUrls.length > 0,\n            urls: validUrls\n        };\n    }\n    /**\r\n   * Obtiene capturas de pantalla para las URLs proporcionadas\r\n   * Utiliza servicios de captura de pantalla de terceros\r\n   */ static async fetchScreenshotsForUrls(urls) {\n        const screenshots = [];\n        // Procesar cada URL en paralelo\n        const screenshotPromises = urls.map(async (url)=>{\n            try {\n                // Asegurarse de que la URL tenga el formato correcto para el servicio de captura\n                const formattedUrl = url.startsWith(\"http\") ? url : \"https://\".concat(url);\n                // Usar un servicio gratuito de capturas de pantalla\n                // En un ambiente de producción, deberías usar un servicio con API key\n                const screenshotUrl = \"https://api.apiflash.com/v1/urltoimage?access_key=demo&url=\".concat(encodeURIComponent(formattedUrl), \"&format=jpeg&quality=80&width=800&height=600\");\n                // En una implementación real, aquí verificarías que la captura se generó correctamente\n                return {\n                    url: url,\n                    screenshotUrl: screenshotUrl\n                };\n            } catch (error) {\n                console.error(\"Error al obtener captura para \".concat(url, \":\"), error);\n                return {\n                    url: url,\n                    error: error instanceof Error ? error.message : \"Error al generar la captura\"\n                };\n            }\n        });\n        // Esperar a que todas las capturas se completen\n        const results = await Promise.all(screenshotPromises);\n        return results;\n    }\n    /**\r\n   * Genera un resumen basado en el análisis de URLs\r\n   */ static generateURLAnalysisSummary(analysis, itemCount) {\n        if (analysis.containsURLs) {\n            const urlCount = analysis.urls.length;\n            return \"He analizado el contenido de \".concat(itemCount, \" elemento\").concat(itemCount !== 1 ? \"s\" : \"\", \" y encontrado \").concat(urlCount, \" URL\").concat(urlCount !== 1 ? \"s\" : \"\", \".\");\n        } else {\n            return \"He analizado el contenido de \".concat(itemCount, \" elemento\").concat(itemCount !== 1 ? \"s\" : \"\", \" y no he encontrado ninguna URL.\");\n        }\n    }\n    /**\r\n   * Genera recomendaciones basadas en el análisis de URLs\r\n   */ static generateRecommendations(analysis) {\n        if (analysis.containsURLs) {\n            return [\n                \"Considere verificar si las URLs son seguras antes de utilizarlas.\",\n                \"Aseg\\xfarese de que las URLs est\\xe9n activas y funcionen correctamente.\",\n                \"Considere revisar si los enlaces apuntan a los recursos deseados.\"\n            ];\n        } else {\n            return [\n                \"El contenido no contiene URLs. Si necesita incluir referencias web, considere a\\xf1adirlas.\",\n                \"Puede a\\xf1adir enlaces a recursos adicionales para enriquecer el contenido.\"\n            ];\n        }\n    }\n}\n/* harmony default export */ __webpack_exports__[\"default\"] = (AIService);\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2ZlYXR1cmVzL2VkaXRvci9zZXJ2aWNlcy9haS1zZXJ2aWNlLnRzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTs7OztDQUlDLEdBMkJNLE1BQU1BO0lBQ1g7O0dBRUMsR0FDRCxhQUFvQkMsYUFBYUMsT0FBMEIsRUFBK0I7UUFDeEYsSUFBSTtZQUNGLDZDQUE2QztZQUM3QyxNQUFNLElBQUlDLFFBQVFDLENBQUFBLFVBQVdDLFdBQVdELFNBQVM7WUFFakRFLFFBQVFDLEdBQUcsQ0FBQyx5QkFBeUJMO1lBRXJDLDREQUE0RDtZQUM1RCxNQUFNTSxlQUFlLElBQUksQ0FBQ0MsdUJBQXVCLENBQUNQLFFBQVFRLEtBQUs7WUFFL0Qsc0RBQXNEO1lBQ3RELE1BQU1DLGdCQUFnQlQsUUFBUVUsT0FBTyxJQUFJSjtZQUV6QyxxQ0FBcUM7WUFDckMsTUFBTUssY0FBYyxJQUFJLENBQUNDLFVBQVUsQ0FBQ0g7WUFFcEMsNENBQTRDO1lBQzVDLElBQUlFLFlBQVlFLFlBQVksSUFBSUYsWUFBWUcsSUFBSSxDQUFDQyxNQUFNLEdBQUcsR0FBRztnQkFDM0RKLFlBQVlLLFdBQVcsR0FBRyxNQUFNLElBQUksQ0FBQ0MsdUJBQXVCLENBQUNOLFlBQVlHLElBQUk7WUFDL0U7WUFFQSxtQ0FBbUM7WUFDbkMsc0VBQXNFO1lBQ3RFLE9BQU87Z0JBQ0xJLFNBQVM7Z0JBQ1RSLFNBQVM7Z0JBQ1RTLFVBQVU7b0JBQ1JDLFNBQVMsSUFBSSxDQUFDQywwQkFBMEIsQ0FBQ1YsYUFBYVgsUUFBUVEsS0FBSyxDQUFDTyxNQUFNO29CQUMxRUosYUFBYUE7b0JBQ2JXLGVBQWV0QixRQUFRUSxLQUFLLENBQUNPLE1BQU07b0JBQ25DUSxjQUFjZDtvQkFDZGUsaUJBQWlCLElBQUksQ0FBQ0MsdUJBQXVCLENBQUNkO29CQUM5Q2UsWUFBWTtnQkFDZDtZQUNGO1FBQ0YsRUFBRSxPQUFPQyxPQUFPO1lBQ2R2QixRQUFRdUIsS0FBSyxDQUFDLHdCQUF3QkE7WUFDdEMsT0FB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LElBQUksTUFBTSxJQUFHLGtCQUErQkMsT0FBZkEsVUFBUyxRQUFnQyxPQUExQkEsYUFBYSxJQUFJLE1BQU0sSUFBRztRQUNsSixPQUFPO1lBQ0wsT0FBTyxnQ0FBcURELE9BQXJCQSxXQUFVLGFBQXNDLE9BQTNCQSxjQUFjLElBQUksTUFBTSxJQUFHO1FBQ3pGO0lBQ0Y7SUFFQTs7R0FFQyxHQUNELE9BQWVyQyx3QkFBd0JOLFFBQTJCLEVBQVk7UUFDNUUsSUFBSUEsU0FBU04sWUFBWSxFQUFFO1lBQ3pCLE9BQU87Z0JBQ0w7Z0JBQ0E7Z0JBQ0E7YUFDRDtRQUNILE9BQU87WUFDTCxPQUFPO2dCQUNMO2dCQUNBO2FBQ0Q7UUFDSDtJQUNGO0FBQ0Y7QUFFQSwrREFBZWYsU0FBU0EsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9mZWF0dXJlcy9lZGl0b3Ivc2VydmljZXMvYWktc2VydmljZS50cz8wYWUyIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxyXG4gKiBTZXJ2aWNpbyBwYXJhIG1hbmVqYXIgbGEgY29tdW5pY2FjacOzbiBjb24gbGEgSUEuXHJcbiAqIEVzdGEgZXMgdW5hIGltcGxlbWVudGFjacOzbiBiYXNlIHF1ZSBzaW11bGEgcmVzcHVlc3Rhcy5cclxuICogRW4gZWwgZnV0dXJvLCBzZSBjb25lY3RhcsOhIGNvbiB1bmEgQVBJIHJlYWwuXHJcbiAqL1xyXG5cclxuaW50ZXJmYWNlIEFJQW5hbHlzaXNSZXF1ZXN0IHtcclxuICBtZXNzYWdlPzogc3RyaW5nO1xyXG4gIGl0ZW1zOiBhbnlbXTsgLy8gTG9zIGVsZW1lbnRvcyBzZWxlY2Npb25hZG9zIGVuIGxhIHRpbWVsaW5lXHJcbiAgY29udGV4dD86IGFueTsgLy8gSW5mb3JtYWNpw7NuIGRlIGNvbnRleHRvIGFkaWNpb25hbFxyXG59XHJcblxyXG5pbnRlcmZhY2UgQUlBbmFseXNpc1Jlc3BvbnNlIHtcclxuICBzdWNjZXNzOiBib29sZWFuO1xyXG4gIG1lc3NhZ2U6IHN0cmluZztcclxuICBhbmFseXNpcz86IGFueTsgLy8gQW7DoWxpc2lzIGRldGFsbGFkbyBkZSBsYSBJQVxyXG4gIGVycm9yPzogc3RyaW5nO1xyXG59XHJcblxyXG5pbnRlcmZhY2UgVVJMU2NyZWVuc2hvdEluZm8ge1xyXG4gIHVybDogc3RyaW5nO1xyXG4gIHNjcmVlbnNob3RVcmw6IHN0cmluZzsgLy8gVVJMIGRlIGxhIGNhcHR1cmEgZGUgcGFudGFsbGFcclxuICBlcnJvcj86IHN0cmluZzsgLy8gRXJyb3IgZW4gY2FzbyBkZSBxdWUgZmFsbGUgbGEgY2FwdHVyYVxyXG59XHJcblxyXG5pbnRlcmZhY2UgVVJMQW5hbHlzaXNSZXN1bHQge1xyXG4gIGNvbnRhaW5zVVJMczogYm9vbGVhbjtcclxuICB1cmxzOiBzdHJpbmdbXTtcclxuICBzY3JlZW5zaG90cz86IFVSTFNjcmVlbnNob3RJbmZvW107IC8vIENhcHR1cmFzIGRlIHBhbnRhbGxhIGRlIGxhcyBVUkxzXHJcbn1cclxuXHJcbmV4cG9ydCBjbGFzcyBBSVNlcnZpY2Uge1xyXG4gIC8qKlxyXG4gICAqIEFuYWxpemEgbG9zIGVsZW1lbnRvcyBzZWxlY2Npb25hZG9zIHBhcmEgYnVzY2FyIFVSTHNcclxuICAgKi9cclxuICBwdWJsaWMgc3RhdGljIGFzeW5jIGFuYWx5emVJdGVtcyhyZXF1ZXN0OiBBSUFuYWx5c2lzUmVxdWVzdCk6IFByb21pc2U8QUlBbmFseXNpc1Jlc3BvbnNlPiB7XHJcbiAgICB0cnkge1xyXG4gICAgICAvLyBTaW11bGFtb3MgdW4gdGllbXBvIGRlIHJlc3B1ZXN0YSBkZSBsYSBBUElcclxuICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDEwMDApKTtcclxuXHJcbiAgICAgIGNvbnNvbGUubG9nKCdBSSBTZXJ2aWNlIC0gUmVxdWVzdDonLCByZXF1ZXN0KTtcclxuXHJcbiAgICAgIC8vIEV4dHJhZXIgZWwgdGV4dG8gcmVsZXZhbnRlIGRlIGxvcyBlbGVtZW50b3Mgc2VsZWNjaW9uYWRvc1xyXG4gICAgICBjb25zdCBlbGVtZW50c1RleHQgPSB0aGlzLmV4dHJhY3RUZXh0RnJvbUVsZW1lbnRzKHJlcXVlc3QuaXRlbXMpO1xyXG5cclxuICAgICAgLy8gTWVuc2FqZSBleHBsw61jaXRvIG8gdGV4dG8gZXh0cmHDrWRvIGRlIGxvcyBlbGVtZW50b3NcclxuICAgICAgY29uc3QgdGV4dFRvQW5hbHl6ZSA9IHJlcXVlc3QubWVzc2FnZSB8fCBlbGVtZW50c1RleHQ7XHJcblxyXG4gICAgICAvLyBBbmFsaXphciBzaSBlbCB0ZXh0byBjb250aWVuZSBVUkxzXHJcbiAgICAgIGNvbnN0IHVybEFuYWx5c2lzID0gdGhpcy5kZXRlY3RVUkxzKHRleHRUb0FuYWx5emUpO1xyXG5cclxuICAgICAgLy8gU2kgaGF5IFVSTHMsIG9idGVuZXIgY2FwdHVyYXMgZGUgcGFudGFsbGFcclxuICAgICAgaWYgKHVybEFuYWx5c2lzLmNvbnRhaW5zVVJMcyAmJiB1cmxBbmFseXNpcy51cmxzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICB1cmxBbmFseXNpcy5zY3JlZW5zaG90cyA9IGF3YWl0IHRoaXMuZmV0Y2hTY3JlZW5zaG90c0ZvclVybHModXJsQW5hbHlzaXMudXJscyk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIFNpbXVsYWNpw7NuIGRlIHJlc3B1ZXN0YSBkZSBsYSBJQVxyXG4gICAgICAvLyBFbiB1biBlbnRvcm5vIHJlYWwsIGVzdG8gZW52aWFyw61hIGxhIHNvbGljaXR1ZCBhIHVuIGVuZHBvaW50IGRlIEFQSVxyXG4gICAgICByZXR1cm4ge1xyXG4gICAgICAgIHN1Y2Nlc3M6IHRydWUsXHJcbiAgICAgICAgbWVzc2FnZTogXCJBbsOhbGlzaXMgY29tcGxldGFkbyBjb24gw6l4aXRvXCIsXHJcbiAgICAgICAgYW5hbHlzaXM6IHtcclxuICAgICAgICAgIHN1bW1hcnk6IHRoaXMuZ2VuZXJhdGVVUkxBbmFseXNpc1N1bW1hcnkodXJsQW5hbHlzaXMsIHJlcXVlc3QuaXRlbXMubGVuZ3RoKSxcclxuICAgICAgICAgIHVybEFuYWx5c2lzOiB1cmxBbmFseXNpcyxcclxuICAgICAgICAgIGl0ZW1zQW5hbHl6ZWQ6IHJlcXVlc3QuaXRlbXMubGVuZ3RoLFxyXG4gICAgICAgICAgYW5hbHl6ZWRUZXh0OiB0ZXh0VG9BbmFseXplLFxyXG4gICAgICAgICAgcmVjb21tZW5kYXRpb25zOiB0aGlzLmdlbmVyYXRlUmVjb21tZW5kYXRpb25zKHVybEFuYWx5c2lzKSxcclxuICAgICAgICAgIGNvbmZpZGVuY2U6IDAuOTVcclxuICAgICAgICB9XHJcbiAgICAgIH07XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBpbiBBSSBzZXJ2aWNlOicsIGVycm9yKTtcclxuICAgICAgcmV0dXJuIHtcclxuICAgICAgICBzdWNjZXNzOiBmYWxzZSxcclxuICAgICAgICBtZXNzYWdlOiBcIkVycm9yIGFsIHByb2Nlc2FyIGxhIHNvbGljaXR1ZFwiLFxyXG4gICAgICAgIGVycm9yOiBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6IFN0cmluZyhlcnJvcilcclxuICAgICAgfTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEV4dHJhZSB0ZXh0byBkZSBsb3MgZWxlbWVudG9zIHNlbGVjY2lvbmFkb3NcclxuICAgKi9cclxuICBwcml2YXRlIHN0YXRpYyBleHRyYWN0VGV4dEZyb21FbGVtZW50cyhpdGVtczogYW55W10pOiBzdHJpbmcge1xyXG4gICAgLy8gQXF1w60gZXh0cmFlbW9zIGVsIHRleHRvIGRlIGxvcyBlbGVtZW50b3Mgc2VsZWNjaW9uYWRvc1xyXG4gICAgLy8gRW4gdW4gY2FzbyByZWFsLCBlc3RvIGRlcGVuZGVyw61hIGRlIGxhIGVzdHJ1Y3R1cmEgZGUgdHVzIGVsZW1lbnRvc1xyXG4gICAgbGV0IGV4dHJhY3RlZFRleHQgPSBcIlwiO1xyXG5cclxuICAgIGZvciAoY29uc3QgaXRlbSBvZiBpdGVtcykge1xyXG4gICAgICAvLyBJbnRlbnRhciBleHRyYWVyIHRleHRvIGRlIGRpZmVyZW50ZXMgcHJvcGllZGFkZXMgY29tdW5lc1xyXG4gICAgICAvLyBFc3RvIGVzIHVuIGVqZW1wbG8geSBkZWJlcsOtYSBhZGFwdGFyc2UgYSB0dSBlc3RydWN0dXJhIGRlIGRhdG9zIHJlYWxcclxuICAgICAgaWYgKGl0ZW0udGV4dCkge1xyXG4gICAgICAgIGV4dHJhY3RlZFRleHQgKz0gXCIgXCIgKyBpdGVtLnRleHQ7XHJcbiAgICAgIH0gZWxzZSBpZiAoaXRlbS5kZXRhaWxzPy50ZXh0KSB7XHJcbiAgICAgICAgZXh0cmFjdGVkVGV4dCArPSBcIiBcIiArIGl0ZW0uZGV0YWlscy50ZXh0O1xyXG4gICAgICB9IGVsc2UgaWYgKGl0ZW0ubmFtZSkge1xyXG4gICAgICAgIGV4dHJhY3RlZFRleHQgKz0gXCIgXCIgKyBpdGVtLm5hbWU7XHJcbiAgICAgIH0gZWxzZSBpZiAoaXRlbS50aXRsZSkge1xyXG4gICAgICAgIGV4dHJhY3RlZFRleHQgKz0gXCIgXCIgKyBpdGVtLnRpdGxlO1xyXG4gICAgICB9IGVsc2UgaWYgKGl0ZW0uZGVzY3JpcHRpb24pIHtcclxuICAgICAgICBleHRyYWN0ZWRUZXh0ICs9IFwiIFwiICsgaXRlbS5kZXNjcmlwdGlvbjtcclxuICAgICAgfSBlbHNlIGlmIChpdGVtLmRldGFpbHM/LmRlc2NyaXB0aW9uKSB7XHJcbiAgICAgICAgZXh0cmFjdGVkVGV4dCArPSBcIiBcIiArIGl0ZW0uZGV0YWlscy5kZXNjcmlwdGlvbjtcclxuICAgICAgfSBlbHNlIGlmIChpdGVtLmRldGFpbHM/LnNyYykge1xyXG4gICAgICAgIGV4dHJhY3RlZFRleHQgKz0gXCIgXCIgKyBpdGVtLmRldGFpbHMuc3JjO1xyXG4gICAgICB9IGVsc2UgaWYgKGl0ZW0uc3JjKSB7XHJcbiAgICAgICAgZXh0cmFjdGVkVGV4dCArPSBcIiBcIiArIGl0ZW0uc3JjO1xyXG4gICAgICB9IGVsc2UgaWYgKGl0ZW0uY29udGVudCkge1xyXG4gICAgICAgIGV4dHJhY3RlZFRleHQgKz0gXCIgXCIgKyBpdGVtLmNvbnRlbnQ7XHJcbiAgICAgIH0gZWxzZSBpZiAoaXRlbS5sYWJlbCkge1xyXG4gICAgICAgIGV4dHJhY3RlZFRleHQgKz0gXCIgXCIgKyBpdGVtLmxhYmVsO1xyXG4gICAgICB9IGVsc2UgaWYgKGl0ZW0udmFsdWUpIHtcclxuICAgICAgICBleHRyYWN0ZWRUZXh0ICs9IFwiIFwiICsgaXRlbS52YWx1ZTtcclxuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgaXRlbSA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICBleHRyYWN0ZWRUZXh0ICs9IFwiIFwiICsgaXRlbTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gVGFtYmnDqW4gcG9kZW1vcyBidXNjYXIgZW4gYXRyaWJ1dG9zIGFuaWRhZG9zXHJcbiAgICAgIGlmIChpdGVtLnByb3BzICYmIHR5cGVvZiBpdGVtLnByb3BzID09PSAnb2JqZWN0Jykge1xyXG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIGl0ZW0ucHJvcHMpIHtcclxuICAgICAgICAgIGlmICh0eXBlb2YgaXRlbS5wcm9wc1trZXldID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICBleHRyYWN0ZWRUZXh0ICs9IFwiIFwiICsgaXRlbS5wcm9wc1trZXldO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gU2kgdG9kYXbDrWEgbm8gaGVtb3MgZW5jb250cmFkbyB0ZXh0bywgaW50ZW50YW1vcyBjb252ZXJ0aXIgZWwgb2JqZXRvIGEgc3RyaW5nXHJcbiAgICAgIGlmIChleHRyYWN0ZWRUZXh0LnRyaW0oKSA9PT0gXCJcIiAmJiBpdGVtLnRvU3RyaW5nKSB7XHJcbiAgICAgICAgY29uc3Qgc3RyID0gaXRlbS50b1N0cmluZygpO1xyXG4gICAgICAgIGlmIChzdHIgIT09IFwiW29iamVjdCBPYmplY3RdXCIpIHtcclxuICAgICAgICAgIGV4dHJhY3RlZFRleHQgKz0gXCIgXCIgKyBzdHI7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGV4dHJhY3RlZFRleHQudHJpbSgpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRGV0ZWN0YSBVUkxzIGVuIHVuIHRleHRvXHJcbiAgICovXHJcbiAgcHJpdmF0ZSBzdGF0aWMgZGV0ZWN0VVJMcyh0ZXh0OiBzdHJpbmcpOiBVUkxBbmFseXNpc1Jlc3VsdCB7XHJcbiAgICAvLyBFeHByZXNpw7NuIHJlZ3VsYXIgbWVqb3JhZGEgcGFyYSBjYXB0dXJhciB1bmEgdmFyaWVkYWQgbcOhcyBhbXBsaWEgZGUgVVJMc1xyXG4gICAgLy8gRXN0YSByZWdleCBidXNjYSBVUkxzIGNvbiBkaXZlcnNvcyBkb21pbmlvcyBkZSBuaXZlbCBzdXBlcmlvciAoLmNvbSwgLm9yZywgLmFpLCBldGMuKVxyXG4gICAgY29uc3QgdXJsUmVnZXggPSAvKD86aHR0cHM/OlxcL1xcLyk/KD86d3d3XFwuKT9bLWEtekEtWjAtOUA6JS5fXFwrfiM9XXsxLDI1Nn1cXC5bYS16QS1aMC05KCldezEsNn1cXGIoPzpbLWEtekEtWjAtOSgpQDolX1xcKy5+Iz8mLy89XSopL2dpO1xyXG5cclxuICAgIGNvbnN0IG1hdGNoZXMgPSB0ZXh0Lm1hdGNoKHVybFJlZ2V4KSB8fCBbXTtcclxuXHJcbiAgICAvLyBGaWx0cmFyIHBvc2libGVzIGZhbHNvcyBwb3NpdGl2b3MgKGNvbW8gbsO6bWVyb3MgZGUgdmVyc2nDs246IDEuMCwgZXRjLilcclxuICAgIGNvbnN0IHZhbGlkVXJscyA9IG1hdGNoZXMuZmlsdGVyKHVybCA9PiB7XHJcbiAgICAgIC8vIFZlcmlmaWNhciBxdWUgZWwgZG9taW5pbyB0ZW5nYSBhbCBtZW5vcyB1biBwdW50byB5IGNhcmFjdGVyZXMgYWxmYW51bcOpcmljb3NcclxuICAgICAgY29uc3QgZG9tYWluUGFydHMgPSB1cmwuc3BsaXQoJy4nKTtcclxuICAgICAgLy8gRGViZSB0ZW5lciBhbCBtZW5vcyB1biBwdW50byB5IGVsIFRMRCBkZWJlIHRlbmVyIGFsIG1lbm9zIDIgY2FyYWN0ZXJlc1xyXG4gICAgICByZXR1cm4gZG9tYWluUGFydHMubGVuZ3RoID49IDIgJiYgZG9tYWluUGFydHNbZG9tYWluUGFydHMubGVuZ3RoIC0gMV0ubGVuZ3RoID49IDI7XHJcbiAgICB9KTtcclxuXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBjb250YWluc1VSTHM6IHZhbGlkVXJscy5sZW5ndGggPiAwLFxyXG4gICAgICB1cmxzOiB2YWxpZFVybHNcclxuICAgIH07XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBPYnRpZW5lIGNhcHR1cmFzIGRlIHBhbnRhbGxhIHBhcmEgbGFzIFVSTHMgcHJvcG9yY2lvbmFkYXNcclxuICAgKiBVdGlsaXphIHNlcnZpY2lvcyBkZSBjYXB0dXJhIGRlIHBhbnRhbGxhIGRlIHRlcmNlcm9zXHJcbiAgICovXHJcbiAgcHJpdmF0ZSBzdGF0aWMgYXN5bmMgZmV0Y2hTY3JlZW5zaG90c0ZvclVybHModXJsczogc3RyaW5nW10pOiBQcm9taXNlPFVSTFNjcmVlbnNob3RJbmZvW10+IHtcclxuICAgIGNvbnN0IHNjcmVlbnNob3RzOiBVUkxTY3JlZW5zaG90SW5mb1tdID0gW107XHJcblxyXG4gICAgLy8gUHJvY2VzYXIgY2FkYSBVUkwgZW4gcGFyYWxlbG9cclxuICAgIGNvbnN0IHNjcmVlbnNob3RQcm9taXNlcyA9IHVybHMubWFwKGFzeW5jICh1cmwpID0+IHtcclxuICAgICAgdHJ5IHtcclxuICAgICAgICAvLyBBc2VndXJhcnNlIGRlIHF1ZSBsYSBVUkwgdGVuZ2EgZWwgZm9ybWF0byBjb3JyZWN0byBwYXJhIGVsIHNlcnZpY2lvIGRlIGNhcHR1cmFcclxuICAgICAgICBjb25zdCBmb3JtYXR0ZWRVcmwgPSB1cmwuc3RhcnRzV2l0aCgnaHR0cCcpID8gdXJsIDogYGh0dHBzOi8vJHt1cmx9YDtcclxuXHJcbiAgICAgICAgLy8gVXNhciB1biBzZXJ2aWNpbyBncmF0dWl0byBkZSBjYXB0dXJhcyBkZSBwYW50YWxsYVxyXG4gICAgICAgIC8vIEVuIHVuIGFtYmllbnRlIGRlIHByb2R1Y2Npw7NuLCBkZWJlcsOtYXMgdXNhciB1biBzZXJ2aWNpbyBjb24gQVBJIGtleVxyXG4gICAgICAgIGNvbnN0IHNjcmVlbnNob3RVcmwgPSBgaHR0cHM6Ly9hcGkuYXBpZmxhc2guY29tL3YxL3VybHRvaW1hZ2U/YWNjZXNzX2tleT1kZW1vJnVybD0ke2VuY29kZVVSSUNvbXBvbmVudChmb3JtYXR0ZWRVcmwpfSZmb3JtYXQ9anBlZyZxdWFsaXR5PTgwJndpZHRoPTgwMCZoZWlnaHQ9NjAwYDtcclxuXHJcbiAgICAgICAgLy8gRW4gdW5hIGltcGxlbWVudGFjacOzbiByZWFsLCBhcXXDrSB2ZXJpZmljYXLDrWFzIHF1ZSBsYSBjYXB0dXJhIHNlIGdlbmVyw7MgY29ycmVjdGFtZW50ZVxyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICB1cmw6IHVybCxcclxuICAgICAgICAgIHNjcmVlbnNob3RVcmw6IHNjcmVlbnNob3RVcmxcclxuICAgICAgICB9O1xyXG4gICAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIGFsIG9idGVuZXIgY2FwdHVyYSBwYXJhICR7dXJsfTpgLCBlcnJvcik7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgIHVybDogdXJsLFxyXG4gICAgICAgICAgZXJyb3I6IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogJ0Vycm9yIGFsIGdlbmVyYXIgbGEgY2FwdHVyYSdcclxuICAgICAgICB9O1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICAvLyBFc3BlcmFyIGEgcXVlIHRvZGFzIGxhcyBjYXB0dXJhcyBzZSBjb21wbGV0ZW5cclxuICAgIGNvbnN0IHJlc3VsdHMgPSBhd2FpdCBQcm9taXNlLmFsbChzY3JlZW5zaG90UHJvbWlzZXMpO1xyXG4gICAgcmV0dXJuIHJlc3VsdHM7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBHZW5lcmEgdW4gcmVzdW1lbiBiYXNhZG8gZW4gZWwgYW7DoWxpc2lzIGRlIFVSTHNcclxuICAgKi9cclxuICBwcml2YXRlIHN0YXRpYyBnZW5lcmF0ZVVSTEFuYWx5c2lzU3VtbWFyeShhbmFseXNpczogVVJMQW5hbHlzaXNSZXN1bHQsIGl0ZW1Db3VudDogbnVtYmVyKTogc3RyaW5nIHtcclxuICAgIGlmIChhbmFseXNpcy5jb250YWluc1VSTHMpIHtcclxuICAgICAgY29uc3QgdXJsQ291bnQgPSBhbmFseXNpcy51cmxzLmxlbmd0aDtcclxuICAgICAgcmV0dXJuIGBIZSBhbmFsaXphZG8gZWwgY29udGVuaWRvIGRlICR7aXRlbUNvdW50fSBlbGVtZW50byR7aXRlbUNvdW50ICE9PSAxID8gJ3MnIDogJyd9IHkgZW5jb250cmFkbyAke3VybENvdW50fSBVUkwke3VybENvdW50ICE9PSAxID8gJ3MnIDogJyd9LmA7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICByZXR1cm4gYEhlIGFuYWxpemFkbyBlbCBjb250ZW5pZG8gZGUgJHtpdGVtQ291bnR9IGVsZW1lbnRvJHtpdGVtQ291bnQgIT09IDEgPyAncycgOiAnJ30geSBubyBoZSBlbmNvbnRyYWRvIG5pbmd1bmEgVVJMLmA7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBHZW5lcmEgcmVjb21lbmRhY2lvbmVzIGJhc2FkYXMgZW4gZWwgYW7DoWxpc2lzIGRlIFVSTHNcclxuICAgKi9cclxuICBwcml2YXRlIHN0YXRpYyBnZW5lcmF0ZVJlY29tbWVuZGF0aW9ucyhhbmFseXNpczogVVJMQW5hbHlzaXNSZXN1bHQpOiBzdHJpbmdbXSB7XHJcbiAgICBpZiAoYW5hbHlzaXMuY29udGFpbnNVUkxzKSB7XHJcbiAgICAgIHJldHVybiBbXHJcbiAgICAgICAgXCJDb25zaWRlcmUgdmVyaWZpY2FyIHNpIGxhcyBVUkxzIHNvbiBzZWd1cmFzIGFudGVzIGRlIHV0aWxpemFybGFzLlwiLFxyXG4gICAgICAgIFwiQXNlZ8O6cmVzZSBkZSBxdWUgbGFzIFVSTHMgZXN0w6luIGFjdGl2YXMgeSBmdW5jaW9uZW4gY29ycmVjdGFtZW50ZS5cIixcclxuICAgICAgICBcIkNvbnNpZGVyZSByZXZpc2FyIHNpIGxvcyBlbmxhY2VzIGFwdW50YW4gYSBsb3MgcmVjdXJzb3MgZGVzZWFkb3MuXCJcclxuICAgICAgXTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHJldHVybiBbXHJcbiAgICAgICAgXCJFbCBjb250ZW5pZG8gbm8gY29udGllbmUgVVJMcy4gU2kgbmVjZXNpdGEgaW5jbHVpciByZWZlcmVuY2lhcyB3ZWIsIGNvbnNpZGVyZSBhw7FhZGlybGFzLlwiLFxyXG4gICAgICAgIFwiUHVlZGUgYcOxYWRpciBlbmxhY2VzIGEgcmVjdXJzb3MgYWRpY2lvbmFsZXMgcGFyYSBlbnJpcXVlY2VyIGVsIGNvbnRlbmlkby5cIlxyXG4gICAgICBdO1xyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgQUlTZXJ2aWNlO1xyXG4iXSwibmFtZXMiOlsiQUlTZXJ2aWNlIiwiYW5hbHl6ZUl0ZW1zIiwicmVxdWVzdCIsIlByb21pc2UiLCJyZXNvbHZlIiwic2V0VGltZW91dCIsImNvbnNvbGUiLCJsb2ciLCJlbGVtZW50c1RleHQiLCJleHRyYWN0VGV4dEZyb21FbGVtZW50cyIsIml0ZW1zIiwidGV4dFRvQW5hbHl6ZSIsIm1lc3NhZ2UiLCJ1cmxBbmFseXNpcyIsImRldGVjdFVSTHMiLCJjb250YWluc1VSTHMiLCJ1cmxzIiwibGVuZ3RoIiwic2NyZWVuc2hvdHMiLCJmZXRjaFNjcmVlbnNob3RzRm9yVXJscyIsInN1Y2Nlc3MiLCJhbmFseXNpcyIsInN1bW1hcnkiLCJnZW5lcmF0ZVVSTEFuYWx5c2lzU3VtbWFyeSIsIml0ZW1zQW5hbHl6ZWQiLCJhbmFseXplZFRleHQiLCJyZWNvbW1lbmRhdGlvbnMiLCJnZW5lcmF0ZVJlY29tbWVuZGF0aW9ucyIsImNvbmZpZGVuY2UiLCJlcnJvciIsIkVycm9yIiwiU3RyaW5nIiwiZXh0cmFjdGVkVGV4dCIsIml0ZW0iLCJ0ZXh0IiwiZGV0YWlscyIsIm5hbWUiLCJ0aXRsZSIsImRlc2NyaXB0aW9uIiwic3JjIiwiY29udGVudCIsImxhYmVsIiwidmFsdWUiLCJwcm9wcyIsImtleSIsInRyaW0iLCJ0b1N0cmluZyIsInN0ciIsInVybFJlZ2V4IiwibWF0Y2hlcyIsIm1hdGNoIiwidmFsaWRVcmxzIiwiZmlsdGVyIiwidXJsIiwiZG9tYWluUGFydHMiLCJzcGxpdCIsInNjcmVlbnNob3RQcm9taXNlcyIsIm1hcCIsImZvcm1hdHRlZFVybCIsInN0YXJ0c1dpdGgiLCJzY3JlZW5zaG90VXJsIiwiZW5jb2RlVVJJQ29tcG9uZW50IiwicmVzdWx0cyIsImFsbCIsIml0ZW1Db3VudCIsInVybENvdW50Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./features/editor/services/ai-service.ts\n"));

/***/ })

});
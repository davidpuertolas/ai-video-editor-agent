"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./components/ai-chat/ai-video-commands.ts":
/*!*************************************************!*\
  !*** ./components/ai-chat/ai-video-commands.ts ***!
  \*************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createVideoCommandExecutor: function() { return /* binding */ createVideoCommandExecutor; }\n/* harmony export */ });\n/* harmony import */ var _designcombo_events__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @designcombo/events */ \"(app-pages-browser)/./node_modules/@designcombo/events/dist/index.es.js\");\n/* harmony import */ var _designcombo_state__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @designcombo/state */ \"(app-pages-browser)/./node_modules/@designcombo/state/dist/index.es.js\");\n/* harmony import */ var _designcombo_timeline__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @designcombo/timeline */ \"(app-pages-browser)/./node_modules/@designcombo/timeline/dist/index.es.js\");\n\n\n\nfunction createVideoCommandExecutor(stateManager) {\n    // Crear el objeto executor con todos los métodos\n    const executor = {\n        addText: (text, options)=>{\n            const position = (options === null || options === void 0 ? void 0 : options.position) || {\n                x: 0.5,\n                y: 0.5\n            }; // Centrado por defecto\n            const fontSize = (options === null || options === void 0 ? void 0 : options.fontSize) || 48;\n            const fontFamily = (options === null || options === void 0 ? void 0 : options.fontFamily) || \"Roboto-Bold\";\n            const color = (options === null || options === void 0 ? void 0 : options.color) || \"#FFFFFF\";\n            const startTime = (options === null || options === void 0 ? void 0 : options.startTime) || 0; // Por defecto al inicio\n            const endTime = (options === null || options === void 0 ? void 0 : options.endTime) || 5; // Por defecto 5 segundos de duración\n            // Crear payload para el texto\n            const textPayload = {\n                id: (0,_designcombo_timeline__WEBPACK_IMPORTED_MODULE_2__.generateId)(),\n                display: {\n                    from: startTime * 1000,\n                    to: endTime * 1000 // Convertir a milisegundos\n                },\n                type: \"text\",\n                details: {\n                    text: text,\n                    fontSize: fontSize,\n                    width: 600,\n                    fontFamily: fontFamily,\n                    color: color,\n                    wordWrap: \"break-word\",\n                    textAlign: \"center\",\n                    borderWidth: 0,\n                    borderColor: \"#000000\",\n                    boxShadow: {\n                        color: \"#ffffff\",\n                        x: 0,\n                        y: 0,\n                        blur: 0\n                    }\n                }\n            };\n            // Agregar texto al timeline\n            (0,_designcombo_events__WEBPACK_IMPORTED_MODULE_0__.dispatch)(_designcombo_state__WEBPACK_IMPORTED_MODULE_1__.ADD_TEXT, {\n                payload: textPayload,\n                options: {}\n            });\n        },\n        changeColor: (elementId, color)=>{\n            // Simulación de cambio de color (la implementación real dependerá de la estructura del proyecto)\n            console.log(\"Cambiando color del elemento \".concat(elementId, \" a \").concat(color));\n        // Aquí iría la lógica real para cambiar el color de un elemento\n        },\n        addImage: (url, options)=>{\n            try {\n                // Asegurar que tenemos una URL válida\n                if (!url) {\n                    console.error(\"❌ URL de imagen no v\\xe1lida o vac\\xeda\");\n                    throw new Error(\"URL de imagen no proporcionada\");\n                }\n                console.log(\"=== INICIANDO PROCESO DE A\\xd1ADIR IMAGEN ===\");\n                console.log(\"URL:\", url);\n                console.log(\"Opciones:\", JSON.stringify(options, null, 2));\n                // Verificar si es una URL genérica de referencia, que no debe usarse directamente\n                if (url === \"imagen_adjunta_por_el_usuario.jpg\" || url.includes(\"/url_de_la_imagen\")) {\n                    console.error(\"Error: URL de imagen gen\\xe9rica inv\\xe1lida detectada\", url);\n                    throw new Error(\"La URL de imagen no es v\\xe1lida. Se intent\\xf3 usar un marcador gen\\xe9rico directamente.\");\n                }\n                const width = (options === null || options === void 0 ? void 0 : options.width) || 480;\n                const height = (options === null || options === void 0 ? void 0 : options.height) || 270;\n                const startTime = (options === null || options === void 0 ? void 0 : options.startTime) !== undefined ? options.startTime : 0;\n                const endTime = (options === null || options === void 0 ? void 0 : options.endTime) !== undefined ? options.endTime : startTime + 5;\n                // Detectores de tipo de imagen\n                const isExplicitlyAnimated = (options === null || options === void 0 ? void 0 : options.isAnimated) === true;\n                const isExplicitlyStatic = (options === null || options === void 0 ? void 0 : options.isStatic) === true;\n                const isAPNG = url.toLowerCase().endsWith(\".apng\");\n                const isGIF = url.toLowerCase().endsWith(\".gif\");\n                // Determinar si debe tratarse como imagen animada\n                const shouldTreatAsAnimated = (isExplicitlyAnimated || isAPNG || isGIF) && !isExplicitlyStatic;\n                // Log de modo detectado\n                if (shouldTreatAsAnimated) {\n                    console.log(\"\\uD83D\\uDD36 Detectada imagen animada: \".concat(url));\n                    console.log(\"Tipo: \".concat(isAPNG ? \"APNG\" : isGIF ? \"GIF\" : \"Animada gen\\xe9rica\"));\n                } else if (isAPNG || isGIF) {\n                    console.log(\"\\uD83D\\uDD39 Detectada imagen potencialmente animada pero trat\\xe1ndola como est\\xe1tica: \".concat(url));\n                } else {\n                    console.log(\"\\uD83D\\uDD37 Detectada imagen est\\xe1tica: \".concat(url));\n                }\n                // Para depuración, mostrar parte de la URL (truncada si es data:URL)\n                const logUrl = url.startsWith(\"data:\") ? \"\".concat(url.substring(0, 30), \"... (data URL)\") : url;\n                console.log(\"A\\xf1adiendo imagen desde \".concat(logUrl, \" desde segundo \").concat(startTime, \" hasta \").concat(endTime));\n                // Posición (centrada por defecto)\n                const position = (options === null || options === void 0 ? void 0 : options.position) || {\n                    x: 0.5,\n                    y: 0.5\n                };\n                // Modos de escala\n                const scaleMode = (options === null || options === void 0 ? void 0 : options.scaleMode) || \"fit\";\n                const useFullScreen = scaleMode === \"cover\";\n                // Propiedades para el payload, común para ambos casos\n                const commonPayloadProps = {\n                    from: startTime * 1000,\n                    to: endTime * 1000\n                };\n                // Propiedades de detalle comunes\n                const commonDetailsProps = {\n                    src: url,\n                    width: width,\n                    height: height,\n                    opacity: 100,\n                    scaleMode: scaleMode,\n                    left: position.x,\n                    top: position.y,\n                    originX: \"center\",\n                    originY: \"center\"\n                };\n                // Crear ID único\n                const imageId = (0,_designcombo_timeline__WEBPACK_IMPORTED_MODULE_2__.generateId)();\n                // Crear el payload de imagen simplificado\n                const imagePayload = {\n                    id: imageId,\n                    display: commonPayloadProps,\n                    type: \"image\",\n                    details: {\n                        ...commonDetailsProps,\n                        // Si es animada, añadir atributos específicos\n                        ...shouldTreatAsAnimated && {\n                            isAnimated: true\n                        },\n                        // Si a pantalla completa, ajustar dimensiones\n                        ...useFullScreen && {\n                            width: 1920,\n                            height: 1080\n                        }\n                    }\n                };\n                console.log(\"Payload de imagen a despachar:\", JSON.stringify({\n                    ...imagePayload,\n                    details: {\n                        ...imagePayload.details,\n                        src: imagePayload.details.src.substring(0, 30) + (imagePayload.details.src.length > 30 ? \"...\" : \"\")\n                    }\n                }, null, 2));\n                // Opciones para el dispatch\n                const dispatchOptions = {\n                    scaleMode: scaleMode,\n                    position: position\n                };\n                // Despachar la acción para añadir la imagen\n                (0,_designcombo_events__WEBPACK_IMPORTED_MODULE_0__.dispatch)(_designcombo_state__WEBPACK_IMPORTED_MODULE_1__.ADD_IMAGE, {\n                    payload: imagePayload,\n                    options: dispatchOptions\n                });\n                // Log de éxito\n                if (shouldTreatAsAnimated) {\n                    console.log(\"✅ Imagen animada a\\xf1adida desde \".concat(startTime, \"s hasta \").concat(endTime, \"s\"));\n                } else {\n                    console.log(\"✅ Imagen est\\xe1tica a\\xf1adida desde \".concat(startTime, \"s hasta \").concat(endTime, \"s\"));\n                }\n            } catch (error) {\n                console.error(\"❌ ERROR CR\\xcdTICO al a\\xf1adir imagen:\", error);\n                console.error(\"Detalles completos:\", error.message);\n                console.error(\"Traza:\", error.stack);\n                throw error; // Propagar el error para manejo superior\n            }\n        },\n        addVideo: (url, options)=>{\n            try {\n                console.log(\"=== INICIANDO PROCESO DE A\\xd1ADIR VIDEO ===\");\n                console.log(\"URL:\", url);\n                console.log(\"Opciones:\", JSON.stringify(options, null, 2));\n                // Validación de URL\n                if (!url) {\n                    console.error(\"❌ URL de video no v\\xe1lida o vac\\xeda\");\n                    throw new Error(\"URL de video no proporcionada\");\n                }\n                const width = (options === null || options === void 0 ? void 0 : options.width) || 640;\n                const height = (options === null || options === void 0 ? void 0 : options.height) || 360;\n                const startTime = (options === null || options === void 0 ? void 0 : options.startTime) || 0; // Por defecto al inicio\n                const endTime = (options === null || options === void 0 ? void 0 : options.endTime) || 10; // Por defecto 10 segundos de duración\n                // Detectar si es un archivo AVI o APNG para tratamiento especial\n                const isAVI = url.toLowerCase().endsWith(\".avi\");\n                const isAPNG = url.toLowerCase().endsWith(\".apng\");\n                // Marcador pasado explícitamente - mayor prioridad que la extensión\n                const isExplicitAPNG = (options === null || options === void 0 ? void 0 : options.isAPNG) === true;\n                console.log(\"Formato detectado:\", isAVI ? \"AVI\" : isAPNG ? \"APNG\" : isExplicitAPNG ? \"Expl\\xedcitamente marcado como APNG\" : \"Formato est\\xe1ndar\");\n                // Si es APNG según algún criterio\n                const treatAsAPNG = isAPNG || isExplicitAPNG;\n                const useFullScreen = isAVI || treatAsAPNG || (options === null || options === void 0 ? void 0 : options.scaleMode) === \"cover\";\n                // Para archivos AVI y APNG, respectar duración natural si no se especifica\n                const respectNativeDuration = (isAVI || treatAsAPNG) && !(options === null || options === void 0 ? void 0 : options.endTime);\n                const finalEndTime = respectNativeDuration ? undefined : endTime;\n                // Log para depurar\n                if (treatAsAPNG) {\n                    console.log(\"\\uD83D\\uDD37 A\\xf1adiendo APNG como VIDEO sincronizado desde \".concat(startTime, \"s con duraci\\xf3n \").concat(respectNativeDuration ? \"natural\" : finalEndTime + \"s\"));\n                    console.log(\"\\uD83D\\uDD37 Configuraciones especiales de APNG - useFullScreen: \".concat(useFullScreen, \", syncWithTimeline: \").concat((options === null || options === void 0 ? void 0 : options.syncWithTimeline) || true));\n                } else if (isAVI) {\n                    console.log(\"\\uD83C\\uDFAC A\\xf1adiendo AVI con duraci\\xf3n \".concat(respectNativeDuration ? \"natural\" : \"especificada: \" + finalEndTime, \"s\"));\n                }\n                // Manejar APNG usando un enfoque especial - intentar con un método alternativo si es posible\n                if (treatAsAPNG) {\n                    try {\n                        // Intentar crear un payload especial para APNG que funcione como animación\n                        console.log(\"Probando con una configuraci\\xf3n especial para APNG...\");\n                        // Configuración de opciones importante para archivos APNG\n                        const apngVideoPayload = {\n                            id: (0,_designcombo_timeline__WEBPACK_IMPORTED_MODULE_2__.generateId)(),\n                            display: {\n                                from: startTime * 1000,\n                                to: finalEndTime ? finalEndTime * 1000 : (startTime + 3) * 1000 // 3 segundos por defecto si no hay duración\n                            },\n                            // Probamos una nueva estrategia: tratarlo como imagen en lugar de video\n                            type: \"image\",\n                            details: {\n                                src: url,\n                                width: 1920,\n                                height: 1080,\n                                opacity: 100,\n                                scaleMode: \"cover\",\n                                left: 0.5,\n                                top: 0.5,\n                                originX: \"center\",\n                                originY: \"center\",\n                                // Propiedades para animar\n                                isAnimated: true\n                            }\n                        };\n                        console.log(\"Payload para APNG como imagen animada:\", JSON.stringify(apngVideoPayload, null, 2));\n                        // Usar ADD_IMAGE en lugar de ADD_VIDEO\n                        (0,_designcombo_events__WEBPACK_IMPORTED_MODULE_0__.dispatch)(_designcombo_state__WEBPACK_IMPORTED_MODULE_1__.ADD_IMAGE, {\n                            payload: apngVideoPayload,\n                            options: {\n                                scaleMode: \"cover\",\n                                position: {\n                                    x: 0.5,\n                                    y: 0.5\n                                }\n                            }\n                        });\n                        console.log(\"✅ APNG a\\xf1adido como imagen animada con \\xe9xito\");\n                        return;\n                    } catch (apngError) {\n                        console.error(\"❌ Error al a\\xf1adir APNG como imagen animada:\", apngError);\n                        console.error(\"Detalles:\", apngError.message);\n                        console.error(\"Traza:\", apngError.stack);\n                        console.log(\"\\uD83D\\uDD04 Continuando con el m\\xe9todo est\\xe1ndar como respaldo...\");\n                    // Continuar con el método estándar como respaldo\n                    }\n                }\n                // Crear payload para el video\n                const videoPayload = {\n                    id: (0,_designcombo_timeline__WEBPACK_IMPORTED_MODULE_2__.generateId)(),\n                    display: {\n                        from: startTime * 1000,\n                        to: finalEndTime ? finalEndTime * 1000 : undefined // Usar undefined si queremos respetar la duración natural\n                    },\n                    type: \"video\",\n                    details: {\n                        src: url,\n                        width: width,\n                        height: height,\n                        opacity: 100,\n                        // Para archivos APNG y AVI, configurar propiedades específicas para pantalla completa\n                        ...useFullScreen && {\n                            scaleMode: \"cover\",\n                            left: 0.5,\n                            top: 0.5,\n                            originX: \"center\",\n                            originY: \"center\"\n                        },\n                        // Propiedades especiales para APNG\n                        ...treatAsAPNG && {\n                            isAPNG: true,\n                            autoPlay: true,\n                            loop: false,\n                            syncWithTimeline: (options === null || options === void 0 ? void 0 : options.syncWithTimeline) || true\n                        }\n                    }\n                };\n                console.log(\"Payload de video est\\xe1ndar:\", JSON.stringify(videoPayload, null, 2));\n                // Configuraciones adicionales para el dispatch\n                const dispatchOptions = {\n                    resourceId: \"main\",\n                    scaleMode: useFullScreen ? \"cover\" : \"fit\",\n                    ...useFullScreen && {\n                        position: {\n                            x: 0.5,\n                            y: 0.5\n                        } // Centrar para videos a pantalla completa\n                    },\n                    respectNativeDuration: respectNativeDuration,\n                    // Propiedades específicas para sincronización de APNG\n                    ...treatAsAPNG && {\n                        isAPNG: true,\n                        syncWithTimeline: (options === null || options === void 0 ? void 0 : options.syncWithTimeline) || true,\n                        playbackBehavior: (options === null || options === void 0 ? void 0 : options.playbackBehavior) || \"sync\"\n                    }\n                };\n                console.log(\"Opciones de dispatch:\", JSON.stringify(dispatchOptions, null, 2));\n                // Agregar video al timeline\n                (0,_designcombo_events__WEBPACK_IMPORTED_MODULE_0__.dispatch)(_designcombo_state__WEBPACK_IMPORTED_MODULE_1__.ADD_VIDEO, {\n                    payload: videoPayload,\n                    options: dispatchOptions\n                });\n                // Mensaje de log adaptado al tipo de archivo\n                if (treatAsAPNG) {\n                    console.log(\"✅ Transici\\xf3n APNG a\\xf1adida como VIDEO SINCRONIZADO al timeline desde \".concat(startTime, \"s \").concat(finalEndTime ? \"hasta \".concat(finalEndTime, \"s\") : \"con duraci\\xf3n natural\", \". Dimensiones: \").concat(width, \"x\").concat(height));\n                } else {\n                    console.log(\"✅ Video \".concat(isAVI ? \"AVI\" : \"\", \" a\\xf1adido al timeline desde \").concat(startTime, \"s\").concat(finalEndTime ? \" hasta \".concat(finalEndTime, \"s\") : \" con duraci\\xf3n natural\", \". Dimensiones: \").concat(width, \"x\").concat(height));\n                }\n            } catch (error) {\n                console.error(\"❌ ERROR CR\\xcdTICO al a\\xf1adir video:\", error);\n                console.error(\"Detalles completos:\", error.message);\n                console.error(\"Traza:\", error.stack);\n                throw error; // Propagar el error para manejo superior\n            }\n        },\n        changeDuration: (elementId, duration)=>{\n            // Simulación de cambio de duración (la implementación real dependerá de la estructura del proyecto)\n            console.log(\"Cambiando duraci\\xf3n del elemento \".concat(elementId, \" a \").concat(duration, \"s\"));\n        // Aquí iría la lógica real para cambiar la duración de un elemento\n        },\n        changeTransition: (elementId, transition)=>{\n            // Simulación de cambio de transición (la implementación real dependerá de la estructura del proyecto)\n            console.log(\"Cambiando transici\\xf3n del elemento \".concat(elementId, \" a \").concat(transition));\n        // Aquí iría la lógica real para cambiar la transición de un elemento\n        },\n        addSubtitles: async (options)=>{\n            try {\n                console.log(\"A\\xf1adiendo subt\\xedtulos directamente sin depender del bot\\xf3n\");\n                // Función para parsear el tiempo de formato SRT a milisegundos\n                const parseTimeToMs = (timeString)=>{\n                    const [hours, minutes, secondsAndMs] = timeString.split(\":\");\n                    const [seconds, ms] = secondsAndMs.split(\",\");\n                    return parseInt(hours) * 3600000 + parseInt(minutes) * 60000 + parseInt(seconds) * 1000 + parseInt(ms);\n                };\n                // Función para parsear el archivo SRT\n                const parseSRT = (srtContent)=>{\n                    const segments = [];\n                    const blocks = srtContent.trim().split(\"\\n\\n\");\n                    blocks.forEach((block)=>{\n                        const lines = block.split(\"\\n\");\n                        if (lines.length >= 3) {\n                            const id = parseInt(lines[0]);\n                            const timeRange = lines[1].split(\" --> \");\n                            const startTime = parseTimeToMs(timeRange[0]);\n                            const endTime = parseTimeToMs(timeRange[1]);\n                            const text = lines.slice(2).join(\"\\n\"); // Unir todas las líneas de texto\n                            segments.push({\n                                id,\n                                startTime,\n                                endTime,\n                                text\n                            });\n                        }\n                    });\n                    return segments;\n                };\n                // Función para dividir un texto en grupos de aproximadamente 3 palabras\n                const splitTextIntoGroups = function(text) {\n                    let wordsPerGroup = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 3;\n                    const words = text.split(/\\s+/);\n                    const groups = [];\n                    for(let i = 0; i < words.length; i += wordsPerGroup){\n                        const group = words.slice(i, i + wordsPerGroup).join(\" \");\n                        groups.push(group);\n                    }\n                    return groups;\n                };\n                // Función para procesar un segmento y dividirlo en múltiples segmentos si es necesario\n                const processSegment = (segment)=>{\n                    const textGroups = splitTextIntoGroups(segment.text);\n                    // Si solo hay un grupo, devolver el segmento original\n                    if (textGroups.length <= 1) {\n                        return [\n                            segment\n                        ];\n                    }\n                    // Calcular la duración de cada grupo\n                    const totalDuration = segment.endTime - segment.startTime;\n                    const groupDuration = totalDuration / textGroups.length;\n                    // Crear un nuevo segmento para cada grupo\n                    return textGroups.map((groupText, index)=>{\n                        const startTime = segment.startTime + index * groupDuration;\n                        const endTime = startTime + groupDuration;\n                        return {\n                            id: segment.id * 1000 + index,\n                            startTime,\n                            endTime,\n                            text: groupText\n                        };\n                    });\n                };\n                // Función para crear el payload de texto para subtítulos\n                const createSubtitlePayload = (text, startTime, endTime)=>({\n                        id: (0,_designcombo_timeline__WEBPACK_IMPORTED_MODULE_2__.generateId)(),\n                        display: {\n                            from: startTime,\n                            to: endTime\n                        },\n                        type: \"text\",\n                        details: {\n                            text: text.toUpperCase(),\n                            fontSize: 80,\n                            width: 900,\n                            fontUrl: \"/fonts/mrbeast.ttf\",\n                            fontFamily: \"MrBeast\",\n                            color: \"#FFFF00\",\n                            wordWrap: \"break-word\",\n                            textAlign: \"center\",\n                            borderWidth: 20,\n                            borderColor: \"#000000\",\n                            boxShadow: {\n                                color: \"#000000\",\n                                x: 3,\n                                y: 3,\n                                blur: 0\n                            },\n                            backgroundColor: \"transparent\",\n                            padding: 10,\n                            borderRadius: 0\n                        }\n                    });\n                // Cargar el archivo SRT\n                console.log(\"Cargando archivo SRT...\");\n                const response = await fetch(\"/transcriptions/transcription1.srt\");\n                if (!response.ok) {\n                    throw new Error(\"Error al cargar el archivo SRT: \".concat(response.status));\n                }\n                const srtContent = await response.text();\n                console.log(\"Archivo SRT cargado correctamente\");\n                // Parsear el archivo SRT\n                let segments = parseSRT(srtContent);\n                console.log(\"Se encontraron \".concat(segments.length, \" segmentos de subt\\xedtulos\"));\n                // Siempre usar el modo agrupado (dividir en grupos de 3 palabras)\n                segments = segments.flatMap(processSegment);\n                console.log(\"Despu\\xe9s de procesar, hay \".concat(segments.length, \" segmentos de subt\\xedtulos\"));\n                // Filtrar por tiempo si es necesario\n                if ((options === null || options === void 0 ? void 0 : options.startTime) !== undefined || (options === null || options === void 0 ? void 0 : options.endTime) !== undefined) {\n                    const originalLength = segments.length;\n                    segments = segments.filter((segment)=>{\n                        const passesStartFilter = options.startTime === undefined || segment.startTime >= options.startTime * 1000;\n                        const passesEndFilter = options.endTime === undefined || segment.endTime <= options.endTime * 1000;\n                        return passesStartFilter && passesEndFilter;\n                    });\n                    console.log(\"Filtrado por tiempo: de \".concat(originalLength, \" a \").concat(segments.length, \" segmentos\"));\n                }\n                // NUEVA FUNCIONALIDAD: Encontrar un track existente para añadir todos los subtítulos\n                // Obtener el estado actual para acceder a los tracks\n                const state = stateManager.getState();\n                let targetTrackId = null;\n                // Si el usuario especificó un trackId en las opciones, usarlo directamente\n                if (options === null || options === void 0 ? void 0 : options.trackId) {\n                    targetTrackId = options.trackId;\n                    console.log(\"Usando track ID especificado por el usuario: \".concat(targetTrackId));\n                } else {\n                    // Buscar un track de tipo \"text\" existente\n                    if (state.tracks && state.tracks.length > 0) {\n                        const textTrack = state.tracks.find((track)=>track.type === \"text\" && track.accepts && track.accepts.includes(\"text\"));\n                        if (textTrack) {\n                            targetTrackId = textTrack.id;\n                            console.log(\"Usando track de texto existente con ID: \".concat(targetTrackId));\n                        }\n                    }\n                    // Si no se encontró un track de texto, buscar cualquier track que acepte \"text\"\n                    if (!targetTrackId && state.tracks && state.tracks.length > 0) {\n                        const anyTrack = state.tracks.find((track)=>track.accepts && track.accepts.includes(\"text\"));\n                        if (anyTrack) {\n                            targetTrackId = anyTrack.id;\n                            console.log(\"Usando track compatible con ID: \".concat(targetTrackId));\n                        }\n                    }\n                    // Si aún no se encuentra un track, podríamos intentar con otro método\n                    if (!targetTrackId) {\n                        // Intentar obtener el primer track disponible como último recurso\n                        if (state.tracks && state.tracks.length > 0) {\n                            targetTrackId = state.tracks[0].id;\n                            console.log(\"Usando primer track disponible como fallback, ID: \".concat(targetTrackId));\n                        } else {\n                            console.log(\"No se encontr\\xf3 ning\\xfan track existente, los subt\\xedtulos se a\\xf1adir\\xe1n en tracks individuales\");\n                        }\n                    }\n                }\n                // Añadir los subtítulos con un retraso entre cada uno\n                console.log(\"A\\xf1adiendo \".concat(segments.length, \" segmentos de subt\\xedtulos al timeline...\"));\n                console.log(targetTrackId ? \"Todos los subt\\xedtulos se a\\xf1adir\\xe1n al track ID: \".concat(targetTrackId) : \"Cada subt\\xedtulo crear\\xe1 su propio track\");\n                segments.forEach((segment, index)=>{\n                    setTimeout(()=>{\n                        (0,_designcombo_events__WEBPACK_IMPORTED_MODULE_0__.dispatch)(_designcombo_state__WEBPACK_IMPORTED_MODULE_1__.ADD_TEXT, {\n                            payload: createSubtitlePayload(segment.text, segment.startTime, segment.endTime),\n                            options: targetTrackId ? {\n                                trackId: targetTrackId\n                            } : {}\n                        });\n                        if ((index + 1) % 10 === 0 || index === segments.length - 1) {\n                            console.log(\"Progreso: \".concat(index + 1, \"/\").concat(segments.length, \" subt\\xedtulos a\\xf1adidos\"));\n                        }\n                    }, index * 200); // 200ms de retraso entre cada subtítulo\n                });\n                return true;\n            } catch (error) {\n                console.error(\"Error al a\\xf1adir subt\\xedtulos:\", error);\n                return false;\n            }\n        },\n        getActiveElements: async ()=>{\n            try {\n                // Obtener el estado actual\n                const state = stateManager.getState();\n                // Verificar si hay IDs activos\n                if (!state.activeIds || state.activeIds.length === 0) {\n                    console.log(\"No hay elementos activos seleccionados\");\n                    return [];\n                }\n                // Verificar si hay elementos en el trackItemsMap\n                if (!state.trackItemsMap) {\n                    console.log(\"No hay trackItemsMap disponible\");\n                    return [];\n                }\n                // Obtener información de los elementos activos\n                const activeElements = state.activeIds.filter((id)=>state.trackItemsMap[id]).map((id)=>{\n                    var _item_display, _item_display1;\n                    const item = state.trackItemsMap[id];\n                    return {\n                        id,\n                        trackId: item.trackId,\n                        type: item.type,\n                        from: (_item_display = item.display) === null || _item_display === void 0 ? void 0 : _item_display.from,\n                        to: (_item_display1 = item.display) === null || _item_display1 === void 0 ? void 0 : _item_display1.to,\n                        duration: item.display ? item.display.to - item.display.from : 0,\n                        details: item.details\n                    };\n                });\n                console.log(\"Se encontraron \".concat(activeElements.length, \" elementos activos\"));\n                return activeElements;\n            } catch (error) {\n                console.error(\"Error al obtener elementos activos:\", error);\n                return [];\n            }\n        },\n        getAllTimelineElements: async ()=>{\n            try {\n                // Obtener el estado actual\n                const state = stateManager.getState();\n                // Verificar si hay elementos en el trackItemsMap\n                if (!state.trackItemsMap || Object.keys(state.trackItemsMap).length === 0) {\n                    console.log(\"No hay elementos en el trackItemsMap\");\n                    // Buscar elementos en otras propiedades del estado\n                    for (const key of Object.keys(state)){\n                        if (typeof state[key] === \"object\" && state[key] !== null) {\n                            const objValue = state[key];\n                            console.log(\"Explorando propiedad alternativa: \".concat(key));\n                            // Verificar si parece ser un mapa de elementos\n                            if (Object.keys(objValue).length > 0) {\n                                const sample = objValue[Object.keys(objValue)[0]];\n                                if (sample && sample.display && sample.type) {\n                                    console.log(\"Encontrada posible fuente alternativa de elementos en propiedad \".concat(key));\n                                    // Procesar elementos de esta propiedad alternativa\n                                    return Object.entries(objValue).filter((param)=>{\n                                        let [_, item] = param;\n                                        return item && item.display;\n                                    }).map((param)=>{\n                                        let [id, item] = param;\n                                        var _item_display, _item_display1;\n                                        return {\n                                            id,\n                                            trackId: item.trackId,\n                                            type: item.type,\n                                            from: (_item_display = item.display) === null || _item_display === void 0 ? void 0 : _item_display.from,\n                                            to: (_item_display1 = item.display) === null || _item_display1 === void 0 ? void 0 : _item_display1.to,\n                                            duration: item.display ? item.display.to - item.display.from : 0,\n                                            details: item.details\n                                        };\n                                    });\n                                }\n                            }\n                        }\n                    }\n                    return [];\n                }\n                // Obtener todos los elementos\n                const allElements = Object.entries(state.trackItemsMap).filter((param)=>{\n                    let [_, item] = param;\n                    return item && item.display;\n                }).map((param)=>{\n                    let [id, item] = param;\n                    var _item_display, _item_display1;\n                    return {\n                        id,\n                        trackId: item.trackId,\n                        type: item.type,\n                        from: (_item_display = item.display) === null || _item_display === void 0 ? void 0 : _item_display.from,\n                        to: (_item_display1 = item.display) === null || _item_display1 === void 0 ? void 0 : _item_display1.to,\n                        duration: item.display ? item.display.to - item.display.from : 0,\n                        details: item.details\n                    };\n                }).sort((a, b)=>(a.from || 0) - (b.from || 0));\n                console.log(\"Se encontraron \".concat(allElements.length, \" elementos en el timeline\"));\n                return allElements;\n            } catch (error) {\n                console.error(\"Error al obtener todos los elementos del timeline:\", error);\n                return [];\n            }\n        },\n        removeSegments: async (segments)=>{\n            try {\n                console.log(\"Iniciando eliminaci\\xf3n de segmentos m\\xfaltiples\");\n                // Obtener el estado actual\n                const state = stateManager.getState();\n                // Validar que haya elementos en la timeline\n                if (!state.activeIds || state.activeIds.length === 0) {\n                    console.error(\"No hay elementos seleccionados en la timeline\");\n                    // Buscar el primer elemento disponible en la timeline\n                    const trackItemsMap = state.trackItemsMap || {};\n                    const trackItems = Object.keys(trackItemsMap);\n                    if (trackItems.length === 0) {\n                        console.error(\"No hay elementos en la timeline para eliminar segmentos\");\n                        throw new Error(\"No hay elementos en la timeline\");\n                    }\n                    // Seleccionar el primer elemento disponible\n                    const firstItemId = trackItems[0];\n                    console.log(\"Seleccionando autom\\xe1ticamente el elemento con ID: \".concat(firstItemId));\n                    (0,_designcombo_events__WEBPACK_IMPORTED_MODULE_0__.dispatch)(_designcombo_state__WEBPACK_IMPORTED_MODULE_1__.LAYER_SELECT, {\n                        payload: {\n                            ids: [\n                                firstItemId\n                            ]\n                        }\n                    });\n                    // Esperar a que se aplique la selección\n                    await new Promise((resolve)=>setTimeout(resolve, 300));\n                }\n                // Almacenamos información del elemento seleccionado\n                const currentState = stateManager.getState();\n                if (!currentState.activeIds || currentState.activeIds.length === 0) {\n                    throw new Error(\"No se pudo seleccionar ning\\xfan elemento en la timeline\");\n                }\n                const originalItemId = currentState.activeIds[0];\n                const originalItem = currentState.trackItemsMap[originalItemId];\n                const trackType = originalItem.type;\n                const trackId = originalItem.trackId;\n                console.log(\"Elemento seleccionado: ID=\".concat(originalItemId, \", tipo=\").concat(trackType, \", trackId=\").concat(trackId));\n                // Procesar cada segmento en orden (de final a principio para evitar afectar posiciones)\n                for(let i = segments.length - 1; i >= 0; i--){\n                    const segment = segments[i];\n                    console.log(\"Procesando segmento \".concat(i + 1, \"/\").concat(segments.length, \": \").concat(segment.startTime, \"s - \").concat(segment.endTime, \"s\"));\n                    try {\n                        // PASO 1: Hacer un corte en el tiempo final\n                        const endMs = segment.endTime * 1000;\n                        (0,_designcombo_events__WEBPACK_IMPORTED_MODULE_0__.dispatch)(_designcombo_state__WEBPACK_IMPORTED_MODULE_1__.ACTIVE_SPLIT, {\n                            payload: {},\n                            options: {\n                                time: endMs\n                            }\n                        });\n                        console.log(\"Paso 1: Corte aplicado en tiempo final \".concat(segment.endTime, \"s\"));\n                        // Esperar a que se procese el primer corte\n                        await new Promise((resolve)=>setTimeout(resolve, 500));\n                        // Obtenemos el estado después del primer corte\n                        const stateAfterFirstCut = stateManager.getState();\n                        const elementsAfterFirstCut = Object.entries(stateAfterFirstCut.trackItemsMap).filter((param)=>{\n                            let [_, item] = param;\n                            return item.type === trackType && item.trackId === trackId && item.display && !isNaN(item.display.from) && !isNaN(item.display.to);\n                        }).map((param)=>{\n                            let [id, item] = param;\n                            return {\n                                id,\n                                from: item.display.from,\n                                to: item.display.to,\n                                duración: item.display.to - item.display.from\n                            };\n                        }).sort((a, b)=>a.from - b.from);\n                        console.log(\"Elementos despu\\xe9s del primer corte:\", elementsAfterFirstCut);\n                        // PASO 2: Identificar el elemento izquierdo que contiene el tiempo inicial\n                        const startMs = segment.startTime * 1000;\n                        const leftElement = elementsAfterFirstCut.find((elem)=>elem.from <= startMs && elem.to >= startMs);\n                        if (!leftElement) {\n                            console.error(\"No se pudo identificar el elemento izquierdo para el segmento \".concat(i + 1));\n                            continue;\n                        }\n                        console.log(\"Paso 2: Elemento izquierdo identificado (ID: \".concat(leftElement.id, \")\"));\n                        // PASO 3: Seleccionar el elemento izquierdo y hacer corte en tiempo inicial\n                        (0,_designcombo_events__WEBPACK_IMPORTED_MODULE_0__.dispatch)(_designcombo_state__WEBPACK_IMPORTED_MODULE_1__.LAYER_SELECT, {\n                            payload: {\n                                ids: [\n                                    leftElement.id\n                                ]\n                            }\n                        });\n                        // Esperar a que se aplique la selección\n                        await new Promise((resolve)=>setTimeout(resolve, 300));\n                        // Aplicar el corte en el tiempo inicial\n                        (0,_designcombo_events__WEBPACK_IMPORTED_MODULE_0__.dispatch)(_designcombo_state__WEBPACK_IMPORTED_MODULE_1__.ACTIVE_SPLIT, {\n                            payload: {},\n                            options: {\n                                time: startMs\n                            }\n                        });\n                        console.log(\"Paso 3: Segundo corte aplicado en tiempo inicial \".concat(segment.startTime, \"s\"));\n                        // Esperar a que se procese el segundo corte\n                        await new Promise((resolve)=>setTimeout(resolve, 500));\n                        // Obtenemos el estado después del segundo corte\n                        const stateAfterSecondCut = stateManager.getState();\n                        const elementsAfterSecondCut = Object.entries(stateAfterSecondCut.trackItemsMap).filter((param)=>{\n                            let [_, item] = param;\n                            return item.type === trackType && item.trackId === trackId && item.display && !isNaN(item.display.from) && !isNaN(item.display.to);\n                        }).map((param)=>{\n                            let [id, item] = param;\n                            return {\n                                id,\n                                from: item.display.from,\n                                to: item.display.to,\n                                duración: item.display.to - item.display.from\n                            };\n                        }).sort((a, b)=>a.from - b.from);\n                        console.log(\"Elementos despu\\xe9s del segundo corte:\", elementsAfterSecondCut);\n                        // PASO 4: Identificar el elemento del medio usando criterios más precisos\n                        const middleElements = elementsAfterSecondCut.filter((elem)=>Math.abs(elem.from - startMs) < 50 && Math.abs(elem.to - endMs) < 50);\n                        console.log(\"Elementos que coinciden con los criterios del medio:\", middleElements);\n                        if (middleElements.length === 0) {\n                            console.error(\"No se pudo identificar el elemento del medio para el segmento \".concat(i + 1));\n                            continue;\n                        }\n                        // Si hay más de un elemento que coincide, tomamos el primero\n                        const middleElement = middleElements[0];\n                        console.log(\"Paso 4: Elemento del medio identificado (ID: \".concat(middleElement.id, \")\"));\n                        // PASO 5: Seleccionar y eliminar el elemento del medio\n                        (0,_designcombo_events__WEBPACK_IMPORTED_MODULE_0__.dispatch)(_designcombo_state__WEBPACK_IMPORTED_MODULE_1__.LAYER_SELECT, {\n                            payload: {\n                                ids: [\n                                    middleElement.id\n                                ]\n                            }\n                        });\n                        // Esperar a que se aplique la selección\n                        await new Promise((resolve)=>setTimeout(resolve, 300));\n                        // Verificar que el elemento está seleccionado antes de eliminarlo\n                        const currentState = stateManager.getState();\n                        if (currentState.activeIds && currentState.activeIds.includes(middleElement.id)) {\n                            console.log(\"Elemento del medio correctamente seleccionado, procediendo con eliminaci\\xf3n\");\n                            (0,_designcombo_events__WEBPACK_IMPORTED_MODULE_0__.dispatch)(_designcombo_state__WEBPACK_IMPORTED_MODULE_1__.LAYER_DELETE);\n                            console.log(\"Elemento eliminado correctamente: \".concat(middleElement.id));\n                        } else {\n                            console.log(\"No se pudo seleccionar normalmente, intentando m\\xe9todo alternativo\");\n                            // Enfoque alternativo: Usar el EDIT_OBJECT para \"ocultar\" el segmento\n                            (0,_designcombo_events__WEBPACK_IMPORTED_MODULE_0__.dispatch)(_designcombo_state__WEBPACK_IMPORTED_MODULE_1__.EDIT_OBJECT, {\n                                payload: {\n                                    [middleElement.id]: {\n                                        display: {\n                                            from: -99999,\n                                            to: -99990\n                                        },\n                                        visible: false // Adicionalmente marcarlo como no visible\n                                    }\n                                }\n                            });\n                            console.log(\"Aplicado m\\xe9todo alternativo para ocultar el segmento\");\n                        }\n                        // Esperar a que se procese la eliminación\n                        await new Promise((resolve)=>setTimeout(resolve, 500));\n                    } catch (error) {\n                        console.error(\"Error al procesar el segmento \".concat(i + 1, \":\"), error);\n                    }\n                    // Pausa entre segmentos\n                    await new Promise((resolve)=>setTimeout(resolve, 500));\n                }\n                // Actualizar la escala para refrescar la vista\n                const { scale } = stateManager.getState();\n                if (scale) {\n                    console.log(\"Actualizando escala para refrescar la vista\");\n                    // Guardar el valor actual de scale.unit\n                    const originalUnit = scale.unit;\n                    // Incrementar el valor\n                    scale.unit += 1;\n                    console.log(\"Scale cambiada: \".concat(originalUnit, \" -> \").concat(scale.unit));\n                    // Asegurar que el cambio sea notado por el sistema\n                    (0,_designcombo_events__WEBPACK_IMPORTED_MODULE_0__.dispatch)(_designcombo_state__WEBPACK_IMPORTED_MODULE_1__.TIMELINE_SCALE_CHANGED, {\n                        payload: {\n                            scale: {\n                                ...scale,\n                                unit: scale.unit // Explícitamente establecer el nuevo valor\n                            }\n                        }\n                    });\n                    // Forzar una actualización adicional volviendo al valor original después de un momento\n                    setTimeout(()=>{\n                        const currentState = stateManager.getState();\n                        if (currentState.scale) {\n                            (0,_designcombo_events__WEBPACK_IMPORTED_MODULE_0__.dispatch)(_designcombo_state__WEBPACK_IMPORTED_MODULE_1__.TIMELINE_SCALE_CHANGED, {\n                                payload: {\n                                    scale: {\n                                        ...currentState.scale,\n                                        unit: originalUnit // Volver al valor original\n                                    }\n                                }\n                            });\n                            console.log(\"Restaurado scale a valor original: \".concat(originalUnit));\n                        }\n                    }, 300);\n                }\n                console.log(\"Eliminaci\\xf3n de segmentos completada\");\n                return true;\n            } catch (error) {\n                console.error(\"Error al eliminar segmentos:\", error);\n                return false;\n            }\n        },\n        compactTimeline: async ()=>{\n            try {\n                console.log(\"=== INICIANDO COMPACTACI\\xd3N DE L\\xcdNEA DE TIEMPO DESDE IA ===\");\n                // Obtener el estado actual\n                const estado = stateManager.getState();\n                console.log(\"Estado para compactaci\\xf3n:\", Object.keys(estado));\n                // Añadir un tiempo de espera inicial para asegurar que el estado está actualizado\n                console.log(\"Esperando 1 segundo para asegurar consistencia del estado...\");\n                await new Promise((resolve)=>setTimeout(resolve, 1000));\n                // Verificación adicional para asegurarnos que los cambios en la timeline ya se aplicaron\n                console.log(\"Verificando que los elementos en la timeline reflejen los cambios m\\xe1s recientes...\");\n                // Pequeña pausa adicional para asegurar consistencia del estado\n                await new Promise((resolve)=>setTimeout(resolve, 500));\n                // Buscar los elementos del timeline - usando la referencia al método dentro del mismo objeto\n                const todosElementos = await executor.getAllTimelineElements();\n                console.log(\"Encontrados \".concat(todosElementos.length, \" elementos en la timeline\"));\n                // Logging de elementos para diagnóstico\n                todosElementos.forEach((elem, index)=>{\n                    console.log(\"Elemento \".concat(index + 1, \": ID=\").concat(elem.id, \", Tipo=\").concat(elem.type, \", Track=\").concat(elem.trackId, \", Tiempo=\").concat(elem.from, \"ms-\").concat(elem.to, \"ms (duraci\\xf3n=\").concat(elem.to - elem.from, \"ms)\"));\n                });\n                // Si no hay elementos, no podemos compactar\n                if (todosElementos.length === 0) {\n                    console.log(\"No hay elementos en el timeline para compactar\");\n                    return false;\n                }\n                // Agrupar elementos por track para análisis\n                const elementosPorTrack = {};\n                todosElementos.forEach((elem)=>{\n                    if (elem.trackId) {\n                        if (!elementosPorTrack[elem.trackId]) {\n                            elementosPorTrack[elem.trackId] = [];\n                        }\n                        elementosPorTrack[elem.trackId].push(elem);\n                    }\n                });\n                // Ordenar elementos en cada track por tiempo\n                Object.keys(elementosPorTrack).forEach((trackId)=>{\n                    elementosPorTrack[trackId].sort((a, b)=>a.from - b.from);\n                });\n                console.log(\"Elementos agrupados por track:\", Object.keys(elementosPorTrack).length);\n                // Logging de tracks para diagnóstico\n                Object.keys(elementosPorTrack).forEach((trackId)=>{\n                    console.log(\"Track \".concat(trackId, \": \").concat(elementosPorTrack[trackId].length, \" elementos\"));\n                    // Mostrar los elementos en este track ordenados\n                    elementosPorTrack[trackId].forEach((elem, idx)=>{\n                        console.log(\"  \".concat(idx + 1, \". ID=\").concat(elem.id.substring(0, 8), \"... Tiempo=\").concat(elem.from, \"ms-\").concat(elem.to, \"ms (duraci\\xf3n: \").concat(elem.to - elem.from, \"ms)\"));\n                    });\n                });\n                // Buscar espacios vacíos en cada track\n                const espaciosVacios = [];\n                Object.keys(elementosPorTrack).forEach((trackId)=>{\n                    const elementos = elementosPorTrack[trackId];\n                    // Si hay al menos 2 elementos, podemos buscar espacios\n                    if (elementos.length >= 2) {\n                        for(let i = 0; i < elementos.length - 1; i++){\n                            const elementoActual = elementos[i];\n                            const elementoSiguiente = elementos[i + 1];\n                            // Verificar si hay un espacio entre el fin del elemento actual y el inicio del siguiente\n                            const espacio = elementoSiguiente.from - elementoActual.to;\n                            // Si el espacio es significativo (más de 100ms)\n                            if (espacio > 100) {\n                                espaciosVacios.push({\n                                    trackId,\n                                    start: elementoActual.to,\n                                    end: elementoSiguiente.from,\n                                    size: espacio,\n                                    elementoAntes: elementoActual.id,\n                                    elementoDespues: elementoSiguiente.id\n                                });\n                                console.log(\"Encontrado espacio de \".concat(espacio, \"ms (\").concat(espacio / 1000, \"s) en track \").concat(trackId, \" entre elementos \").concat(elementoActual.id.substring(0, 8), \"... y \").concat(elementoSiguiente.id.substring(0, 8), \"...\"));\n                            }\n                        }\n                    }\n                });\n                console.log(\"Se encontraron \".concat(espaciosVacios.length, \" espacios vac\\xedos\"));\n                // Si no hay espacios, no necesitamos compactar\n                if (espaciosVacios.length === 0) {\n                    console.log(\"No hay espacios significativos para compactar\");\n                    return true; // Devolvemos true porque técnicamente está compactado\n                }\n                // Ordenar espacios por posición (de izquierda a derecha)\n                espaciosVacios.sort((a, b)=>a.start - b.start);\n                // Calcular el espacio total a compactar\n                let espacioTotal = 0;\n                espaciosVacios.forEach((espacio)=>{\n                    espacioTotal += espacio.size;\n                });\n                console.log(\"Espacio total a compactar: \".concat(espacioTotal, \"ms (\").concat(espacioTotal / 1000, \"s)\"));\n                console.log(\"Preparando actualizaciones para \".concat(todosElementos.length, \" elementos...\"));\n                // Preparar actualizaciones para cada elemento\n                const actualizaciones = {};\n                let elementosAMover = 0;\n                // Para cada elemento, calculamos el desplazamiento basado en los espacios anteriores\n                todosElementos.forEach((elemento)=>{\n                    let desplazamiento = 0;\n                    // Calcular cuánto debe moverse basado en los espacios vacíos anteriores\n                    for (const espacio of espaciosVacios){\n                        // Si el elemento está después del espacio vacío, debe moverse\n                        if (elemento.from > espacio.end) {\n                            desplazamiento += espacio.size;\n                        }\n                    }\n                    // Si hay desplazamiento, añadir a las actualizaciones\n                    if (desplazamiento > 0) {\n                        const nuevoFrom = elemento.from - desplazamiento;\n                        const nuevoTo = elemento.to - desplazamiento;\n                        console.log(\"Elemento \".concat(elemento.id.substring(0, 8), \"... se mover\\xe1: \").concat(elemento.from, \"ms -> \").concat(nuevoFrom, \"ms (desplazamiento: \").concat(desplazamiento, \"ms)\"));\n                        actualizaciones[elemento.id] = {\n                            display: {\n                                from: nuevoFrom,\n                                to: nuevoTo\n                            }\n                        };\n                        elementosAMover++;\n                    }\n                });\n                console.log(\"Elementos a mover: \".concat(elementosAMover, \" de \").concat(todosElementos.length, \" total\"));\n                // Aplicar las actualizaciones\n                if (elementosAMover > 0) {\n                    console.log(\"Aplicando actualizaciones para compactar timeline...\");\n                    try {\n                        (0,_designcombo_events__WEBPACK_IMPORTED_MODULE_0__.dispatch)(_designcombo_state__WEBPACK_IMPORTED_MODULE_1__.EDIT_OBJECT, {\n                            payload: actualizaciones\n                        });\n                        console.log(\"Actualizaciones aplicadas con \\xe9xito\");\n                    } catch (error) {\n                        console.error(\"Error al aplicar actualizaciones:\", error);\n                        return false;\n                    }\n                    // Refrescar la vista\n                    setTimeout(()=>{\n                        try {\n                            const { scale } = stateManager.getState();\n                            if (scale) {\n                                // Hacer un pequeño cambio en la escala para forzar la actualización\n                                const updatedScale = {\n                                    ...scale\n                                };\n                                if (typeof updatedScale.unit === \"number\") {\n                                    updatedScale.unit = (updatedScale.unit || 0) + 1;\n                                    (0,_designcombo_events__WEBPACK_IMPORTED_MODULE_0__.dispatch)(_designcombo_state__WEBPACK_IMPORTED_MODULE_1__.TIMELINE_SCALE_CHANGED, {\n                                        payload: {\n                                            scale: updatedScale\n                                        }\n                                    });\n                                    // Volver a la escala original\n                                    setTimeout(()=>{\n                                        const currentScale = {\n                                            ...stateManager.getState().scale\n                                        };\n                                        currentScale.unit = (currentScale.unit || 1) - 1;\n                                        (0,_designcombo_events__WEBPACK_IMPORTED_MODULE_0__.dispatch)(_designcombo_state__WEBPACK_IMPORTED_MODULE_1__.TIMELINE_SCALE_CHANGED, {\n                                            payload: {\n                                                scale: currentScale\n                                            }\n                                        });\n                                    }, 300);\n                                }\n                            }\n                        } catch (error) {\n                            console.error(\"Error al refrescar la vista:\", error);\n                        }\n                    }, 500);\n                    console.log(\"Compactaci\\xf3n completada con \\xe9xito\");\n                    return true;\n                } else {\n                    console.log(\"No hay elementos que necesiten moverse\");\n                    return true;\n                }\n            } catch (error) {\n                console.error(\"Error al compactar la l\\xednea de tiempo:\", error);\n                return false;\n            }\n        },\n        smartTrim: async ()=>{\n            try {\n                console.log(\"=== INICIANDO PROCESO DE RECORTE INTELIGENTE DESDE IA ===\");\n                // 1. Realizar la llamada al API para analizar la transcripción\n                console.log(\"Solicitando an\\xe1lisis de transcripci\\xf3n...\");\n                const response = await fetch(\"/api/smart-trim\");\n                if (!response.ok) {\n                    throw new Error(\"Error al analizar la transcripci\\xf3n: \".concat(response.status));\n                }\n                const data = await response.json();\n                console.log(\"An\\xe1lisis de transcripci\\xf3n completado:\", data);\n                if (!data.removeSegments || !Array.isArray(data.removeSegments) || data.removeSegments.length === 0) {\n                    console.log(\"No se encontraron segmentos para eliminar\");\n                    return false;\n                }\n                // 2. Convertir los segmentos al formato que espera removeSegments\n                const segments = data.removeSegments.map((segment)=>({\n                        startTime: segment.startTime,\n                        endTime: segment.endTime // Ya está en segundos\n                    }));\n                console.log(\"Se eliminar\\xe1n \".concat(segments.length, \" segmentos:\"), segments.map((s)=>\"\".concat(s.startTime, \"s-\").concat(s.endTime, \"s\")).join(\", \"));\n                // Almacenar información del estado previo para identificar tracks y elementos\n                console.log(\"Obteniendo informaci\\xf3n del estado antes de eliminar segmentos...\");\n                const estadoPrevio = stateManager.getState();\n                const elementosPrevios = await executor.getAllTimelineElements();\n                // Determinar el trackId principal basado en los elementos\n                const contadorTracks = {};\n                elementosPrevios.forEach((elem)=>{\n                    if (elem.trackId) {\n                        contadorTracks[elem.trackId] = (contadorTracks[elem.trackId] || 0) + 1;\n                    }\n                });\n                // Encontrar el track con más elementos\n                let trackIdPrincipal = \"\";\n                if (Object.keys(contadorTracks).length > 0) {\n                    const tracksPorUso = Object.entries(contadorTracks).sort((a, b)=>b[1] - a[1]);\n                    if (tracksPorUso.length > 0) {\n                        trackIdPrincipal = tracksPorUso[0][0];\n                        console.log(\"Usando trackId principal: \".concat(trackIdPrincipal));\n                    }\n                }\n                // 3. Eliminar los segmentos\n                console.log(\"Ejecutando eliminaci\\xf3n de segmentos...\");\n                const result = await executor.removeSegments(segments);\n                if (!result) {\n                    console.log(\"Error al eliminar los segmentos\");\n                    return false;\n                }\n                console.log(\"Segmentos eliminados correctamente\");\n                // 4. Crear registro de los segmentos eliminados para compactación\n                const segmentosEliminados = segments.map((segment)=>({\n                        start: segment.startTime * 1000,\n                        end: segment.endTime * 1000,\n                        trackId: trackIdPrincipal,\n                        size: (segment.endTime - segment.startTime) * 1000\n                    }));\n                console.log(\"Segmentos registrados para compactaci\\xf3n:\", segmentosEliminados);\n                // 5. Esperar un momento para que se completen las actualizaciones del DOM y el estado\n                console.log(\"Esperando 5 segundos para asegurar que los cambios en la timeline est\\xe9n completos antes de compactar...\");\n                await new Promise((resolve)=>setTimeout(resolve, 5000));\n                // 6. Compactar el timeline usando el enfoque de segmentos registrados\n                console.log(\"Compactando timeline basado en segmentos eliminados...\");\n                // Obtener elementos actuales después de la eliminación\n                const elementosActuales = await executor.getAllTimelineElements();\n                console.log(\"Se encontraron \".concat(elementosActuales.length, \" elementos en la timeline despu\\xe9s de eliminar segmentos\"));\n                // Calcular el espacio total a compactar\n                let espacioTotal = 0;\n                segmentosEliminados.forEach((segmento)=>{\n                    espacioTotal += segmento.size;\n                });\n                console.log(\"Espacio total a compactar: \".concat(espacioTotal, \"ms (\").concat(espacioTotal / 1000, \"s)\"));\n                // Preparar actualizaciones para cada elemento\n                const actualizaciones = {};\n                let elementosAMover = 0;\n                // Ordenar segmentos por posición de inicio\n                const segmentosOrdenados = [\n                    ...segmentosEliminados\n                ].sort((a, b)=>a.start - b.start);\n                // Para cada elemento, calcular el desplazamiento basado en los segmentos eliminados\n                elementosActuales.forEach((elemento)=>{\n                    let desplazamiento = 0;\n                    // Calcular cuánto debe moverse basado en los segmentos eliminados anteriores\n                    for (const segmento of segmentosOrdenados){\n                        if (elemento.from > segmento.start) {\n                            desplazamiento += segmento.size;\n                        }\n                    }\n                    // Si hay desplazamiento, añadir a las actualizaciones\n                    if (desplazamiento > 0) {\n                        const nuevoFrom = elemento.from - desplazamiento;\n                        const nuevoTo = elemento.to - desplazamiento;\n                        console.log(\"Elemento \".concat(elemento.id.substring(0, 8), \"... se mover\\xe1: \").concat(elemento.from, \"ms -> \").concat(nuevoFrom, \"ms (desplazamiento: \").concat(desplazamiento, \"ms)\"));\n                        actualizaciones[elemento.id] = {\n                            display: {\n                                from: nuevoFrom,\n                                to: nuevoTo\n                            }\n                        };\n                        elementosAMover++;\n                    }\n                });\n                console.log(\"Elementos a mover: \".concat(elementosAMover, \" de \").concat(elementosActuales.length, \" total\"));\n                // Aplicar las actualizaciones\n                if (elementosAMover > 0) {\n                    console.log(\"Aplicando actualizaciones para compactar timeline...\");\n                    try {\n                        (0,_designcombo_events__WEBPACK_IMPORTED_MODULE_0__.dispatch)(_designcombo_state__WEBPACK_IMPORTED_MODULE_1__.EDIT_OBJECT, {\n                            payload: actualizaciones\n                        });\n                        console.log(\"Actualizaciones aplicadas con \\xe9xito\");\n                        // Refrescar la vista\n                        setTimeout(()=>{\n                            try {\n                                const { scale } = stateManager.getState();\n                                if (scale) {\n                                    const updatedScale = {\n                                        ...scale\n                                    };\n                                    if (typeof updatedScale.unit === \"number\") {\n                                        updatedScale.unit = (updatedScale.unit || 0) + 1;\n                                        (0,_designcombo_events__WEBPACK_IMPORTED_MODULE_0__.dispatch)(_designcombo_state__WEBPACK_IMPORTED_MODULE_1__.TIMELINE_SCALE_CHANGED, {\n                                            payload: {\n                                                scale: updatedScale\n                                            }\n                                        });\n                                        // Volver a la escala original\n                                        setTimeout(()=>{\n                                            const currentScale = {\n                                                ...stateManager.getState().scale\n                                            };\n                                            currentScale.unit = (currentScale.unit || 1) - 1;\n                                            (0,_designcombo_events__WEBPACK_IMPORTED_MODULE_0__.dispatch)(_designcombo_state__WEBPACK_IMPORTED_MODULE_1__.TIMELINE_SCALE_CHANGED, {\n                                                payload: {\n                                                    scale: currentScale\n                                                }\n                                            });\n                                        }, 300);\n                                    }\n                                }\n                            } catch (error) {\n                                console.error(\"Error al refrescar la vista:\", error);\n                            }\n                        }, 500);\n                    } catch (error) {\n                        console.error(\"Error al aplicar actualizaciones:\", error);\n                        return false;\n                    }\n                } else {\n                    console.log(\"No se encontraron elementos que necesiten moverse\");\n                }\n                console.log(\"Timeline compactado correctamente\");\n                return true;\n            } catch (error) {\n                console.error(\"Error al realizar el recorte inteligente:\", error);\n                return false;\n            }\n        },\n        addMusic: (musicPath, options)=>{\n            try {\n                // Valores predeterminados\n                const startTime = (options === null || options === void 0 ? void 0 : options.startTime) !== undefined ? options.startTime : 0;\n                const endTime = (options === null || options === void 0 ? void 0 : options.endTime) !== undefined ? options.endTime : startTime + 30; // Duración predeterminada más larga para música\n                const volume = (options === null || options === void 0 ? void 0 : options.volume) !== undefined ? options.volume : 80; // Volumen predeterminado al 80%\n                const respectNativeDuration = (options === null || options === void 0 ? void 0 : options.respectNativeDuration) !== undefined ? options.respectNativeDuration : true; // Por defecto, respetar duración nativa\n                console.log(\"A\\xf1adiendo m\\xfasica desde \".concat(musicPath));\n                console.log(\"Tiempos: \".concat(startTime, \"s a \").concat(endTime, \"s, volumen: \").concat(volume, \", respectNativeDuration: \").concat(respectNativeDuration));\n                // Crear payload para la música\n                const audioPayload = {\n                    id: (0,_designcombo_timeline__WEBPACK_IMPORTED_MODULE_2__.generateId)(),\n                    display: {\n                        from: startTime * 1000,\n                        to: endTime * 1000 // Convertir a milisegundos\n                    },\n                    type: \"audio\",\n                    details: {\n                        src: musicPath,\n                        volume: volume,\n                        fadeIn: (options === null || options === void 0 ? void 0 : options.fadeIn) === true,\n                        fadeOut: (options === null || options === void 0 ? void 0 : options.fadeOut) === true\n                    }\n                };\n                // Agregar audio al timeline usando ADD_AUDIO\n                (0,_designcombo_events__WEBPACK_IMPORTED_MODULE_0__.dispatch)(_designcombo_state__WEBPACK_IMPORTED_MODULE_1__.ADD_AUDIO, {\n                    payload: audioPayload,\n                    options: {\n                        respectNativeDuration: respectNativeDuration\n                    }\n                });\n                console.log(\"M\\xfasica agregada exitosamente con ID: \".concat(audioPayload.id));\n                return audioPayload.id;\n            } catch (error) {\n                console.error(\"Error al agregar m\\xfasica:\", error);\n                throw error;\n            }\n        }\n    };\n    return executor;\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2NvbXBvbmVudHMvYWktY2hhdC9haS12aWRlby1jb21tYW5kcy50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQytDO0FBQ29LO0FBQ2hLO0FBZ0Y1QyxTQUFTVywyQkFBMkJDLFlBQTBCO0lBQ25FLGlEQUFpRDtJQUNqRCxNQUFNQyxXQUFpQztRQUNyQ0MsU0FBUyxDQUFDQyxNQUFjQztZQUN0QixNQUFNQyxXQUFXRCxDQUFBQSxvQkFBQUEsOEJBQUFBLFFBQVNDLFFBQVEsS0FBSTtnQkFBRUMsR0FBRztnQkFBS0MsR0FBRztZQUFJLEdBQUcsdUJBQXVCO1lBQ2pGLE1BQU1DLFdBQVdKLENBQUFBLG9CQUFBQSw4QkFBQUEsUUFBU0ksUUFBUSxLQUFJO1lBQ3RDLE1BQU1DLGFBQWFMLENBQUFBLG9CQUFBQSw4QkFBQUEsUUFBU0ssVUFBVSxLQUFJO1lBQzFDLE1BQU1DLFFBQVFOLENBQUFBLG9CQUFBQSw4QkFBQUEsUUFBU00sS0FBSyxLQUFJO1lBQ2hDLE1BQU1DLFlBQVlQLENBQUFBLG9CQUFBQSw4QkFBQUEsUUFBU08sU0FBUyxLQUFJLEdBQUcsd0JBQXdCO1lBQ25FLE1BQU1DLFVBQVVSLENBQUFBLG9CQUFBQSw4QkFBQUEsUUFBU1EsT0FBTyxLQUFJLEdBQUcscUNBQXFDO1lBRTVFLDhCQUE4QjtZQUM5QixNQUFNQyxjQUFjO2dCQUNsQkMsSUFBSWhCLGlFQUFVQTtnQkFDZGlCLFNBQVM7b0JBQ1BDLE1BQU1MLFlBQVk7b0JBQ2xCTSxJQUFJTCxVQUFVLEtBQVMsMkJBQTJCO2dCQUNwRDtnQkFDQU0sTUFBTTtnQkFDTkMsU0FBUztvQkFDUGhCLE1BQU1BO29CQUNOSyxVQUFVQTtvQkFDVlksT0FBTztvQkFDUFgsWUFBWUE7b0JBQ1pDLE9BQU9BO29CQUNQVyxVQUFVO29CQUNWQyxXQUFXO29CQUNYQyxhQUFhO29CQUNiQyxhQUFhO29CQUNiQyxXQUFXO3dCQUNUZixPQUFPO3dCQUNQSixHQUFHO3dCQUNIQyxHQUFHO3dC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VUFBVSxLQUFTLDJCQUEyQjtvQkFDcEQ7b0JBQ0FNLE1BQU07b0JBQ05DLFNBQVM7d0JBQ1BzQyxLQUFLbUw7d0JBQ0xDLFFBQVFBO3dCQUNSRSxRQUFRM08sQ0FBQUEsb0JBQUFBLDhCQUFBQSxRQUFTMk8sTUFBTSxNQUFLO3dCQUM1QkMsU0FBUzVPLENBQUFBLG9CQUFBQSw4QkFBQUEsUUFBUzRPLE9BQU8sTUFBSztvQkFDaEM7Z0JBQ0Y7Z0JBRUEsNkNBQTZDO2dCQUM3QzVQLDZEQUFRQSxDQUFDSSx5REFBU0EsRUFBRTtvQkFDbEJtQyxTQUFTbU47b0JBQ1QxTyxTQUFTO3dCQUNQcUUsdUJBQXVCQTtvQkFDekI7Z0JBQ0Y7Z0JBRUEzQyxRQUFRQyxHQUFHLENBQUMsMkNBQXdELE9BQWhCK00sYUFBYWhPLEVBQUU7Z0JBQ25FLE9BQU9nTyxhQUFhaE8sRUFBRTtZQUN4QixFQUFFLE9BQU9vQixPQUFPO2dCQUNkSixRQUFRSSxLQUFLLENBQUMsK0JBQTRCQTtnQkFDMUMsTUFBTUE7WUFDUjtRQUNGO0lBQ0Y7SUFFQSxPQUFPakM7QUFDVCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9jb21wb25lbnRzL2FpLWNoYXQvYWktdmlkZW8tY29tbWFuZHMudHM/MjYyMyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgU3RhdGVNYW5hZ2VyIGZyb20gXCJAZGVzaWduY29tYm8vc3RhdGVcIjtcbmltcG9ydCB7IGRpc3BhdGNoIH0gZnJvbSBcIkBkZXNpZ25jb21iby9ldmVudHNcIjtcbmltcG9ydCB7IERFU0lHTl9BRERfVEVYVCwgREVTSUdOX0FERF9BVURJTywgREVTSUdOX0FERF9JTUFHRSwgQUREX1RFWFQsIEFERF9WSURFTywgQUREX0lNQUdFLCBBRERfQVVESU8sIEFDVElWRV9TUExJVCwgTEFZRVJfU0VMRUNULCBMQVlFUl9ERUxFVEUsIFRJTUVMSU5FX1NDQUxFX0NIQU5HRUQsIEVESVRfT0JKRUNUIH0gZnJvbSBcIkBkZXNpZ25jb21iby9zdGF0ZVwiO1xuaW1wb3J0IHsgZ2VuZXJhdGVJZCB9IGZyb20gXCJAZGVzaWduY29tYm8vdGltZWxpbmVcIjtcblxuXG5leHBvcnQgaW50ZXJmYWNlIFZpZGVvQ29tbWFuZEV4ZWN1dG9yIHtcbiAgYWRkVGV4dDogKHRleHQ6IHN0cmluZywgb3B0aW9ucz86IFRleHRPcHRpb25zKSA9PiB2b2lkO1xuICBjaGFuZ2VDb2xvcjogKGVsZW1lbnRJZDogc3RyaW5nLCBjb2xvcjogc3RyaW5nKSA9PiB2b2lkO1xuICBhZGRJbWFnZTogKHVybDogc3RyaW5nLCBvcHRpb25zPzogSW1hZ2VPcHRpb25zKSA9PiB2b2lkO1xuICBhZGRWaWRlbzogKHVybDogc3RyaW5nLCBvcHRpb25zPzogVmlkZW9PcHRpb25zKSA9PiB2b2lkO1xuICBjaGFuZ2VEdXJhdGlvbjogKGVsZW1lbnRJZDogc3RyaW5nLCBkdXJhdGlvbjogbnVtYmVyKSA9PiB2b2lkO1xuICBjaGFuZ2VUcmFuc2l0aW9uOiAoZWxlbWVudElkOiBzdHJpbmcsIHRyYW5zaXRpb246IHN0cmluZykgPT4gdm9pZDtcbiAgYWRkU3VidGl0bGVzOiAob3B0aW9ucz86IFN1YnRpdGxlT3B0aW9ucykgPT4gdm9pZDtcbiAgcmVtb3ZlU2VnbWVudHM6IChzZWdtZW50czogVGltZVNlZ21lbnRbXSkgPT4gdm9pZDtcbiAgZ2V0QWN0aXZlRWxlbWVudHM6ICgpID0+IFByb21pc2U8YW55W10+O1xuICBnZXRBbGxUaW1lbGluZUVsZW1lbnRzOiAoKSA9PiBQcm9taXNlPGFueVtdPjtcbiAgY29tcGFjdFRpbWVsaW5lOiAoKSA9PiBQcm9taXNlPGJvb2xlYW4+O1xuICBzbWFydFRyaW06ICgpID0+IFByb21pc2U8Ym9vbGVhbj47XG4gIGFkZE11c2ljOiAobXVzaWNQYXRoOiBzdHJpbmcsIG9wdGlvbnM/OiBNdXNpY09wdGlvbnMpID0+IHZvaWQ7XG59XG5cbmludGVyZmFjZSBUZXh0T3B0aW9ucyB7XG4gIGZvbnRTaXplPzogbnVtYmVyO1xuICBmb250RmFtaWx5Pzogc3RyaW5nO1xuICBjb2xvcj86IHN0cmluZztcbiAgcG9zaXRpb24/OiB7IHg6IG51bWJlcjsgeTogbnVtYmVyIH07XG4gIHN0YXJ0VGltZT86IG51bWJlcjsgLy8gZW4gc2VndW5kb3NcbiAgZW5kVGltZT86IG51bWJlcjsgLy8gZW4gc2VndW5kb3Ncbn1cblxuaW50ZXJmYWNlIEltYWdlT3B0aW9ucyB7XG4gIHdpZHRoPzogbnVtYmVyO1xuICBoZWlnaHQ/OiBudW1iZXI7XG4gIHBvc2l0aW9uPzogeyB4OiBudW1iZXI7IHk6IG51bWJlciB9O1xuICBzdGFydFRpbWU/OiBudW1iZXI7IC8vIGVuIHNlZ3VuZG9zXG4gIGVuZFRpbWU/OiBudW1iZXI7IC8vIGVuIHNlZ3VuZG9zXG4gIGlzQW5pbWF0ZWQ/OiBib29sZWFuO1xuICBpc1N0YXRpYz86IGJvb2xlYW47IC8vIFBhcmEgZm9yemFyIHRyYXRhciB1bmEgaW1hZ2VuIGFuaW1hZGEgY29tbyBlc3TDoXRpY2FcbiAgc2NhbGVNb2RlPzogc3RyaW5nO1xufVxuXG5pbnRlcmZhY2UgVmlkZW9PcHRpb25zIHtcbiAgd2lkdGg/OiBudW1iZXI7XG4gIGhlaWdodD86IG51bWJlcjtcbiAgcG9zaXRpb24/OiB7IHg6IG51bWJlcjsgeTogbnVtYmVyIH07XG4gIHN0YXJ0VGltZT86IG51bWJlcjsgLy8gZW4gc2VndW5kb3NcbiAgZW5kVGltZT86IG51bWJlcjsgLy8gZW4gc2VndW5kb3NcbiAgc2NhbGVNb2RlPzogc3RyaW5nO1xuICBpc0FQTkc/OiBib29sZWFuO1xuICBzeW5jV2l0aFRpbWVsaW5lPzogYm9vbGVhbjtcbiAgcGxheWJhY2tCZWhhdmlvcj86IHN0cmluZztcbn1cblxuaW50ZXJmYWNlIFN1YnRpdGxlT3B0aW9ucyB7XG4gIGdyb3VwV29yZHM/OiBib29sZWFuOyAvLyBTaSBzZSBkZWJlbiBhZ3J1cGFyIHBhbGFicmFzICh0cnVlKSBvIHVzYXIgc3VidMOtdHVsb3MgY29tcGxldG9zIChmYWxzZSlcbiAgc3RhcnRUaW1lPzogbnVtYmVyOyAgIC8vIFRpZW1wbyBkZSBpbmljaW8gcGFyYSBmaWx0cmFyIHN1YnTDrXR1bG9zIChvcGNpb25hbClcbiAgZW5kVGltZT86IG51bWJlcjsgICAgIC8vIFRpZW1wbyBkZSBmaW4gcGFyYSBmaWx0cmFyIHN1YnTDrXR1bG9zIChvcGNpb25hbClcbiAgdHJhY2tJZD86IHN0cmluZzsgICAgIC8vIElEIGVzcGVjw61maWNvIGRlbCB0cmFjayBkb25kZSBhw7FhZGlyIGxvcyBzdWJ0w610dWxvcyAob3BjaW9uYWwpXG59XG5cbmludGVyZmFjZSBNdXNpY09wdGlvbnMge1xuICBzdGFydFRpbWU/OiBudW1iZXI7IC8vIGVuIHNlZ3VuZG9zXG4gIGVuZFRpbWU/OiBudW1iZXI7IC8vIGVuIHNlZ3VuZG9zXG4gIHZvbHVtZT86IG51bWJlcjsgLy8gMC0xMDBcbiAgZmFkZUluPzogYm9vbGVhbjtcbiAgZmFkZU91dD86IGJvb2xlYW47XG4gIHJlc3BlY3ROYXRpdmVEdXJhdGlvbj86IGJvb2xlYW47IC8vIFJlc3BldGFyIGxhIGR1cmFjacOzbiBuYXRpdmEgZGVsIGFyY2hpdm8gZGUgYXVkaW9cbn1cblxuLy8gVGlwbyBwYXJhIHJlcHJlc2VudGFyIHVuIHNlZ21lbnRvIGRlIHN1YnTDrXR1bG9cbmludGVyZmFjZSBTdWJ0aXRsZVNlZ21lbnQge1xuICBpZDogbnVtYmVyO1xuICBzdGFydFRpbWU6IG51bWJlcjsgLy8gZW4gbWlsaXNlZ3VuZG9zXG4gIGVuZFRpbWU6IG51bWJlcjsgICAvLyBlbiBtaWxpc2VndW5kb3NcbiAgdGV4dDogc3RyaW5nO1xufVxuXG5pbnRlcmZhY2UgVGltZVNlZ21lbnQge1xuICBzdGFydFRpbWU6IG51bWJlcjsgLy8gVGllbXBvIGRlIGluaWNpbyBlbiBzZWd1bmRvc1xuICBlbmRUaW1lOiBudW1iZXI7ICAgLy8gVGllbXBvIGZpbmFsIGVuIHNlZ3VuZG9zXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVWaWRlb0NvbW1hbmRFeGVjdXRvcihzdGF0ZU1hbmFnZXI6IFN0YXRlTWFuYWdlcik6IFZpZGVvQ29tbWFuZEV4ZWN1dG9yIHtcbiAgLy8gQ3JlYXIgZWwgb2JqZXRvIGV4ZWN1dG9yIGNvbiB0b2RvcyBsb3MgbcOpdG9kb3NcbiAgY29uc3QgZXhlY3V0b3I6IFZpZGVvQ29tbWFuZEV4ZWN1dG9yID0ge1xuICAgIGFkZFRleHQ6ICh0ZXh0OiBzdHJpbmcsIG9wdGlvbnM/OiBUZXh0T3B0aW9ucykgPT4ge1xuICAgICAgY29uc3QgcG9zaXRpb24gPSBvcHRpb25zPy5wb3NpdGlvbiB8fCB7IHg6IDAuNSwgeTogMC41IH07IC8vIENlbnRyYWRvIHBvciBkZWZlY3RvXG4gICAgICBjb25zdCBmb250U2l6ZSA9IG9wdGlvbnM/LmZvbnRTaXplIHx8IDQ4O1xuICAgICAgY29uc3QgZm9udEZhbWlseSA9IG9wdGlvbnM/LmZvbnRGYW1pbHkgfHwgXCJSb2JvdG8tQm9sZFwiO1xuICAgICAgY29uc3QgY29sb3IgPSBvcHRpb25zPy5jb2xvciB8fCBcIiNGRkZGRkZcIjtcbiAgICAgIGNvbnN0IHN0YXJ0VGltZSA9IG9wdGlvbnM/LnN0YXJ0VGltZSB8fCAwOyAvLyBQb3IgZGVmZWN0byBhbCBpbmljaW9cbiAgICAgIGNvbnN0IGVuZFRpbWUgPSBvcHRpb25zPy5lbmRUaW1lIHx8IDU7IC8vIFBvciBkZWZlY3RvIDUgc2VndW5kb3MgZGUgZHVyYWNpw7NuXG5cbiAgICAgIC8vIENyZWFyIHBheWxvYWQgcGFyYSBlbCB0ZXh0b1xuICAgICAgY29uc3QgdGV4dFBheWxvYWQgPSB7XG4gICAgICAgIGlkOiBnZW5lcmF0ZUlkKCksXG4gICAgICAgIGRpc3BsYXk6IHtcbiAgICAgICAgICBmcm9tOiBzdGFydFRpbWUgKiAxMDAwLCAvLyBDb252ZXJ0aXIgYSBtaWxpc2VndW5kb3NcbiAgICAgICAgICB0bzogZW5kVGltZSAqIDEwMDAgICAgIC8vIENvbnZlcnRpciBhIG1pbGlzZWd1bmRvc1xuICAgICAgICB9LFxuICAgICAgICB0eXBlOiAndGV4dCcsXG4gICAgICAgIGRldGFpbHM6IHtcbiAgICAgICAgICB0ZXh0OiB0ZXh0LFxuICAgICAgICAgIGZvbnRTaXplOiBmb250U2l6ZSxcbiAgICAgICAgICB3aWR0aDogNjAwLFxuICAgICAgICAgIGZvbnRGYW1pbHk6IGZvbnRGYW1pbHksXG4gICAgICAgICAgY29sb3I6IGNvbG9yLFxuICAgICAgICAgIHdvcmRXcmFwOiAnYnJlYWstd29yZCcsXG4gICAgICAgICAgdGV4dEFsaWduOiAnY2VudGVyJyxcbiAgICAgICAgICBib3JkZXJXaWR0aDogMCxcbiAgICAgICAgICBib3JkZXJDb2xvcjogJyMwMDAwMDAnLFxuICAgICAgICAgIGJveFNoYWRvdzoge1xuICAgICAgICAgICAgY29sb3I6ICcjZmZmZmZmJyxcbiAgICAgICAgICAgIHg6IDAsXG4gICAgICAgICAgICB5OiAwLFxuICAgICAgICAgICAgYmx1cjogMCxcbiAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgfTtcblxuICAgICAgLy8gQWdyZWdhciB0ZXh0byBhbCB0aW1lbGluZVxuICAgICAgZGlzcGF0Y2goQUREX1RFWFQsIHtcbiAgICAgICAgcGF5bG9hZDogdGV4dFBheWxvYWQsXG4gICAgICAgIG9wdGlvbnM6IHt9LFxuICAgICAgfSk7XG4gICAgfSxcblxuICAgIGNoYW5nZUNvbG9yOiAoZWxlbWVudElkOiBzdHJpbmcsIGNvbG9yOiBzdHJpbmcpID0+IHtcbiAgICAgIC8vIFNpbXVsYWNpw7NuIGRlIGNhbWJpbyBkZSBjb2xvciAobGEgaW1wbGVtZW50YWNpw7NuIHJlYWwgZGVwZW5kZXLDoSBkZSBsYSBlc3RydWN0dXJhIGRlbCBwcm95ZWN0bylcbiAgICAgIGNvbnNvbGUubG9nKGBDYW1iaWFuZG8gY29sb3IgZGVsIGVsZW1lbnRvICR7ZWxlbWVudElkfSBhICR7Y29sb3J9YCk7XG5cbiAgICAgIC8vIEFxdcOtIGlyw61hIGxhIGzDs2dpY2EgcmVhbCBwYXJhIGNhbWJpYXIgZWwgY29sb3IgZGUgdW4gZWxlbWVudG9cbiAgICB9LFxuXG4gICAgYWRkSW1hZ2U6ICh1cmw6IHN0cmluZywgb3B0aW9ucz86IEltYWdlT3B0aW9ucykgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgIC8vIEFzZWd1cmFyIHF1ZSB0ZW5lbW9zIHVuYSBVUkwgdsOhbGlkYVxuICAgICAgaWYgKCF1cmwpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFwi4p2MIFVSTCBkZSBpbWFnZW4gbm8gdsOhbGlkYSBvIHZhY8OtYVwiKTtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVUkwgZGUgaW1hZ2VuIG5vIHByb3BvcmNpb25hZGFcIik7XG4gICAgICB9XG5cbiAgICAgICAgY29uc29sZS5sb2coXCI9PT0gSU5JQ0lBTkRPIFBST0NFU08gREUgQcORQURJUiBJTUFHRU4gPT09XCIpO1xuICAgICAgICBjb25zb2xlLmxvZyhcIlVSTDpcIiwgdXJsKTtcbiAgICAgICAgY29uc29sZS5sb2coXCJPcGNpb25lczpcIiwgSlNPTi5zdHJpbmdpZnkob3B0aW9ucywgbnVsbCwgMikpO1xuXG4gICAgICAvLyBWZXJpZmljYXIgc2kgZXMgdW5hIFVSTCBnZW7DqXJpY2EgZGUgcmVmZXJlbmNpYSwgcXVlIG5vIGRlYmUgdXNhcnNlIGRpcmVjdGFtZW50ZVxuICAgICAgaWYgKHVybCA9PT0gJ2ltYWdlbl9hZGp1bnRhX3Bvcl9lbF91c3VhcmlvLmpwZycgfHwgdXJsLmluY2x1ZGVzKCcvdXJsX2RlX2xhX2ltYWdlbicpKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvcjogVVJMIGRlIGltYWdlbiBnZW7DqXJpY2EgaW52w6FsaWRhIGRldGVjdGFkYVwiLCB1cmwpO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJMYSBVUkwgZGUgaW1hZ2VuIG5vIGVzIHbDoWxpZGEuIFNlIGludGVudMOzIHVzYXIgdW4gbWFyY2Fkb3IgZ2Vuw6lyaWNvIGRpcmVjdGFtZW50ZS5cIik7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHdpZHRoID0gb3B0aW9ucz8ud2lkdGggfHwgNDgwO1xuICAgICAgY29uc3QgaGVpZ2h0ID0gb3B0aW9ucz8uaGVpZ2h0IHx8IDI3MDtcbiAgICAgIGNvbnN0IHN0YXJ0VGltZSA9IG9wdGlvbnM/LnN0YXJ0VGltZSAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5zdGFydFRpbWUgOiAwO1xuICAgICAgY29uc3QgZW5kVGltZSA9IG9wdGlvbnM/LmVuZFRpbWUgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuZW5kVGltZSA6IHN0YXJ0VGltZSArIDU7XG5cbiAgICAgICAgLy8gRGV0ZWN0b3JlcyBkZSB0aXBvIGRlIGltYWdlblxuICAgICAgICBjb25zdCBpc0V4cGxpY2l0bHlBbmltYXRlZCA9IG9wdGlvbnM/LmlzQW5pbWF0ZWQgPT09IHRydWU7XG4gICAgICAgIGNvbnN0IGlzRXhwbGljaXRseVN0YXRpYyA9IG9wdGlvbnM/LmlzU3RhdGljID09PSB0cnVlO1xuICAgICAgICBjb25zdCBpc0FQTkcgPSB1cmwudG9Mb3dlckNhc2UoKS5lbmRzV2l0aCgnLmFwbmcnKTtcbiAgICAgICAgY29uc3QgaXNHSUYgPSB1cmwudG9Mb3dlckNhc2UoKS5lbmRzV2l0aCgnLmdpZicpO1xuXG4gICAgICAgIC8vIERldGVybWluYXIgc2kgZGViZSB0cmF0YXJzZSBjb21vIGltYWdlbiBhbmltYWRhXG4gICAgICAgIGNvbnN0IHNob3VsZFRyZWF0QXNBbmltYXRlZCA9IChpc0V4cGxpY2l0bHlBbmltYXRlZCB8fCBpc0FQTkcgfHwgaXNHSUYpICYmICFpc0V4cGxpY2l0bHlTdGF0aWM7XG5cbiAgICAgICAgLy8gTG9nIGRlIG1vZG8gZGV0ZWN0YWRvXG4gICAgICAgIGlmIChzaG91bGRUcmVhdEFzQW5pbWF0ZWQpIHtcbiAgICAgICAgICBjb25zb2xlLmxvZyhg8J+UtiBEZXRlY3RhZGEgaW1hZ2VuIGFuaW1hZGE6ICR7dXJsfWApO1xuICAgICAgICAgIGNvbnNvbGUubG9nKGBUaXBvOiAke2lzQVBORyA/ICdBUE5HJyA6IGlzR0lGID8gJ0dJRicgOiAnQW5pbWFkYSBnZW7DqXJpY2EnfWApO1xuICAgICAgICB9IGVsc2UgaWYgKGlzQVBORyB8fCBpc0dJRikge1xuICAgICAgICAgIGNvbnNvbGUubG9nKGDwn5S5IERldGVjdGFkYSBpbWFnZW4gcG90ZW5jaWFsbWVudGUgYW5pbWFkYSBwZXJvIHRyYXTDoW5kb2xhIGNvbW8gZXN0w6F0aWNhOiAke3VybH1gKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zb2xlLmxvZyhg8J+UtyBEZXRlY3RhZGEgaW1hZ2VuIGVzdMOhdGljYTogJHt1cmx9YCk7XG4gICAgICAgIH1cblxuICAgICAgLy8gUGFyYSBkZXB1cmFjacOzbiwgbW9zdHJhciBwYXJ0ZSBkZSBsYSBVUkwgKHRydW5jYWRhIHNpIGVzIGRhdGE6VVJMKVxuICAgICAgY29uc3QgbG9nVXJsID0gdXJsLnN0YXJ0c1dpdGgoJ2RhdGE6JylcbiAgICAgICAgPyBgJHt1cmwuc3Vic3RyaW5nKDAsIDMwKX0uLi4gKGRhdGEgVVJMKWBcbiAgICAgICAgOiB1cmw7XG4gICAgICBjb25zb2xlLmxvZyhgQcOxYWRpZW5kbyBpbWFnZW4gZGVzZGUgJHtsb2dVcmx9IGRlc2RlIHNlZ3VuZG8gJHtzdGFydFRpbWV9IGhhc3RhICR7ZW5kVGltZX1gKTtcblxuICAgICAgICAvLyBQb3NpY2nDs24gKGNlbnRyYWRhIHBvciBkZWZlY3RvKVxuICAgICAgICBjb25zdCBwb3NpdGlvbiA9IG9wdGlvbnM/LnBvc2l0aW9uIHx8IHsgeDogMC41LCB5OiAwLjUgfTtcblxuICAgICAgICAvLyBNb2RvcyBkZSBlc2NhbGFcbiAgICAgICAgY29uc3Qgc2NhbGVNb2RlID0gb3B0aW9ucz8uc2NhbGVNb2RlIHx8IFwiZml0XCI7XG4gICAgICAgIGNvbnN0IHVzZUZ1bGxTY3JlZW4gPSBzY2FsZU1vZGUgPT09IFwiY292ZXJcIjtcblxuICAgICAgICAvLyBQcm9waWVkYWRlcyBwYXJhIGVsIHBheWxvYWQsIGNvbcO6biBwYXJhIGFtYm9zIGNhc29zXG4gICAgICAgIGNvbnN0IGNvbW1vblBheWxvYWRQcm9wcyA9IHtcbiAgICAgICAgICBmcm9tOiBzdGFydFRpbWUgKiAxMDAwLFxuICAgICAgICAgIHRvOiBlbmRUaW1lICogMTAwMFxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIFByb3BpZWRhZGVzIGRlIGRldGFsbGUgY29tdW5lc1xuICAgICAgICBjb25zdCBjb21tb25EZXRhaWxzUHJvcHMgPSB7XG4gICAgICAgICAgc3JjOiB1cmwsXG4gICAgICAgICAgd2lkdGg6IHdpZHRoLFxuICAgICAgICAgIGhlaWdodDogaGVpZ2h0LFxuICAgICAgICAgIG9wYWNpdHk6IDEwMCxcbiAgICAgICAgICBzY2FsZU1vZGU6IHNjYWxlTW9kZSxcbiAgICAgICAgICBsZWZ0OiBwb3NpdGlvbi54LFxuICAgICAgICAgIHRvcDogcG9zaXRpb24ueSxcbiAgICAgICAgICBvcmlnaW5YOiBcImNlbnRlclwiLFxuICAgICAgICAgIG9yaWdpblk6IFwiY2VudGVyXCJcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBDcmVhciBJRCDDum5pY29cbiAgICAgICAgY29uc3QgaW1hZ2VJZCA9IGdlbmVyYXRlSWQoKTtcblxuICAgICAgICAvLyBDcmVhciBlbCBwYXlsb2FkIGRlIGltYWdlbiBzaW1wbGlmaWNhZG9cbiAgICAgICAgY29uc3QgaW1hZ2VQYXlsb2FkID0ge1xuICAgICAgICAgIGlkOiBpbWFnZUlkLFxuICAgICAgICAgIGRpc3BsYXk6IGNvbW1vblBheWxvYWRQcm9wcyxcbiAgICAgICAgICB0eXBlOiAnaW1hZ2UnLFxuICAgICAgICAgIGRldGFpbHM6IHtcbiAgICAgICAgICAgIC4uLmNvbW1vbkRldGFpbHNQcm9wcyxcbiAgICAgICAgICAgIC8vIFNpIGVzIGFuaW1hZGEsIGHDsWFkaXIgYXRyaWJ1dG9zIGVzcGVjw61maWNvc1xuICAgICAgICAgICAgLi4uKHNob3VsZFRyZWF0QXNBbmltYXRlZCAmJiB7XG4gICAgICAgICAgICAgIGlzQW5pbWF0ZWQ6IHRydWUsXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIC8vIFNpIGEgcGFudGFsbGEgY29tcGxldGEsIGFqdXN0YXIgZGltZW5zaW9uZXNcbiAgICAgICAgICAgIC4uLih1c2VGdWxsU2NyZWVuICYmIHtcbiAgICAgICAgICAgICAgd2lkdGg6IDE5MjAsXG4gICAgICAgICAgICAgIGhlaWdodDogMTA4MFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgY29uc29sZS5sb2coXCJQYXlsb2FkIGRlIGltYWdlbiBhIGRlc3BhY2hhcjpcIiwgSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgIC4uLmltYWdlUGF5bG9hZCxcbiAgICAgICAgICBkZXRhaWxzOiB7XG4gICAgICAgICAgICAuLi5pbWFnZVBheWxvYWQuZGV0YWlscyxcbiAgICAgICAgICAgIHNyYzogaW1hZ2VQYXlsb2FkLmRldGFpbHMuc3JjLnN1YnN0cmluZygwLCAzMCkgKyAoaW1hZ2VQYXlsb2FkLmRldGFpbHMuc3JjLmxlbmd0aCA+IDMwID8gJy4uLicgOiAnJylcbiAgICAgICAgICB9XG4gICAgICAgIH0sIG51bGwsIDIpKTtcblxuICAgICAgICAvLyBPcGNpb25lcyBwYXJhIGVsIGRpc3BhdGNoXG4gICAgICAgIGNvbnN0IGRpc3BhdGNoT3B0aW9ucyA9IHtcbiAgICAgICAgICBzY2FsZU1vZGU6IHNjYWxlTW9kZSxcbiAgICAgICAgICBwb3NpdGlvbjogcG9zaXRpb24sXG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gRGVzcGFjaGFyIGxhIGFjY2nDs24gcGFyYSBhw7FhZGlyIGxhIGltYWdlblxuICAgICAgICBkaXNwYXRjaChBRERfSU1BR0UsIHtcbiAgICAgICAgICBwYXlsb2FkOiBpbWFnZVBheWxvYWQsXG4gICAgICAgICAgb3B0aW9uczogZGlzcGF0Y2hPcHRpb25zXG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIExvZyBkZSDDqXhpdG9cbiAgICAgICAgaWYgKHNob3VsZFRyZWF0QXNBbmltYXRlZCkge1xuICAgICAgICAgIGNvbnNvbGUubG9nKGDinIUgSW1hZ2VuIGFuaW1hZGEgYcOxYWRpZGEgZGVzZGUgJHtzdGFydFRpbWV9cyBoYXN0YSAke2VuZFRpbWV9c2ApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnNvbGUubG9nKGDinIUgSW1hZ2VuIGVzdMOhdGljYSBhw7FhZGlkYSBkZXNkZSAke3N0YXJ0VGltZX1zIGhhc3RhICR7ZW5kVGltZX1zYCk7XG4gICAgICAgIH1cblxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcIuKdjCBFUlJPUiBDUsONVElDTyBhbCBhw7FhZGlyIGltYWdlbjpcIiwgZXJyb3IpO1xuICAgICAgICBjb25zb2xlLmVycm9yKFwiRGV0YWxsZXMgY29tcGxldG9zOlwiLCBlcnJvci5tZXNzYWdlKTtcbiAgICAgICAgY29uc29sZS5lcnJvcihcIlRyYXphOlwiLCBlcnJvci5zdGFjayk7XG4gICAgICAgIHRocm93IGVycm9yOyAvLyBQcm9wYWdhciBlbCBlcnJvciBwYXJhIG1hbmVqbyBzdXBlcmlvclxuICAgICAgfVxuICAgIH0sXG5cbiAgICBhZGRWaWRlbzogKHVybDogc3RyaW5nLCBvcHRpb25zPzogVmlkZW9PcHRpb25zKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zb2xlLmxvZyhcIj09PSBJTklDSUFORE8gUFJPQ0VTTyBERSBBw5FBRElSIFZJREVPID09PVwiKTtcbiAgICAgICAgY29uc29sZS5sb2coXCJVUkw6XCIsIHVybCk7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiT3BjaW9uZXM6XCIsIEpTT04uc3RyaW5naWZ5KG9wdGlvbnMsIG51bGwsIDIpKTtcblxuICAgICAgICAvLyBWYWxpZGFjacOzbiBkZSBVUkxcbiAgICAgICAgaWYgKCF1cmwpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFwi4p2MIFVSTCBkZSB2aWRlbyBubyB2w6FsaWRhIG8gdmFjw61hXCIpO1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVSTCBkZSB2aWRlbyBubyBwcm9wb3JjaW9uYWRhXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qgd2lkdGggPSBvcHRpb25zPy53aWR0aCB8fCA2NDA7XG4gICAgICAgIGNvbnN0IGhlaWdodCA9IG9wdGlvbnM/LmhlaWdodCB8fCAzNjA7XG4gICAgICAgIGNvbnN0IHN0YXJ0VGltZSA9IG9wdGlvbnM/LnN0YXJ0VGltZSB8fCAwOyAvLyBQb3IgZGVmZWN0byBhbCBpbmljaW9cbiAgICAgICAgY29uc3QgZW5kVGltZSA9IG9wdGlvbnM/LmVuZFRpbWUgfHwgMTA7IC8vIFBvciBkZWZlY3RvIDEwIHNlZ3VuZG9zIGRlIGR1cmFjacOzblxuXG4gICAgICAgIC8vIERldGVjdGFyIHNpIGVzIHVuIGFyY2hpdm8gQVZJIG8gQVBORyBwYXJhIHRyYXRhbWllbnRvIGVzcGVjaWFsXG4gICAgICAgIGNvbnN0IGlzQVZJID0gdXJsLnRvTG93ZXJDYXNlKCkuZW5kc1dpdGgoJy5hdmknKTtcbiAgICAgICAgY29uc3QgaXNBUE5HID0gdXJsLnRvTG93ZXJDYXNlKCkuZW5kc1dpdGgoJy5hcG5nJyk7XG4gICAgICAgIC8vIE1hcmNhZG9yIHBhc2FkbyBleHBsw61jaXRhbWVudGUgLSBtYXlvciBwcmlvcmlkYWQgcXVlIGxhIGV4dGVuc2nDs25cbiAgICAgICAgY29uc3QgaXNFeHBsaWNpdEFQTkcgPSBvcHRpb25zPy5pc0FQTkcgPT09IHRydWU7XG5cbiAgICAgICAgY29uc29sZS5sb2coXCJGb3JtYXRvIGRldGVjdGFkbzpcIixcbiAgICAgICAgICBpc0FWSSA/IFwiQVZJXCIgOiBpc0FQTkcgPyBcIkFQTkdcIiA6IGlzRXhwbGljaXRBUE5HID8gXCJFeHBsw61jaXRhbWVudGUgbWFyY2FkbyBjb21vIEFQTkdcIiA6IFwiRm9ybWF0byBlc3TDoW5kYXJcIik7XG5cbiAgICAgICAgLy8gU2kgZXMgQVBORyBzZWfDum4gYWxnw7puIGNyaXRlcmlvXG4gICAgICAgIGNvbnN0IHRyZWF0QXNBUE5HID0gaXNBUE5HIHx8IGlzRXhwbGljaXRBUE5HO1xuICAgICAgICBjb25zdCB1c2VGdWxsU2NyZWVuID0gaXNBVkkgfHwgdHJlYXRBc0FQTkcgfHwgKG9wdGlvbnM/LnNjYWxlTW9kZSA9PT0gXCJjb3ZlclwiKTtcblxuICAgICAgICAvLyBQYXJhIGFyY2hpdm9zIEFWSSB5IEFQTkcsIHJlc3BlY3RhciBkdXJhY2nDs24gbmF0dXJhbCBzaSBubyBzZSBlc3BlY2lmaWNhXG4gICAgICAgIGNvbnN0IHJlc3BlY3ROYXRpdmVEdXJhdGlvbiA9IChpc0FWSSB8fCB0cmVhdEFzQVBORykgJiYgIW9wdGlvbnM/LmVuZFRpbWU7XG4gICAgICAgIGNvbnN0IGZpbmFsRW5kVGltZSA9IHJlc3BlY3ROYXRpdmVEdXJhdGlvbiA/IHVuZGVmaW5lZCA6IGVuZFRpbWU7XG5cbiAgICAgICAgLy8gTG9nIHBhcmEgZGVwdXJhclxuICAgICAgICBpZiAodHJlYXRBc0FQTkcpIHtcbiAgICAgICAgICBjb25zb2xlLmxvZyhg8J+UtyBBw7FhZGllbmRvIEFQTkcgY29tbyBWSURFTyBzaW5jcm9uaXphZG8gZGVzZGUgJHtzdGFydFRpbWV9cyBjb24gZHVyYWNpw7NuICR7cmVzcGVjdE5hdGl2ZUR1cmF0aW9uID8gJ25hdHVyYWwnIDogZmluYWxFbmRUaW1lICsgJ3MnfWApO1xuICAgICAgICAgIGNvbnNvbGUubG9nKGDwn5S3IENvbmZpZ3VyYWNpb25lcyBlc3BlY2lhbGVzIGRlIEFQTkcgLSB1c2VGdWxsU2NyZWVuOiAke3VzZUZ1bGxTY3JlZW59LCBzeW5jV2l0aFRpbWVsaW5lOiAke29wdGlvbnM/LnN5bmNXaXRoVGltZWxpbmUgfHwgdHJ1ZX1gKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc0FWSSkge1xuICAgICAgICAgIGNvbnNvbGUubG9nKGDwn46sIEHDsWFkaWVuZG8gQVZJIGNvbiBkdXJhY2nDs24gJHtyZXNwZWN0TmF0aXZlRHVyYXRpb24gPyAnbmF0dXJhbCcgOiAnZXNwZWNpZmljYWRhOiAnICsgZmluYWxFbmRUaW1lfXNgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIE1hbmVqYXIgQVBORyB1c2FuZG8gdW4gZW5mb3F1ZSBlc3BlY2lhbCAtIGludGVudGFyIGNvbiB1biBtw6l0b2RvIGFsdGVybmF0aXZvIHNpIGVzIHBvc2libGVcbiAgICAgICAgaWYgKHRyZWF0QXNBUE5HKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIEludGVudGFyIGNyZWFyIHVuIHBheWxvYWQgZXNwZWNpYWwgcGFyYSBBUE5HIHF1ZSBmdW5jaW9uZSBjb21vIGFuaW1hY2nDs25cbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiUHJvYmFuZG8gY29uIHVuYSBjb25maWd1cmFjacOzbiBlc3BlY2lhbCBwYXJhIEFQTkcuLi5cIik7XG5cbiAgICAgICAgICAgIC8vIENvbmZpZ3VyYWNpw7NuIGRlIG9wY2lvbmVzIGltcG9ydGFudGUgcGFyYSBhcmNoaXZvcyBBUE5HXG4gICAgICAgICAgICBjb25zdCBhcG5nVmlkZW9QYXlsb2FkID0ge1xuICAgICAgICAgICAgaWQ6IGdlbmVyYXRlSWQoKSxcbiAgICAgICAgICAgIGRpc3BsYXk6IHtcbiAgICAgICAgICAgICAgZnJvbTogc3RhcnRUaW1lICogMTAwMCwgLy8gQ29udmVydGlyIGEgbWlsaXNlZ3VuZG9zXG4gICAgICAgICAgICAgICAgdG86IGZpbmFsRW5kVGltZSA/IGZpbmFsRW5kVGltZSAqIDEwMDAgOiAoc3RhcnRUaW1lICsgMykgKiAxMDAwIC8vIDMgc2VndW5kb3MgcG9yIGRlZmVjdG8gc2kgbm8gaGF5IGR1cmFjacOzblxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgLy8gUHJvYmFtb3MgdW5hIG51ZXZhIGVzdHJhdGVnaWE6IHRyYXRhcmxvIGNvbW8gaW1hZ2VuIGVuIGx1Z2FyIGRlIHZpZGVvXG4gICAgICAgICAgICB0eXBlOiAnaW1hZ2UnLFxuICAgICAgICAgICAgZGV0YWlsczoge1xuICAgICAgICAgICAgICBzcmM6IHVybCxcbiAgICAgICAgICAgICAgICB3aWR0aDogMTkyMCwgLy8gQW5jaG8gcGFyYSBwYW50YWxsYSBjb21wbGV0YVxuICAgICAgICAgICAgICAgIGhlaWdodDogMTA4MCwgLy8gQWx0byBwYXJhIHBhbnRhbGxhIGNvbXBsZXRhXG4gICAgICAgICAgICAgIG9wYWNpdHk6IDEwMCxcbiAgICAgICAgICAgICAgICBzY2FsZU1vZGU6IFwiY292ZXJcIiwgLy8gUGFyYSBsbGVuYXIgdG9kYSBsYSBwYW50YWxsYVxuICAgICAgICAgICAgICAgIGxlZnQ6IDAuNSwgLy8gQ2VudHJhZG8gaG9yaXpvbnRhbG1lbnRlXG4gICAgICAgICAgICAgICAgdG9wOiAwLjUsICAvLyBDZW50cmFkbyB2ZXJ0aWNhbG1lbnRlXG4gICAgICAgICAgICAgICAgb3JpZ2luWDogXCJjZW50ZXJcIiwgLy8gT3JpZ2VuIGVuIGVsIGNlbnRyb1xuICAgICAgICAgICAgICAgIG9yaWdpblk6IFwiY2VudGVyXCIsIC8vIE9yaWdlbiBlbiBlbCBjZW50cm9cbiAgICAgICAgICAgICAgICAvLyBQcm9waWVkYWRlcyBwYXJhIGFuaW1hclxuICAgICAgICAgICAgICAgIGlzQW5pbWF0ZWQ6IHRydWVcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiUGF5bG9hZCBwYXJhIEFQTkcgY29tbyBpbWFnZW4gYW5pbWFkYTpcIiwgSlNPTi5zdHJpbmdpZnkoYXBuZ1ZpZGVvUGF5bG9hZCwgbnVsbCwgMikpO1xuXG4gICAgICAgICAgICAvLyBVc2FyIEFERF9JTUFHRSBlbiBsdWdhciBkZSBBRERfVklERU9cbiAgICAgICAgICBkaXNwYXRjaChBRERfSU1BR0UsIHtcbiAgICAgICAgICAgICAgcGF5bG9hZDogYXBuZ1ZpZGVvUGF5bG9hZCxcbiAgICAgICAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgICAgICAgICBzY2FsZU1vZGU6IFwiY292ZXJcIixcbiAgICAgICAgICAgICAgICBwb3NpdGlvbjogeyB4OiAwLjUsIHk6IDAuNSB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIuKchSBBUE5HIGHDsWFkaWRvIGNvbW8gaW1hZ2VuIGFuaW1hZGEgY29uIMOpeGl0b1wiKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9IGNhdGNoIChhcG5nRXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCLinYwgRXJyb3IgYWwgYcOxYWRpciBBUE5HIGNvbW8gaW1hZ2VuIGFuaW1hZGE6XCIsIGFwbmdFcnJvcik7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiRGV0YWxsZXM6XCIsIGFwbmdFcnJvci5tZXNzYWdlKTtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJUcmF6YTpcIiwgYXBuZ0Vycm9yLnN0YWNrKTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwi8J+UhCBDb250aW51YW5kbyBjb24gZWwgbcOpdG9kbyBlc3TDoW5kYXIgY29tbyByZXNwYWxkby4uLlwiKTtcbiAgICAgICAgICAgIC8vIENvbnRpbnVhciBjb24gZWwgbcOpdG9kbyBlc3TDoW5kYXIgY29tbyByZXNwYWxkb1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAvLyBDcmVhciBwYXlsb2FkIHBhcmEgZWwgdmlkZW9cbiAgICAgIGNvbnN0IHZpZGVvUGF5bG9hZCA9IHtcbiAgICAgICAgaWQ6IGdlbmVyYXRlSWQoKSxcbiAgICAgICAgZGlzcGxheToge1xuICAgICAgICAgIGZyb206IHN0YXJ0VGltZSAqIDEwMDAsIC8vIENvbnZlcnRpciBhIG1pbGlzZWd1bmRvc1xuICAgICAgICAgICAgdG86IGZpbmFsRW5kVGltZSA/IGZpbmFsRW5kVGltZSAqIDEwMDAgOiB1bmRlZmluZWQgLy8gVXNhciB1bmRlZmluZWQgc2kgcXVlcmVtb3MgcmVzcGV0YXIgbGEgZHVyYWNpw7NuIG5hdHVyYWxcbiAgICAgICAgfSxcbiAgICAgICAgdHlwZTogJ3ZpZGVvJyxcbiAgICAgICAgZGV0YWlsczoge1xuICAgICAgICAgIHNyYzogdXJsLFxuICAgICAgICAgIHdpZHRoOiB3aWR0aCxcbiAgICAgICAgICBoZWlnaHQ6IGhlaWdodCxcbiAgICAgICAgICBvcGFjaXR5OiAxMDAsXG4gICAgICAgICAgICAvLyBQYXJhIGFyY2hpdm9zIEFQTkcgeSBBVkksIGNvbmZpZ3VyYXIgcHJvcGllZGFkZXMgZXNwZWPDrWZpY2FzIHBhcmEgcGFudGFsbGEgY29tcGxldGFcbiAgICAgICAgICAgIC4uLih1c2VGdWxsU2NyZWVuICYmIHtcbiAgICAgICAgICAgICAgc2NhbGVNb2RlOiBcImNvdmVyXCIsIC8vIFVzYXIgXCJjb3ZlclwiIGVuIGx1Z2FyIGRlIFwiZml0XCIgcGFyYSBhc2VndXJhciBxdWUgY3VicmEgdG9kb1xuICAgICAgICAgICAgICBsZWZ0OiAwLjUsIC8vIENlbnRyYWRvIGhvcml6b250YWxtZW50ZVxuICAgICAgICAgICAgICB0b3A6IDAuNSwgIC8vIENlbnRyYWRvIHZlcnRpY2FsbWVudGVcbiAgICAgICAgICAgICAgb3JpZ2luWDogXCJjZW50ZXJcIiwgLy8gT3JpZ2VuIGVuIGVsIGNlbnRyb1xuICAgICAgICAgICAgICBvcmlnaW5ZOiBcImNlbnRlclwiLCAvLyBPcmlnZW4gZW4gZWwgY2VudHJvXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIC8vIFByb3BpZWRhZGVzIGVzcGVjaWFsZXMgcGFyYSBBUE5HXG4gICAgICAgICAgICAuLi4odHJlYXRBc0FQTkcgJiYge1xuICAgICAgICAgICAgICBpc0FQTkc6IHRydWUsXG4gICAgICAgICAgICAgIGF1dG9QbGF5OiB0cnVlLFxuICAgICAgICAgICAgICBsb29wOiBmYWxzZSxcbiAgICAgICAgICAgICAgc3luY1dpdGhUaW1lbGluZTogb3B0aW9ucz8uc3luY1dpdGhUaW1lbGluZSB8fCB0cnVlXG4gICAgICAgICAgICB9KVxuICAgICAgICAgIH0sXG4gICAgICAgIH07XG5cbiAgICAgICAgY29uc29sZS5sb2coXCJQYXlsb2FkIGRlIHZpZGVvIGVzdMOhbmRhcjpcIiwgSlNPTi5zdHJpbmdpZnkodmlkZW9QYXlsb2FkLCBudWxsLCAyKSk7XG5cbiAgICAgICAgLy8gQ29uZmlndXJhY2lvbmVzIGFkaWNpb25hbGVzIHBhcmEgZWwgZGlzcGF0Y2hcbiAgICAgICAgY29uc3QgZGlzcGF0Y2hPcHRpb25zID0ge1xuICAgICAgICAgIHJlc291cmNlSWQ6IFwibWFpblwiLFxuICAgICAgICAgIHNjYWxlTW9kZTogdXNlRnVsbFNjcmVlbiA/IFwiY292ZXJcIiA6IFwiZml0XCIsIC8vIFVzYXIgY292ZXIgcGFyYSBwYW50YWxsYSBjb21wbGV0YSwgZml0IHBhcmEgb3Ryb3MgdmlkZW9zXG4gICAgICAgICAgLi4uKHVzZUZ1bGxTY3JlZW4gJiYge1xuICAgICAgICAgICAgcG9zaXRpb246IHsgeDogMC41LCB5OiAwLjUgfSAvLyBDZW50cmFyIHBhcmEgdmlkZW9zIGEgcGFudGFsbGEgY29tcGxldGFcbiAgICAgICAgICB9KSxcbiAgICAgICAgICByZXNwZWN0TmF0aXZlRHVyYXRpb246IHJlc3BlY3ROYXRpdmVEdXJhdGlvbixcbiAgICAgICAgICAvLyBQcm9waWVkYWRlcyBlc3BlY8OtZmljYXMgcGFyYSBzaW5jcm9uaXphY2nDs24gZGUgQVBOR1xuICAgICAgICAgIC4uLih0cmVhdEFzQVBORyAmJiB7XG4gICAgICAgICAgICBpc0FQTkc6IHRydWUsXG4gICAgICAgICAgICBzeW5jV2l0aFRpbWVsaW5lOiBvcHRpb25zPy5zeW5jV2l0aFRpbWVsaW5lIHx8IHRydWUsXG4gICAgICAgICAgICBwbGF5YmFja0JlaGF2aW9yOiBvcHRpb25zPy5wbGF5YmFja0JlaGF2aW9yIHx8IFwic3luY1wiXG4gICAgICAgICAgfSlcbiAgICAgICAgfTtcblxuICAgICAgICBjb25zb2xlLmxvZyhcIk9wY2lvbmVzIGRlIGRpc3BhdGNoOlwiLCBKU09OLnN0cmluZ2lmeShkaXNwYXRjaE9wdGlvbnMsIG51bGwsIDIpKTtcblxuICAgICAgLy8gQWdyZWdhciB2aWRlbyBhbCB0aW1lbGluZVxuICAgICAgZGlzcGF0Y2goQUREX1ZJREVPLCB7XG4gICAgICAgIHBheWxvYWQ6IHZpZGVvUGF5bG9hZCxcbiAgICAgICAgICBvcHRpb25zOiBkaXNwYXRjaE9wdGlvbnMsXG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIE1lbnNhamUgZGUgbG9nIGFkYXB0YWRvIGFsIHRpcG8gZGUgYXJjaGl2b1xuICAgICAgICBpZiAodHJlYXRBc0FQTkcpIHtcbiAgICAgICAgICBjb25zb2xlLmxvZyhg4pyFIFRyYW5zaWNpw7NuIEFQTkcgYcOxYWRpZGEgY29tbyBWSURFTyBTSU5DUk9OSVpBRE8gYWwgdGltZWxpbmUgZGVzZGUgJHtzdGFydFRpbWV9cyAke2ZpbmFsRW5kVGltZSA/IGBoYXN0YSAke2ZpbmFsRW5kVGltZX1zYCA6ICdjb24gZHVyYWNpw7NuIG5hdHVyYWwnfS4gRGltZW5zaW9uZXM6ICR7d2lkdGh9eCR7aGVpZ2h0fWApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnNvbGUubG9nKGDinIUgVmlkZW8gJHtpc0FWSSA/ICdBVkknIDogJyd9IGHDsWFkaWRvIGFsIHRpbWVsaW5lIGRlc2RlICR7c3RhcnRUaW1lfXMke2ZpbmFsRW5kVGltZSA/IGAgaGFzdGEgJHtmaW5hbEVuZFRpbWV9c2AgOiAnIGNvbiBkdXJhY2nDs24gbmF0dXJhbCd9LiBEaW1lbnNpb25lczogJHt3aWR0aH14JHtoZWlnaHR9YCk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCLinYwgRVJST1IgQ1LDjVRJQ08gYWwgYcOxYWRpciB2aWRlbzpcIiwgZXJyb3IpO1xuICAgICAgICBjb25zb2xlLmVycm9yKFwiRGV0YWxsZXMgY29tcGxldG9zOlwiLCBlcnJvci5tZXNzYWdlKTtcbiAgICAgICAgY29uc29sZS5lcnJvcihcIlRyYXphOlwiLCBlcnJvci5zdGFjayk7XG4gICAgICAgIHRocm93IGVycm9yOyAvLyBQcm9wYWdhciBlbCBlcnJvciBwYXJhIG1hbmVqbyBzdXBlcmlvclxuICAgICAgfVxuICAgIH0sXG5cbiAgICBjaGFuZ2VEdXJhdGlvbjogKGVsZW1lbnRJZDogc3RyaW5nLCBkdXJhdGlvbjogbnVtYmVyKSA9PiB7XG4gICAgICAvLyBTaW11bGFjacOzbiBkZSBjYW1iaW8gZGUgZHVyYWNpw7NuIChsYSBpbXBsZW1lbnRhY2nDs24gcmVhbCBkZXBlbmRlcsOhIGRlIGxhIGVzdHJ1Y3R1cmEgZGVsIHByb3llY3RvKVxuICAgICAgY29uc29sZS5sb2coYENhbWJpYW5kbyBkdXJhY2nDs24gZGVsIGVsZW1lbnRvICR7ZWxlbWVudElkfSBhICR7ZHVyYXRpb259c2ApO1xuXG4gICAgICAvLyBBcXXDrSBpcsOtYSBsYSBsw7NnaWNhIHJlYWwgcGFyYSBjYW1iaWFyIGxhIGR1cmFjacOzbiBkZSB1biBlbGVtZW50b1xuICAgIH0sXG5cbiAgICBjaGFuZ2VUcmFuc2l0aW9uOiAoZWxlbWVudElkOiBzdHJpbmcsIHRyYW5zaXRpb246IHN0cmluZykgPT4ge1xuICAgICAgLy8gU2ltdWxhY2nDs24gZGUgY2FtYmlvIGRlIHRyYW5zaWNpw7NuIChsYSBpbXBsZW1lbnRhY2nDs24gcmVhbCBkZXBlbmRlcsOhIGRlIGxhIGVzdHJ1Y3R1cmEgZGVsIHByb3llY3RvKVxuICAgICAgY29uc29sZS5sb2coYENhbWJpYW5kbyB0cmFuc2ljacOzbiBkZWwgZWxlbWVudG8gJHtlbGVtZW50SWR9IGEgJHt0cmFuc2l0aW9ufWApO1xuXG4gICAgICAvLyBBcXXDrSBpcsOtYSBsYSBsw7NnaWNhIHJlYWwgcGFyYSBjYW1iaWFyIGxhIHRyYW5zaWNpw7NuIGRlIHVuIGVsZW1lbnRvXG4gICAgfSxcblxuICAgIGFkZFN1YnRpdGxlczogYXN5bmMgKG9wdGlvbnM/OiBTdWJ0aXRsZU9wdGlvbnMpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiQcOxYWRpZW5kbyBzdWJ0w610dWxvcyBkaXJlY3RhbWVudGUgc2luIGRlcGVuZGVyIGRlbCBib3TDs25cIik7XG5cbiAgICAgICAgLy8gVGlwbyBwYXJhIHJlcHJlc2VudGFyIHVuIHNlZ21lbnRvIGRlIHN1YnTDrXR1bG9cbiAgICAgICAgaW50ZXJmYWNlIFN1YnRpdGxlU2VnbWVudCB7XG4gICAgICAgICAgaWQ6IG51bWJlcjtcbiAgICAgICAgICBzdGFydFRpbWU6IG51bWJlcjsgLy8gZW4gbWlsaXNlZ3VuZG9zXG4gICAgICAgICAgZW5kVGltZTogbnVtYmVyOyAgIC8vIGVuIG1pbGlzZWd1bmRvc1xuICAgICAgICAgIHRleHQ6IHN0cmluZztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEZ1bmNpw7NuIHBhcmEgcGFyc2VhciBlbCB0aWVtcG8gZGUgZm9ybWF0byBTUlQgYSBtaWxpc2VndW5kb3NcbiAgICAgICAgY29uc3QgcGFyc2VUaW1lVG9NcyA9ICh0aW1lU3RyaW5nOiBzdHJpbmcpOiBudW1iZXIgPT4ge1xuICAgICAgICAgIGNvbnN0IFtob3VycywgbWludXRlcywgc2Vjb25kc0FuZE1zXSA9IHRpbWVTdHJpbmcuc3BsaXQoJzonKTtcbiAgICAgICAgICBjb25zdCBbc2Vjb25kcywgbXNdID0gc2Vjb25kc0FuZE1zLnNwbGl0KCcsJyk7XG5cbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgcGFyc2VJbnQoaG91cnMpICogMzYwMDAwMCArXG4gICAgICAgICAgICBwYXJzZUludChtaW51dGVzKSAqIDYwMDAwICtcbiAgICAgICAgICAgIHBhcnNlSW50KHNlY29uZHMpICogMTAwMCArXG4gICAgICAgICAgICBwYXJzZUludChtcylcbiAgICAgICAgICApO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIEZ1bmNpw7NuIHBhcmEgcGFyc2VhciBlbCBhcmNoaXZvIFNSVFxuICAgICAgICBjb25zdCBwYXJzZVNSVCA9IChzcnRDb250ZW50OiBzdHJpbmcpOiBTdWJ0aXRsZVNlZ21lbnRbXSA9PiB7XG4gICAgICAgICAgY29uc3Qgc2VnbWVudHM6IFN1YnRpdGxlU2VnbWVudFtdID0gW107XG4gICAgICAgICAgY29uc3QgYmxvY2tzID0gc3J0Q29udGVudC50cmltKCkuc3BsaXQoJ1xcblxcbicpO1xuXG4gICAgICAgICAgYmxvY2tzLmZvckVhY2goYmxvY2sgPT4ge1xuICAgICAgICAgICAgY29uc3QgbGluZXMgPSBibG9jay5zcGxpdCgnXFxuJyk7XG4gICAgICAgICAgICBpZiAobGluZXMubGVuZ3RoID49IDMpIHtcbiAgICAgICAgICAgICAgY29uc3QgaWQgPSBwYXJzZUludChsaW5lc1swXSk7XG4gICAgICAgICAgICAgIGNvbnN0IHRpbWVSYW5nZSA9IGxpbmVzWzFdLnNwbGl0KCcgLS0+ICcpO1xuICAgICAgICAgICAgICBjb25zdCBzdGFydFRpbWUgPSBwYXJzZVRpbWVUb01zKHRpbWVSYW5nZVswXSk7XG4gICAgICAgICAgICAgIGNvbnN0IGVuZFRpbWUgPSBwYXJzZVRpbWVUb01zKHRpbWVSYW5nZVsxXSk7XG4gICAgICAgICAgICAgIGNvbnN0IHRleHQgPSBsaW5lcy5zbGljZSgyKS5qb2luKCdcXG4nKTsgLy8gVW5pciB0b2RhcyBsYXMgbMOtbmVhcyBkZSB0ZXh0b1xuXG4gICAgICAgICAgICAgIHNlZ21lbnRzLnB1c2goe1xuICAgICAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgICAgIHN0YXJ0VGltZSxcbiAgICAgICAgICAgICAgICBlbmRUaW1lLFxuICAgICAgICAgICAgICAgIHRleHRcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICByZXR1cm4gc2VnbWVudHM7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gRnVuY2nDs24gcGFyYSBkaXZpZGlyIHVuIHRleHRvIGVuIGdydXBvcyBkZSBhcHJveGltYWRhbWVudGUgMyBwYWxhYnJhc1xuICAgICAgICBjb25zdCBzcGxpdFRleHRJbnRvR3JvdXBzID0gKHRleHQ6IHN0cmluZywgd29yZHNQZXJHcm91cCA9IDMpOiBzdHJpbmdbXSA9PiB7XG4gICAgICAgICAgY29uc3Qgd29yZHMgPSB0ZXh0LnNwbGl0KC9cXHMrLyk7XG4gICAgICAgICAgY29uc3QgZ3JvdXBzOiBzdHJpbmdbXSA9IFtdO1xuXG4gICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB3b3Jkcy5sZW5ndGg7IGkgKz0gd29yZHNQZXJHcm91cCkge1xuICAgICAgICAgICAgY29uc3QgZ3JvdXAgPSB3b3Jkcy5zbGljZShpLCBpICsgd29yZHNQZXJHcm91cCkuam9pbignICcpO1xuICAgICAgICAgICAgZ3JvdXBzLnB1c2goZ3JvdXApO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBncm91cHM7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gRnVuY2nDs24gcGFyYSBwcm9jZXNhciB1biBzZWdtZW50byB5IGRpdmlkaXJsbyBlbiBtw7psdGlwbGVzIHNlZ21lbnRvcyBzaSBlcyBuZWNlc2FyaW9cbiAgICAgICAgY29uc3QgcHJvY2Vzc1NlZ21lbnQgPSAoc2VnbWVudDogU3VidGl0bGVTZWdtZW50KTogU3VidGl0bGVTZWdtZW50W10gPT4ge1xuICAgICAgICAgIGNvbnN0IHRleHRHcm91cHMgPSBzcGxpdFRleHRJbnRvR3JvdXBzKHNlZ21lbnQudGV4dCk7XG5cbiAgICAgICAgICAvLyBTaSBzb2xvIGhheSB1biBncnVwbywgZGV2b2x2ZXIgZWwgc2VnbWVudG8gb3JpZ2luYWxcbiAgICAgICAgICBpZiAodGV4dEdyb3Vwcy5sZW5ndGggPD0gMSkge1xuICAgICAgICAgICAgcmV0dXJuIFtzZWdtZW50XTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBDYWxjdWxhciBsYSBkdXJhY2nDs24gZGUgY2FkYSBncnVwb1xuICAgICAgICAgIGNvbnN0IHRvdGFsRHVyYXRpb24gPSBzZWdtZW50LmVuZFRpbWUgLSBzZWdtZW50LnN0YXJ0VGltZTtcbiAgICAgICAgICBjb25zdCBncm91cER1cmF0aW9uID0gdG90YWxEdXJhdGlvbiAvIHRleHRHcm91cHMubGVuZ3RoO1xuXG4gICAgICAgICAgLy8gQ3JlYXIgdW4gbnVldm8gc2VnbWVudG8gcGFyYSBjYWRhIGdydXBvXG4gICAgICAgICAgcmV0dXJuIHRleHRHcm91cHMubWFwKChncm91cFRleHQsIGluZGV4KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBzdGFydFRpbWUgPSBzZWdtZW50LnN0YXJ0VGltZSArIChpbmRleCAqIGdyb3VwRHVyYXRpb24pO1xuICAgICAgICAgICAgY29uc3QgZW5kVGltZSA9IHN0YXJ0VGltZSArIGdyb3VwRHVyYXRpb247XG5cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIGlkOiBzZWdtZW50LmlkICogMTAwMCArIGluZGV4LCAvLyBHZW5lcmFyIHVuIElEIMO6bmljb1xuICAgICAgICAgICAgICBzdGFydFRpbWUsXG4gICAgICAgICAgICAgIGVuZFRpbWUsXG4gICAgICAgICAgICAgIHRleHQ6IGdyb3VwVGV4dFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBGdW5jacOzbiBwYXJhIGNyZWFyIGVsIHBheWxvYWQgZGUgdGV4dG8gcGFyYSBzdWJ0w610dWxvc1xuICAgICAgICBjb25zdCBjcmVhdGVTdWJ0aXRsZVBheWxvYWQgPSAodGV4dDogc3RyaW5nLCBzdGFydFRpbWU6IG51bWJlciwgZW5kVGltZTogbnVtYmVyKSA9PiAoe1xuICAgICAgICAgIGlkOiBnZW5lcmF0ZUlkKCksXG4gICAgICAgICAgZGlzcGxheToge1xuICAgICAgICAgICAgZnJvbTogc3RhcnRUaW1lLFxuICAgICAgICAgICAgdG86IGVuZFRpbWUsXG4gICAgICAgICAgfSxcbiAgICAgICAgICB0eXBlOiAndGV4dCcsXG4gICAgICAgICAgZGV0YWlsczoge1xuICAgICAgICAgICAgdGV4dDogdGV4dC50b1VwcGVyQ2FzZSgpLCAvLyBDb252ZXJ0aXIgYSBtYXnDunNjdWxhcyBjb21vIE1yQmVhc3RcbiAgICAgICAgICAgIGZvbnRTaXplOiA4MCwgLy8gVGFtYcOxbyBtw6FzIGdyYW5kZSBwYXJhIGVzdGlsbyBNckJlYXN0XG4gICAgICAgICAgICB3aWR0aDogOTAwLFxuICAgICAgICAgICAgZm9udFVybDogJy9mb250cy9tcmJlYXN0LnR0ZicsIC8vIFVzYXIgbGEgZnVlbnRlIE1yQmVhc3RcbiAgICAgICAgICAgIGZvbnRGYW1pbHk6ICdNckJlYXN0JywgLy8gTm9tYnJlIGRlIGxhIGZ1ZW50ZSBNckJlYXN0XG4gICAgICAgICAgICBjb2xvcjogJyNGRkZGMDAnLCAvLyBBbWFyaWxsbyBicmlsbGFudGVcbiAgICAgICAgICAgIHdvcmRXcmFwOiAnYnJlYWstd29yZCcsXG4gICAgICAgICAgICB0ZXh0QWxpZ246ICdjZW50ZXInLFxuICAgICAgICAgICAgYm9yZGVyV2lkdGg6IDIwLCAvLyBTdHJva2UgbmVncm8gZ3J1ZXNvXG4gICAgICAgICAgICBib3JkZXJDb2xvcjogJyMwMDAwMDAnLFxuICAgICAgICAgICAgYm94U2hhZG93OiB7XG4gICAgICAgICAgICAgIGNvbG9yOiAnIzAwMDAwMCcsXG4gICAgICAgICAgICAgIHg6IDMsXG4gICAgICAgICAgICAgIHk6IDMsXG4gICAgICAgICAgICAgIGJsdXI6IDAsIC8vIFNpbiBkZXNlbmZvcXVlIHBhcmEgdW4gZXN0aWxvIG3DoXMgaW1wYWN0YW50ZVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogJ3RyYW5zcGFyZW50JywgLy8gU2luIGZvbmRvIHBhcmEgcXVlIGRlc3RhcXVlIG3DoXNcbiAgICAgICAgICAgIHBhZGRpbmc6IDEwLFxuICAgICAgICAgICAgYm9yZGVyUmFkaXVzOiAwLCAvLyBTaW4gYm9yZGVzIHJlZG9uZGVhZG9zIHBhcmEgdW4gZXN0aWxvIG3DoXMgaW1wYWN0YW50ZVxuICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIENhcmdhciBlbCBhcmNoaXZvIFNSVFxuICAgICAgICBjb25zb2xlLmxvZyhcIkNhcmdhbmRvIGFyY2hpdm8gU1JULi4uXCIpO1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKCcvdHJhbnNjcmlwdGlvbnMvdHJhbnNjcmlwdGlvbjEuc3J0Jyk7XG4gICAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEVycm9yIGFsIGNhcmdhciBlbCBhcmNoaXZvIFNSVDogJHtyZXNwb25zZS5zdGF0dXN9YCk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBzcnRDb250ZW50ID0gYXdhaXQgcmVzcG9uc2UudGV4dCgpO1xuICAgICAgICBjb25zb2xlLmxvZyhcIkFyY2hpdm8gU1JUIGNhcmdhZG8gY29ycmVjdGFtZW50ZVwiKTtcblxuICAgICAgICAvLyBQYXJzZWFyIGVsIGFyY2hpdm8gU1JUXG4gICAgICAgIGxldCBzZWdtZW50cyA9IHBhcnNlU1JUKHNydENvbnRlbnQpO1xuICAgICAgICBjb25zb2xlLmxvZyhgU2UgZW5jb250cmFyb24gJHtzZWdtZW50cy5sZW5ndGh9IHNlZ21lbnRvcyBkZSBzdWJ0w610dWxvc2ApO1xuXG4gICAgICAgIC8vIFNpZW1wcmUgdXNhciBlbCBtb2RvIGFncnVwYWRvIChkaXZpZGlyIGVuIGdydXBvcyBkZSAzIHBhbGFicmFzKVxuICAgICAgICBzZWdtZW50cyA9IHNlZ21lbnRzLmZsYXRNYXAocHJvY2Vzc1NlZ21lbnQpO1xuICAgICAgICBjb25zb2xlLmxvZyhgRGVzcHXDqXMgZGUgcHJvY2VzYXIsIGhheSAke3NlZ21lbnRzLmxlbmd0aH0gc2VnbWVudG9zIGRlIHN1YnTDrXR1bG9zYCk7XG5cbiAgICAgICAgLy8gRmlsdHJhciBwb3IgdGllbXBvIHNpIGVzIG5lY2VzYXJpb1xuICAgICAgICBpZiAob3B0aW9ucz8uc3RhcnRUaW1lICE9PSB1bmRlZmluZWQgfHwgb3B0aW9ucz8uZW5kVGltZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgY29uc3Qgb3JpZ2luYWxMZW5ndGggPSBzZWdtZW50cy5sZW5ndGg7XG4gICAgICAgICAgc2VnbWVudHMgPSBzZWdtZW50cy5maWx0ZXIoc2VnbWVudCA9PiB7XG4gICAgICAgICAgICBjb25zdCBwYXNzZXNTdGFydEZpbHRlciA9IG9wdGlvbnMuc3RhcnRUaW1lID09PSB1bmRlZmluZWQgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWdtZW50LnN0YXJ0VGltZSA+PSAob3B0aW9ucy5zdGFydFRpbWUgKiAxMDAwKTtcbiAgICAgICAgICAgIGNvbnN0IHBhc3Nlc0VuZEZpbHRlciA9IG9wdGlvbnMuZW5kVGltZSA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlZ21lbnQuZW5kVGltZSA8PSAob3B0aW9ucy5lbmRUaW1lICogMTAwMCk7XG4gICAgICAgICAgICByZXR1cm4gcGFzc2VzU3RhcnRGaWx0ZXIgJiYgcGFzc2VzRW5kRmlsdGVyO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGNvbnNvbGUubG9nKGBGaWx0cmFkbyBwb3IgdGllbXBvOiBkZSAke29yaWdpbmFsTGVuZ3RofSBhICR7c2VnbWVudHMubGVuZ3RofSBzZWdtZW50b3NgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIE5VRVZBIEZVTkNJT05BTElEQUQ6IEVuY29udHJhciB1biB0cmFjayBleGlzdGVudGUgcGFyYSBhw7FhZGlyIHRvZG9zIGxvcyBzdWJ0w610dWxvc1xuICAgICAgICAvLyBPYnRlbmVyIGVsIGVzdGFkbyBhY3R1YWwgcGFyYSBhY2NlZGVyIGEgbG9zIHRyYWNrc1xuICAgICAgICBjb25zdCBzdGF0ZSA9IHN0YXRlTWFuYWdlci5nZXRTdGF0ZSgpO1xuICAgICAgICBsZXQgdGFyZ2V0VHJhY2tJZCA9IG51bGw7XG5cbiAgICAgICAgLy8gU2kgZWwgdXN1YXJpbyBlc3BlY2lmaWPDsyB1biB0cmFja0lkIGVuIGxhcyBvcGNpb25lcywgdXNhcmxvIGRpcmVjdGFtZW50ZVxuICAgICAgICBpZiAob3B0aW9ucz8udHJhY2tJZCkge1xuICAgICAgICAgIHRhcmdldFRyYWNrSWQgPSBvcHRpb25zLnRyYWNrSWQ7XG4gICAgICAgICAgY29uc29sZS5sb2coYFVzYW5kbyB0cmFjayBJRCBlc3BlY2lmaWNhZG8gcG9yIGVsIHVzdWFyaW86ICR7dGFyZ2V0VHJhY2tJZH1gKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBEZSBsbyBjb250cmFyaW8sIGJ1c2NhciB1biB0cmFjayBhZGVjdWFkbyBhdXRvbcOhdGljYW1lbnRlXG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIC8vIEJ1c2NhciB1biB0cmFjayBkZSB0aXBvIFwidGV4dFwiIGV4aXN0ZW50ZVxuICAgICAgICAgIGlmIChzdGF0ZS50cmFja3MgJiYgc3RhdGUudHJhY2tzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGNvbnN0IHRleHRUcmFjayA9IHN0YXRlLnRyYWNrcy5maW5kKHRyYWNrID0+XG4gICAgICAgICAgICAgIHRyYWNrLnR5cGUgPT09ICd0ZXh0JyAmJiB0cmFjay5hY2NlcHRzICYmIHRyYWNrLmFjY2VwdHMuaW5jbHVkZXMoJ3RleHQnKVxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgaWYgKHRleHRUcmFjaykge1xuICAgICAgICAgICAgICB0YXJnZXRUcmFja0lkID0gdGV4dFRyYWNrLmlkO1xuICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgVXNhbmRvIHRyYWNrIGRlIHRleHRvIGV4aXN0ZW50ZSBjb24gSUQ6ICR7dGFyZ2V0VHJhY2tJZH1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBTaSBubyBzZSBlbmNvbnRyw7MgdW4gdHJhY2sgZGUgdGV4dG8sIGJ1c2NhciBjdWFscXVpZXIgdHJhY2sgcXVlIGFjZXB0ZSBcInRleHRcIlxuICAgICAgICAgIGlmICghdGFyZ2V0VHJhY2tJZCAmJiBzdGF0ZS50cmFja3MgJiYgc3RhdGUudHJhY2tzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGNvbnN0IGFueVRyYWNrID0gc3RhdGUudHJhY2tzLmZpbmQodHJhY2sgPT5cbiAgICAgICAgICAgICAgdHJhY2suYWNjZXB0cyAmJiB0cmFjay5hY2NlcHRzLmluY2x1ZGVzKCd0ZXh0JylcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIGlmIChhbnlUcmFjaykge1xuICAgICAgICAgICAgICB0YXJnZXRUcmFja0lkID0gYW55VHJhY2suaWQ7XG4gICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBVc2FuZG8gdHJhY2sgY29tcGF0aWJsZSBjb24gSUQ6ICR7dGFyZ2V0VHJhY2tJZH1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBTaSBhw7puIG5vIHNlIGVuY3VlbnRyYSB1biB0cmFjaywgcG9kcsOtYW1vcyBpbnRlbnRhciBjb24gb3RybyBtw6l0b2RvXG4gICAgICAgICAgaWYgKCF0YXJnZXRUcmFja0lkKSB7XG4gICAgICAgICAgICAvLyBJbnRlbnRhciBvYnRlbmVyIGVsIHByaW1lciB0cmFjayBkaXNwb25pYmxlIGNvbW8gw7psdGltbyByZWN1cnNvXG4gICAgICAgICAgICBpZiAoc3RhdGUudHJhY2tzICYmIHN0YXRlLnRyYWNrcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgIHRhcmdldFRyYWNrSWQgPSBzdGF0ZS50cmFja3NbMF0uaWQ7XG4gICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBVc2FuZG8gcHJpbWVyIHRyYWNrIGRpc3BvbmlibGUgY29tbyBmYWxsYmFjaywgSUQ6ICR7dGFyZ2V0VHJhY2tJZH1gKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiTm8gc2UgZW5jb250csOzIG5pbmfDum4gdHJhY2sgZXhpc3RlbnRlLCBsb3Mgc3VidMOtdHVsb3Mgc2UgYcOxYWRpcsOhbiBlbiB0cmFja3MgaW5kaXZpZHVhbGVzXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEHDsWFkaXIgbG9zIHN1YnTDrXR1bG9zIGNvbiB1biByZXRyYXNvIGVudHJlIGNhZGEgdW5vXG4gICAgICAgIGNvbnNvbGUubG9nKGBBw7FhZGllbmRvICR7c2VnbWVudHMubGVuZ3RofSBzZWdtZW50b3MgZGUgc3VidMOtdHVsb3MgYWwgdGltZWxpbmUuLi5gKTtcbiAgICAgICAgY29uc29sZS5sb2codGFyZ2V0VHJhY2tJZCA/IGBUb2RvcyBsb3Mgc3VidMOtdHVsb3Mgc2UgYcOxYWRpcsOhbiBhbCB0cmFjayBJRDogJHt0YXJnZXRUcmFja0lkfWAgOiBcIkNhZGEgc3VidMOtdHVsbyBjcmVhcsOhIHN1IHByb3BpbyB0cmFja1wiKTtcblxuICAgICAgICBzZWdtZW50cy5mb3JFYWNoKChzZWdtZW50LCBpbmRleCkgPT4ge1xuICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgZGlzcGF0Y2goQUREX1RFWFQsIHtcbiAgICAgICAgICAgICAgcGF5bG9hZDogY3JlYXRlU3VidGl0bGVQYXlsb2FkKHNlZ21lbnQudGV4dCwgc2VnbWVudC5zdGFydFRpbWUsIHNlZ21lbnQuZW5kVGltZSksXG4gICAgICAgICAgICAgIG9wdGlvbnM6IHRhcmdldFRyYWNrSWQgPyB7IHRyYWNrSWQ6IHRhcmdldFRyYWNrSWQgfSA6IHt9LFxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGlmICgoaW5kZXggKyAxKSAlIDEwID09PSAwIHx8IGluZGV4ID09PSBzZWdtZW50cy5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBQcm9ncmVzbzogJHtpbmRleCArIDF9LyR7c2VnbWVudHMubGVuZ3RofSBzdWJ0w610dWxvcyBhw7FhZGlkb3NgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LCBpbmRleCAqIDIwMCk7IC8vIDIwMG1zIGRlIHJldHJhc28gZW50cmUgY2FkYSBzdWJ0w610dWxvXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIGFsIGHDsWFkaXIgc3VidMOtdHVsb3M6XCIsIGVycm9yKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBnZXRBY3RpdmVFbGVtZW50czogYXN5bmMgKCkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gT2J0ZW5lciBlbCBlc3RhZG8gYWN0dWFsXG4gICAgICAgIGNvbnN0IHN0YXRlID0gc3RhdGVNYW5hZ2VyLmdldFN0YXRlKCk7XG5cbiAgICAgICAgLy8gVmVyaWZpY2FyIHNpIGhheSBJRHMgYWN0aXZvc1xuICAgICAgICBpZiAoIXN0YXRlLmFjdGl2ZUlkcyB8fCBzdGF0ZS5hY3RpdmVJZHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgY29uc29sZS5sb2coXCJObyBoYXkgZWxlbWVudG9zIGFjdGl2b3Mgc2VsZWNjaW9uYWRvc1wiKTtcbiAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cblxuICAgICAgICAvLyBWZXJpZmljYXIgc2kgaGF5IGVsZW1lbnRvcyBlbiBlbCB0cmFja0l0ZW1zTWFwXG4gICAgICAgIGlmICghc3RhdGUudHJhY2tJdGVtc01hcCkge1xuICAgICAgICAgIGNvbnNvbGUubG9nKFwiTm8gaGF5IHRyYWNrSXRlbXNNYXAgZGlzcG9uaWJsZVwiKTtcbiAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cblxuICAgICAgICAvLyBPYnRlbmVyIGluZm9ybWFjacOzbiBkZSBsb3MgZWxlbWVudG9zIGFjdGl2b3NcbiAgICAgICAgY29uc3QgYWN0aXZlRWxlbWVudHMgPSBzdGF0ZS5hY3RpdmVJZHNcbiAgICAgICAgICAuZmlsdGVyKGlkID0+IHN0YXRlLnRyYWNrSXRlbXNNYXBbaWRdKVxuICAgICAgICAgIC5tYXAoaWQgPT4ge1xuICAgICAgICAgICAgY29uc3QgaXRlbSA9IHN0YXRlLnRyYWNrSXRlbXNNYXBbaWRdO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICAgIHRyYWNrSWQ6IGl0ZW0udHJhY2tJZCxcbiAgICAgICAgICAgICAgdHlwZTogaXRlbS50eXBlLFxuICAgICAgICAgICAgICBmcm9tOiBpdGVtLmRpc3BsYXk/LmZyb20sXG4gICAgICAgICAgICAgIHRvOiBpdGVtLmRpc3BsYXk/LnRvLFxuICAgICAgICAgICAgICBkdXJhdGlvbjogaXRlbS5kaXNwbGF5ID8gKGl0ZW0uZGlzcGxheS50byAtIGl0ZW0uZGlzcGxheS5mcm9tKSA6IDAsXG4gICAgICAgICAgICAgIGRldGFpbHM6IGl0ZW0uZGV0YWlsc1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9KTtcblxuICAgICAgICBjb25zb2xlLmxvZyhgU2UgZW5jb250cmFyb24gJHthY3RpdmVFbGVtZW50cy5sZW5ndGh9IGVsZW1lbnRvcyBhY3Rpdm9zYCk7XG4gICAgICAgIHJldHVybiBhY3RpdmVFbGVtZW50cztcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBhbCBvYnRlbmVyIGVsZW1lbnRvcyBhY3Rpdm9zOlwiLCBlcnJvcik7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgZ2V0QWxsVGltZWxpbmVFbGVtZW50czogYXN5bmMgKCkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gT2J0ZW5lciBlbCBlc3RhZG8gYWN0dWFsXG4gICAgICAgIGNvbnN0IHN0YXRlID0gc3RhdGVNYW5hZ2VyLmdldFN0YXRlKCk7XG5cbiAgICAgICAgLy8gVmVyaWZpY2FyIHNpIGhheSBlbGVtZW50b3MgZW4gZWwgdHJhY2tJdGVtc01hcFxuICAgICAgICBpZiAoIXN0YXRlLnRyYWNrSXRlbXNNYXAgfHwgT2JqZWN0LmtleXMoc3RhdGUudHJhY2tJdGVtc01hcCkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgY29uc29sZS5sb2coXCJObyBoYXkgZWxlbWVudG9zIGVuIGVsIHRyYWNrSXRlbXNNYXBcIik7XG5cbiAgICAgICAgICAvLyBCdXNjYXIgZWxlbWVudG9zIGVuIG90cmFzIHByb3BpZWRhZGVzIGRlbCBlc3RhZG9cbiAgICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhzdGF0ZSkpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygc3RhdGVba2V5XSA9PT0gJ29iamVjdCcgJiYgc3RhdGVba2V5XSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICBjb25zdCBvYmpWYWx1ZSA9IHN0YXRlW2tleV07XG4gICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBFeHBsb3JhbmRvIHByb3BpZWRhZCBhbHRlcm5hdGl2YTogJHtrZXl9YCk7XG5cbiAgICAgICAgICAgICAgLy8gVmVyaWZpY2FyIHNpIHBhcmVjZSBzZXIgdW4gbWFwYSBkZSBlbGVtZW50b3NcbiAgICAgICAgICAgICAgaWYgKE9iamVjdC5rZXlzKG9ialZhbHVlKS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2FtcGxlID0gb2JqVmFsdWVbT2JqZWN0LmtleXMob2JqVmFsdWUpWzBdXTtcbiAgICAgICAgICAgICAgICBpZiAoc2FtcGxlICYmIHNhbXBsZS5kaXNwbGF5ICYmIHNhbXBsZS50eXBlKSB7XG4gICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgRW5jb250cmFkYSBwb3NpYmxlIGZ1ZW50ZSBhbHRlcm5hdGl2YSBkZSBlbGVtZW50b3MgZW4gcHJvcGllZGFkICR7a2V5fWApO1xuXG4gICAgICAgICAgICAgICAgICAvLyBQcm9jZXNhciBlbGVtZW50b3MgZGUgZXN0YSBwcm9waWVkYWQgYWx0ZXJuYXRpdmFcbiAgICAgICAgICAgICAgICAgIHJldHVybiBPYmplY3QuZW50cmllcyhvYmpWYWx1ZSlcbiAgICAgICAgICAgICAgICAgICAgLmZpbHRlcigoW18sIGl0ZW1dKSA9PiBpdGVtICYmIGl0ZW0uZGlzcGxheSlcbiAgICAgICAgICAgICAgICAgICAgLm1hcCgoW2lkLCBpdGVtXSkgPT4gKHtcbiAgICAgICAgICAgICAgICAgICAgICBpZCxcbiAgICAgICAgICAgICAgICAgICAgICB0cmFja0lkOiBpdGVtLnRyYWNrSWQsXG4gICAgICAgICAgICAgICAgICAgICAgdHlwZTogaXRlbS50eXBlLFxuICAgICAgICAgICAgICAgICAgICAgIGZyb206IGl0ZW0uZGlzcGxheT8uZnJvbSxcbiAgICAgICAgICAgICAgICAgICAgICB0bzogaXRlbS5kaXNwbGF5Py50byxcbiAgICAgICAgICAgICAgICAgICAgICBkdXJhdGlvbjogaXRlbS5kaXNwbGF5ID8gKGl0ZW0uZGlzcGxheS50byAtIGl0ZW0uZGlzcGxheS5mcm9tKSA6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgZGV0YWlsczogaXRlbS5kZXRhaWxzXG4gICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cblxuICAgICAgICAvLyBPYnRlbmVyIHRvZG9zIGxvcyBlbGVtZW50b3NcbiAgICAgICAgY29uc3QgYWxsRWxlbWVudHMgPSBPYmplY3QuZW50cmllcyhzdGF0ZS50cmFja0l0ZW1zTWFwKVxuICAgICAgICAgIC5maWx0ZXIoKFtfLCBpdGVtXSkgPT4gaXRlbSAmJiBpdGVtLmRpc3BsYXkpXG4gICAgICAgICAgLm1hcCgoW2lkLCBpdGVtXSkgPT4gKHtcbiAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgdHJhY2tJZDogaXRlbS50cmFja0lkLFxuICAgICAgICAgICAgdHlwZTogaXRlbS50eXBlLFxuICAgICAgICAgICAgZnJvbTogaXRlbS5kaXNwbGF5Py5mcm9tLFxuICAgICAgICAgICAgdG86IGl0ZW0uZGlzcGxheT8udG8sXG4gICAgICAgICAgICBkdXJhdGlvbjogaXRlbS5kaXNwbGF5ID8gKGl0ZW0uZGlzcGxheS50byAtIGl0ZW0uZGlzcGxheS5mcm9tKSA6IDAsXG4gICAgICAgICAgICBkZXRhaWxzOiBpdGVtLmRldGFpbHNcbiAgICAgICAgICB9KSlcbiAgICAgICAgICAuc29ydCgoYSwgYikgPT4gKGEuZnJvbSB8fCAwKSAtIChiLmZyb20gfHwgMCkpO1xuXG4gICAgICAgIGNvbnNvbGUubG9nKGBTZSBlbmNvbnRyYXJvbiAke2FsbEVsZW1lbnRzLmxlbmd0aH0gZWxlbWVudG9zIGVuIGVsIHRpbWVsaW5lYCk7XG4gICAgICAgIHJldHVybiBhbGxFbGVtZW50cztcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBhbCBvYnRlbmVyIHRvZG9zIGxvcyBlbGVtZW50b3MgZGVsIHRpbWVsaW5lOlwiLCBlcnJvcik7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgcmVtb3ZlU2VnbWVudHM6IGFzeW5jIChzZWdtZW50czogVGltZVNlZ21lbnRbXSkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc29sZS5sb2coXCJJbmljaWFuZG8gZWxpbWluYWNpw7NuIGRlIHNlZ21lbnRvcyBtw7psdGlwbGVzXCIpO1xuXG4gICAgICAgIC8vIE9idGVuZXIgZWwgZXN0YWRvIGFjdHVhbFxuICAgICAgICBjb25zdCBzdGF0ZSA9IHN0YXRlTWFuYWdlci5nZXRTdGF0ZSgpO1xuXG4gICAgICAgIC8vIFZhbGlkYXIgcXVlIGhheWEgZWxlbWVudG9zIGVuIGxhIHRpbWVsaW5lXG4gICAgICAgIGlmICghc3RhdGUuYWN0aXZlSWRzIHx8IHN0YXRlLmFjdGl2ZUlkcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFwiTm8gaGF5IGVsZW1lbnRvcyBzZWxlY2Npb25hZG9zIGVuIGxhIHRpbWVsaW5lXCIpO1xuXG4gICAgICAgICAgLy8gQnVzY2FyIGVsIHByaW1lciBlbGVtZW50byBkaXNwb25pYmxlIGVuIGxhIHRpbWVsaW5lXG4gICAgICAgICAgY29uc3QgdHJhY2tJdGVtc01hcCA9IHN0YXRlLnRyYWNrSXRlbXNNYXAgfHwge307XG4gICAgICAgICAgY29uc3QgdHJhY2tJdGVtcyA9IE9iamVjdC5rZXlzKHRyYWNrSXRlbXNNYXApO1xuXG4gICAgICAgICAgaWYgKHRyYWNrSXRlbXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiTm8gaGF5IGVsZW1lbnRvcyBlbiBsYSB0aW1lbGluZSBwYXJhIGVsaW1pbmFyIHNlZ21lbnRvc1wiKTtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIGhheSBlbGVtZW50b3MgZW4gbGEgdGltZWxpbmVcIik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gU2VsZWNjaW9uYXIgZWwgcHJpbWVyIGVsZW1lbnRvIGRpc3BvbmlibGVcbiAgICAgICAgICBjb25zdCBmaXJzdEl0ZW1JZCA9IHRyYWNrSXRlbXNbMF07XG4gICAgICAgICAgY29uc29sZS5sb2coYFNlbGVjY2lvbmFuZG8gYXV0b23DoXRpY2FtZW50ZSBlbCBlbGVtZW50byBjb24gSUQ6ICR7Zmlyc3RJdGVtSWR9YCk7XG5cbiAgICAgICAgICBkaXNwYXRjaChMQVlFUl9TRUxFQ1QsIHtcbiAgICAgICAgICAgIHBheWxvYWQ6IHtcbiAgICAgICAgICAgICAgaWRzOiBbZmlyc3RJdGVtSWRdXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICAvLyBFc3BlcmFyIGEgcXVlIHNlIGFwbGlxdWUgbGEgc2VsZWNjacOzblxuICAgICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCAzMDApKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEFsbWFjZW5hbW9zIGluZm9ybWFjacOzbiBkZWwgZWxlbWVudG8gc2VsZWNjaW9uYWRvXG4gICAgICAgIGNvbnN0IGN1cnJlbnRTdGF0ZSA9IHN0YXRlTWFuYWdlci5nZXRTdGF0ZSgpO1xuICAgICAgICBpZiAoIWN1cnJlbnRTdGF0ZS5hY3RpdmVJZHMgfHwgY3VycmVudFN0YXRlLmFjdGl2ZUlkcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBzZSBwdWRvIHNlbGVjY2lvbmFyIG5pbmfDum4gZWxlbWVudG8gZW4gbGEgdGltZWxpbmVcIik7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBvcmlnaW5hbEl0ZW1JZCA9IGN1cnJlbnRTdGF0ZS5hY3RpdmVJZHNbMF07XG4gICAgICAgIGNvbnN0IG9yaWdpbmFsSXRlbSA9IGN1cnJlbnRTdGF0ZS50cmFja0l0ZW1zTWFwW29yaWdpbmFsSXRlbUlkXTtcbiAgICAgICAgY29uc3QgdHJhY2tUeXBlID0gb3JpZ2luYWxJdGVtLnR5cGU7XG4gICAgICAgIGNvbnN0IHRyYWNrSWQgPSBvcmlnaW5hbEl0ZW0udHJhY2tJZDtcblxuICAgICAgICBjb25zb2xlLmxvZyhgRWxlbWVudG8gc2VsZWNjaW9uYWRvOiBJRD0ke29yaWdpbmFsSXRlbUlkfSwgdGlwbz0ke3RyYWNrVHlwZX0sIHRyYWNrSWQ9JHt0cmFja0lkfWApO1xuXG4gICAgICAgIC8vIFByb2Nlc2FyIGNhZGEgc2VnbWVudG8gZW4gb3JkZW4gKGRlIGZpbmFsIGEgcHJpbmNpcGlvIHBhcmEgZXZpdGFyIGFmZWN0YXIgcG9zaWNpb25lcylcbiAgICAgICAgZm9yIChsZXQgaSA9IHNlZ21lbnRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgY29uc3Qgc2VnbWVudCA9IHNlZ21lbnRzW2ldO1xuICAgICAgICAgIGNvbnNvbGUubG9nKGBQcm9jZXNhbmRvIHNlZ21lbnRvICR7aSsxfS8ke3NlZ21lbnRzLmxlbmd0aH06ICR7c2VnbWVudC5zdGFydFRpbWV9cyAtICR7c2VnbWVudC5lbmRUaW1lfXNgKTtcblxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBQQVNPIDE6IEhhY2VyIHVuIGNvcnRlIGVuIGVsIHRpZW1wbyBmaW5hbFxuICAgICAgICAgICAgY29uc3QgZW5kTXMgPSBzZWdtZW50LmVuZFRpbWUgKiAxMDAwO1xuICAgICAgICAgICAgZGlzcGF0Y2goQUNUSVZFX1NQTElULCB7XG4gICAgICAgICAgICAgIHBheWxvYWQ6IHt9LFxuICAgICAgICAgICAgICBvcHRpb25zOiB7XG4gICAgICAgICAgICAgICAgdGltZTogZW5kTXMsXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGBQYXNvIDE6IENvcnRlIGFwbGljYWRvIGVuIHRpZW1wbyBmaW5hbCAke3NlZ21lbnQuZW5kVGltZX1zYCk7XG5cbiAgICAgICAgICAgIC8vIEVzcGVyYXIgYSBxdWUgc2UgcHJvY2VzZSBlbCBwcmltZXIgY29ydGVcbiAgICAgICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCA1MDApKTtcblxuICAgICAgICAgICAgLy8gT2J0ZW5lbW9zIGVsIGVzdGFkbyBkZXNwdcOpcyBkZWwgcHJpbWVyIGNvcnRlXG4gICAgICAgICAgICBjb25zdCBzdGF0ZUFmdGVyRmlyc3RDdXQgPSBzdGF0ZU1hbmFnZXIuZ2V0U3RhdGUoKTtcbiAgICAgICAgICAgIGNvbnN0IGVsZW1lbnRzQWZ0ZXJGaXJzdEN1dCA9IE9iamVjdC5lbnRyaWVzKHN0YXRlQWZ0ZXJGaXJzdEN1dC50cmFja0l0ZW1zTWFwKVxuICAgICAgICAgICAgICAuZmlsdGVyKChbXywgaXRlbV0pID0+XG4gICAgICAgICAgICAgICAgaXRlbS50eXBlID09PSB0cmFja1R5cGUgJiZcbiAgICAgICAgICAgICAgICBpdGVtLnRyYWNrSWQgPT09IHRyYWNrSWQgJiZcbiAgICAgICAgICAgICAgICBpdGVtLmRpc3BsYXkgJiZcbiAgICAgICAgICAgICAgICAhaXNOYU4oaXRlbS5kaXNwbGF5LmZyb20pICYmXG4gICAgICAgICAgICAgICAgIWlzTmFOKGl0ZW0uZGlzcGxheS50bylcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAubWFwKChbaWQsIGl0ZW1dKSA9PiAoe1xuICAgICAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgICAgIGZyb206IGl0ZW0uZGlzcGxheS5mcm9tLFxuICAgICAgICAgICAgICAgIHRvOiBpdGVtLmRpc3BsYXkudG8sXG4gICAgICAgICAgICAgICAgZHVyYWNpw7NuOiBpdGVtLmRpc3BsYXkudG8gLSBpdGVtLmRpc3BsYXkuZnJvbVxuICAgICAgICAgICAgICB9KSlcbiAgICAgICAgICAgICAgLnNvcnQoKGEsIGIpID0+IGEuZnJvbSAtIGIuZnJvbSk7XG5cbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiRWxlbWVudG9zIGRlc3B1w6lzIGRlbCBwcmltZXIgY29ydGU6XCIsIGVsZW1lbnRzQWZ0ZXJGaXJzdEN1dCk7XG5cbiAgICAgICAgICAgIC8vIFBBU08gMjogSWRlbnRpZmljYXIgZWwgZWxlbWVudG8gaXpxdWllcmRvIHF1ZSBjb250aWVuZSBlbCB0aWVtcG8gaW5pY2lhbFxuICAgICAgICAgICAgY29uc3Qgc3RhcnRNcyA9IHNlZ21lbnQuc3RhcnRUaW1lICogMTAwMDtcbiAgICAgICAgICAgIGNvbnN0IGxlZnRFbGVtZW50ID0gZWxlbWVudHNBZnRlckZpcnN0Q3V0LmZpbmQoZWxlbSA9PlxuICAgICAgICAgICAgICBlbGVtLmZyb20gPD0gc3RhcnRNcyAmJiBlbGVtLnRvID49IHN0YXJ0TXNcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIGlmICghbGVmdEVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihgTm8gc2UgcHVkbyBpZGVudGlmaWNhciBlbCBlbGVtZW50byBpenF1aWVyZG8gcGFyYSBlbCBzZWdtZW50byAke2krMX1gKTtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGBQYXNvIDI6IEVsZW1lbnRvIGl6cXVpZXJkbyBpZGVudGlmaWNhZG8gKElEOiAke2xlZnRFbGVtZW50LmlkfSlgKTtcblxuICAgICAgICAgICAgLy8gUEFTTyAzOiBTZWxlY2Npb25hciBlbCBlbGVtZW50byBpenF1aWVyZG8geSBoYWNlciBjb3J0ZSBlbiB0aWVtcG8gaW5pY2lhbFxuICAgICAgICAgICAgZGlzcGF0Y2goTEFZRVJfU0VMRUNULCB7XG4gICAgICAgICAgICAgIHBheWxvYWQ6IHtcbiAgICAgICAgICAgICAgICBpZHM6IFtsZWZ0RWxlbWVudC5pZF1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vIEVzcGVyYXIgYSBxdWUgc2UgYXBsaXF1ZSBsYSBzZWxlY2Npw7NuXG4gICAgICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgMzAwKSk7XG5cbiAgICAgICAgICAgIC8vIEFwbGljYXIgZWwgY29ydGUgZW4gZWwgdGllbXBvIGluaWNpYWxcbiAgICAgICAgICAgIGRpc3BhdGNoKEFDVElWRV9TUExJVCwge1xuICAgICAgICAgICAgICBwYXlsb2FkOiB7fSxcbiAgICAgICAgICAgICAgb3B0aW9uczoge1xuICAgICAgICAgICAgICAgIHRpbWU6IHN0YXJ0TXMsXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGBQYXNvIDM6IFNlZ3VuZG8gY29ydGUgYXBsaWNhZG8gZW4gdGllbXBvIGluaWNpYWwgJHtzZWdtZW50LnN0YXJ0VGltZX1zYCk7XG5cbiAgICAgICAgICAgIC8vIEVzcGVyYXIgYSBxdWUgc2UgcHJvY2VzZSBlbCBzZWd1bmRvIGNvcnRlXG4gICAgICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgNTAwKSk7XG5cbiAgICAgICAgICAgIC8vIE9idGVuZW1vcyBlbCBlc3RhZG8gZGVzcHXDqXMgZGVsIHNlZ3VuZG8gY29ydGVcbiAgICAgICAgICAgIGNvbnN0IHN0YXRlQWZ0ZXJTZWNvbmRDdXQgPSBzdGF0ZU1hbmFnZXIuZ2V0U3RhdGUoKTtcbiAgICAgICAgICAgIGNvbnN0IGVsZW1lbnRzQWZ0ZXJTZWNvbmRDdXQgPSBPYmplY3QuZW50cmllcyhzdGF0ZUFmdGVyU2Vjb25kQ3V0LnRyYWNrSXRlbXNNYXApXG4gICAgICAgICAgICAgIC5maWx0ZXIoKFtfLCBpdGVtXSkgPT5cbiAgICAgICAgICAgICAgICBpdGVtLnR5cGUgPT09IHRyYWNrVHlwZSAmJlxuICAgICAgICAgICAgICAgIGl0ZW0udHJhY2tJZCA9PT0gdHJhY2tJZCAmJlxuICAgICAgICAgICAgICAgIGl0ZW0uZGlzcGxheSAmJlxuICAgICAgICAgICAgICAgICFpc05hTihpdGVtLmRpc3BsYXkuZnJvbSkgJiZcbiAgICAgICAgICAgICAgICAhaXNOYU4oaXRlbS5kaXNwbGF5LnRvKVxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgIC5tYXAoKFtpZCwgaXRlbV0pID0+ICh7XG4gICAgICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICAgICAgZnJvbTogaXRlbS5kaXNwbGF5LmZyb20sXG4gICAgICAgICAgICAgICAgdG86IGl0ZW0uZGlzcGxheS50byxcbiAgICAgICAgICAgICAgICBkdXJhY2nDs246IGl0ZW0uZGlzcGxheS50byAtIGl0ZW0uZGlzcGxheS5mcm9tXG4gICAgICAgICAgICAgIH0pKVxuICAgICAgICAgICAgICAuc29ydCgoYSwgYikgPT4gYS5mcm9tIC0gYi5mcm9tKTtcblxuICAgICAgICAgICAgY29uc29sZS5sb2coXCJFbGVtZW50b3MgZGVzcHXDqXMgZGVsIHNlZ3VuZG8gY29ydGU6XCIsIGVsZW1lbnRzQWZ0ZXJTZWNvbmRDdXQpO1xuXG4gICAgICAgICAgICAvLyBQQVNPIDQ6IElkZW50aWZpY2FyIGVsIGVsZW1lbnRvIGRlbCBtZWRpbyB1c2FuZG8gY3JpdGVyaW9zIG3DoXMgcHJlY2lzb3NcbiAgICAgICAgICAgIGNvbnN0IG1pZGRsZUVsZW1lbnRzID0gZWxlbWVudHNBZnRlclNlY29uZEN1dC5maWx0ZXIoZWxlbSA9PlxuICAgICAgICAgICAgICBNYXRoLmFicyhlbGVtLmZyb20gLSBzdGFydE1zKSA8IDUwICYmIE1hdGguYWJzKGVsZW0udG8gLSBlbmRNcykgPCA1MFxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgY29uc29sZS5sb2coXCJFbGVtZW50b3MgcXVlIGNvaW5jaWRlbiBjb24gbG9zIGNyaXRlcmlvcyBkZWwgbWVkaW86XCIsIG1pZGRsZUVsZW1lbnRzKTtcblxuICAgICAgICAgICAgaWYgKG1pZGRsZUVsZW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGBObyBzZSBwdWRvIGlkZW50aWZpY2FyIGVsIGVsZW1lbnRvIGRlbCBtZWRpbyBwYXJhIGVsIHNlZ21lbnRvICR7aSsxfWApO1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gU2kgaGF5IG3DoXMgZGUgdW4gZWxlbWVudG8gcXVlIGNvaW5jaWRlLCB0b21hbW9zIGVsIHByaW1lcm9cbiAgICAgICAgICAgIGNvbnN0IG1pZGRsZUVsZW1lbnQgPSBtaWRkbGVFbGVtZW50c1swXTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGBQYXNvIDQ6IEVsZW1lbnRvIGRlbCBtZWRpbyBpZGVudGlmaWNhZG8gKElEOiAke21pZGRsZUVsZW1lbnQuaWR9KWApO1xuXG4gICAgICAgICAgICAvLyBQQVNPIDU6IFNlbGVjY2lvbmFyIHkgZWxpbWluYXIgZWwgZWxlbWVudG8gZGVsIG1lZGlvXG4gICAgICAgICAgICBkaXNwYXRjaChMQVlFUl9TRUxFQ1QsIHtcbiAgICAgICAgICAgICAgcGF5bG9hZDoge1xuICAgICAgICAgICAgICAgIGlkczogW21pZGRsZUVsZW1lbnQuaWRdXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvLyBFc3BlcmFyIGEgcXVlIHNlIGFwbGlxdWUgbGEgc2VsZWNjacOzblxuICAgICAgICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDMwMCkpO1xuXG4gICAgICAgICAgICAvLyBWZXJpZmljYXIgcXVlIGVsIGVsZW1lbnRvIGVzdMOhIHNlbGVjY2lvbmFkbyBhbnRlcyBkZSBlbGltaW5hcmxvXG4gICAgICAgICAgICBjb25zdCBjdXJyZW50U3RhdGUgPSBzdGF0ZU1hbmFnZXIuZ2V0U3RhdGUoKTtcbiAgICAgICAgICAgIGlmIChjdXJyZW50U3RhdGUuYWN0aXZlSWRzICYmIGN1cnJlbnRTdGF0ZS5hY3RpdmVJZHMuaW5jbHVkZXMobWlkZGxlRWxlbWVudC5pZCkpIHtcbiAgICAgICAgICAgICAgY29uc29sZS5sb2coYEVsZW1lbnRvIGRlbCBtZWRpbyBjb3JyZWN0YW1lbnRlIHNlbGVjY2lvbmFkbywgcHJvY2VkaWVuZG8gY29uIGVsaW1pbmFjacOzbmApO1xuICAgICAgICAgICAgICBkaXNwYXRjaChMQVlFUl9ERUxFVEUpO1xuICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgRWxlbWVudG8gZWxpbWluYWRvIGNvcnJlY3RhbWVudGU6ICR7bWlkZGxlRWxlbWVudC5pZH1gKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBObyBzZSBwdWRvIHNlbGVjY2lvbmFyIG5vcm1hbG1lbnRlLCBpbnRlbnRhbmRvIG3DqXRvZG8gYWx0ZXJuYXRpdm9gKTtcblxuICAgICAgICAgICAgICAvLyBFbmZvcXVlIGFsdGVybmF0aXZvOiBVc2FyIGVsIEVESVRfT0JKRUNUIHBhcmEgXCJvY3VsdGFyXCIgZWwgc2VnbWVudG9cbiAgICAgICAgICAgICAgZGlzcGF0Y2goRURJVF9PQkpFQ1QsIHtcbiAgICAgICAgICAgICAgICBwYXlsb2FkOiB7XG4gICAgICAgICAgICAgICAgICBbbWlkZGxlRWxlbWVudC5pZF06IHtcbiAgICAgICAgICAgICAgICAgICAgZGlzcGxheToge1xuICAgICAgICAgICAgICAgICAgICAgIGZyb206IC05OTk5OSwgLy8gVW4gdmFsb3IgZnVlcmEgZGVsIHJhbmdvIHZpc2libGVcbiAgICAgICAgICAgICAgICAgICAgICB0bzogLTk5OTkwXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHZpc2libGU6IGZhbHNlIC8vIEFkaWNpb25hbG1lbnRlIG1hcmNhcmxvIGNvbW8gbm8gdmlzaWJsZVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBBcGxpY2FkbyBtw6l0b2RvIGFsdGVybmF0aXZvIHBhcmEgb2N1bHRhciBlbCBzZWdtZW50b2ApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBFc3BlcmFyIGEgcXVlIHNlIHByb2Nlc2UgbGEgZWxpbWluYWNpw7NuXG4gICAgICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgNTAwKSk7XG5cbiAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihgRXJyb3IgYWwgcHJvY2VzYXIgZWwgc2VnbWVudG8gJHtpKzF9OmAsIGVycm9yKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBQYXVzYSBlbnRyZSBzZWdtZW50b3NcbiAgICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgNTAwKSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBBY3R1YWxpemFyIGxhIGVzY2FsYSBwYXJhIHJlZnJlc2NhciBsYSB2aXN0YVxuICAgICAgICBjb25zdCB7IHNjYWxlIH0gPSBzdGF0ZU1hbmFnZXIuZ2V0U3RhdGUoKTtcbiAgICAgICAgaWYgKHNjYWxlKSB7XG4gICAgICAgICAgY29uc29sZS5sb2coXCJBY3R1YWxpemFuZG8gZXNjYWxhIHBhcmEgcmVmcmVzY2FyIGxhIHZpc3RhXCIpO1xuXG4gICAgICAgICAgLy8gR3VhcmRhciBlbCB2YWxvciBhY3R1YWwgZGUgc2NhbGUudW5pdFxuICAgICAgICAgIGNvbnN0IG9yaWdpbmFsVW5pdCA9IHNjYWxlLnVuaXQ7XG5cbiAgICAgICAgICAvLyBJbmNyZW1lbnRhciBlbCB2YWxvclxuICAgICAgICAgIHNjYWxlLnVuaXQgKz0gMTtcbiAgICAgICAgICBjb25zb2xlLmxvZyhgU2NhbGUgY2FtYmlhZGE6ICR7b3JpZ2luYWxVbml0fSAtPiAke3NjYWxlLnVuaXR9YCk7XG5cbiAgICAgICAgICAvLyBBc2VndXJhciBxdWUgZWwgY2FtYmlvIHNlYSBub3RhZG8gcG9yIGVsIHNpc3RlbWFcbiAgICAgICAgICBkaXNwYXRjaChUSU1FTElORV9TQ0FMRV9DSEFOR0VELCB7XG4gICAgICAgICAgICBwYXlsb2FkOiB7XG4gICAgICAgICAgICAgIHNjYWxlOiB7XG4gICAgICAgICAgICAgICAgLi4uc2NhbGUsICAvLyBJbmNsdWlyIHRvZGFzIGxhcyBwcm9waWVkYWRlcyBkZSBzY2FsZVxuICAgICAgICAgICAgICAgIHVuaXQ6IHNjYWxlLnVuaXQgIC8vIEV4cGzDrWNpdGFtZW50ZSBlc3RhYmxlY2VyIGVsIG51ZXZvIHZhbG9yXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgLy8gRm9yemFyIHVuYSBhY3R1YWxpemFjacOzbiBhZGljaW9uYWwgdm9sdmllbmRvIGFsIHZhbG9yIG9yaWdpbmFsIGRlc3B1w6lzIGRlIHVuIG1vbWVudG9cbiAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRTdGF0ZSA9IHN0YXRlTWFuYWdlci5nZXRTdGF0ZSgpO1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRTdGF0ZS5zY2FsZSkge1xuICAgICAgICAgICAgICBkaXNwYXRjaChUSU1FTElORV9TQ0FMRV9DSEFOR0VELCB7XG4gICAgICAgICAgICAgICAgcGF5bG9hZDoge1xuICAgICAgICAgICAgICAgICAgc2NhbGU6IHtcbiAgICAgICAgICAgICAgICAgICAgLi4uY3VycmVudFN0YXRlLnNjYWxlLFxuICAgICAgICAgICAgICAgICAgICB1bml0OiBvcmlnaW5hbFVuaXQgIC8vIFZvbHZlciBhbCB2YWxvciBvcmlnaW5hbFxuICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgUmVzdGF1cmFkbyBzY2FsZSBhIHZhbG9yIG9yaWdpbmFsOiAke29yaWdpbmFsVW5pdH1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LCAzMDApO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc29sZS5sb2coXCJFbGltaW5hY2nDs24gZGUgc2VnbWVudG9zIGNvbXBsZXRhZGFcIik7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIGFsIGVsaW1pbmFyIHNlZ21lbnRvczpcIiwgZXJyb3IpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfSxcblxuICAgIGNvbXBhY3RUaW1lbGluZTogYXN5bmMgKCkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc29sZS5sb2coXCI9PT0gSU5JQ0lBTkRPIENPTVBBQ1RBQ0nDk04gREUgTMONTkVBIERFIFRJRU1QTyBERVNERSBJQSA9PT1cIik7XG5cbiAgICAgICAgLy8gT2J0ZW5lciBlbCBlc3RhZG8gYWN0dWFsXG4gICAgICAgIGNvbnN0IGVzdGFkbyA9IHN0YXRlTWFuYWdlci5nZXRTdGF0ZSgpO1xuICAgICAgICBjb25zb2xlLmxvZyhcIkVzdGFkbyBwYXJhIGNvbXBhY3RhY2nDs246XCIsIE9iamVjdC5rZXlzKGVzdGFkbykpO1xuXG4gICAgICAgIC8vIEHDsWFkaXIgdW4gdGllbXBvIGRlIGVzcGVyYSBpbmljaWFsIHBhcmEgYXNlZ3VyYXIgcXVlIGVsIGVzdGFkbyBlc3TDoSBhY3R1YWxpemFkb1xuICAgICAgICBjb25zb2xlLmxvZyhcIkVzcGVyYW5kbyAxIHNlZ3VuZG8gcGFyYSBhc2VndXJhciBjb25zaXN0ZW5jaWEgZGVsIGVzdGFkby4uLlwiKTtcbiAgICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDEwMDApKTtcblxuICAgICAgICAvLyBWZXJpZmljYWNpw7NuIGFkaWNpb25hbCBwYXJhIGFzZWd1cmFybm9zIHF1ZSBsb3MgY2FtYmlvcyBlbiBsYSB0aW1lbGluZSB5YSBzZSBhcGxpY2Fyb25cbiAgICAgICAgY29uc29sZS5sb2coXCJWZXJpZmljYW5kbyBxdWUgbG9zIGVsZW1lbnRvcyBlbiBsYSB0aW1lbGluZSByZWZsZWplbiBsb3MgY2FtYmlvcyBtw6FzIHJlY2llbnRlcy4uLlwiKTtcblxuICAgICAgICAvLyBQZXF1ZcOxYSBwYXVzYSBhZGljaW9uYWwgcGFyYSBhc2VndXJhciBjb25zaXN0ZW5jaWEgZGVsIGVzdGFkb1xuICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgNTAwKSk7XG5cbiAgICAgICAgLy8gQnVzY2FyIGxvcyBlbGVtZW50b3MgZGVsIHRpbWVsaW5lIC0gdXNhbmRvIGxhIHJlZmVyZW5jaWEgYWwgbcOpdG9kbyBkZW50cm8gZGVsIG1pc21vIG9iamV0b1xuICAgICAgICBjb25zdCB0b2Rvc0VsZW1lbnRvcyA9IGF3YWl0IGV4ZWN1dG9yLmdldEFsbFRpbWVsaW5lRWxlbWVudHMoKTtcbiAgICAgICAgY29uc29sZS5sb2coYEVuY29udHJhZG9zICR7dG9kb3NFbGVtZW50b3MubGVuZ3RofSBlbGVtZW50b3MgZW4gbGEgdGltZWxpbmVgKTtcblxuICAgICAgICAvLyBMb2dnaW5nIGRlIGVsZW1lbnRvcyBwYXJhIGRpYWduw7NzdGljb1xuICAgICAgICB0b2Rvc0VsZW1lbnRvcy5mb3JFYWNoKChlbGVtLCBpbmRleCkgPT4ge1xuICAgICAgICAgIGNvbnNvbGUubG9nKGBFbGVtZW50byAke2luZGV4ICsgMX06IElEPSR7ZWxlbS5pZH0sIFRpcG89JHtlbGVtLnR5cGV9LCBUcmFjaz0ke2VsZW0udHJhY2tJZH0sIFRpZW1wbz0ke2VsZW0uZnJvbX1tcy0ke2VsZW0udG99bXMgKGR1cmFjacOzbj0ke2VsZW0udG8tZWxlbS5mcm9tfW1zKWApO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBTaSBubyBoYXkgZWxlbWVudG9zLCBubyBwb2RlbW9zIGNvbXBhY3RhclxuICAgICAgICBpZiAodG9kb3NFbGVtZW50b3MubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgY29uc29sZS5sb2coXCJObyBoYXkgZWxlbWVudG9zIGVuIGVsIHRpbWVsaW5lIHBhcmEgY29tcGFjdGFyXCIpO1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEFncnVwYXIgZWxlbWVudG9zIHBvciB0cmFjayBwYXJhIGFuw6FsaXNpc1xuICAgICAgICBjb25zdCBlbGVtZW50b3NQb3JUcmFjayA9IHt9O1xuICAgICAgICB0b2Rvc0VsZW1lbnRvcy5mb3JFYWNoKGVsZW0gPT4ge1xuICAgICAgICAgIGlmIChlbGVtLnRyYWNrSWQpIHtcbiAgICAgICAgICAgIGlmICghZWxlbWVudG9zUG9yVHJhY2tbZWxlbS50cmFja0lkXSkge1xuICAgICAgICAgICAgICBlbGVtZW50b3NQb3JUcmFja1tlbGVtLnRyYWNrSWRdID0gW107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbGVtZW50b3NQb3JUcmFja1tlbGVtLnRyYWNrSWRdLnB1c2goZWxlbSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICAvLyBPcmRlbmFyIGVsZW1lbnRvcyBlbiBjYWRhIHRyYWNrIHBvciB0aWVtcG9cbiAgICAgICAgT2JqZWN0LmtleXMoZWxlbWVudG9zUG9yVHJhY2spLmZvckVhY2godHJhY2tJZCA9PiB7XG4gICAgICAgICAgZWxlbWVudG9zUG9yVHJhY2tbdHJhY2tJZF0uc29ydCgoYSwgYikgPT4gYS5mcm9tIC0gYi5mcm9tKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgY29uc29sZS5sb2coXCJFbGVtZW50b3MgYWdydXBhZG9zIHBvciB0cmFjazpcIiwgT2JqZWN0LmtleXMoZWxlbWVudG9zUG9yVHJhY2spLmxlbmd0aCk7XG5cbiAgICAgICAgLy8gTG9nZ2luZyBkZSB0cmFja3MgcGFyYSBkaWFnbsOzc3RpY29cbiAgICAgICAgT2JqZWN0LmtleXMoZWxlbWVudG9zUG9yVHJhY2spLmZvckVhY2godHJhY2tJZCA9PiB7XG4gICAgICAgICAgY29uc29sZS5sb2coYFRyYWNrICR7dHJhY2tJZH06ICR7ZWxlbWVudG9zUG9yVHJhY2tbdHJhY2tJZF0ubGVuZ3RofSBlbGVtZW50b3NgKTtcbiAgICAgICAgICAvLyBNb3N0cmFyIGxvcyBlbGVtZW50b3MgZW4gZXN0ZSB0cmFjayBvcmRlbmFkb3NcbiAgICAgICAgICBlbGVtZW50b3NQb3JUcmFja1t0cmFja0lkXS5mb3JFYWNoKChlbGVtLCBpZHgpID0+IHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGAgICR7aWR4KzF9LiBJRD0ke2VsZW0uaWQuc3Vic3RyaW5nKDAsOCl9Li4uIFRpZW1wbz0ke2VsZW0uZnJvbX1tcy0ke2VsZW0udG99bXMgKGR1cmFjacOzbjogJHtlbGVtLnRvLWVsZW0uZnJvbX1tcylgKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gQnVzY2FyIGVzcGFjaW9zIHZhY8Otb3MgZW4gY2FkYSB0cmFja1xuICAgICAgICBjb25zdCBlc3BhY2lvc1ZhY2lvcyA9IFtdO1xuXG4gICAgICAgIE9iamVjdC5rZXlzKGVsZW1lbnRvc1BvclRyYWNrKS5mb3JFYWNoKHRyYWNrSWQgPT4ge1xuICAgICAgICAgIGNvbnN0IGVsZW1lbnRvcyA9IGVsZW1lbnRvc1BvclRyYWNrW3RyYWNrSWRdO1xuXG4gICAgICAgICAgLy8gU2kgaGF5IGFsIG1lbm9zIDIgZWxlbWVudG9zLCBwb2RlbW9zIGJ1c2NhciBlc3BhY2lvc1xuICAgICAgICAgIGlmIChlbGVtZW50b3MubGVuZ3RoID49IDIpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZWxlbWVudG9zLmxlbmd0aCAtIDE7IGkrKykge1xuICAgICAgICAgICAgICBjb25zdCBlbGVtZW50b0FjdHVhbCA9IGVsZW1lbnRvc1tpXTtcbiAgICAgICAgICAgICAgY29uc3QgZWxlbWVudG9TaWd1aWVudGUgPSBlbGVtZW50b3NbaSArIDFdO1xuXG4gICAgICAgICAgICAgIC8vIFZlcmlmaWNhciBzaSBoYXkgdW4gZXNwYWNpbyBlbnRyZSBlbCBmaW4gZGVsIGVsZW1lbnRvIGFjdHVhbCB5IGVsIGluaWNpbyBkZWwgc2lndWllbnRlXG4gICAgICAgICAgICAgIGNvbnN0IGVzcGFjaW8gPSBlbGVtZW50b1NpZ3VpZW50ZS5mcm9tIC0gZWxlbWVudG9BY3R1YWwudG87XG5cbiAgICAgICAgICAgICAgLy8gU2kgZWwgZXNwYWNpbyBlcyBzaWduaWZpY2F0aXZvIChtw6FzIGRlIDEwMG1zKVxuICAgICAgICAgICAgICBpZiAoZXNwYWNpbyA+IDEwMCkge1xuICAgICAgICAgICAgICAgIGVzcGFjaW9zVmFjaW9zLnB1c2goe1xuICAgICAgICAgICAgICAgICAgdHJhY2tJZCxcbiAgICAgICAgICAgICAgICAgIHN0YXJ0OiBlbGVtZW50b0FjdHVhbC50byxcbiAgICAgICAgICAgICAgICAgIGVuZDogZWxlbWVudG9TaWd1aWVudGUuZnJvbSxcbiAgICAgICAgICAgICAgICAgIHNpemU6IGVzcGFjaW8sXG4gICAgICAgICAgICAgICAgICBlbGVtZW50b0FudGVzOiBlbGVtZW50b0FjdHVhbC5pZCxcbiAgICAgICAgICAgICAgICAgIGVsZW1lbnRvRGVzcHVlczogZWxlbWVudG9TaWd1aWVudGUuaWRcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgRW5jb250cmFkbyBlc3BhY2lvIGRlICR7ZXNwYWNpb31tcyAoJHtlc3BhY2lvLzEwMDB9cykgZW4gdHJhY2sgJHt0cmFja0lkfSBlbnRyZSBlbGVtZW50b3MgJHtlbGVtZW50b0FjdHVhbC5pZC5zdWJzdHJpbmcoMCw4KX0uLi4geSAke2VsZW1lbnRvU2lndWllbnRlLmlkLnN1YnN0cmluZygwLDgpfS4uLmApO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBjb25zb2xlLmxvZyhgU2UgZW5jb250cmFyb24gJHtlc3BhY2lvc1ZhY2lvcy5sZW5ndGh9IGVzcGFjaW9zIHZhY8Otb3NgKTtcblxuICAgICAgICAvLyBTaSBubyBoYXkgZXNwYWNpb3MsIG5vIG5lY2VzaXRhbW9zIGNvbXBhY3RhclxuICAgICAgICBpZiAoZXNwYWNpb3NWYWNpb3MubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgY29uc29sZS5sb2coXCJObyBoYXkgZXNwYWNpb3Mgc2lnbmlmaWNhdGl2b3MgcGFyYSBjb21wYWN0YXJcIik7XG4gICAgICAgICAgcmV0dXJuIHRydWU7IC8vIERldm9sdmVtb3MgdHJ1ZSBwb3JxdWUgdMOpY25pY2FtZW50ZSBlc3TDoSBjb21wYWN0YWRvXG4gICAgICAgIH1cblxuICAgICAgICAvLyBPcmRlbmFyIGVzcGFjaW9zIHBvciBwb3NpY2nDs24gKGRlIGl6cXVpZXJkYSBhIGRlcmVjaGEpXG4gICAgICAgIGVzcGFjaW9zVmFjaW9zLnNvcnQoKGEsIGIpID0+IGEuc3RhcnQgLSBiLnN0YXJ0KTtcblxuICAgICAgICAvLyBDYWxjdWxhciBlbCBlc3BhY2lvIHRvdGFsIGEgY29tcGFjdGFyXG4gICAgICAgIGxldCBlc3BhY2lvVG90YWwgPSAwO1xuICAgICAgICBlc3BhY2lvc1ZhY2lvcy5mb3JFYWNoKGVzcGFjaW8gPT4ge1xuICAgICAgICAgIGVzcGFjaW9Ub3RhbCArPSBlc3BhY2lvLnNpemU7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNvbnNvbGUubG9nKGBFc3BhY2lvIHRvdGFsIGEgY29tcGFjdGFyOiAke2VzcGFjaW9Ub3RhbH1tcyAoJHtlc3BhY2lvVG90YWwvMTAwMH1zKWApO1xuICAgICAgICBjb25zb2xlLmxvZyhgUHJlcGFyYW5kbyBhY3R1YWxpemFjaW9uZXMgcGFyYSAke3RvZG9zRWxlbWVudG9zLmxlbmd0aH0gZWxlbWVudG9zLi4uYCk7XG5cbiAgICAgICAgLy8gUHJlcGFyYXIgYWN0dWFsaXphY2lvbmVzIHBhcmEgY2FkYSBlbGVtZW50b1xuICAgICAgICBjb25zdCBhY3R1YWxpemFjaW9uZXMgPSB7fTtcbiAgICAgICAgbGV0IGVsZW1lbnRvc0FNb3ZlciA9IDA7XG5cbiAgICAgICAgLy8gUGFyYSBjYWRhIGVsZW1lbnRvLCBjYWxjdWxhbW9zIGVsIGRlc3BsYXphbWllbnRvIGJhc2FkbyBlbiBsb3MgZXNwYWNpb3MgYW50ZXJpb3Jlc1xuICAgICAgICB0b2Rvc0VsZW1lbnRvcy5mb3JFYWNoKGVsZW1lbnRvID0+IHtcbiAgICAgICAgICBsZXQgZGVzcGxhemFtaWVudG8gPSAwO1xuXG4gICAgICAgICAgLy8gQ2FsY3VsYXIgY3XDoW50byBkZWJlIG1vdmVyc2UgYmFzYWRvIGVuIGxvcyBlc3BhY2lvcyB2YWPDrW9zIGFudGVyaW9yZXNcbiAgICAgICAgICBmb3IgKGNvbnN0IGVzcGFjaW8gb2YgZXNwYWNpb3NWYWNpb3MpIHtcbiAgICAgICAgICAgIC8vIFNpIGVsIGVsZW1lbnRvIGVzdMOhIGRlc3B1w6lzIGRlbCBlc3BhY2lvIHZhY8OtbywgZGViZSBtb3ZlcnNlXG4gICAgICAgICAgICBpZiAoZWxlbWVudG8uZnJvbSA+IGVzcGFjaW8uZW5kKSB7XG4gICAgICAgICAgICAgIGRlc3BsYXphbWllbnRvICs9IGVzcGFjaW8uc2l6ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBTaSBoYXkgZGVzcGxhemFtaWVudG8sIGHDsWFkaXIgYSBsYXMgYWN0dWFsaXphY2lvbmVzXG4gICAgICAgICAgaWYgKGRlc3BsYXphbWllbnRvID4gMCkge1xuICAgICAgICAgICAgY29uc3QgbnVldm9Gcm9tID0gZWxlbWVudG8uZnJvbSAtIGRlc3BsYXphbWllbnRvO1xuICAgICAgICAgICAgY29uc3QgbnVldm9UbyA9IGVsZW1lbnRvLnRvIC0gZGVzcGxhemFtaWVudG87XG5cbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGBFbGVtZW50byAke2VsZW1lbnRvLmlkLnN1YnN0cmluZygwLDgpfS4uLiBzZSBtb3ZlcsOhOiAke2VsZW1lbnRvLmZyb219bXMgLT4gJHtudWV2b0Zyb219bXMgKGRlc3BsYXphbWllbnRvOiAke2Rlc3BsYXphbWllbnRvfW1zKWApO1xuXG4gICAgICAgICAgICBhY3R1YWxpemFjaW9uZXNbZWxlbWVudG8uaWRdID0ge1xuICAgICAgICAgICAgICBkaXNwbGF5OiB7XG4gICAgICAgICAgICAgICAgZnJvbTogbnVldm9Gcm9tLFxuICAgICAgICAgICAgICAgIHRvOiBudWV2b1RvXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBlbGVtZW50b3NBTW92ZXIrKztcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNvbnNvbGUubG9nKGBFbGVtZW50b3MgYSBtb3ZlcjogJHtlbGVtZW50b3NBTW92ZXJ9IGRlICR7dG9kb3NFbGVtZW50b3MubGVuZ3RofSB0b3RhbGApO1xuXG4gICAgICAgIC8vIEFwbGljYXIgbGFzIGFjdHVhbGl6YWNpb25lc1xuICAgICAgICBpZiAoZWxlbWVudG9zQU1vdmVyID4gMCkge1xuICAgICAgICAgIGNvbnNvbGUubG9nKFwiQXBsaWNhbmRvIGFjdHVhbGl6YWNpb25lcyBwYXJhIGNvbXBhY3RhciB0aW1lbGluZS4uLlwiKTtcblxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBkaXNwYXRjaChFRElUX09CSkVDVCwge1xuICAgICAgICAgICAgICBwYXlsb2FkOiBhY3R1YWxpemFjaW9uZXNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc29sZS5sb2coXCJBY3R1YWxpemFjaW9uZXMgYXBsaWNhZGFzIGNvbiDDqXhpdG9cIik7XG4gICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBhbCBhcGxpY2FyIGFjdHVhbGl6YWNpb25lczpcIiwgZXJyb3IpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIFJlZnJlc2NhciBsYSB2aXN0YVxuICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgY29uc3QgeyBzY2FsZSB9ID0gc3RhdGVNYW5hZ2VyLmdldFN0YXRlKCk7XG4gICAgICAgICAgICAgIGlmIChzY2FsZSkge1xuICAgICAgICAgICAgICAgIC8vIEhhY2VyIHVuIHBlcXVlw7FvIGNhbWJpbyBlbiBsYSBlc2NhbGEgcGFyYSBmb3J6YXIgbGEgYWN0dWFsaXphY2nDs25cbiAgICAgICAgICAgICAgICBjb25zdCB1cGRhdGVkU2NhbGUgPSB7IC4uLnNjYWxlIH07XG5cbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHVwZGF0ZWRTY2FsZS51bml0ID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgICAgdXBkYXRlZFNjYWxlLnVuaXQgPSAodXBkYXRlZFNjYWxlLnVuaXQgfHwgMCkgKyAxO1xuXG4gICAgICAgICAgICAgICAgICBkaXNwYXRjaChUSU1FTElORV9TQ0FMRV9DSEFOR0VELCB7XG4gICAgICAgICAgICAgICAgICAgIHBheWxvYWQ6IHsgc2NhbGU6IHVwZGF0ZWRTY2FsZSB9XG4gICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgLy8gVm9sdmVyIGEgbGEgZXNjYWxhIG9yaWdpbmFsXG4gICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY3VycmVudFNjYWxlID0geyAuLi5zdGF0ZU1hbmFnZXIuZ2V0U3RhdGUoKS5zY2FsZSB9O1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50U2NhbGUudW5pdCA9IChjdXJyZW50U2NhbGUudW5pdCB8fCAxKSAtIDE7XG4gICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoKFRJTUVMSU5FX1NDQUxFX0NIQU5HRUQsIHtcbiAgICAgICAgICAgICAgICAgICAgICBwYXlsb2FkOiB7IHNjYWxlOiBjdXJyZW50U2NhbGUgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgIH0sIDMwMCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgYWwgcmVmcmVzY2FyIGxhIHZpc3RhOlwiLCBlcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSwgNTAwKTtcblxuICAgICAgICAgIGNvbnNvbGUubG9nKFwiQ29tcGFjdGFjacOzbiBjb21wbGV0YWRhIGNvbiDDqXhpdG9cIik7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc29sZS5sb2coXCJObyBoYXkgZWxlbWVudG9zIHF1ZSBuZWNlc2l0ZW4gbW92ZXJzZVwiKTtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIGFsIGNvbXBhY3RhciBsYSBsw61uZWEgZGUgdGllbXBvOlwiLCBlcnJvcik7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgc21hcnRUcmltOiBhc3luYyAoKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zb2xlLmxvZyhcIj09PSBJTklDSUFORE8gUFJPQ0VTTyBERSBSRUNPUlRFIElOVEVMSUdFTlRFIERFU0RFIElBID09PVwiKTtcblxuICAgICAgICAvLyAxLiBSZWFsaXphciBsYSBsbGFtYWRhIGFsIEFQSSBwYXJhIGFuYWxpemFyIGxhIHRyYW5zY3JpcGNpw7NuXG4gICAgICAgIGNvbnNvbGUubG9nKFwiU29saWNpdGFuZG8gYW7DoWxpc2lzIGRlIHRyYW5zY3JpcGNpw7NuLi4uXCIpO1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKCcvYXBpL3NtYXJ0LXRyaW0nKTtcblxuICAgICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBFcnJvciBhbCBhbmFsaXphciBsYSB0cmFuc2NyaXBjacOzbjogJHtyZXNwb25zZS5zdGF0dXN9YCk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgICBjb25zb2xlLmxvZyhcIkFuw6FsaXNpcyBkZSB0cmFuc2NyaXBjacOzbiBjb21wbGV0YWRvOlwiLCBkYXRhKTtcblxuICAgICAgICBpZiAoIWRhdGEucmVtb3ZlU2VnbWVudHMgfHwgIUFycmF5LmlzQXJyYXkoZGF0YS5yZW1vdmVTZWdtZW50cykgfHwgZGF0YS5yZW1vdmVTZWdtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICBjb25zb2xlLmxvZyhcIk5vIHNlIGVuY29udHJhcm9uIHNlZ21lbnRvcyBwYXJhIGVsaW1pbmFyXCIpO1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIDIuIENvbnZlcnRpciBsb3Mgc2VnbWVudG9zIGFsIGZvcm1hdG8gcXVlIGVzcGVyYSByZW1vdmVTZWdtZW50c1xuICAgICAgICBjb25zdCBzZWdtZW50cyA9IGRhdGEucmVtb3ZlU2VnbWVudHMubWFwKHNlZ21lbnQgPT4gKHtcbiAgICAgICAgICBzdGFydFRpbWU6IHNlZ21lbnQuc3RhcnRUaW1lLCAvLyBZYSBlc3TDoSBlbiBzZWd1bmRvc1xuICAgICAgICAgIGVuZFRpbWU6IHNlZ21lbnQuZW5kVGltZSAgICAgIC8vIFlhIGVzdMOhIGVuIHNlZ3VuZG9zXG4gICAgICAgIH0pKTtcblxuICAgICAgICBjb25zb2xlLmxvZyhgU2UgZWxpbWluYXLDoW4gJHtzZWdtZW50cy5sZW5ndGh9IHNlZ21lbnRvczpgLFxuICAgICAgICAgIHNlZ21lbnRzLm1hcChzID0+IGAke3Muc3RhcnRUaW1lfXMtJHtzLmVuZFRpbWV9c2ApLmpvaW4oJywgJykpO1xuXG4gICAgICAgIC8vIEFsbWFjZW5hciBpbmZvcm1hY2nDs24gZGVsIGVzdGFkbyBwcmV2aW8gcGFyYSBpZGVudGlmaWNhciB0cmFja3MgeSBlbGVtZW50b3NcbiAgICAgICAgY29uc29sZS5sb2coXCJPYnRlbmllbmRvIGluZm9ybWFjacOzbiBkZWwgZXN0YWRvIGFudGVzIGRlIGVsaW1pbmFyIHNlZ21lbnRvcy4uLlwiKTtcbiAgICAgICAgY29uc3QgZXN0YWRvUHJldmlvID0gc3RhdGVNYW5hZ2VyLmdldFN0YXRlKCk7XG4gICAgICAgIGNvbnN0IGVsZW1lbnRvc1ByZXZpb3MgPSBhd2FpdCBleGVjdXRvci5nZXRBbGxUaW1lbGluZUVsZW1lbnRzKCk7XG5cbiAgICAgICAgLy8gRGV0ZXJtaW5hciBlbCB0cmFja0lkIHByaW5jaXBhbCBiYXNhZG8gZW4gbG9zIGVsZW1lbnRvc1xuICAgICAgICBjb25zdCBjb250YWRvclRyYWNrcyA9IHt9O1xuICAgICAgICBlbGVtZW50b3NQcmV2aW9zLmZvckVhY2goZWxlbSA9PiB7XG4gICAgICAgICAgaWYgKGVsZW0udHJhY2tJZCkge1xuICAgICAgICAgICAgY29udGFkb3JUcmFja3NbZWxlbS50cmFja0lkXSA9IChjb250YWRvclRyYWNrc1tlbGVtLnRyYWNrSWRdIHx8IDApICsgMTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIEVuY29udHJhciBlbCB0cmFjayBjb24gbcOhcyBlbGVtZW50b3NcbiAgICAgICAgbGV0IHRyYWNrSWRQcmluY2lwYWwgPSBcIlwiO1xuICAgICAgICBpZiAoT2JqZWN0LmtleXMoY29udGFkb3JUcmFja3MpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBjb25zdCB0cmFja3NQb3JVc28gPSBPYmplY3QuZW50cmllcyhjb250YWRvclRyYWNrcylcbiAgICAgICAgICAgIC5zb3J0KChhLCBiKSA9PiBiWzFdIC0gYVsxXSk7XG5cbiAgICAgICAgICBpZiAodHJhY2tzUG9yVXNvLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHRyYWNrSWRQcmluY2lwYWwgPSB0cmFja3NQb3JVc29bMF1bMF07XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhgVXNhbmRvIHRyYWNrSWQgcHJpbmNpcGFsOiAke3RyYWNrSWRQcmluY2lwYWx9YCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gMy4gRWxpbWluYXIgbG9zIHNlZ21lbnRvc1xuICAgICAgICBjb25zb2xlLmxvZyhcIkVqZWN1dGFuZG8gZWxpbWluYWNpw7NuIGRlIHNlZ21lbnRvcy4uLlwiKTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgZXhlY3V0b3IucmVtb3ZlU2VnbWVudHMoc2VnbWVudHMpO1xuXG4gICAgICAgIGlmICghcmVzdWx0KSB7XG4gICAgICAgICAgY29uc29sZS5sb2coXCJFcnJvciBhbCBlbGltaW5hciBsb3Mgc2VnbWVudG9zXCIpO1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnNvbGUubG9nKFwiU2VnbWVudG9zIGVsaW1pbmFkb3MgY29ycmVjdGFtZW50ZVwiKTtcblxuICAgICAgICAvLyA0LiBDcmVhciByZWdpc3RybyBkZSBsb3Mgc2VnbWVudG9zIGVsaW1pbmFkb3MgcGFyYSBjb21wYWN0YWNpw7NuXG4gICAgICAgIGNvbnN0IHNlZ21lbnRvc0VsaW1pbmFkb3MgPSBzZWdtZW50cy5tYXAoc2VnbWVudCA9PiAoe1xuICAgICAgICAgIHN0YXJ0OiBzZWdtZW50LnN0YXJ0VGltZSAqIDEwMDAsICAvLyBDb252ZXJ0aXIgYSBtc1xuICAgICAgICAgIGVuZDogc2VnbWVudC5lbmRUaW1lICogMTAwMCwgICAgICAvLyBDb252ZXJ0aXIgYSBtc1xuICAgICAgICAgIHRyYWNrSWQ6IHRyYWNrSWRQcmluY2lwYWwsXG4gICAgICAgICAgc2l6ZTogKHNlZ21lbnQuZW5kVGltZSAtIHNlZ21lbnQuc3RhcnRUaW1lKSAqIDEwMDBcbiAgICAgICAgfSkpO1xuXG4gICAgICAgIGNvbnNvbGUubG9nKFwiU2VnbWVudG9zIHJlZ2lzdHJhZG9zIHBhcmEgY29tcGFjdGFjacOzbjpcIiwgc2VnbWVudG9zRWxpbWluYWRvcyk7XG5cbiAgICAgICAgLy8gNS4gRXNwZXJhciB1biBtb21lbnRvIHBhcmEgcXVlIHNlIGNvbXBsZXRlbiBsYXMgYWN0dWFsaXphY2lvbmVzIGRlbCBET00geSBlbCBlc3RhZG9cbiAgICAgICAgY29uc29sZS5sb2coXCJFc3BlcmFuZG8gNSBzZWd1bmRvcyBwYXJhIGFzZWd1cmFyIHF1ZSBsb3MgY2FtYmlvcyBlbiBsYSB0aW1lbGluZSBlc3TDqW4gY29tcGxldG9zIGFudGVzIGRlIGNvbXBhY3Rhci4uLlwiKTtcbiAgICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDUwMDApKTtcblxuICAgICAgICAvLyA2LiBDb21wYWN0YXIgZWwgdGltZWxpbmUgdXNhbmRvIGVsIGVuZm9xdWUgZGUgc2VnbWVudG9zIHJlZ2lzdHJhZG9zXG4gICAgICAgIGNvbnNvbGUubG9nKFwiQ29tcGFjdGFuZG8gdGltZWxpbmUgYmFzYWRvIGVuIHNlZ21lbnRvcyBlbGltaW5hZG9zLi4uXCIpO1xuXG4gICAgICAgIC8vIE9idGVuZXIgZWxlbWVudG9zIGFjdHVhbGVzIGRlc3B1w6lzIGRlIGxhIGVsaW1pbmFjacOzblxuICAgICAgICBjb25zdCBlbGVtZW50b3NBY3R1YWxlcyA9IGF3YWl0IGV4ZWN1dG9yLmdldEFsbFRpbWVsaW5lRWxlbWVudHMoKTtcbiAgICAgICAgY29uc29sZS5sb2coYFNlIGVuY29udHJhcm9uICR7ZWxlbWVudG9zQWN0dWFsZXMubGVuZ3RofSBlbGVtZW50b3MgZW4gbGEgdGltZWxpbmUgZGVzcHXDqXMgZGUgZWxpbWluYXIgc2VnbWVudG9zYCk7XG5cbiAgICAgICAgLy8gQ2FsY3VsYXIgZWwgZXNwYWNpbyB0b3RhbCBhIGNvbXBhY3RhclxuICAgICAgICBsZXQgZXNwYWNpb1RvdGFsID0gMDtcbiAgICAgICAgc2VnbWVudG9zRWxpbWluYWRvcy5mb3JFYWNoKHNlZ21lbnRvID0+IHtcbiAgICAgICAgICBlc3BhY2lvVG90YWwgKz0gc2VnbWVudG8uc2l6ZTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgY29uc29sZS5sb2coYEVzcGFjaW8gdG90YWwgYSBjb21wYWN0YXI6ICR7ZXNwYWNpb1RvdGFsfW1zICgke2VzcGFjaW9Ub3RhbC8xMDAwfXMpYCk7XG5cbiAgICAgICAgLy8gUHJlcGFyYXIgYWN0dWFsaXphY2lvbmVzIHBhcmEgY2FkYSBlbGVtZW50b1xuICAgICAgICBjb25zdCBhY3R1YWxpemFjaW9uZXMgPSB7fTtcbiAgICAgICAgbGV0IGVsZW1lbnRvc0FNb3ZlciA9IDA7XG5cbiAgICAgICAgLy8gT3JkZW5hciBzZWdtZW50b3MgcG9yIHBvc2ljacOzbiBkZSBpbmljaW9cbiAgICAgICAgY29uc3Qgc2VnbWVudG9zT3JkZW5hZG9zID0gWy4uLnNlZ21lbnRvc0VsaW1pbmFkb3NdLnNvcnQoKGEsIGIpID0+IGEuc3RhcnQgLSBiLnN0YXJ0KTtcblxuICAgICAgICAvLyBQYXJhIGNhZGEgZWxlbWVudG8sIGNhbGN1bGFyIGVsIGRlc3BsYXphbWllbnRvIGJhc2FkbyBlbiBsb3Mgc2VnbWVudG9zIGVsaW1pbmFkb3NcbiAgICAgICAgZWxlbWVudG9zQWN0dWFsZXMuZm9yRWFjaChlbGVtZW50byA9PiB7XG4gICAgICAgICAgbGV0IGRlc3BsYXphbWllbnRvID0gMDtcblxuICAgICAgICAgIC8vIENhbGN1bGFyIGN1w6FudG8gZGViZSBtb3ZlcnNlIGJhc2FkbyBlbiBsb3Mgc2VnbWVudG9zIGVsaW1pbmFkb3MgYW50ZXJpb3Jlc1xuICAgICAgICAgIGZvciAoY29uc3Qgc2VnbWVudG8gb2Ygc2VnbWVudG9zT3JkZW5hZG9zKSB7XG4gICAgICAgICAgICBpZiAoZWxlbWVudG8uZnJvbSA+IHNlZ21lbnRvLnN0YXJ0KSB7XG4gICAgICAgICAgICAgIGRlc3BsYXphbWllbnRvICs9IHNlZ21lbnRvLnNpemU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gU2kgaGF5IGRlc3BsYXphbWllbnRvLCBhw7FhZGlyIGEgbGFzIGFjdHVhbGl6YWNpb25lc1xuICAgICAgICAgIGlmIChkZXNwbGF6YW1pZW50byA+IDApIHtcbiAgICAgICAgICAgIGNvbnN0IG51ZXZvRnJvbSA9IGVsZW1lbnRvLmZyb20gLSBkZXNwbGF6YW1pZW50bztcbiAgICAgICAgICAgIGNvbnN0IG51ZXZvVG8gPSBlbGVtZW50by50byAtIGRlc3BsYXphbWllbnRvO1xuXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhgRWxlbWVudG8gJHtlbGVtZW50by5pZC5zdWJzdHJpbmcoMCw4KX0uLi4gc2UgbW92ZXLDoTogJHtlbGVtZW50by5mcm9tfW1zIC0+ICR7bnVldm9Gcm9tfW1zIChkZXNwbGF6YW1pZW50bzogJHtkZXNwbGF6YW1pZW50b31tcylgKTtcblxuICAgICAgICAgICAgYWN0dWFsaXphY2lvbmVzW2VsZW1lbnRvLmlkXSA9IHtcbiAgICAgICAgICAgICAgZGlzcGxheToge1xuICAgICAgICAgICAgICAgIGZyb206IG51ZXZvRnJvbSxcbiAgICAgICAgICAgICAgICB0bzogbnVldm9Ub1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZWxlbWVudG9zQU1vdmVyKys7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBjb25zb2xlLmxvZyhgRWxlbWVudG9zIGEgbW92ZXI6ICR7ZWxlbWVudG9zQU1vdmVyfSBkZSAke2VsZW1lbnRvc0FjdHVhbGVzLmxlbmd0aH0gdG90YWxgKTtcblxuICAgICAgICAvLyBBcGxpY2FyIGxhcyBhY3R1YWxpemFjaW9uZXNcbiAgICAgICAgaWYgKGVsZW1lbnRvc0FNb3ZlciA+IDApIHtcbiAgICAgICAgICBjb25zb2xlLmxvZyhcIkFwbGljYW5kbyBhY3R1YWxpemFjaW9uZXMgcGFyYSBjb21wYWN0YXIgdGltZWxpbmUuLi5cIik7XG5cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgZGlzcGF0Y2goRURJVF9PQkpFQ1QsIHtcbiAgICAgICAgICAgICAgcGF5bG9hZDogYWN0dWFsaXphY2lvbmVzXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiQWN0dWFsaXphY2lvbmVzIGFwbGljYWRhcyBjb24gw6l4aXRvXCIpO1xuXG4gICAgICAgICAgICAvLyBSZWZyZXNjYXIgbGEgdmlzdGFcbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgc2NhbGUgfSA9IHN0YXRlTWFuYWdlci5nZXRTdGF0ZSgpO1xuICAgICAgICAgICAgICAgIGlmIChzY2FsZSkge1xuICAgICAgICAgICAgICAgICAgY29uc3QgdXBkYXRlZFNjYWxlID0geyAuLi5zY2FsZSB9O1xuICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB1cGRhdGVkU2NhbGUudW5pdCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlZFNjYWxlLnVuaXQgPSAodXBkYXRlZFNjYWxlLnVuaXQgfHwgMCkgKyAxO1xuXG4gICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoKFRJTUVMSU5FX1NDQUxFX0NIQU5HRUQsIHtcbiAgICAgICAgICAgICAgICAgICAgICBwYXlsb2FkOiB7IHNjYWxlOiB1cGRhdGVkU2NhbGUgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBWb2x2ZXIgYSBsYSBlc2NhbGEgb3JpZ2luYWxcbiAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgY29uc3QgY3VycmVudFNjYWxlID0geyAuLi5zdGF0ZU1hbmFnZXIuZ2V0U3RhdGUoKS5zY2FsZSB9O1xuICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRTY2FsZS51bml0ID0gKGN1cnJlbnRTY2FsZS51bml0IHx8IDEpIC0gMTtcbiAgICAgICAgICAgICAgICAgICAgICBkaXNwYXRjaChUSU1FTElORV9TQ0FMRV9DSEFOR0VELCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXlsb2FkOiB7IHNjYWxlOiBjdXJyZW50U2NhbGUgfVxuICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9LCAzMDApO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgYWwgcmVmcmVzY2FyIGxhIHZpc3RhOlwiLCBlcnJvcik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIDUwMCk7XG5cbiAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIGFsIGFwbGljYXIgYWN0dWFsaXphY2lvbmVzOlwiLCBlcnJvcik7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnNvbGUubG9nKFwiTm8gc2UgZW5jb250cmFyb24gZWxlbWVudG9zIHF1ZSBuZWNlc2l0ZW4gbW92ZXJzZVwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnNvbGUubG9nKFwiVGltZWxpbmUgY29tcGFjdGFkbyBjb3JyZWN0YW1lbnRlXCIpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBhbCByZWFsaXphciBlbCByZWNvcnRlIGludGVsaWdlbnRlOlwiLCBlcnJvcik7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgYWRkTXVzaWM6IChtdXNpY1BhdGg6IHN0cmluZywgb3B0aW9ucz86IE11c2ljT3B0aW9ucykgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gVmFsb3JlcyBwcmVkZXRlcm1pbmFkb3NcbiAgICAgICAgY29uc3Qgc3RhcnRUaW1lID0gb3B0aW9ucz8uc3RhcnRUaW1lICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLnN0YXJ0VGltZSA6IDA7XG4gICAgICAgIGNvbnN0IGVuZFRpbWUgPSBvcHRpb25zPy5lbmRUaW1lICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmVuZFRpbWUgOiAoc3RhcnRUaW1lICsgMzApOyAvLyBEdXJhY2nDs24gcHJlZGV0ZXJtaW5hZGEgbcOhcyBsYXJnYSBwYXJhIG3DunNpY2FcbiAgICAgICAgY29uc3Qgdm9sdW1lID0gb3B0aW9ucz8udm9sdW1lICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLnZvbHVtZSA6IDgwOyAvLyBWb2x1bWVuIHByZWRldGVybWluYWRvIGFsIDgwJVxuICAgICAgICBjb25zdCByZXNwZWN0TmF0aXZlRHVyYXRpb24gPSBvcHRpb25zPy5yZXNwZWN0TmF0aXZlRHVyYXRpb24gIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMucmVzcGVjdE5hdGl2ZUR1cmF0aW9uIDogdHJ1ZTsgLy8gUG9yIGRlZmVjdG8sIHJlc3BldGFyIGR1cmFjacOzbiBuYXRpdmFcblxuICAgICAgICBjb25zb2xlLmxvZyhgQcOxYWRpZW5kbyBtw7pzaWNhIGRlc2RlICR7bXVzaWNQYXRofWApO1xuICAgICAgICBjb25zb2xlLmxvZyhgVGllbXBvczogJHtzdGFydFRpbWV9cyBhICR7ZW5kVGltZX1zLCB2b2x1bWVuOiAke3ZvbHVtZX0sIHJlc3BlY3ROYXRpdmVEdXJhdGlvbjogJHtyZXNwZWN0TmF0aXZlRHVyYXRpb259YCk7XG5cbiAgICAgICAgLy8gQ3JlYXIgcGF5bG9hZCBwYXJhIGxhIG3DunNpY2FcbiAgICAgICAgY29uc3QgYXVkaW9QYXlsb2FkID0ge1xuICAgICAgICAgIGlkOiBnZW5lcmF0ZUlkKCksXG4gICAgICAgICAgZGlzcGxheToge1xuICAgICAgICAgICAgZnJvbTogc3RhcnRUaW1lICogMTAwMCwgLy8gQ29udmVydGlyIGEgbWlsaXNlZ3VuZG9zXG4gICAgICAgICAgICB0bzogZW5kVGltZSAqIDEwMDAgICAgIC8vIENvbnZlcnRpciBhIG1pbGlzZWd1bmRvc1xuICAgICAgICAgIH0sXG4gICAgICAgICAgdHlwZTogJ2F1ZGlvJyxcbiAgICAgICAgICBkZXRhaWxzOiB7XG4gICAgICAgICAgICBzcmM6IG11c2ljUGF0aCxcbiAgICAgICAgICAgIHZvbHVtZTogdm9sdW1lLFxuICAgICAgICAgICAgZmFkZUluOiBvcHRpb25zPy5mYWRlSW4gPT09IHRydWUsXG4gICAgICAgICAgICBmYWRlT3V0OiBvcHRpb25zPy5mYWRlT3V0ID09PSB0cnVlXG4gICAgICAgICAgfSxcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBBZ3JlZ2FyIGF1ZGlvIGFsIHRpbWVsaW5lIHVzYW5kbyBBRERfQVVESU9cbiAgICAgICAgZGlzcGF0Y2goQUREX0FVRElPLCB7XG4gICAgICAgICAgcGF5bG9hZDogYXVkaW9QYXlsb2FkLFxuICAgICAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgICAgIHJlc3BlY3ROYXRpdmVEdXJhdGlvbjogcmVzcGVjdE5hdGl2ZUR1cmF0aW9uXG4gICAgICAgICAgfSxcbiAgICAgICAgfSk7XG5cbiAgICAgICAgY29uc29sZS5sb2coYE3DunNpY2EgYWdyZWdhZGEgZXhpdG9zYW1lbnRlIGNvbiBJRDogJHthdWRpb1BheWxvYWQuaWR9YCk7XG4gICAgICAgIHJldHVybiBhdWRpb1BheWxvYWQuaWQ7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgYWwgYWdyZWdhciBtw7pzaWNhOlwiLCBlcnJvcik7XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICByZXR1cm4gZXhlY3V0b3I7XG59XG4iXSwibmFtZXMiOlsiZGlzcGF0Y2giLCJBRERfVEVYVCIsIkFERF9WSURFTyIsIkFERF9JTUFHRSIsIkFERF9BVURJTyIsIkFDVElWRV9TUExJVCIsIkxBWUVSX1NFTEVDVCIsIkxBWUVSX0RFTEVURSIsIlRJTUVMSU5FX1NDQUxFX0NIQU5HRUQiLCJFRElUX09CSkVDVCIsImdlbmVyYXRlSWQiLCJjcmVhdGVWaWRlb0NvbW1hbmRFeGVjdXRvciIsInN0YXRlTWFuYWdlciIsImV4ZWN1dG9yIiwiYWRkVGV4dCIsInRleHQiLCJvcHRpb25zIiwicG9zaXRpb24iLCJ4IiwieSIsImZvbnRTaXplIiwiZm9udEZhbWlseSIsImNvbG9yIiwic3RhcnRUaW1lIiwiZW5kVGltZSIsInRleHRQYXlsb2FkIiwiaWQiLCJkaXNwbGF5IiwiZnJvbSIsInRvIiwidHlwZSIsImRldGFpbHMiLCJ3aWR0aCIsIndvcmRXcmFwIiwidGV4dEFsaWduIiwiYm9yZGVyV2lkdGgiLCJib3JkZXJDb2xvciIsImJveFNoYWRvdyIsImJsdXIiLCJwYXlsb2FkIiwiY2hhbmdlQ29sb3IiLCJlbGVtZW50SWQiLCJjb25zb2xlIiwibG9nIiwiYWRkSW1hZ2UiLCJ1cmwiLCJlcnJvciIsIkVycm9yIiwiSlNPTiIsInN0cmluZ2lmeSIsImluY2x1ZGVzIiwiaGVpZ2h0IiwidW5kZWZpbmVkIiwiaXNFeHBsaWNpdGx5QW5pbWF0ZWQiLCJpc0FuaW1hdGVkIiwiaXNFeHBsaWNpdGx5U3RhdGljIiwiaXNTdGF0aWMiLCJpc0FQTkciLCJ0b0xvd2VyQ2FzZSIsImVuZHNXaXRoIiwiaXNHSUYiLCJzaG91bGRUcmVhdEFzQW5pbWF0ZWQiLCJsb2dVcmwiLCJzdGFydHNXaXRoIiwic3Vic3RyaW5nIiwic2NhbGVNb2RlIiwidXNlRnVsbFNjcmVlbiIsImNvbW1vblBheWxvYWRQcm9wcyIsImNvbW1vbkRldGFpbHNQcm9wcyIsInNyYyIsIm9wYWNpdHkiLCJsZWZ0IiwidG9wIiwib3JpZ2luWCIsIm9yaWdpblkiLCJpbWFnZUlkIiwiaW1hZ2VQYXlsb2FkIiwibGVuZ3RoIiwiZGlzcGF0Y2hPcHRpb25zIiwibWVzc2FnZSIsInN0YWNrIiwiYWRkVmlkZW8iLCJpc0FWSSIsImlzRXhwbGljaXRBUE5HIiwidHJlYXRBc0FQTkciLCJyZXNwZWN0TmF0aXZlRHVyYXRpb24iLCJmaW5hbEVuZFRpbWUiLCJzeW5jV2l0aFRpbWVsaW5lIiwiYXBuZ1ZpZGVvUGF5bG9hZCIsImFwbmdFcnJvciIsInZpZGVvUGF5bG9hZCIsImF1dG9QbGF5IiwibG9vcCIsInJlc291cmNlSWQiLCJwbGF5YmFja0JlaGF2aW9yIiwiY2hhbmdlRHVyYXRpb24iLCJkdXJhdGlvbiIsImNoYW5nZVRyYW5zaXRpb24iLCJ0cmFuc2l0aW9uIiwiYWRkU3VidGl0bGVzIiwicGFyc2VUaW1lVG9NcyIsInRpbWVTdHJpbmciLCJob3VycyIsIm1pbnV0ZXMiLCJzZWNvbmRzQW5kTXMiLCJzcGxpdCIsInNlY29uZHMiLCJtcyIsInBhcnNlSW50IiwicGFyc2VTUlQiLCJzcnRDb250ZW50Iiwic2VnbWVudHMiLCJibG9ja3MiLCJ0cmltIiwiZm9yRWFjaCIsImJsb2NrIiwibGluZXMiLCJ0aW1lUmFuZ2UiLCJzbGljZSIsImpvaW4iLCJwdXNoIiwic3BsaXRUZXh0SW50b0dyb3VwcyIsIndvcmRzUGVyR3JvdXAiLCJ3b3JkcyIsImdyb3VwcyIsImkiLCJncm91cCIsInByb2Nlc3NTZWdtZW50Iiwic2VnbWVudCIsInRleHRHcm91cHMiLCJ0b3RhbER1cmF0aW9uIiwiZ3JvdXBEdXJhdGlvbiIsIm1hcCIsImdyb3VwVGV4dCIsImluZGV4IiwiY3JlYXRlU3VidGl0bGVQYXlsb2FkIiwidG9VcHBlckNhc2UiLCJmb250VXJsIiwiYmFja2dyb3VuZENvbG9yIiwicGFkZGluZyIsImJvcmRlclJhZGl1cyIsInJlc3BvbnNlIiwiZmV0Y2giLCJvayIsInN0YXR1cyIsImZsYXRNYXAiLCJvcmlnaW5hbExlbmd0aCIsImZpbHRlciIsInBhc3Nlc1N0YXJ0RmlsdGVyIiwicGFzc2VzRW5kRmlsdGVyIiwic3RhdGUiLCJnZXRTdGF0ZSIsInRhcmdldFRyYWNrSWQiLCJ0cmFja0lkIiwidHJhY2tzIiwidGV4dFRyYWNrIiwiZmluZCIsInRyYWNrIiwiYWNjZXB0cyIsImFueVRyYWNrIiwic2V0VGltZW91dCIsImdldEFjdGl2ZUVsZW1lbnRzIiwiYWN0aXZlSWRzIiwidHJhY2tJdGVtc01hcCIsImFjdGl2ZUVsZW1lbnRzIiwiaXRlbSIsImdldEFsbFRpbWVsaW5lRWxlbWVudHMiLCJPYmplY3QiLCJrZXlzIiwia2V5Iiwib2JqVmFsdWUiLCJzYW1wbGUiLCJlbnRyaWVzIiwiXyIsImFsbEVsZW1lbnRzIiwic29ydCIsImEiLCJiIiwicmVtb3ZlU2VnbWVudHMiLCJ0cmFja0l0ZW1zIiwiZmlyc3RJdGVtSWQiLCJpZHMiLCJQcm9taXNlIiwicmVzb2x2ZSIsImN1cnJlbnRTdGF0ZSIsIm9yaWdpbmFsSXRlbUlkIiwib3JpZ2luYWxJdGVtIiwidHJhY2tUeXBlIiwiZW5kTXMiLCJ0aW1lIiwic3RhdGVBZnRlckZpcnN0Q3V0IiwiZWxlbWVudHNBZnRlckZpcnN0Q3V0IiwiaXNOYU4iLCJkdXJhY2nDs24iLCJzdGFydE1zIiwibGVmdEVsZW1lbnQiLCJlbGVtIiwic3RhdGVBZnRlclNlY29uZEN1dCIsImVsZW1lbnRzQWZ0ZXJTZWNvbmRDdXQiLCJtaWRkbGVFbGVtZW50cyIsIk1hdGgiLCJhYnMiLCJtaWRkbGVFbGVtZW50IiwidmlzaWJsZSIsInNjYWxlIiwib3JpZ2luYWxVbml0IiwidW5pdCIsImNvbXBhY3RUaW1lbGluZSIsImVzdGFkbyIsInRvZG9zRWxlbWVudG9zIiwiZWxlbWVudG9zUG9yVHJhY2siLCJpZHgiLCJlc3BhY2lvc1ZhY2lvcyIsImVsZW1lbnRvcyIsImVsZW1lbnRvQWN0dWFsIiwiZWxlbWVudG9TaWd1aWVudGUiLCJlc3BhY2lvIiwic3RhcnQiLCJlbmQiLCJzaXplIiwiZWxlbWVudG9BbnRlcyIsImVsZW1lbnRvRGVzcHVlcyIsImVzcGFjaW9Ub3RhbCIsImFjdHVhbGl6YWNpb25lcyIsImVsZW1lbnRvc0FNb3ZlciIsImVsZW1lbnRvIiwiZGVzcGxhemFtaWVudG8iLCJudWV2b0Zyb20iLCJudWV2b1RvIiwidXBkYXRlZFNjYWxlIiwiY3VycmVudFNjYWxlIiwic21hcnRUcmltIiwiZGF0YSIsImpzb24iLCJBcnJheSIsImlzQXJyYXkiLCJzIiwiZXN0YWRvUHJldmlvIiwiZWxlbWVudG9zUHJldmlvcyIsImNvbnRhZG9yVHJhY2tzIiwidHJhY2tJZFByaW5jaXBhbCIsInRyYWNrc1BvclVzbyIsInJlc3VsdCIsInNlZ21lbnRvc0VsaW1pbmFkb3MiLCJlbGVtZW50b3NBY3R1YWxlcyIsInNlZ21lbnRvIiwic2VnbWVudG9zT3JkZW5hZG9zIiwiYWRkTXVzaWMiLCJtdXNpY1BhdGgiLCJ2b2x1bWUiLCJhdWRpb1BheWxvYWQiLCJmYWRlSW4iLCJmYWRlT3V0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./components/ai-chat/ai-video-commands.ts\n"));

/***/ })

});
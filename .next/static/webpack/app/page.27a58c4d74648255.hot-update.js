"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./components/ai-chat/ai-video-commands.ts":
/*!*************************************************!*\
  !*** ./components/ai-chat/ai-video-commands.ts ***!
  \*************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createVideoCommandExecutor: function() { return /* binding */ createVideoCommandExecutor; }\n/* harmony export */ });\n/* harmony import */ var _designcombo_events__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @designcombo/events */ \"(app-pages-browser)/./node_modules/@designcombo/events/dist/index.es.js\");\n/* harmony import */ var _designcombo_state__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @designcombo/state */ \"(app-pages-browser)/./node_modules/@designcombo/state/dist/index.es.js\");\n/* harmony import */ var _designcombo_timeline__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @designcombo/timeline */ \"(app-pages-browser)/./node_modules/@designcombo/timeline/dist/index.es.js\");\n\n\n\nfunction createVideoCommandExecutor(stateManager) {\n    // Crear el objeto executor con todos los métodos\n    const executor = {\n        addText: (text, options)=>{\n            const position = (options === null || options === void 0 ? void 0 : options.position) || {\n                x: 0.5,\n                y: 0.5\n            }; // Centrado por defecto\n            const fontSize = (options === null || options === void 0 ? void 0 : options.fontSize) || 48;\n            const fontFamily = (options === null || options === void 0 ? void 0 : options.fontFamily) || \"Roboto-Bold\";\n            const color = (options === null || options === void 0 ? void 0 : options.color) || \"#FFFFFF\";\n            const startTime = (options === null || options === void 0 ? void 0 : options.startTime) || 0; // Por defecto al inicio\n            const endTime = (options === null || options === void 0 ? void 0 : options.endTime) || 5; // Por defecto 5 segundos de duración\n            // Crear payload para el texto\n            const textPayload = {\n                id: (0,_designcombo_timeline__WEBPACK_IMPORTED_MODULE_2__.generateId)(),\n                display: {\n                    from: startTime * 1000,\n                    to: endTime * 1000 // Convertir a milisegundos\n                },\n                type: \"text\",\n                details: {\n                    text: text,\n                    fontSize: fontSize,\n                    width: 600,\n                    fontFamily: fontFamily,\n                    color: color,\n                    wordWrap: \"break-word\",\n                    textAlign: \"center\",\n                    borderWidth: 0,\n                    borderColor: \"#000000\",\n                    boxShadow: {\n                        color: \"#ffffff\",\n                        x: 0,\n                        y: 0,\n                        blur: 0\n                    }\n                }\n            };\n            // Agregar texto al timeline\n            (0,_designcombo_events__WEBPACK_IMPORTED_MODULE_0__.dispatch)(_designcombo_state__WEBPACK_IMPORTED_MODULE_1__.ADD_TEXT, {\n                payload: textPayload,\n                options: {}\n            });\n        },\n        changeColor: (elementId, color)=>{\n            // Simulación de cambio de color (la implementación real dependerá de la estructura del proyecto)\n            console.log(\"Cambiando color del elemento \".concat(elementId, \" a \").concat(color));\n        // Aquí iría la lógica real para cambiar el color de un elemento\n        },\n        addImage: (url, options)=>{\n            try {\n                // Asegurar que tenemos una URL válida\n                if (!url) {\n                    console.error(\"❌ URL de imagen no v\\xe1lida o vac\\xeda\");\n                    throw new Error(\"URL de imagen no proporcionada\");\n                }\n                console.log(\"=== INICIANDO PROCESO DE A\\xd1ADIR IMAGEN ===\");\n                console.log(\"URL:\", url);\n                console.log(\"Opciones:\", JSON.stringify(options, null, 2));\n                // Verificar si es una URL genérica de referencia, que no debe usarse directamente\n                if (url === \"imagen_adjunta_por_el_usuario.jpg\" || url.includes(\"/url_de_la_imagen\")) {\n                    console.error(\"Error: URL de imagen gen\\xe9rica inv\\xe1lida detectada\", url);\n                    throw new Error(\"La URL de imagen no es v\\xe1lida. Se intent\\xf3 usar un marcador gen\\xe9rico directamente.\");\n                }\n                const width = (options === null || options === void 0 ? void 0 : options.width) || 480;\n                const height = (options === null || options === void 0 ? void 0 : options.height) || 270;\n                const startTime = (options === null || options === void 0 ? void 0 : options.startTime) !== undefined ? options.startTime : 0;\n                const endTime = (options === null || options === void 0 ? void 0 : options.endTime) !== undefined ? options.endTime : startTime + 5;\n                // Detectores de tipo de imagen\n                const isExplicitlyAnimated = (options === null || options === void 0 ? void 0 : options.isAnimated) === true;\n                const isExplicitlyStatic = (options === null || options === void 0 ? void 0 : options.isStatic) === true;\n                const isAPNG = url.toLowerCase().endsWith(\".apng\");\n                const isGIF = url.toLowerCase().endsWith(\".gif\");\n                // Determinar si debe tratarse como imagen animada\n                const shouldTreatAsAnimated = (isExplicitlyAnimated || isAPNG || isGIF) && !isExplicitlyStatic;\n                // Log de modo detectado\n                if (shouldTreatAsAnimated) {\n                    console.log(\"\\uD83D\\uDD36 Detectada imagen animada: \".concat(url));\n                    console.log(\"Tipo: \".concat(isAPNG ? \"APNG\" : isGIF ? \"GIF\" : \"Animada gen\\xe9rica\"));\n                } else if (isAPNG || isGIF) {\n                    console.log(\"\\uD83D\\uDD39 Detectada imagen potencialmente animada pero trat\\xe1ndola como est\\xe1tica: \".concat(url));\n                } else {\n                    console.log(\"\\uD83D\\uDD37 Detectada imagen est\\xe1tica: \".concat(url));\n                }\n                // Para depuración, mostrar parte de la URL (truncada si es data:URL)\n                const logUrl = url.startsWith(\"data:\") ? \"\".concat(url.substring(0, 30), \"... (data URL)\") : url;\n                console.log(\"A\\xf1adiendo imagen desde \".concat(logUrl, \" desde segundo \").concat(startTime, \" hasta \").concat(endTime));\n                // Posición (centrada por defecto)\n                const position = (options === null || options === void 0 ? void 0 : options.position) || {\n                    x: 0.5,\n                    y: 0.5\n                };\n                // Modos de escala\n                const scaleMode = (options === null || options === void 0 ? void 0 : options.scaleMode) || \"fit\";\n                const useFullScreen = scaleMode === \"cover\";\n                // Propiedades para el payload, común para ambos casos\n                const commonPayloadProps = {\n                    from: startTime * 1000,\n                    to: endTime * 1000\n                };\n                // Propiedades de detalle comunes\n                const commonDetailsProps = {\n                    src: url,\n                    width: width,\n                    height: height,\n                    opacity: 100,\n                    scaleMode: scaleMode,\n                    left: position.x,\n                    top: position.y,\n                    originX: \"center\",\n                    originY: \"center\"\n                };\n                // Crear ID único\n                const imageId = (0,_designcombo_timeline__WEBPACK_IMPORTED_MODULE_2__.generateId)();\n                // Crear el payload de imagen simplificado\n                const imagePayload = {\n                    id: imageId,\n                    display: commonPayloadProps,\n                    type: \"image\",\n                    details: {\n                        ...commonDetailsProps,\n                        // Si es animada, añadir atributos específicos\n                        ...shouldTreatAsAnimated && {\n                            isAnimated: true\n                        },\n                        // Si a pantalla completa, ajustar dimensiones\n                        ...useFullScreen && {\n                            width: 1920,\n                            height: 1080\n                        }\n                    }\n                };\n                console.log(\"Payload de imagen a despachar:\", JSON.stringify({\n                    ...imagePayload,\n                    details: {\n                        ...imagePayload.details,\n                        src: imagePayload.details.src.substring(0, 30) + (imagePayload.details.src.length > 30 ? \"...\" : \"\")\n                    }\n                }, null, 2));\n                // Opciones para el dispatch\n                const dispatchOptions = {\n                    scaleMode: scaleMode,\n                    position: position\n                };\n                // Despachar la acción para añadir la imagen\n                (0,_designcombo_events__WEBPACK_IMPORTED_MODULE_0__.dispatch)(_designcombo_state__WEBPACK_IMPORTED_MODULE_1__.ADD_IMAGE, {\n                    payload: imagePayload,\n                    options: dispatchOptions\n                });\n                // Log de éxito\n                if (shouldTreatAsAnimated) {\n                    console.log(\"✅ Imagen animada a\\xf1adida desde \".concat(startTime, \"s hasta \").concat(endTime, \"s\"));\n                } else {\n                    console.log(\"✅ Imagen est\\xe1tica a\\xf1adida desde \".concat(startTime, \"s hasta \").concat(endTime, \"s\"));\n                }\n            } catch (error) {\n                console.error(\"❌ ERROR CR\\xcdTICO al a\\xf1adir imagen:\", error);\n                console.error(\"Detalles completos:\", error.message);\n                console.error(\"Traza:\", error.stack);\n                throw error; // Propagar el error para manejo superior\n            }\n        },\n        addVideo: (url, options)=>{\n            try {\n                console.log(\"=== INICIANDO PROCESO DE A\\xd1ADIR VIDEO ===\");\n                console.log(\"URL:\", url);\n                console.log(\"Opciones:\", JSON.stringify(options, null, 2));\n                // Validación de URL\n                if (!url) {\n                    console.error(\"❌ URL de video no v\\xe1lida o vac\\xeda\");\n                    throw new Error(\"URL de video no proporcionada\");\n                }\n                const width = (options === null || options === void 0 ? void 0 : options.width) || 640;\n                const height = (options === null || options === void 0 ? void 0 : options.height) || 360;\n                const startTime = (options === null || options === void 0 ? void 0 : options.startTime) || 0; // Por defecto al inicio\n                const endTime = (options === null || options === void 0 ? void 0 : options.endTime) || 10; // Por defecto 10 segundos de duración\n                // Detectar si es un archivo AVI o APNG para tratamiento especial\n                const isAVI = url.toLowerCase().endsWith(\".avi\");\n                const isAPNG = url.toLowerCase().endsWith(\".apng\");\n                // Marcador pasado explícitamente - mayor prioridad que la extensión\n                const isExplicitAPNG = (options === null || options === void 0 ? void 0 : options.isAPNG) === true;\n                console.log(\"Formato detectado:\", isAVI ? \"AVI\" : isAPNG ? \"APNG\" : isExplicitAPNG ? \"Expl\\xedcitamente marcado como APNG\" : \"Formato est\\xe1ndar\");\n                // Si es APNG según algún criterio\n                const treatAsAPNG = isAPNG || isExplicitAPNG;\n                const useFullScreen = isAVI || treatAsAPNG || (options === null || options === void 0 ? void 0 : options.scaleMode) === \"cover\";\n                // Para archivos AVI y APNG, respectar duración natural si no se especifica\n                const respectNativeDuration = (isAVI || treatAsAPNG) && !(options === null || options === void 0 ? void 0 : options.endTime);\n                const finalEndTime = respectNativeDuration ? undefined : endTime;\n                // Log para depurar\n                if (treatAsAPNG) {\n                    console.log(\"\\uD83D\\uDD37 A\\xf1adiendo APNG como VIDEO sincronizado desde \".concat(startTime, \"s con duraci\\xf3n \").concat(respectNativeDuration ? \"natural\" : finalEndTime + \"s\"));\n                    console.log(\"\\uD83D\\uDD37 Configuraciones especiales de APNG - useFullScreen: \".concat(useFullScreen, \", syncWithTimeline: \").concat((options === null || options === void 0 ? void 0 : options.syncWithTimeline) || true));\n                } else if (isAVI) {\n                    console.log(\"\\uD83C\\uDFAC A\\xf1adiendo AVI con duraci\\xf3n \".concat(respectNativeDuration ? \"natural\" : \"especificada: \" + finalEndTime, \"s\"));\n                }\n                // Manejar APNG usando un enfoque especial - intentar con un método alternativo si es posible\n                if (treatAsAPNG) {\n                    try {\n                        // Intentar crear un payload especial para APNG que funcione como animación\n                        console.log(\"Probando con una configuraci\\xf3n especial para APNG...\");\n                        // Configuración de opciones importante para archivos APNG\n                        const apngVideoPayload = {\n                            id: (0,_designcombo_timeline__WEBPACK_IMPORTED_MODULE_2__.generateId)(),\n                            display: {\n                                from: startTime * 1000,\n                                to: finalEndTime ? finalEndTime * 1000 : (startTime + 3) * 1000 // 3 segundos por defecto si no hay duración\n                            },\n                            // Probamos una nueva estrategia: tratarlo como imagen en lugar de video\n                            type: \"image\",\n                            details: {\n                                src: url,\n                                width: 1920,\n                                height: 1080,\n                                opacity: 100,\n                                scaleMode: \"cover\",\n                                left: 0.5,\n                                top: 0.5,\n                                originX: \"center\",\n                                originY: \"center\",\n                                // Propiedades para animar\n                                isAnimated: true\n                            }\n                        };\n                        console.log(\"Payload para APNG como imagen animada:\", JSON.stringify(apngVideoPayload, null, 2));\n                        // Usar ADD_IMAGE en lugar de ADD_VIDEO\n                        (0,_designcombo_events__WEBPACK_IMPORTED_MODULE_0__.dispatch)(_designcombo_state__WEBPACK_IMPORTED_MODULE_1__.ADD_IMAGE, {\n                            payload: apngVideoPayload,\n                            options: {\n                                scaleMode: \"cover\",\n                                position: {\n                                    x: 0.5,\n                                    y: 0.5\n                                }\n                            }\n                        });\n                        console.log(\"✅ APNG a\\xf1adido como imagen animada con \\xe9xito\");\n                        return;\n                    } catch (apngError) {\n                        console.error(\"❌ Error al a\\xf1adir APNG como imagen animada:\", apngError);\n                        console.error(\"Detalles:\", apngError.message);\n                        console.error(\"Traza:\", apngError.stack);\n                        console.log(\"\\uD83D\\uDD04 Continuando con el m\\xe9todo est\\xe1ndar como respaldo...\");\n                    // Continuar con el método estándar como respaldo\n                    }\n                }\n                // Crear payload para el video\n                const videoPayload = {\n                    id: (0,_designcombo_timeline__WEBPACK_IMPORTED_MODULE_2__.generateId)(),\n                    display: {\n                        from: startTime * 1000,\n                        to: finalEndTime ? finalEndTime * 1000 : undefined // Usar undefined si queremos respetar la duración natural\n                    },\n                    type: \"video\",\n                    details: {\n                        src: url,\n                        width: width,\n                        height: height,\n                        opacity: 100,\n                        // Para archivos APNG y AVI, configurar propiedades específicas para pantalla completa\n                        ...useFullScreen && {\n                            scaleMode: \"cover\",\n                            left: 0.5,\n                            top: 0.5,\n                            originX: \"center\",\n                            originY: \"center\"\n                        },\n                        // Propiedades especiales para APNG\n                        ...treatAsAPNG && {\n                            isAPNG: true,\n                            autoPlay: true,\n                            loop: false,\n                            syncWithTimeline: (options === null || options === void 0 ? void 0 : options.syncWithTimeline) || true\n                        }\n                    }\n                };\n                console.log(\"Payload de video est\\xe1ndar:\", JSON.stringify(videoPayload, null, 2));\n                // Configuraciones adicionales para el dispatch\n                const dispatchOptions = {\n                    resourceId: \"main\",\n                    scaleMode: useFullScreen ? \"cover\" : \"fit\",\n                    ...useFullScreen && {\n                        position: {\n                            x: 0.5,\n                            y: 0.5\n                        } // Centrar para videos a pantalla completa\n                    },\n                    respectNativeDuration: respectNativeDuration,\n                    // Propiedades específicas para sincronización de APNG\n                    ...treatAsAPNG && {\n                        isAPNG: true,\n                        syncWithTimeline: (options === null || options === void 0 ? void 0 : options.syncWithTimeline) || true,\n                        playbackBehavior: (options === null || options === void 0 ? void 0 : options.playbackBehavior) || \"sync\"\n                    }\n                };\n                console.log(\"Opciones de dispatch:\", JSON.stringify(dispatchOptions, null, 2));\n                // Agregar video al timeline\n                (0,_designcombo_events__WEBPACK_IMPORTED_MODULE_0__.dispatch)(_designcombo_state__WEBPACK_IMPORTED_MODULE_1__.ADD_VIDEO, {\n                    payload: videoPayload,\n                    options: dispatchOptions\n                });\n                // Mensaje de log adaptado al tipo de archivo\n                if (treatAsAPNG) {\n                    console.log(\"✅ Transici\\xf3n APNG a\\xf1adida como VIDEO SINCRONIZADO al timeline desde \".concat(startTime, \"s \").concat(finalEndTime ? \"hasta \".concat(finalEndTime, \"s\") : \"con duraci\\xf3n natural\", \". Dimensiones: \").concat(width, \"x\").concat(height));\n                } else {\n                    console.log(\"✅ Video \".concat(isAVI ? \"AVI\" : \"\", \" a\\xf1adido al timeline desde \").concat(startTime, \"s\").concat(finalEndTime ? \" hasta \".concat(finalEndTime, \"s\") : \" con duraci\\xf3n natural\", \". Dimensiones: \").concat(width, \"x\").concat(height));\n                }\n            } catch (error) {\n                console.error(\"❌ ERROR CR\\xcdTICO al a\\xf1adir video:\", error);\n                console.error(\"Detalles completos:\", error.message);\n                console.error(\"Traza:\", error.stack);\n                throw error; // Propagar el error para manejo superior\n            }\n        },\n        changeDuration: (elementId, duration)=>{\n            // Simulación de cambio de duración (la implementación real dependerá de la estructura del proyecto)\n            console.log(\"Cambiando duraci\\xf3n del elemento \".concat(elementId, \" a \").concat(duration, \"s\"));\n        // Aquí iría la lógica real para cambiar la duración de un elemento\n        },\n        changeTransition: (elementId, transition)=>{\n            // Simulación de cambio de transición (la implementación real dependerá de la estructura del proyecto)\n            console.log(\"Cambiando transici\\xf3n del elemento \".concat(elementId, \" a \").concat(transition));\n        // Aquí iría la lógica real para cambiar la transición de un elemento\n        },\n        addSubtitles: async (options)=>{\n            try {\n                console.log(\"A\\xf1adiendo subt\\xedtulos directamente sin depender del bot\\xf3n\");\n                // Función para parsear el tiempo de formato SRT a milisegundos\n                const parseTimeToMs = (timeString)=>{\n                    const [hours, minutes, secondsAndMs] = timeString.split(\":\");\n                    const [seconds, ms] = secondsAndMs.split(\",\");\n                    return parseInt(hours) * 3600000 + parseInt(minutes) * 60000 + parseInt(seconds) * 1000 + parseInt(ms);\n                };\n                // Función para parsear el archivo SRT\n                const parseSRT = (srtContent)=>{\n                    const segments = [];\n                    const blocks = srtContent.trim().split(\"\\n\\n\");\n                    blocks.forEach((block)=>{\n                        const lines = block.split(\"\\n\");\n                        if (lines.length >= 3) {\n                            const id = parseInt(lines[0]);\n                            const timeRange = lines[1].split(\" --> \");\n                            const startTime = parseTimeToMs(timeRange[0]);\n                            const endTime = parseTimeToMs(timeRange[1]);\n                            const text = lines.slice(2).join(\"\\n\"); // Unir todas las líneas de texto\n                            segments.push({\n                                id,\n                                startTime,\n                                endTime,\n                                text\n                            });\n                        }\n                    });\n                    return segments;\n                };\n                // Función para dividir un texto en grupos de aproximadamente 3 palabras\n                const splitTextIntoGroups = function(text) {\n                    let wordsPerGroup = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 3;\n                    const words = text.split(/\\s+/);\n                    const groups = [];\n                    for(let i = 0; i < words.length; i += wordsPerGroup){\n                        const group = words.slice(i, i + wordsPerGroup).join(\" \");\n                        groups.push(group);\n                    }\n                    return groups;\n                };\n                // Función para procesar un segmento y dividirlo en múltiples segmentos si es necesario\n                const processSegment = (segment)=>{\n                    const textGroups = splitTextIntoGroups(segment.text);\n                    // Si solo hay un grupo, devolver el segmento original\n                    if (textGroups.length <= 1) {\n                        return [\n                            segment\n                        ];\n                    }\n                    // Calcular la duración de cada grupo\n                    const totalDuration = segment.endTime - segment.startTime;\n                    const groupDuration = totalDuration / textGroups.length;\n                    // Crear un nuevo segmento para cada grupo\n                    return textGroups.map((groupText, index)=>{\n                        const startTime = segment.startTime + index * groupDuration;\n                        const endTime = startTime + groupDuration;\n                        return {\n                            id: segment.id * 1000 + index,\n                            startTime,\n                            endTime,\n                            text: groupText\n                        };\n                    });\n                };\n                // Función para crear el payload de texto para subtítulos\n                const createSubtitlePayload = (text, startTime, endTime)=>({\n                        id: (0,_designcombo_timeline__WEBPACK_IMPORTED_MODULE_2__.generateId)(),\n                        display: {\n                            from: startTime,\n                            to: endTime\n                        },\n                        type: \"text\",\n                        details: {\n                            text: text.toUpperCase(),\n                            fontSize: 80,\n                            width: 900,\n                            fontUrl: \"/fonts/mrbeast.ttf\",\n                            fontFamily: \"MrBeast\",\n                            color: \"#FFFF00\",\n                            wordWrap: \"break-word\",\n                            textAlign: \"center\",\n                            borderWidth: 20,\n                            borderColor: \"#000000\",\n                            boxShadow: {\n                                color: \"#000000\",\n                                x: 3,\n                                y: 3,\n                                blur: 0\n                            },\n                            backgroundColor: \"transparent\",\n                            padding: 10,\n                            borderRadius: 0\n                        }\n                    });\n                // Función para encontrar un track adecuado para subtítulos\n                const getSubtitleTrackId = ()=>{\n                    // Obtener el estado actual\n                    const state = stateManager.getState();\n                    // Inspeccionar el estado completo para depuración\n                    console.log(\"Claves disponibles en el estado:\", Object.keys(state));\n                    // Intentar varias estrategias para encontrar los tracks\n                    // Estrategia 1: Buscar directamente en state.tracks\n                    let tracks = state.tracks || [];\n                    if (Array.isArray(tracks) && tracks.length > 0) {\n                        console.log(\"Encontrados \".concat(tracks.length, \" tracks en state.tracks\"));\n                        const textTrack = tracks.find((track)=>track.type === \"text\" && track.accepts && track.accepts.includes(\"text\"));\n                        if (textTrack) {\n                            console.log(\"Encontrado track de texto con ID: \".concat(textTrack.id));\n                            return textTrack.id;\n                        }\n                    } else {\n                        console.log(\"No se encontraron tracks en state.tracks\");\n                    }\n                    // Estrategia 2: Buscar en la estructura del timeline\n                    if (state.timeline) {\n                        console.log(\"Timeline encontrado en el estado\");\n                        // Revisar si hay canvas y tracks en el timeline\n                        if (state.timeline.canvas && state.timeline.canvas.tracks) {\n                            const canvasTracks = state.timeline.canvas.tracks;\n                            if (Array.isArray(canvasTracks) && canvasTracks.length > 0) {\n                                console.log(\"Encontrados \".concat(canvasTracks.length, \" tracks en timeline.canvas.tracks\"));\n                                const trackId = canvasTracks[0].id;\n                                console.log(\"Usando primer track de canvas: \".concat(trackId));\n                                return trackId;\n                            }\n                        }\n                        // Alternativa: buscar en otras propiedades del timeline\n                        if (state.timeline.tracks) {\n                            const timelineTracks = state.timeline.tracks;\n                            if (Array.isArray(timelineTracks) && timelineTracks.length > 0) {\n                                console.log(\"Encontrados \".concat(timelineTracks.length, \" tracks en timeline.tracks\"));\n                                const trackId = timelineTracks[0].id;\n                                console.log(\"Usando primer track de timeline.tracks: \".concat(trackId));\n                                return trackId;\n                            }\n                        }\n                    } else {\n                        console.log(\"No se encontr\\xf3 timeline en el estado\");\n                    }\n                    // Estrategia 3: Buscar elementos activos y usar su trackId\n                    if (state.activeIds && state.activeIds.length > 0 && state.trackItemsMap) {\n                        const activeElement = state.trackItemsMap[state.activeIds[0]];\n                        if (activeElement && activeElement.trackId) {\n                            console.log(\"Usando trackId del elemento activo: \".concat(activeElement.trackId));\n                            return activeElement.trackId;\n                        }\n                    }\n                    // Estrategia 4: Explorar trackItemsMap para encontrar un tipo de track\n                    if (state.trackItemsMap && Object.keys(state.trackItemsMap).length > 0) {\n                        console.log(\"Explorando \".concat(Object.keys(state.trackItemsMap).length, \" elementos en trackItemsMap\"));\n                        // Buscar un elemento de tipo texto y usar su trackId\n                        const textItems = Object.values(state.trackItemsMap).filter((item)=>item.type === \"text\");\n                        if (textItems.length > 0) {\n                            const trackId = textItems[0].trackId;\n                            console.log(\"Encontrado trackId \".concat(trackId, \" de un elemento de texto existente\"));\n                            return trackId;\n                        }\n                        // Si no hay elementos de texto, usar el primer trackId disponible\n                        const firstItem = Object.values(state.trackItemsMap)[0];\n                        if (firstItem && firstItem.trackId) {\n                            console.log(\"Usando primer trackId disponible: \".concat(firstItem.trackId));\n                            return firstItem.trackId;\n                        }\n                    }\n                    // Estrategia 5: Buscar en otras propiedades del estado que podrían contener tracks\n                    for (const key of Object.keys(state)){\n                        if (typeof state[key] === \"object\" && state[key] !== null) {\n                            // Buscar propiedades que parezcan contener tracks\n                            if (state[key].tracks && Array.isArray(state[key].tracks) && state[key].tracks.length > 0) {\n                                console.log(\"Encontrados tracks en state.\".concat(key, \".tracks\"));\n                                const trackId = state[key].tracks[0].id;\n                                console.log(\"Usando track de state.\".concat(key, \".tracks: \").concat(trackId));\n                                return trackId;\n                            }\n                        }\n                    }\n                    console.log(\"No se encontr\\xf3 ning\\xfan track adecuado despu\\xe9s de intentar m\\xfaltiples estrategias\");\n                    return null;\n                };\n                // Cargar el archivo SRT\n                console.log(\"Cargando archivo SRT...\");\n                const response = await fetch(\"/transcriptions/transcription1.srt\");\n                if (!response.ok) {\n                    throw new Error(\"Error al cargar el archivo SRT: \".concat(response.status));\n                }\n                const srtContent = await response.text();\n                console.log(\"Archivo SRT cargado correctamente\");\n                // Parsear el archivo SRT\n                let segments = parseSRT(srtContent);\n                console.log(\"Se encontraron \".concat(segments.length, \" segmentos de subt\\xedtulos\"));\n                // Siempre usar el modo agrupado (dividir en grupos de 3 palabras)\n                segments = segments.flatMap(processSegment);\n                console.log(\"Despu\\xe9s de procesar, hay \".concat(segments.length, \" segmentos de subt\\xedtulos\"));\n                // Filtrar por tiempo si es necesario\n                if ((options === null || options === void 0 ? void 0 : options.startTime) !== undefined || (options === null || options === void 0 ? void 0 : options.endTime) !== undefined) {\n                    const originalLength = segments.length;\n                    segments = segments.filter((segment)=>{\n                        const passesStartFilter = options.startTime === undefined || segment.startTime >= options.startTime * 1000;\n                        const passesEndFilter = options.endTime === undefined || segment.endTime <= options.endTime * 1000;\n                        return passesStartFilter && passesEndFilter;\n                    });\n                    console.log(\"Filtrado por tiempo: de \".concat(originalLength, \" a \").concat(segments.length, \" segmentos\"));\n                }\n                // Obtener el ID del track para subtítulos\n                let trackId = getSubtitleTrackId();\n                // Enfoque adaptativo: si no hay un track identificado, agregar el primer subtítulo,\n                // obtener su trackId, y luego agregar el resto\n                if (!trackId && segments.length > 0) {\n                    console.log(\"No se identific\\xf3 un track adecuado. Usando enfoque adaptativo: a\\xf1adir primer subt\\xedtulo y obtener su trackId\");\n                    // Crear una promesa para manejar este proceso asíncrono\n                    return new Promise((resolve)=>{\n                        // Extraer el primer subtítulo\n                        const firstSegment = segments[0];\n                        const remainingSegments = segments.slice(1);\n                        console.log(\"A\\xf1adiendo primer subt\\xedtulo como elemento inicial para identificar un track...\");\n                        // Añadir el primer subtítulo\n                        (0,_designcombo_events__WEBPACK_IMPORTED_MODULE_0__.dispatch)(_designcombo_state__WEBPACK_IMPORTED_MODULE_1__.ADD_TEXT, {\n                            payload: createSubtitlePayload(firstSegment.text, firstSegment.startTime, firstSegment.endTime),\n                            options: {}\n                        });\n                        // Esperar 3 segundos para que el elemento se cree y esté disponible en el estado\n                        console.log(\"Esperando 3 segundos para que el primer subt\\xedtulo se cree completamente...\");\n                        setTimeout(()=>{\n                            // Obtener el estado actualizado\n                            const updatedState = stateManager.getState();\n                            // Buscar elementos de tipo texto recién añadidos\n                            let newTrackId = null;\n                            // Opciones para encontrar el nuevo trackId\n                            if (updatedState.trackItemsMap) {\n                                const textItems = Object.values(updatedState.trackItemsMap).filter((item)=>item.type === \"text\" && item.details && item.details.text === firstSegment.text.toUpperCase());\n                                if (textItems.length > 0) {\n                                    newTrackId = textItems[0].trackId;\n                                    console.log(\"Subt\\xedtulo identificado en track: \".concat(newTrackId));\n                                } else {\n                                    // Alternativa: buscar el elemento más reciente\n                                    const allItems = Object.values(updatedState.trackItemsMap);\n                                    if (allItems.length > 0) {\n                                        const mostRecentItem = allItems.sort((a, b)=>{\n                                            // Ordenar por timestamp de creación si existe, o por rango de tiempo\n                                            const aTime = a.timestamp || (a.display ? a.display.from : 0);\n                                            const bTime = b.timestamp || (b.display ? b.display.from : 0);\n                                            return bTime - aTime; // Orden descendente (más reciente primero)\n                                        })[0];\n                                        newTrackId = mostRecentItem.trackId;\n                                        console.log(\"Usando track del elemento m\\xe1s reciente: \".concat(newTrackId));\n                                    }\n                                }\n                            }\n                            // Marcar el primer subtítulo como añadido\n                            console.log(\"Primer subt\\xedtulo a\\xf1adido como referencia. Track identificado: \".concat(newTrackId || \"ninguno\"));\n                            // Si no se encontró trackId, intentar con el método original una vez más\n                            if (!newTrackId) {\n                                newTrackId = getSubtitleTrackId();\n                                console.log(\"Reintentando obtener trackId: \".concat(newTrackId || \"fallido\"));\n                            }\n                            // Añadir el resto de los subtítulos con el trackId identificado\n                            if (remainingSegments.length > 0) {\n                                console.log(\"A\\xf1adiendo los \".concat(remainingSegments.length, \" subt\\xedtulos restantes\").concat(newTrackId ? \" al track \".concat(newTrackId) : \"\", \"...\"));\n                                // Almacenar los tracks usados para detectar tracks secundarios\n                                const usedTracks = new Set();\n                                if (newTrackId) usedTracks.add(newTrackId);\n                                // Mapa para llevar registro de las posiciones y ocupación de tiempo por track\n                                const trackTimeMap = {};\n                                // Función para comprobar si un segmento se solapa con los existentes en un track\n                                const checkOverlap = (trackId, from, to)=>{\n                                    if (!trackTimeMap[trackId]) return false; // Si el track no tiene elementos, no hay solapamiento\n                                    return trackTimeMap[trackId].some((timeSlot)=>{\n                                        // Verificar si hay solapamiento (hay varias formas en que dos intervalos pueden superponerse)\n                                        return from >= timeSlot.from && from < timeSlot.to || // Inicio dentro de un slot existente\n                                        to > timeSlot.from && to <= timeSlot.to || // Fin dentro de un slot existente\n                                        from <= timeSlot.from && to >= timeSlot.to; // Abarca completamente un slot existente\n                                    });\n                                };\n                                // Función para añadir un registro de tiempo utilizado en un track\n                                const addTimeSlot = (trackId, from, to)=>{\n                                    if (!trackTimeMap[trackId]) {\n                                        trackTimeMap[trackId] = [];\n                                    }\n                                    trackTimeMap[trackId].push({\n                                        from,\n                                        to\n                                    });\n                                    // Ordenar para facilitar búsquedas futuras\n                                    trackTimeMap[trackId].sort((a, b)=>a.from - b.from);\n                                };\n                                // Para monitorear tracks adicionales que se creen\n                                const checkForNewTracks = (prevState, currentState)=>{\n                                    if (!currentState.trackItemsMap) return null;\n                                    // Buscar elementos nuevos que no estaban en el estado anterior\n                                    const prevItems = prevState.trackItemsMap ? Object.keys(prevState.trackItemsMap) : [];\n                                    const currentItems = Object.keys(currentState.trackItemsMap);\n                                    // Encontrar los IDs de elementos nuevos\n                                    const newItemIds = currentItems.filter((id)=>!prevItems.includes(id));\n                                    if (newItemIds.length === 0) return null;\n                                    // Obtener información de los nuevos elementos\n                                    const newItems = newItemIds.map((id)=>currentState.trackItemsMap[id]);\n                                    // Buscar trackIds que no hayamos visto antes\n                                    for (const item of newItems){\n                                        if (item.trackId && !usedTracks.has(item.trackId)) {\n                                            console.log(\"Detectado nuevo track secundario: \".concat(item.trackId));\n                                            usedTracks.add(item.trackId);\n                                            return item.trackId;\n                                        }\n                                    }\n                                    return null;\n                                };\n                                // Procesar los subtítulos restantes con seguimiento de estado\n                                let currentState = updatedState;\n                                let recentTrackId = newTrackId;\n                                const processSegmentWithTracking = (index)=>{\n                                    if (index >= remainingSegments.length) {\n                                        console.log(\"Proceso de a\\xf1adir subt\\xedtulos completado con \\xe9xito\");\n                                        resolve(true);\n                                        return;\n                                    }\n                                    const segment = remainingSegments[index];\n                                    const from = segment.startTime;\n                                    const to = segment.endTime;\n                                    // Comprobar superposición en los tracks disponibles\n                                    let selectedTrackId = recentTrackId;\n                                    // Verificar si hay superposición en el track principal\n                                    let hasOverlap = selectedTrackId ? checkOverlap(selectedTrackId, from, to) : false;\n                                    // Si hay superposición, buscar otro track donde no haya superposición\n                                    if (hasOverlap) {\n                                        console.log(\"Superposici\\xf3n detectada en track \".concat(selectedTrackId, \" para el segmento \").concat(index + 1));\n                                        // Intentar otros tracks que ya conocemos\n                                        let foundNonOverlappingTrack = false;\n                                        for (const trackId of usedTracks){\n                                            if (trackId !== selectedTrackId && !checkOverlap(trackId, from, to)) {\n                                                console.log(\"Usando track alternativo \".concat(trackId, \" para evitar superposici\\xf3n\"));\n                                                selectedTrackId = trackId;\n                                                foundNonOverlappingTrack = true;\n                                                break;\n                                            }\n                                        }\n                                        // Si no se encontró un track sin superposición, mantener el original\n                                        // El sistema podría crear un nuevo track automáticamente\n                                        if (!foundNonOverlappingTrack) {\n                                            console.log(\"No se encontr\\xf3 track alternativo, permitiendo que el sistema cree uno nuevo\");\n                                        }\n                                    }\n                                    // Copiar el estado actual antes de la acción\n                                    const prevState = {\n                                        ...currentState\n                                    };\n                                    console.log(\"A\\xf1adiendo subt\\xedtulo \".concat(index + 1, \"/\").concat(remainingSegments.length, \" al track \").concat(selectedTrackId || \"autom\\xe1tico\"));\n                                    // Añadir el subtítulo\n                                    (0,_designcombo_events__WEBPACK_IMPORTED_MODULE_0__.dispatch)(_designcombo_state__WEBPACK_IMPORTED_MODULE_1__.ADD_TEXT, {\n                                        payload: createSubtitlePayload(segment.text, from, to),\n                                        options: selectedTrackId ? {\n                                            trackId: selectedTrackId\n                                        } : {}\n                                    });\n                                    // Esperar un poco para que se actualice el estado\n                                    setTimeout(()=>{\n                                        // Obtener estado actualizado\n                                        currentState = stateManager.getState();\n                                        // Comprobar si se ha creado un nuevo track\n                                        const newTrack = checkForNewTracks(prevState, currentState);\n                                        if (newTrack) {\n                                            console.log(\"El sistema ha creado un nuevo track: \".concat(newTrack));\n                                            recentTrackId = newTrack;\n                                        // No necesitamos registrar el tiempo en el track anterior\n                                        // ya que el sistema movió el elemento a un nuevo track\n                                        } else {\n                                            // Registrar el tiempo ocupado en el track utilizado\n                                            addTimeSlot(selectedTrackId, from, to);\n                                        }\n                                        // Reportar progreso\n                                        if ((index + 1) % 10 === 0 || index === remainingSegments.length - 1) {\n                                            console.log(\"Progreso: \".concat(index + 1, \"/\").concat(remainingSegments.length, \" subt\\xedtulos adicionales a\\xf1adidos\"));\n                                            console.log(\"Tracks utilizados hasta ahora: \".concat(Array.from(usedTracks).join(\", \")));\n                                        }\n                                        // Procesar el siguiente segmento\n                                        processSegmentWithTracking(index + 1);\n                                    }, 200); // Pequeña espera para que el estado se actualice\n                                };\n                                // Iniciar el procesamiento del primer segmento restante\n                                processSegmentWithTracking(0);\n                            } else {\n                                console.log(\"No hay subt\\xedtulos adicionales para a\\xf1adir\");\n                                resolve(true);\n                            }\n                        }, 3000); // Esperar 3 segundos\n                    });\n                }\n                // Enfoque original si ya tenemos un trackId identificado\n                console.log(\"A\\xf1adiendo \".concat(segments.length, \" segmentos de subt\\xedtulos al timeline\").concat(trackId ? \" en el track \".concat(trackId) : \"\", \"...\"));\n                // Crear una promesa para el enfoque tradicional\n                return new Promise((resolve)=>{\n                    let completedCount = 0;\n                    // Almacenar los tracks usados para detectar tracks secundarios\n                    const usedTracks = new Set();\n                    if (trackId) usedTracks.add(trackId);\n                    // Mapa para llevar registro de las posiciones y ocupación de tiempo por track\n                    const trackTimeMap = {};\n                    // Función para comprobar si un segmento se solapa con los existentes en un track\n                    const checkOverlap = (trackId, from, to)=>{\n                        if (!trackTimeMap[trackId]) return false; // Si el track no tiene elementos, no hay solapamiento\n                        return trackTimeMap[trackId].some((timeSlot)=>{\n                            // Verificar si hay solapamiento\n                            return from >= timeSlot.from && from < timeSlot.to || // Inicio dentro de un slot existente\n                            to > timeSlot.from && to <= timeSlot.to || // Fin dentro de un slot existente\n                            from <= timeSlot.from && to >= timeSlot.to; // Abarca completamente un slot existente\n                        });\n                    };\n                    // Función para añadir un registro de tiempo utilizado en un track\n                    const addTimeSlot = (trackId, from, to)=>{\n                        if (!trackTimeMap[trackId]) {\n                            trackTimeMap[trackId] = [];\n                        }\n                        trackTimeMap[trackId].push({\n                            from,\n                            to\n                        });\n                        // Ordenar para facilitar búsquedas futuras\n                        trackTimeMap[trackId].sort((a, b)=>a.from - b.from);\n                    };\n                    // Para monitorear tracks adicionales que se creen\n                    const checkForNewTracks = (prevState, currentState)=>{\n                        if (!currentState.trackItemsMap) return null;\n                        // Buscar elementos nuevos que no estaban en el estado anterior\n                        const prevItems = prevState.trackItemsMap ? Object.keys(prevState.trackItemsMap) : [];\n                        const currentItems = Object.keys(currentState.trackItemsMap);\n                        // Encontrar los IDs de elementos nuevos\n                        const newItemIds = currentItems.filter((id)=>!prevItems.includes(id));\n                        if (newItemIds.length === 0) return null;\n                        // Obtener información de los nuevos elementos\n                        const newItems = newItemIds.map((id)=>currentState.trackItemsMap[id]);\n                        // Buscar trackIds que no hayamos visto antes\n                        for (const item of newItems){\n                            if (item.trackId && !usedTracks.has(item.trackId)) {\n                                console.log(\"Detectado nuevo track secundario: \".concat(item.trackId));\n                                usedTracks.add(item.trackId);\n                                return item.trackId;\n                            }\n                        }\n                        return null;\n                    };\n                    // Procesar los subtítulos con seguimiento de estado\n                    let currentState = stateManager.getState();\n                    let recentTrackId = trackId;\n                    const processSegmentWithTracking = (index)=>{\n                        if (index >= segments.length) {\n                            console.log(\"Proceso de a\\xf1adir subt\\xedtulos completado con \\xe9xito\");\n                            console.log(\"Tracks utilizados: \".concat(Array.from(usedTracks).join(\", \")));\n                            resolve(true);\n                            return;\n                        }\n                        const segment = segments[index];\n                        const from = segment.startTime;\n                        const to = segment.endTime;\n                        // Comprobar superposición en los tracks disponibles\n                        let selectedTrackId = recentTrackId;\n                        // Verificar si hay superposición en el track principal\n                        let hasOverlap = selectedTrackId ? checkOverlap(selectedTrackId, from, to) : false;\n                        // Si hay superposición, buscar otro track donde no haya superposición\n                        if (hasOverlap) {\n                            console.log(\"Superposici\\xf3n detectada en track \".concat(selectedTrackId, \" para el segmento \").concat(index + 1));\n                            // Intentar otros tracks que ya conocemos\n                            let foundNonOverlappingTrack = false;\n                            for (const trackId of usedTracks){\n                                if (trackId !== selectedTrackId && !checkOverlap(trackId, from, to)) {\n                                    console.log(\"Usando track alternativo \".concat(trackId, \" para evitar superposici\\xf3n\"));\n                                    selectedTrackId = trackId;\n                                    foundNonOverlappingTrack = true;\n                                    break;\n                                }\n                            }\n                            // Si no se encontró un track sin superposición, mantener el original\n                            // El sistema podría crear un nuevo track automáticamente\n                            if (!foundNonOverlappingTrack) {\n                                console.log(\"No se encontr\\xf3 track alternativo, permitiendo que el sistema cree uno nuevo\");\n                            }\n                        }\n                        // Copiar el estado actual antes de la acción\n                        const prevState = {\n                            ...currentState\n                        };\n                        console.log(\"A\\xf1adiendo subt\\xedtulo \".concat(index + 1, \"/\").concat(segments.length, \" al track \").concat(selectedTrackId || \"autom\\xe1tico\"));\n                        // Añadir el subtítulo\n                        (0,_designcombo_events__WEBPACK_IMPORTED_MODULE_0__.dispatch)(_designcombo_state__WEBPACK_IMPORTED_MODULE_1__.ADD_TEXT, {\n                            payload: createSubtitlePayload(segment.text, from, to),\n                            options: selectedTrackId ? {\n                                trackId: selectedTrackId\n                            } : {}\n                        });\n                        // Esperar un poco para que se actualice el estado\n                        setTimeout(()=>{\n                            // Obtener estado actualizado\n                            currentState = stateManager.getState();\n                            // Comprobar si se ha creado un nuevo track\n                            const newTrack = checkForNewTracks(prevState, currentState);\n                            if (newTrack) {\n                                console.log(\"El sistema ha creado un nuevo track: \".concat(newTrack));\n                                recentTrackId = newTrack;\n                            // No necesitamos registrar el tiempo en el track anterior\n                            // ya que el sistema movió el elemento a un nuevo track\n                            } else {\n                                // Registrar el tiempo ocupado en el track utilizado\n                                if (selectedTrackId) {\n                                    addTimeSlot(selectedTrackId, from, to);\n                                }\n                            }\n                            // Reportar progreso\n                            completedCount++;\n                            if (completedCount % 10 === 0 || completedCount === segments.length) {\n                                console.log(\"Progreso: \".concat(completedCount, \"/\").concat(segments.length, \" subt\\xedtulos a\\xf1adidos\"));\n                            }\n                            // Procesar el siguiente segmento\n                            processSegmentWithTracking(index + 1);\n                        }, 200); // Pequeña espera para que el estado se actualice\n                    };\n                    // Iniciar el procesamiento del primer segmento\n                    processSegmentWithTracking(0);\n                });\n            } catch (error) {\n                console.error(\"Error al a\\xf1adir subt\\xedtulos:\", error);\n                return false;\n            }\n        },\n        getActiveElements: async ()=>{\n            try {\n                // Obtener el estado actual\n                const state = stateManager.getState();\n                // Verificar si hay IDs activos\n                if (!state.activeIds || state.activeIds.length === 0) {\n                    console.log(\"No hay elementos activos seleccionados\");\n                    return [];\n                }\n                // Verificar si hay elementos en el trackItemsMap\n                if (!state.trackItemsMap) {\n                    console.log(\"No hay trackItemsMap disponible\");\n                    return [];\n                }\n                // Obtener información de los elementos activos\n                const activeElements = state.activeIds.filter((id)=>state.trackItemsMap[id]).map((id)=>{\n                    var _item_display, _item_display1;\n                    const item = state.trackItemsMap[id];\n                    return {\n                        id,\n                        trackId: item.trackId,\n                        type: item.type,\n                        from: (_item_display = item.display) === null || _item_display === void 0 ? void 0 : _item_display.from,\n                        to: (_item_display1 = item.display) === null || _item_display1 === void 0 ? void 0 : _item_display1.to,\n                        duration: item.display ? item.display.to - item.display.from : 0,\n                        details: item.details\n                    };\n                });\n                console.log(\"Se encontraron \".concat(activeElements.length, \" elementos activos\"));\n                return activeElements;\n            } catch (error) {\n                console.error(\"Error al obtener elementos activos:\", error);\n                return [];\n            }\n        },\n        getAllTimelineElements: async ()=>{\n            try {\n                // Obtener el estado actual\n                const state = stateManager.getState();\n                // Verificar si hay elementos en el trackItemsMap\n                if (!state.trackItemsMap || Object.keys(state.trackItemsMap).length === 0) {\n                    console.log(\"No hay elementos en el trackItemsMap\");\n                    // Buscar elementos en otras propiedades del estado\n                    for (const key of Object.keys(state)){\n                        if (typeof state[key] === \"object\" && state[key] !== null) {\n                            const objValue = state[key];\n                            console.log(\"Explorando propiedad alternativa: \".concat(key));\n                            // Verificar si parece ser un mapa de elementos\n                            if (Object.keys(objValue).length > 0) {\n                                const sample = objValue[Object.keys(objValue)[0]];\n                                if (sample && sample.display && sample.type) {\n                                    console.log(\"Encontrada posible fuente alternativa de elementos en propiedad \".concat(key));\n                                    // Procesar elementos de esta propiedad alternativa\n                                    return Object.entries(objValue).filter((param)=>{\n                                        let [_, item] = param;\n                                        return item && item.display;\n                                    }).map((param)=>{\n                                        let [id, item] = param;\n                                        var _item_display, _item_display1;\n                                        return {\n                                            id,\n                                            trackId: item.trackId,\n                                            type: item.type,\n                                            from: (_item_display = item.display) === null || _item_display === void 0 ? void 0 : _item_display.from,\n                                            to: (_item_display1 = item.display) === null || _item_display1 === void 0 ? void 0 : _item_display1.to,\n                                            duration: item.display ? item.display.to - item.display.from : 0,\n                                            details: item.details\n                                        };\n                                    });\n                                }\n                            }\n                        }\n                    }\n                    return [];\n                }\n                // Obtener todos los elementos\n                const allElements = Object.entries(state.trackItemsMap).filter((param)=>{\n                    let [_, item] = param;\n                    return item && item.display;\n                }).map((param)=>{\n                    let [id, item] = param;\n                    var _item_display, _item_display1;\n                    return {\n                        id,\n                        trackId: item.trackId,\n                        type: item.type,\n                        from: (_item_display = item.display) === null || _item_display === void 0 ? void 0 : _item_display.from,\n                        to: (_item_display1 = item.display) === null || _item_display1 === void 0 ? void 0 : _item_display1.to,\n                        duration: item.display ? item.display.to - item.display.from : 0,\n                        details: item.details\n                    };\n                }).sort((a, b)=>(a.from || 0) - (b.from || 0));\n                console.log(\"Se encontraron \".concat(allElements.length, \" elementos en el timeline\"));\n                return allElements;\n            } catch (error) {\n                console.error(\"Error al obtener todos los elementos del timeline:\", error);\n                return [];\n            }\n        },\n        removeSegments: async (segments)=>{\n            try {\n                console.log(\"Iniciando eliminaci\\xf3n de segmentos m\\xfaltiples\");\n                // Obtener el estado actual\n                const state = stateManager.getState();\n                // Validar que haya elementos en la timeline\n                if (!state.activeIds || state.activeIds.length === 0) {\n                    console.error(\"No hay elementos seleccionados en la timeline\");\n                    // Buscar el primer elemento disponible en la timeline\n                    const trackItemsMap = state.trackItemsMap || {};\n                    const trackItems = Object.keys(trackItemsMap);\n                    if (trackItems.length === 0) {\n                        console.error(\"No hay elementos en la timeline para eliminar segmentos\");\n                        throw new Error(\"No hay elementos en la timeline\");\n                    }\n                    // Seleccionar el primer elemento disponible\n                    const firstItemId = trackItems[0];\n                    console.log(\"Seleccionando autom\\xe1ticamente el elemento con ID: \".concat(firstItemId));\n                    (0,_designcombo_events__WEBPACK_IMPORTED_MODULE_0__.dispatch)(_designcombo_state__WEBPACK_IMPORTED_MODULE_1__.LAYER_SELECT, {\n                        payload: {\n                            ids: [\n                                firstItemId\n                            ]\n                        }\n                    });\n                    // Esperar a que se aplique la selección\n                    await new Promise((resolve)=>setTimeout(resolve, 300));\n                }\n                // Almacenamos información del elemento seleccionado\n                const currentState = stateManager.getState();\n                if (!currentState.activeIds || currentState.activeIds.length === 0) {\n                    throw new Error(\"No se pudo seleccionar ning\\xfan elemento en la timeline\");\n                }\n                const originalItemId = currentState.activeIds[0];\n                const originalItem = currentState.trackItemsMap[originalItemId];\n                const trackType = originalItem.type;\n                const trackId = originalItem.trackId;\n                console.log(\"Elemento seleccionado: ID=\".concat(originalItemId, \", tipo=\").concat(trackType, \", trackId=\").concat(trackId));\n                // Procesar cada segmento en orden (de final a principio para evitar afectar posiciones)\n                for(let i = segments.length - 1; i >= 0; i--){\n                    const segment = segments[i];\n                    console.log(\"Procesando segmento \".concat(i + 1, \"/\").concat(segments.length, \": \").concat(segment.startTime, \"s - \").concat(segment.endTime, \"s\"));\n                    try {\n                        // PASO 1: Hacer un corte en el tiempo final\n                        const endMs = segment.endTime * 1000;\n                        (0,_designcombo_events__WEBPACK_IMPORTED_MODULE_0__.dispatch)(_designcombo_state__WEBPACK_IMPORTED_MODULE_1__.ACTIVE_SPLIT, {\n                            payload: {},\n                            options: {\n                                time: endMs\n                            }\n                        });\n                        console.log(\"Paso 1: Corte aplicado en tiempo final \".concat(segment.endTime, \"s\"));\n                        // Esperar a que se procese el primer corte\n                        await new Promise((resolve)=>setTimeout(resolve, 500));\n                        // Obtenemos el estado después del primer corte\n                        const stateAfterFirstCut = stateManager.getState();\n                        const elementsAfterFirstCut = Object.entries(stateAfterFirstCut.trackItemsMap).filter((param)=>{\n                            let [_, item] = param;\n                            return item.type === trackType && item.trackId === trackId && item.display && !isNaN(item.display.from) && !isNaN(item.display.to);\n                        }).map((param)=>{\n                            let [id, item] = param;\n                            return {\n                                id,\n                                from: item.display.from,\n                                to: item.display.to,\n                                duración: item.display.to - item.display.from\n                            };\n                        }).sort((a, b)=>a.from - b.from);\n                        console.log(\"Elementos despu\\xe9s del primer corte:\", elementsAfterFirstCut);\n                        // PASO 2: Identificar el elemento izquierdo que contiene el tiempo inicial\n                        const startMs = segment.startTime * 1000;\n                        const leftElement = elementsAfterFirstCut.find((elem)=>elem.from <= startMs && elem.to >= startMs);\n                        if (!leftElement) {\n                            console.error(\"No se pudo identificar el elemento izquierdo para el segmento \".concat(i + 1));\n                            continue;\n                        }\n                        console.log(\"Paso 2: Elemento izquierdo identificado (ID: \".concat(leftElement.id, \")\"));\n                        // PASO 3: Seleccionar el elemento izquierdo y hacer corte en tiempo inicial\n                        (0,_designcombo_events__WEBPACK_IMPORTED_MODULE_0__.dispatch)(_designcombo_state__WEBPACK_IMPORTED_MODULE_1__.LAYER_SELECT, {\n                            payload: {\n                                ids: [\n                                    leftElement.id\n                                ]\n                            }\n                        });\n                        // Esperar a que se aplique la selección\n                        await new Promise((resolve)=>setTimeout(resolve, 300));\n                        // Aplicar el corte en el tiempo inicial\n                        (0,_designcombo_events__WEBPACK_IMPORTED_MODULE_0__.dispatch)(_designcombo_state__WEBPACK_IMPORTED_MODULE_1__.ACTIVE_SPLIT, {\n                            payload: {},\n                            options: {\n                                time: startMs\n                            }\n                        });\n                        console.log(\"Paso 3: Segundo corte aplicado en tiempo inicial \".concat(segment.startTime, \"s\"));\n                        // Esperar a que se procese el segundo corte\n                        await new Promise((resolve)=>setTimeout(resolve, 500));\n                        // Obtenemos el estado después del segundo corte\n                        const stateAfterSecondCut = stateManager.getState();\n                        const elementsAfterSecondCut = Object.entries(stateAfterSecondCut.trackItemsMap).filter((param)=>{\n                            let [_, item] = param;\n                            return item.type === trackType && item.trackId === trackId && item.display && !isNaN(item.display.from) && !isNaN(item.display.to);\n                        }).map((param)=>{\n                            let [id, item] = param;\n                            return {\n                                id,\n                                from: item.display.from,\n                                to: item.display.to,\n                                duración: item.display.to - item.display.from\n                            };\n                        }).sort((a, b)=>a.from - b.from);\n                        console.log(\"Elementos despu\\xe9s del segundo corte:\", elementsAfterSecondCut);\n                        // PASO 4: Identificar el elemento del medio usando criterios más precisos\n                        const middleElements = elementsAfterSecondCut.filter((elem)=>Math.abs(elem.from - startMs) < 50 && Math.abs(elem.to - endMs) < 50);\n                        console.log(\"Elementos que coinciden con los criterios del medio:\", middleElements);\n                        if (middleElements.length === 0) {\n                            console.error(\"No se pudo identificar el elemento del medio para el segmento \".concat(i + 1));\n                            continue;\n                        }\n                        // Si hay más de un elemento que coincide, tomamos el primero\n                        const middleElement = middleElements[0];\n                        console.log(\"Paso 4: Elemento del medio identificado (ID: \".concat(middleElement.id, \")\"));\n                        // PASO 5: Seleccionar y eliminar el elemento del medio\n                        (0,_designcombo_events__WEBPACK_IMPORTED_MODULE_0__.dispatch)(_designcombo_state__WEBPACK_IMPORTED_MODULE_1__.LAYER_SELECT, {\n                            payload: {\n                                ids: [\n                                    middleElement.id\n                                ]\n                            }\n                        });\n                        // Esperar a que se aplique la selección\n                        await new Promise((resolve)=>setTimeout(resolve, 300));\n                        // Verificar que el elemento está seleccionado antes de eliminarlo\n                        const currentState = stateManager.getState();\n                        if (currentState.activeIds && currentState.activeIds.includes(middleElement.id)) {\n                            console.log(\"Elemento del medio correctamente seleccionado, procediendo con eliminaci\\xf3n\");\n                            (0,_designcombo_events__WEBPACK_IMPORTED_MODULE_0__.dispatch)(_designcombo_state__WEBPACK_IMPORTED_MODULE_1__.LAYER_DELETE);\n                            console.log(\"Elemento eliminado correctamente: \".concat(middleElement.id));\n                        } else {\n                            console.log(\"No se pudo seleccionar normalmente, intentando m\\xe9todo alternativo\");\n                            // Enfoque alternativo: Usar el EDIT_OBJECT para \"ocultar\" el segmento\n                            (0,_designcombo_events__WEBPACK_IMPORTED_MODULE_0__.dispatch)(_designcombo_state__WEBPACK_IMPORTED_MODULE_1__.EDIT_OBJECT, {\n                                payload: {\n                                    [middleElement.id]: {\n                                        display: {\n                                            from: -99999,\n                                            to: -99990\n                                        },\n                                        visible: false // Adicionalmente marcarlo como no visible\n                                    }\n                                }\n                            });\n                            console.log(\"Aplicado m\\xe9todo alternativo para ocultar el segmento\");\n                        }\n                        // Esperar a que se procese la eliminación\n                        await new Promise((resolve)=>setTimeout(resolve, 500));\n                    } catch (error) {\n                        console.error(\"Error al procesar el segmento \".concat(i + 1, \":\"), error);\n                    }\n                    // Pausa entre segmentos\n                    await new Promise((resolve)=>setTimeout(resolve, 500));\n                }\n                // Actualizar la escala para refrescar la vista\n                const { scale } = stateManager.getState();\n                if (scale) {\n                    console.log(\"Actualizando escala para refrescar la vista\");\n                    // Guardar el valor actual de scale.unit\n                    const originalUnit = scale.unit;\n                    // Incrementar el valor\n                    scale.unit += 1;\n                    console.log(\"Scale cambiada: \".concat(originalUnit, \" -> \").concat(scale.unit));\n                    // Asegurar que el cambio sea notado por el sistema\n                    (0,_designcombo_events__WEBPACK_IMPORTED_MODULE_0__.dispatch)(_designcombo_state__WEBPACK_IMPORTED_MODULE_1__.TIMELINE_SCALE_CHANGED, {\n                        payload: {\n                            scale: {\n                                ...scale,\n                                unit: scale.unit // Explícitamente establecer el nuevo valor\n                            }\n                        }\n                    });\n                    // Forzar una actualización adicional volviendo al valor original después de un momento\n                    setTimeout(()=>{\n                        const currentState = stateManager.getState();\n                        if (currentState.scale) {\n                            (0,_designcombo_events__WEBPACK_IMPORTED_MODULE_0__.dispatch)(_designcombo_state__WEBPACK_IMPORTED_MODULE_1__.TIMELINE_SCALE_CHANGED, {\n                                payload: {\n                                    scale: {\n                                        ...currentState.scale,\n                                        unit: originalUnit // Volver al valor original\n                                    }\n                                }\n                            });\n                            console.log(\"Restaurado scale a valor original: \".concat(originalUnit));\n                        }\n                    }, 300);\n                }\n                console.log(\"Eliminaci\\xf3n de segmentos completada\");\n                return true;\n            } catch (error) {\n                console.error(\"Error al eliminar segmentos:\", error);\n                return false;\n            }\n        },\n        compactTimeline: async ()=>{\n            try {\n                console.log(\"=== INICIANDO COMPACTACI\\xd3N DE L\\xcdNEA DE TIEMPO DESDE IA ===\");\n                // Obtener el estado actual\n                const estado = stateManager.getState();\n                console.log(\"Estado para compactaci\\xf3n:\", Object.keys(estado));\n                // Añadir un tiempo de espera inicial para asegurar que el estado está actualizado\n                console.log(\"Esperando 1 segundo para asegurar consistencia del estado...\");\n                await new Promise((resolve)=>setTimeout(resolve, 1000));\n                // Verificación adicional para asegurarnos que los cambios en la timeline ya se aplicaron\n                console.log(\"Verificando que los elementos en la timeline reflejen los cambios m\\xe1s recientes...\");\n                // Pequeña pausa adicional para asegurar consistencia del estado\n                await new Promise((resolve)=>setTimeout(resolve, 500));\n                // Buscar los elementos del timeline - usando la referencia al método dentro del mismo objeto\n                const todosElementos = await executor.getAllTimelineElements();\n                console.log(\"Encontrados \".concat(todosElementos.length, \" elementos en la timeline\"));\n                // Logging de elementos para diagnóstico\n                todosElementos.forEach((elem, index)=>{\n                    console.log(\"Elemento \".concat(index + 1, \": ID=\").concat(elem.id, \", Tipo=\").concat(elem.type, \", Track=\").concat(elem.trackId, \", Tiempo=\").concat(elem.from, \"ms-\").concat(elem.to, \"ms (duraci\\xf3n=\").concat(elem.to - elem.from, \"ms)\"));\n                });\n                // Si no hay elementos, no podemos compactar\n                if (todosElementos.length === 0) {\n                    console.log(\"No hay elementos en el timeline para compactar\");\n                    return false;\n                }\n                // Agrupar elementos por track para análisis\n                const elementosPorTrack = {};\n                todosElementos.forEach((elem)=>{\n                    if (elem.trackId) {\n                        if (!elementosPorTrack[elem.trackId]) {\n                            elementosPorTrack[elem.trackId] = [];\n                        }\n                        elementosPorTrack[elem.trackId].push(elem);\n                    }\n                });\n                // Ordenar elementos en cada track por tiempo\n                Object.keys(elementosPorTrack).forEach((trackId)=>{\n                    elementosPorTrack[trackId].sort((a, b)=>a.from - b.from);\n                });\n                console.log(\"Elementos agrupados por track:\", Object.keys(elementosPorTrack).length);\n                // Logging de tracks para diagnóstico\n                Object.keys(elementosPorTrack).forEach((trackId)=>{\n                    console.log(\"Track \".concat(trackId, \": \").concat(elementosPorTrack[trackId].length, \" elementos\"));\n                    // Mostrar los elementos en este track ordenados\n                    elementosPorTrack[trackId].forEach((elem, idx)=>{\n                        console.log(\"  \".concat(idx + 1, \". ID=\").concat(elem.id.substring(0, 8), \"... Tiempo=\").concat(elem.from, \"ms-\").concat(elem.to, \"ms (duraci\\xf3n: \").concat(elem.to - elem.from, \"ms)\"));\n                    });\n                });\n                // Buscar espacios vacíos en cada track\n                const espaciosVacios = [];\n                Object.keys(elementosPorTrack).forEach((trackId)=>{\n                    const elementos = elementosPorTrack[trackId];\n                    // Si hay al menos 2 elementos, podemos buscar espacios\n                    if (elementos.length >= 2) {\n                        for(let i = 0; i < elementos.length - 1; i++){\n                            const elementoActual = elementos[i];\n                            const elementoSiguiente = elementos[i + 1];\n                            // Verificar si hay un espacio entre el fin del elemento actual y el inicio del siguiente\n                            const espacio = elementoSiguiente.from - elementoActual.to;\n                            // Si el espacio es significativo (más de 100ms)\n                            if (espacio > 100) {\n                                espaciosVacios.push({\n                                    trackId,\n                                    start: elementoActual.to,\n                                    end: elementoSiguiente.from,\n                                    size: espacio,\n                                    elementoAntes: elementoActual.id,\n                                    elementoDespues: elementoSiguiente.id\n                                });\n                                console.log(\"Encontrado espacio de \".concat(espacio, \"ms (\").concat(espacio / 1000, \"s) en track \").concat(trackId, \" entre elementos \").concat(elementoActual.id.substring(0, 8), \"... y \").concat(elementoSiguiente.id.substring(0, 8), \"...\"));\n                            }\n                        }\n                    }\n                });\n                console.log(\"Se encontraron \".concat(espaciosVacios.length, \" espacios vac\\xedos\"));\n                // Si no hay espacios, no necesitamos compactar\n                if (espaciosVacios.length === 0) {\n                    console.log(\"No hay espacios significativos para compactar\");\n                    return true; // Devolvemos true porque técnicamente está compactado\n                }\n                // Ordenar espacios por posición (de izquierda a derecha)\n                espaciosVacios.sort((a, b)=>a.start - b.start);\n                // Calcular el espacio total a compactar\n                let espacioTotal = 0;\n                espaciosVacios.forEach((espacio)=>{\n                    espacioTotal += espacio.size;\n                });\n                console.log(\"Espacio total a compactar: \".concat(espacioTotal, \"ms (\").concat(espacioTotal / 1000, \"s)\"));\n                console.log(\"Preparando actualizaciones para \".concat(todosElementos.length, \" elementos...\"));\n                // Preparar actualizaciones para cada elemento\n                const actualizaciones = {};\n                let elementosAMover = 0;\n                // Para cada elemento, calculamos el desplazamiento basado en los espacios anteriores\n                todosElementos.forEach((elemento)=>{\n                    let desplazamiento = 0;\n                    // Calcular cuánto debe moverse basado en los espacios vacíos anteriores\n                    for (const espacio of espaciosVacios){\n                        // Si el elemento está después del espacio vacío, debe moverse\n                        if (elemento.from > espacio.end) {\n                            desplazamiento += espacio.size;\n                        }\n                    }\n                    // Si hay desplazamiento, añadir a las actualizaciones\n                    if (desplazamiento > 0) {\n                        const nuevoFrom = elemento.from - desplazamiento;\n                        const nuevoTo = elemento.to - desplazamiento;\n                        console.log(\"Elemento \".concat(elemento.id.substring(0, 8), \"... se mover\\xe1: \").concat(elemento.from, \"ms -> \").concat(nuevoFrom, \"ms (desplazamiento: \").concat(desplazamiento, \"ms)\"));\n                        actualizaciones[elemento.id] = {\n                            display: {\n                                from: nuevoFrom,\n                                to: nuevoTo\n                            }\n                        };\n                        elementosAMover++;\n                    }\n                });\n                console.log(\"Elementos a mover: \".concat(elementosAMover, \" de \").concat(todosElementos.length, \" total\"));\n                // Aplicar las actualizaciones\n                if (elementosAMover > 0) {\n                    console.log(\"Aplicando actualizaciones para compactar timeline...\");\n                    try {\n                        (0,_designcombo_events__WEBPACK_IMPORTED_MODULE_0__.dispatch)(_designcombo_state__WEBPACK_IMPORTED_MODULE_1__.EDIT_OBJECT, {\n                            payload: actualizaciones\n                        });\n                        console.log(\"Actualizaciones aplicadas con \\xe9xito\");\n                    } catch (error) {\n                        console.error(\"Error al aplicar actualizaciones:\", error);\n                        return false;\n                    }\n                    // Refrescar la vista\n                    setTimeout(()=>{\n                        try {\n                            const { scale } = stateManager.getState();\n                            if (scale) {\n                                // Hacer un pequeño cambio en la escala para forzar la actualización\n                                const updatedScale = {\n                                    ...scale\n                                };\n                                if (typeof updatedScale.unit === \"number\") {\n                                    updatedScale.unit = (updatedScale.unit || 0) + 1;\n                                    (0,_designcombo_events__WEBPACK_IMPORTED_MODULE_0__.dispatch)(_designcombo_state__WEBPACK_IMPORTED_MODULE_1__.TIMELINE_SCALE_CHANGED, {\n                                        payload: {\n                                            scale: updatedScale\n                                        }\n                                    });\n                                    // Volver a la escala original\n                                    setTimeout(()=>{\n                                        const currentScale = {\n                                            ...stateManager.getState().scale\n                                        };\n                                        currentScale.unit = (currentScale.unit || 1) - 1;\n                                        (0,_designcombo_events__WEBPACK_IMPORTED_MODULE_0__.dispatch)(_designcombo_state__WEBPACK_IMPORTED_MODULE_1__.TIMELINE_SCALE_CHANGED, {\n                                            payload: {\n                                                scale: currentScale\n                                            }\n                                        });\n                                    }, 300);\n                                }\n                            }\n                        } catch (error) {\n                            console.error(\"Error al refrescar la vista:\", error);\n                        }\n                    }, 500);\n                    console.log(\"Compactaci\\xf3n completada con \\xe9xito\");\n                    return true;\n                } else {\n                    console.log(\"No hay elementos que necesiten moverse\");\n                    return true;\n                }\n            } catch (error) {\n                console.error(\"Error al compactar la l\\xednea de tiempo:\", error);\n                return false;\n            }\n        },\n        smartTrim: async ()=>{\n            try {\n                console.log(\"=== INICIANDO PROCESO DE RECORTE INTELIGENTE DESDE IA ===\");\n                // 1. Realizar la llamada al API para analizar la transcripción\n                console.log(\"Solicitando an\\xe1lisis de transcripci\\xf3n...\");\n                const response = await fetch(\"/api/smart-trim\");\n                if (!response.ok) {\n                    throw new Error(\"Error al analizar la transcripci\\xf3n: \".concat(response.status));\n                }\n                const data = await response.json();\n                console.log(\"An\\xe1lisis de transcripci\\xf3n completado:\", data);\n                if (!data.removeSegments || !Array.isArray(data.removeSegments) || data.removeSegments.length === 0) {\n                    console.log(\"No se encontraron segmentos para eliminar\");\n                    return false;\n                }\n                // 2. Convertir los segmentos al formato que espera removeSegments\n                const segments = data.removeSegments.map((segment)=>({\n                        startTime: segment.startTime,\n                        endTime: segment.endTime // Ya está en segundos\n                    }));\n                console.log(\"Se eliminar\\xe1n \".concat(segments.length, \" segmentos:\"), segments.map((s)=>\"\".concat(s.startTime, \"s-\").concat(s.endTime, \"s\")).join(\", \"));\n                // Almacenar información del estado previo para identificar tracks y elementos\n                console.log(\"Obteniendo informaci\\xf3n del estado antes de eliminar segmentos...\");\n                const estadoPrevio = stateManager.getState();\n                const elementosPrevios = await executor.getAllTimelineElements();\n                // Determinar el trackId principal basado en los elementos\n                const contadorTracks = {};\n                elementosPrevios.forEach((elem)=>{\n                    if (elem.trackId) {\n                        contadorTracks[elem.trackId] = (contadorTracks[elem.trackId] || 0) + 1;\n                    }\n                });\n                // Encontrar el track con más elementos\n                let trackIdPrincipal = \"\";\n                if (Object.keys(contadorTracks).length > 0) {\n                    const tracksPorUso = Object.entries(contadorTracks).sort((a, b)=>b[1] - a[1]);\n                    if (tracksPorUso.length > 0) {\n                        trackIdPrincipal = tracksPorUso[0][0];\n                        console.log(\"Usando trackId principal: \".concat(trackIdPrincipal));\n                    }\n                }\n                // 3. Eliminar los segmentos\n                console.log(\"Ejecutando eliminaci\\xf3n de segmentos...\");\n                const result = await executor.removeSegments(segments);\n                if (!result) {\n                    console.log(\"Error al eliminar los segmentos\");\n                    return false;\n                }\n                console.log(\"Segmentos eliminados correctamente\");\n                // 4. Crear registro de los segmentos eliminados para compactación\n                const segmentosEliminados = segments.map((segment)=>({\n                        start: segment.startTime * 1000,\n                        end: segment.endTime * 1000,\n                        trackId: trackIdPrincipal,\n                        size: (segment.endTime - segment.startTime) * 1000\n                    }));\n                console.log(\"Segmentos registrados para compactaci\\xf3n:\", segmentosEliminados);\n                // 5. Esperar un momento para que se completen las actualizaciones del DOM y el estado\n                console.log(\"Esperando 5 segundos para asegurar que los cambios en la timeline est\\xe9n completos antes de compactar...\");\n                await new Promise((resolve)=>setTimeout(resolve, 5000));\n                // 6. Compactar el timeline usando el enfoque de segmentos registrados\n                console.log(\"Compactando timeline basado en segmentos eliminados...\");\n                // Obtener elementos actuales después de la eliminación\n                const elementosActuales = await executor.getAllTimelineElements();\n                console.log(\"Se encontraron \".concat(elementosActuales.length, \" elementos en la timeline despu\\xe9s de eliminar segmentos\"));\n                // Calcular el espacio total a compactar\n                let espacioTotal = 0;\n                segmentosEliminados.forEach((segmento)=>{\n                    espacioTotal += segmento.size;\n                });\n                console.log(\"Espacio total a compactar: \".concat(espacioTotal, \"ms (\").concat(espacioTotal / 1000, \"s)\"));\n                // Preparar actualizaciones para cada elemento\n                const actualizaciones = {};\n                let elementosAMover = 0;\n                // Ordenar segmentos por posición de inicio\n                const segmentosOrdenados = [\n                    ...segmentosEliminados\n                ].sort((a, b)=>a.start - b.start);\n                // Para cada elemento, calcular el desplazamiento basado en los segmentos eliminados\n                elementosActuales.forEach((elemento)=>{\n                    let desplazamiento = 0;\n                    // Calcular cuánto debe moverse basado en los segmentos eliminados anteriores\n                    for (const segmento of segmentosOrdenados){\n                        if (elemento.from > segmento.start) {\n                            desplazamiento += segmento.size;\n                        }\n                    }\n                    // Si hay desplazamiento, añadir a las actualizaciones\n                    if (desplazamiento > 0) {\n                        const nuevoFrom = elemento.from - desplazamiento;\n                        const nuevoTo = elemento.to - desplazamiento;\n                        console.log(\"Elemento \".concat(elemento.id.substring(0, 8), \"... se mover\\xe1: \").concat(elemento.from, \"ms -> \").concat(nuevoFrom, \"ms (desplazamiento: \").concat(desplazamiento, \"ms)\"));\n                        actualizaciones[elemento.id] = {\n                            display: {\n                                from: nuevoFrom,\n                                to: nuevoTo\n                            }\n                        };\n                        elementosAMover++;\n                    }\n                });\n                console.log(\"Elementos a mover: \".concat(elementosAMover, \" de \").concat(elementosActuales.length, \" total\"));\n                // Aplicar las actualizaciones\n                if (elementosAMover > 0) {\n                    console.log(\"Aplicando actualizaciones para compactar timeline...\");\n                    try {\n                        (0,_designcombo_events__WEBPACK_IMPORTED_MODULE_0__.dispatch)(_designcombo_state__WEBPACK_IMPORTED_MODULE_1__.EDIT_OBJECT, {\n                            payload: actualizaciones\n                        });\n                        console.log(\"Actualizaciones aplicadas con \\xe9xito\");\n                        // Refrescar la vista\n                        setTimeout(()=>{\n                            try {\n                                const { scale } = stateManager.getState();\n                                if (scale) {\n                                    const updatedScale = {\n                                        ...scale\n                                    };\n                                    if (typeof updatedScale.unit === \"number\") {\n                                        updatedScale.unit = (updatedScale.unit || 0) + 1;\n                                        (0,_designcombo_events__WEBPACK_IMPORTED_MODULE_0__.dispatch)(_designcombo_state__WEBPACK_IMPORTED_MODULE_1__.TIMELINE_SCALE_CHANGED, {\n                                            payload: {\n                                                scale: updatedScale\n                                            }\n                                        });\n                                        // Volver a la escala original\n                                        setTimeout(()=>{\n                                            const currentScale = {\n                                                ...stateManager.getState().scale\n                                            };\n                                            currentScale.unit = (currentScale.unit || 1) - 1;\n                                            (0,_designcombo_events__WEBPACK_IMPORTED_MODULE_0__.dispatch)(_designcombo_state__WEBPACK_IMPORTED_MODULE_1__.TIMELINE_SCALE_CHANGED, {\n                                                payload: {\n                                                    scale: currentScale\n                                                }\n                                            });\n                                        }, 300);\n                                    }\n                                }\n                            } catch (error) {\n                                console.error(\"Error al refrescar la vista:\", error);\n                            }\n                        }, 500);\n                    } catch (error) {\n                        console.error(\"Error al aplicar actualizaciones:\", error);\n                        return false;\n                    }\n                } else {\n                    console.log(\"No se encontraron elementos que necesiten moverse\");\n                }\n                console.log(\"Timeline compactado correctamente\");\n                return true;\n            } catch (error) {\n                console.error(\"Error al realizar el recorte inteligente:\", error);\n                return false;\n            }\n        },\n        addMusic: (musicPath, options)=>{\n            try {\n                // Valores predeterminados\n                const startTime = (options === null || options === void 0 ? void 0 : options.startTime) !== undefined ? options.startTime : 0;\n                const endTime = (options === null || options === void 0 ? void 0 : options.endTime) !== undefined ? options.endTime : startTime + 30; // Duración predeterminada más larga para música\n                const volume = (options === null || options === void 0 ? void 0 : options.volume) !== undefined ? options.volume : 80; // Volumen predeterminado al 80%\n                const respectNativeDuration = (options === null || options === void 0 ? void 0 : options.respectNativeDuration) !== undefined ? options.respectNativeDuration : true; // Por defecto, respetar duración nativa\n                console.log(\"A\\xf1adiendo m\\xfasica desde \".concat(musicPath));\n                console.log(\"Tiempos: \".concat(startTime, \"s a \").concat(endTime, \"s, volumen: \").concat(volume, \", respectNativeDuration: \").concat(respectNativeDuration));\n                // Crear payload para la música\n                const audioPayload = {\n                    id: (0,_designcombo_timeline__WEBPACK_IMPORTED_MODULE_2__.generateId)(),\n                    display: {\n                        from: startTime * 1000,\n                        to: endTime * 1000 // Convertir a milisegundos\n                    },\n                    type: \"audio\",\n                    details: {\n                        src: musicPath,\n                        volume: volume,\n                        fadeIn: (options === null || options === void 0 ? void 0 : options.fadeIn) === true,\n                        fadeOut: (options === null || options === void 0 ? void 0 : options.fadeOut) === true\n                    }\n                };\n                // Agregar audio al timeline usando ADD_AUDIO\n                (0,_designcombo_events__WEBPACK_IMPORTED_MODULE_0__.dispatch)(_designcombo_state__WEBPACK_IMPORTED_MODULE_1__.ADD_AUDIO, {\n                    payload: audioPayload,\n                    options: {\n                        respectNativeDuration: respectNativeDuration\n                    }\n                });\n                console.log(\"M\\xfasica agregada exitosamente con ID: \".concat(audioPayload.id));\n                return audioPayload.id;\n            } catch (error) {\n                console.error(\"Error al agregar m\\xfasica:\", error);\n                throw error;\n            }\n        }\n    };\n    return executor;\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2NvbXBvbmVudHMvYWktY2hhdC9haS12aWRlby1jb21tYW5kcy50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQytDO0FBQ29LO0FBQ2hLO0FBK0U1QyxTQUFTVywyQkFBMkJDLFlBQTBCO0lBQ25FLGlEQUFpRDtJQUNqRCxNQUFNQyxXQUFpQztRQUNyQ0MsU0FBUyxDQUFDQyxNQUFjQztZQUN0QixNQUFNQyxXQUFXRCxDQUFBQSxvQkFBQUEsOEJBQUFBLFFBQVNDLFFBQVEsS0FBSTtnQkFBRUMsR0FBRztnQkFBS0MsR0FBRztZQUFJLEdBQUcsdUJBQXVCO1lBQ2pGLE1BQU1DLFdBQVdKLENBQUFBLG9CQUFBQSw4QkFBQUEsUUFBU0ksUUFBUSxLQUFJO1lBQ3RDLE1BQU1DLGFBQWFMLENBQUFBLG9CQUFBQSw4QkFBQUEsUUFBU0ssVUFBVSxLQUFJO1lBQzFDLE1BQU1DLFFBQVFOLENBQUFBLG9CQUFBQSw4QkFBQUEsUUFBU00sS0FBSyxLQUFJO1lBQ2hDLE1BQU1DLFlBQVlQLENBQUFBLG9CQUFBQSw4QkFBQUEsUUFBU08sU0FBUyxLQUFJLEdBQUcsd0JBQXdCO1lBQ25FLE1BQU1DLFVBQVVSLENBQUFBLG9CQUFBQSw4QkFBQUEsUUFBU1EsT0FBTyxLQUFJLEdBQUcscUNBQXFDO1lBRTVFLDhCQUE4QjtZQUM5QixNQUFNQyxjQUFjO2dCQUNsQkMsSUFBSWhCLGlFQUFVQTtnQkFDZGlCLFNBQVM7b0JBQ1BDLE1BQU1MLFlBQVk7b0JBQ2xCTSxJQUFJTCxVQUFVLEtBQVMsMkJBQTJCO2dCQUNwRDtnQkFDQU0sTUFBTTtnQkFDTkMsU0FBUztvQkFDUGhCLE1BQU1BO29CQUNOSyxVQUFVQTtvQkFDVlksT0FBTztvQkFDUFgsWUFBWUE7b0JBQ1pDLE9BQU9BO29CQUNQVyxVQUFVO29CQUNWQyxXQUFXO29CQUNYQyxhQUFhO29CQUNiQyxhQUFhO29CQUNiQyxXQUFXO3dCQUNUZixPQUFPO3dCQUNQSixHQUFHO3dCQUNIQyxHQUFHO3dC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U2lSLE1BQU0sTUFBSzt3QkFDNUJDLFNBQVNsUixDQUFBQSxvQkFBQUEsOEJBQUFBLFFBQVNrUixPQUFPLE1BQUs7b0JBQ2hDO2dCQUNGO2dCQUVBLDZDQUE2QztnQkFDN0NsUyw2REFBUUEsQ0FBQ0kseURBQVNBLEVBQUU7b0JBQ2xCbUMsU0FBU3lQO29CQUNUaFIsU0FBUzt3QkFDUHFFLHVCQUF1QkE7b0JBQ3pCO2dCQUNGO2dCQUVBM0MsUUFBUUMsR0FBRyxDQUFDLDJDQUF3RCxPQUFoQnFQLGFBQWF0USxFQUFFO2dCQUNuRSxPQUFPc1EsYUFBYXRRLEVBQUU7WUFDeEIsRUFBRSxPQUFPb0IsT0FBTztnQkFDZEosUUFBUUksS0FBSyxDQUFDLCtCQUE0QkE7Z0JBQzFDLE1BQU1BO1lBQ1I7UUFDRjtJQUNGO0lBRUEsT0FBT2pDO0FBQ1QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vY29tcG9uZW50cy9haS1jaGF0L2FpLXZpZGVvLWNvbW1hbmRzLnRzPzI2MjMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFN0YXRlTWFuYWdlciBmcm9tIFwiQGRlc2lnbmNvbWJvL3N0YXRlXCI7XG5pbXBvcnQgeyBkaXNwYXRjaCB9IGZyb20gXCJAZGVzaWduY29tYm8vZXZlbnRzXCI7XG5pbXBvcnQgeyBERVNJR05fQUREX1RFWFQsIERFU0lHTl9BRERfQVVESU8sIERFU0lHTl9BRERfSU1BR0UsIEFERF9URVhULCBBRERfVklERU8sIEFERF9JTUFHRSwgQUREX0FVRElPLCBBQ1RJVkVfU1BMSVQsIExBWUVSX1NFTEVDVCwgTEFZRVJfREVMRVRFLCBUSU1FTElORV9TQ0FMRV9DSEFOR0VELCBFRElUX09CSkVDVCB9IGZyb20gXCJAZGVzaWduY29tYm8vc3RhdGVcIjtcbmltcG9ydCB7IGdlbmVyYXRlSWQgfSBmcm9tIFwiQGRlc2lnbmNvbWJvL3RpbWVsaW5lXCI7XG5cblxuZXhwb3J0IGludGVyZmFjZSBWaWRlb0NvbW1hbmRFeGVjdXRvciB7XG4gIGFkZFRleHQ6ICh0ZXh0OiBzdHJpbmcsIG9wdGlvbnM/OiBUZXh0T3B0aW9ucykgPT4gdm9pZDtcbiAgY2hhbmdlQ29sb3I6IChlbGVtZW50SWQ6IHN0cmluZywgY29sb3I6IHN0cmluZykgPT4gdm9pZDtcbiAgYWRkSW1hZ2U6ICh1cmw6IHN0cmluZywgb3B0aW9ucz86IEltYWdlT3B0aW9ucykgPT4gdm9pZDtcbiAgYWRkVmlkZW86ICh1cmw6IHN0cmluZywgb3B0aW9ucz86IFZpZGVvT3B0aW9ucykgPT4gdm9pZDtcbiAgY2hhbmdlRHVyYXRpb246IChlbGVtZW50SWQ6IHN0cmluZywgZHVyYXRpb246IG51bWJlcikgPT4gdm9pZDtcbiAgY2hhbmdlVHJhbnNpdGlvbjogKGVsZW1lbnRJZDogc3RyaW5nLCB0cmFuc2l0aW9uOiBzdHJpbmcpID0+IHZvaWQ7XG4gIGFkZFN1YnRpdGxlczogKG9wdGlvbnM/OiBTdWJ0aXRsZU9wdGlvbnMpID0+IHZvaWQ7XG4gIHJlbW92ZVNlZ21lbnRzOiAoc2VnbWVudHM6IFRpbWVTZWdtZW50W10pID0+IHZvaWQ7XG4gIGdldEFjdGl2ZUVsZW1lbnRzOiAoKSA9PiBQcm9taXNlPGFueVtdPjtcbiAgZ2V0QWxsVGltZWxpbmVFbGVtZW50czogKCkgPT4gUHJvbWlzZTxhbnlbXT47XG4gIGNvbXBhY3RUaW1lbGluZTogKCkgPT4gUHJvbWlzZTxib29sZWFuPjtcbiAgc21hcnRUcmltOiAoKSA9PiBQcm9taXNlPGJvb2xlYW4+O1xuICBhZGRNdXNpYzogKG11c2ljUGF0aDogc3RyaW5nLCBvcHRpb25zPzogTXVzaWNPcHRpb25zKSA9PiB2b2lkO1xufVxuXG5pbnRlcmZhY2UgVGV4dE9wdGlvbnMge1xuICBmb250U2l6ZT86IG51bWJlcjtcbiAgZm9udEZhbWlseT86IHN0cmluZztcbiAgY29sb3I/OiBzdHJpbmc7XG4gIHBvc2l0aW9uPzogeyB4OiBudW1iZXI7IHk6IG51bWJlciB9O1xuICBzdGFydFRpbWU/OiBudW1iZXI7IC8vIGVuIHNlZ3VuZG9zXG4gIGVuZFRpbWU/OiBudW1iZXI7IC8vIGVuIHNlZ3VuZG9zXG59XG5cbmludGVyZmFjZSBJbWFnZU9wdGlvbnMge1xuICB3aWR0aD86IG51bWJlcjtcbiAgaGVpZ2h0PzogbnVtYmVyO1xuICBwb3NpdGlvbj86IHsgeDogbnVtYmVyOyB5OiBudW1iZXIgfTtcbiAgc3RhcnRUaW1lPzogbnVtYmVyOyAvLyBlbiBzZWd1bmRvc1xuICBlbmRUaW1lPzogbnVtYmVyOyAvLyBlbiBzZWd1bmRvc1xuICBpc0FuaW1hdGVkPzogYm9vbGVhbjtcbiAgaXNTdGF0aWM/OiBib29sZWFuOyAvLyBQYXJhIGZvcnphciB0cmF0YXIgdW5hIGltYWdlbiBhbmltYWRhIGNvbW8gZXN0w6F0aWNhXG4gIHNjYWxlTW9kZT86IHN0cmluZztcbn1cblxuaW50ZXJmYWNlIFZpZGVvT3B0aW9ucyB7XG4gIHdpZHRoPzogbnVtYmVyO1xuICBoZWlnaHQ/OiBudW1iZXI7XG4gIHBvc2l0aW9uPzogeyB4OiBudW1iZXI7IHk6IG51bWJlciB9O1xuICBzdGFydFRpbWU/OiBudW1iZXI7IC8vIGVuIHNlZ3VuZG9zXG4gIGVuZFRpbWU/OiBudW1iZXI7IC8vIGVuIHNlZ3VuZG9zXG4gIHNjYWxlTW9kZT86IHN0cmluZztcbiAgaXNBUE5HPzogYm9vbGVhbjtcbiAgc3luY1dpdGhUaW1lbGluZT86IGJvb2xlYW47XG4gIHBsYXliYWNrQmVoYXZpb3I/OiBzdHJpbmc7XG59XG5cbmludGVyZmFjZSBTdWJ0aXRsZU9wdGlvbnMge1xuICBncm91cFdvcmRzPzogYm9vbGVhbjsgLy8gU2kgc2UgZGViZW4gYWdydXBhciBwYWxhYnJhcyAodHJ1ZSkgbyB1c2FyIHN1YnTDrXR1bG9zIGNvbXBsZXRvcyAoZmFsc2UpXG4gIHN0YXJ0VGltZT86IG51bWJlcjsgICAvLyBUaWVtcG8gZGUgaW5pY2lvIHBhcmEgZmlsdHJhciBzdWJ0w610dWxvcyAob3BjaW9uYWwpXG4gIGVuZFRpbWU/OiBudW1iZXI7ICAgICAvLyBUaWVtcG8gZGUgZmluIHBhcmEgZmlsdHJhciBzdWJ0w610dWxvcyAob3BjaW9uYWwpXG59XG5cbmludGVyZmFjZSBNdXNpY09wdGlvbnMge1xuICBzdGFydFRpbWU/OiBudW1iZXI7IC8vIGVuIHNlZ3VuZG9zXG4gIGVuZFRpbWU/OiBudW1iZXI7IC8vIGVuIHNlZ3VuZG9zXG4gIHZvbHVtZT86IG51bWJlcjsgLy8gMC0xMDBcbiAgZmFkZUluPzogYm9vbGVhbjtcbiAgZmFkZU91dD86IGJvb2xlYW47XG4gIHJlc3BlY3ROYXRpdmVEdXJhdGlvbj86IGJvb2xlYW47IC8vIFJlc3BldGFyIGxhIGR1cmFjacOzbiBuYXRpdmEgZGVsIGFyY2hpdm8gZGUgYXVkaW9cbn1cblxuLy8gVGlwbyBwYXJhIHJlcHJlc2VudGFyIHVuIHNlZ21lbnRvIGRlIHN1YnTDrXR1bG9cbmludGVyZmFjZSBTdWJ0aXRsZVNlZ21lbnQge1xuICBpZDogbnVtYmVyO1xuICBzdGFydFRpbWU6IG51bWJlcjsgLy8gZW4gbWlsaXNlZ3VuZG9zXG4gIGVuZFRpbWU6IG51bWJlcjsgICAvLyBlbiBtaWxpc2VndW5kb3NcbiAgdGV4dDogc3RyaW5nO1xufVxuXG5pbnRlcmZhY2UgVGltZVNlZ21lbnQge1xuICBzdGFydFRpbWU6IG51bWJlcjsgLy8gVGllbXBvIGRlIGluaWNpbyBlbiBzZWd1bmRvc1xuICBlbmRUaW1lOiBudW1iZXI7ICAgLy8gVGllbXBvIGZpbmFsIGVuIHNlZ3VuZG9zXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVWaWRlb0NvbW1hbmRFeGVjdXRvcihzdGF0ZU1hbmFnZXI6IFN0YXRlTWFuYWdlcik6IFZpZGVvQ29tbWFuZEV4ZWN1dG9yIHtcbiAgLy8gQ3JlYXIgZWwgb2JqZXRvIGV4ZWN1dG9yIGNvbiB0b2RvcyBsb3MgbcOpdG9kb3NcbiAgY29uc3QgZXhlY3V0b3I6IFZpZGVvQ29tbWFuZEV4ZWN1dG9yID0ge1xuICAgIGFkZFRleHQ6ICh0ZXh0OiBzdHJpbmcsIG9wdGlvbnM/OiBUZXh0T3B0aW9ucykgPT4ge1xuICAgICAgY29uc3QgcG9zaXRpb24gPSBvcHRpb25zPy5wb3NpdGlvbiB8fCB7IHg6IDAuNSwgeTogMC41IH07IC8vIENlbnRyYWRvIHBvciBkZWZlY3RvXG4gICAgICBjb25zdCBmb250U2l6ZSA9IG9wdGlvbnM/LmZvbnRTaXplIHx8IDQ4O1xuICAgICAgY29uc3QgZm9udEZhbWlseSA9IG9wdGlvbnM/LmZvbnRGYW1pbHkgfHwgXCJSb2JvdG8tQm9sZFwiO1xuICAgICAgY29uc3QgY29sb3IgPSBvcHRpb25zPy5jb2xvciB8fCBcIiNGRkZGRkZcIjtcbiAgICAgIGNvbnN0IHN0YXJ0VGltZSA9IG9wdGlvbnM/LnN0YXJ0VGltZSB8fCAwOyAvLyBQb3IgZGVmZWN0byBhbCBpbmljaW9cbiAgICAgIGNvbnN0IGVuZFRpbWUgPSBvcHRpb25zPy5lbmRUaW1lIHx8IDU7IC8vIFBvciBkZWZlY3RvIDUgc2VndW5kb3MgZGUgZHVyYWNpw7NuXG5cbiAgICAgIC8vIENyZWFyIHBheWxvYWQgcGFyYSBlbCB0ZXh0b1xuICAgICAgY29uc3QgdGV4dFBheWxvYWQgPSB7XG4gICAgICAgIGlkOiBnZW5lcmF0ZUlkKCksXG4gICAgICAgIGRpc3BsYXk6IHtcbiAgICAgICAgICBmcm9tOiBzdGFydFRpbWUgKiAxMDAwLCAvLyBDb252ZXJ0aXIgYSBtaWxpc2VndW5kb3NcbiAgICAgICAgICB0bzogZW5kVGltZSAqIDEwMDAgICAgIC8vIENvbnZlcnRpciBhIG1pbGlzZWd1bmRvc1xuICAgICAgICB9LFxuICAgICAgICB0eXBlOiAndGV4dCcsXG4gICAgICAgIGRldGFpbHM6IHtcbiAgICAgICAgICB0ZXh0OiB0ZXh0LFxuICAgICAgICAgIGZvbnRTaXplOiBmb250U2l6ZSxcbiAgICAgICAgICB3aWR0aDogNjAwLFxuICAgICAgICAgIGZvbnRGYW1pbHk6IGZvbnRGYW1pbHksXG4gICAgICAgICAgY29sb3I6IGNvbG9yLFxuICAgICAgICAgIHdvcmRXcmFwOiAnYnJlYWstd29yZCcsXG4gICAgICAgICAgdGV4dEFsaWduOiAnY2VudGVyJyxcbiAgICAgICAgICBib3JkZXJXaWR0aDogMCxcbiAgICAgICAgICBib3JkZXJDb2xvcjogJyMwMDAwMDAnLFxuICAgICAgICAgIGJveFNoYWRvdzoge1xuICAgICAgICAgICAgY29sb3I6ICcjZmZmZmZmJyxcbiAgICAgICAgICAgIHg6IDAsXG4gICAgICAgICAgICB5OiAwLFxuICAgICAgICAgICAgYmx1cjogMCxcbiAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgfTtcblxuICAgICAgLy8gQWdyZWdhciB0ZXh0byBhbCB0aW1lbGluZVxuICAgICAgZGlzcGF0Y2goQUREX1RFWFQsIHtcbiAgICAgICAgcGF5bG9hZDogdGV4dFBheWxvYWQsXG4gICAgICAgIG9wdGlvbnM6IHt9LFxuICAgICAgfSk7XG4gICAgfSxcblxuICAgIGNoYW5nZUNvbG9yOiAoZWxlbWVudElkOiBzdHJpbmcsIGNvbG9yOiBzdHJpbmcpID0+IHtcbiAgICAgIC8vIFNpbXVsYWNpw7NuIGRlIGNhbWJpbyBkZSBjb2xvciAobGEgaW1wbGVtZW50YWNpw7NuIHJlYWwgZGVwZW5kZXLDoSBkZSBsYSBlc3RydWN0dXJhIGRlbCBwcm95ZWN0bylcbiAgICAgIGNvbnNvbGUubG9nKGBDYW1iaWFuZG8gY29sb3IgZGVsIGVsZW1lbnRvICR7ZWxlbWVudElkfSBhICR7Y29sb3J9YCk7XG5cbiAgICAgIC8vIEFxdcOtIGlyw61hIGxhIGzDs2dpY2EgcmVhbCBwYXJhIGNhbWJpYXIgZWwgY29sb3IgZGUgdW4gZWxlbWVudG9cbiAgICB9LFxuXG4gICAgYWRkSW1hZ2U6ICh1cmw6IHN0cmluZywgb3B0aW9ucz86IEltYWdlT3B0aW9ucykgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgIC8vIEFzZWd1cmFyIHF1ZSB0ZW5lbW9zIHVuYSBVUkwgdsOhbGlkYVxuICAgICAgaWYgKCF1cmwpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFwi4p2MIFVSTCBkZSBpbWFnZW4gbm8gdsOhbGlkYSBvIHZhY8OtYVwiKTtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVUkwgZGUgaW1hZ2VuIG5vIHByb3BvcmNpb25hZGFcIik7XG4gICAgICB9XG5cbiAgICAgICAgY29uc29sZS5sb2coXCI9PT0gSU5JQ0lBTkRPIFBST0NFU08gREUgQcORQURJUiBJTUFHRU4gPT09XCIpO1xuICAgICAgICBjb25zb2xlLmxvZyhcIlVSTDpcIiwgdXJsKTtcbiAgICAgICAgY29uc29sZS5sb2coXCJPcGNpb25lczpcIiwgSlNPTi5zdHJpbmdpZnkob3B0aW9ucywgbnVsbCwgMikpO1xuXG4gICAgICAvLyBWZXJpZmljYXIgc2kgZXMgdW5hIFVSTCBnZW7DqXJpY2EgZGUgcmVmZXJlbmNpYSwgcXVlIG5vIGRlYmUgdXNhcnNlIGRpcmVjdGFtZW50ZVxuICAgICAgaWYgKHVybCA9PT0gJ2ltYWdlbl9hZGp1bnRhX3Bvcl9lbF91c3VhcmlvLmpwZycgfHwgdXJsLmluY2x1ZGVzKCcvdXJsX2RlX2xhX2ltYWdlbicpKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvcjogVVJMIGRlIGltYWdlbiBnZW7DqXJpY2EgaW52w6FsaWRhIGRldGVjdGFkYVwiLCB1cmwpO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJMYSBVUkwgZGUgaW1hZ2VuIG5vIGVzIHbDoWxpZGEuIFNlIGludGVudMOzIHVzYXIgdW4gbWFyY2Fkb3IgZ2Vuw6lyaWNvIGRpcmVjdGFtZW50ZS5cIik7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHdpZHRoID0gb3B0aW9ucz8ud2lkdGggfHwgNDgwO1xuICAgICAgY29uc3QgaGVpZ2h0ID0gb3B0aW9ucz8uaGVpZ2h0IHx8IDI3MDtcbiAgICAgIGNvbnN0IHN0YXJ0VGltZSA9IG9wdGlvbnM/LnN0YXJ0VGltZSAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5zdGFydFRpbWUgOiAwO1xuICAgICAgY29uc3QgZW5kVGltZSA9IG9wdGlvbnM/LmVuZFRpbWUgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuZW5kVGltZSA6IHN0YXJ0VGltZSArIDU7XG5cbiAgICAgICAgLy8gRGV0ZWN0b3JlcyBkZSB0aXBvIGRlIGltYWdlblxuICAgICAgICBjb25zdCBpc0V4cGxpY2l0bHlBbmltYXRlZCA9IG9wdGlvbnM/LmlzQW5pbWF0ZWQgPT09IHRydWU7XG4gICAgICAgIGNvbnN0IGlzRXhwbGljaXRseVN0YXRpYyA9IG9wdGlvbnM/LmlzU3RhdGljID09PSB0cnVlO1xuICAgICAgICBjb25zdCBpc0FQTkcgPSB1cmwudG9Mb3dlckNhc2UoKS5lbmRzV2l0aCgnLmFwbmcnKTtcbiAgICAgICAgY29uc3QgaXNHSUYgPSB1cmwudG9Mb3dlckNhc2UoKS5lbmRzV2l0aCgnLmdpZicpO1xuXG4gICAgICAgIC8vIERldGVybWluYXIgc2kgZGViZSB0cmF0YXJzZSBjb21vIGltYWdlbiBhbmltYWRhXG4gICAgICAgIGNvbnN0IHNob3VsZFRyZWF0QXNBbmltYXRlZCA9IChpc0V4cGxpY2l0bHlBbmltYXRlZCB8fCBpc0FQTkcgfHwgaXNHSUYpICYmICFpc0V4cGxpY2l0bHlTdGF0aWM7XG5cbiAgICAgICAgLy8gTG9nIGRlIG1vZG8gZGV0ZWN0YWRvXG4gICAgICAgIGlmIChzaG91bGRUcmVhdEFzQW5pbWF0ZWQpIHtcbiAgICAgICAgICBjb25zb2xlLmxvZyhg8J+UtiBEZXRlY3RhZGEgaW1hZ2VuIGFuaW1hZGE6ICR7dXJsfWApO1xuICAgICAgICAgIGNvbnNvbGUubG9nKGBUaXBvOiAke2lzQVBORyA/ICdBUE5HJyA6IGlzR0lGID8gJ0dJRicgOiAnQW5pbWFkYSBnZW7DqXJpY2EnfWApO1xuICAgICAgICB9IGVsc2UgaWYgKGlzQVBORyB8fCBpc0dJRikge1xuICAgICAgICAgIGNvbnNvbGUubG9nKGDwn5S5IERldGVjdGFkYSBpbWFnZW4gcG90ZW5jaWFsbWVudGUgYW5pbWFkYSBwZXJvIHRyYXTDoW5kb2xhIGNvbW8gZXN0w6F0aWNhOiAke3VybH1gKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zb2xlLmxvZyhg8J+UtyBEZXRlY3RhZGEgaW1hZ2VuIGVzdMOhdGljYTogJHt1cmx9YCk7XG4gICAgICAgIH1cblxuICAgICAgLy8gUGFyYSBkZXB1cmFjacOzbiwgbW9zdHJhciBwYXJ0ZSBkZSBsYSBVUkwgKHRydW5jYWRhIHNpIGVzIGRhdGE6VVJMKVxuICAgICAgY29uc3QgbG9nVXJsID0gdXJsLnN0YXJ0c1dpdGgoJ2RhdGE6JylcbiAgICAgICAgPyBgJHt1cmwuc3Vic3RyaW5nKDAsIDMwKX0uLi4gKGRhdGEgVVJMKWBcbiAgICAgICAgOiB1cmw7XG4gICAgICBjb25zb2xlLmxvZyhgQcOxYWRpZW5kbyBpbWFnZW4gZGVzZGUgJHtsb2dVcmx9IGRlc2RlIHNlZ3VuZG8gJHtzdGFydFRpbWV9IGhhc3RhICR7ZW5kVGltZX1gKTtcblxuICAgICAgICAvLyBQb3NpY2nDs24gKGNlbnRyYWRhIHBvciBkZWZlY3RvKVxuICAgICAgICBjb25zdCBwb3NpdGlvbiA9IG9wdGlvbnM/LnBvc2l0aW9uIHx8IHsgeDogMC41LCB5OiAwLjUgfTtcblxuICAgICAgICAvLyBNb2RvcyBkZSBlc2NhbGFcbiAgICAgICAgY29uc3Qgc2NhbGVNb2RlID0gb3B0aW9ucz8uc2NhbGVNb2RlIHx8IFwiZml0XCI7XG4gICAgICAgIGNvbnN0IHVzZUZ1bGxTY3JlZW4gPSBzY2FsZU1vZGUgPT09IFwiY292ZXJcIjtcblxuICAgICAgICAvLyBQcm9waWVkYWRlcyBwYXJhIGVsIHBheWxvYWQsIGNvbcO6biBwYXJhIGFtYm9zIGNhc29zXG4gICAgICAgIGNvbnN0IGNvbW1vblBheWxvYWRQcm9wcyA9IHtcbiAgICAgICAgICBmcm9tOiBzdGFydFRpbWUgKiAxMDAwLFxuICAgICAgICAgIHRvOiBlbmRUaW1lICogMTAwMFxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIFByb3BpZWRhZGVzIGRlIGRldGFsbGUgY29tdW5lc1xuICAgICAgICBjb25zdCBjb21tb25EZXRhaWxzUHJvcHMgPSB7XG4gICAgICAgICAgc3JjOiB1cmwsXG4gICAgICAgICAgd2lkdGg6IHdpZHRoLFxuICAgICAgICAgIGhlaWdodDogaGVpZ2h0LFxuICAgICAgICAgIG9wYWNpdHk6IDEwMCxcbiAgICAgICAgICBzY2FsZU1vZGU6IHNjYWxlTW9kZSxcbiAgICAgICAgICBsZWZ0OiBwb3NpdGlvbi54LFxuICAgICAgICAgIHRvcDogcG9zaXRpb24ueSxcbiAgICAgICAgICBvcmlnaW5YOiBcImNlbnRlclwiLFxuICAgICAgICAgIG9yaWdpblk6IFwiY2VudGVyXCJcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBDcmVhciBJRCDDum5pY29cbiAgICAgICAgY29uc3QgaW1hZ2VJZCA9IGdlbmVyYXRlSWQoKTtcblxuICAgICAgICAvLyBDcmVhciBlbCBwYXlsb2FkIGRlIGltYWdlbiBzaW1wbGlmaWNhZG9cbiAgICAgICAgY29uc3QgaW1hZ2VQYXlsb2FkID0ge1xuICAgICAgICAgIGlkOiBpbWFnZUlkLFxuICAgICAgICAgIGRpc3BsYXk6IGNvbW1vblBheWxvYWRQcm9wcyxcbiAgICAgICAgICB0eXBlOiAnaW1hZ2UnLFxuICAgICAgICAgIGRldGFpbHM6IHtcbiAgICAgICAgICAgIC4uLmNvbW1vbkRldGFpbHNQcm9wcyxcbiAgICAgICAgICAgIC8vIFNpIGVzIGFuaW1hZGEsIGHDsWFkaXIgYXRyaWJ1dG9zIGVzcGVjw61maWNvc1xuICAgICAgICAgICAgLi4uKHNob3VsZFRyZWF0QXNBbmltYXRlZCAmJiB7XG4gICAgICAgICAgICAgIGlzQW5pbWF0ZWQ6IHRydWUsXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIC8vIFNpIGEgcGFudGFsbGEgY29tcGxldGEsIGFqdXN0YXIgZGltZW5zaW9uZXNcbiAgICAgICAgICAgIC4uLih1c2VGdWxsU2NyZWVuICYmIHtcbiAgICAgICAgICAgICAgd2lkdGg6IDE5MjAsXG4gICAgICAgICAgICAgIGhlaWdodDogMTA4MFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgY29uc29sZS5sb2coXCJQYXlsb2FkIGRlIGltYWdlbiBhIGRlc3BhY2hhcjpcIiwgSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgIC4uLmltYWdlUGF5bG9hZCxcbiAgICAgICAgICBkZXRhaWxzOiB7XG4gICAgICAgICAgICAuLi5pbWFnZVBheWxvYWQuZGV0YWlscyxcbiAgICAgICAgICAgIHNyYzogaW1hZ2VQYXlsb2FkLmRldGFpbHMuc3JjLnN1YnN0cmluZygwLCAzMCkgKyAoaW1hZ2VQYXlsb2FkLmRldGFpbHMuc3JjLmxlbmd0aCA+IDMwID8gJy4uLicgOiAnJylcbiAgICAgICAgICB9XG4gICAgICAgIH0sIG51bGwsIDIpKTtcblxuICAgICAgICAvLyBPcGNpb25lcyBwYXJhIGVsIGRpc3BhdGNoXG4gICAgICAgIGNvbnN0IGRpc3BhdGNoT3B0aW9ucyA9IHtcbiAgICAgICAgICBzY2FsZU1vZGU6IHNjYWxlTW9kZSxcbiAgICAgICAgICBwb3NpdGlvbjogcG9zaXRpb24sXG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gRGVzcGFjaGFyIGxhIGFjY2nDs24gcGFyYSBhw7FhZGlyIGxhIGltYWdlblxuICAgICAgICBkaXNwYXRjaChBRERfSU1BR0UsIHtcbiAgICAgICAgICBwYXlsb2FkOiBpbWFnZVBheWxvYWQsXG4gICAgICAgICAgb3B0aW9uczogZGlzcGF0Y2hPcHRpb25zXG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIExvZyBkZSDDqXhpdG9cbiAgICAgICAgaWYgKHNob3VsZFRyZWF0QXNBbmltYXRlZCkge1xuICAgICAgICAgIGNvbnNvbGUubG9nKGDinIUgSW1hZ2VuIGFuaW1hZGEgYcOxYWRpZGEgZGVzZGUgJHtzdGFydFRpbWV9cyBoYXN0YSAke2VuZFRpbWV9c2ApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnNvbGUubG9nKGDinIUgSW1hZ2VuIGVzdMOhdGljYSBhw7FhZGlkYSBkZXNkZSAke3N0YXJ0VGltZX1zIGhhc3RhICR7ZW5kVGltZX1zYCk7XG4gICAgICAgIH1cblxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcIuKdjCBFUlJPUiBDUsONVElDTyBhbCBhw7FhZGlyIGltYWdlbjpcIiwgZXJyb3IpO1xuICAgICAgICBjb25zb2xlLmVycm9yKFwiRGV0YWxsZXMgY29tcGxldG9zOlwiLCBlcnJvci5tZXNzYWdlKTtcbiAgICAgICAgY29uc29sZS5lcnJvcihcIlRyYXphOlwiLCBlcnJvci5zdGFjayk7XG4gICAgICAgIHRocm93IGVycm9yOyAvLyBQcm9wYWdhciBlbCBlcnJvciBwYXJhIG1hbmVqbyBzdXBlcmlvclxuICAgICAgfVxuICAgIH0sXG5cbiAgICBhZGRWaWRlbzogKHVybDogc3RyaW5nLCBvcHRpb25zPzogVmlkZW9PcHRpb25zKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zb2xlLmxvZyhcIj09PSBJTklDSUFORE8gUFJPQ0VTTyBERSBBw5FBRElSIFZJREVPID09PVwiKTtcbiAgICAgICAgY29uc29sZS5sb2coXCJVUkw6XCIsIHVybCk7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiT3BjaW9uZXM6XCIsIEpTT04uc3RyaW5naWZ5KG9wdGlvbnMsIG51bGwsIDIpKTtcblxuICAgICAgICAvLyBWYWxpZGFjacOzbiBkZSBVUkxcbiAgICAgICAgaWYgKCF1cmwpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFwi4p2MIFVSTCBkZSB2aWRlbyBubyB2w6FsaWRhIG8gdmFjw61hXCIpO1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVSTCBkZSB2aWRlbyBubyBwcm9wb3JjaW9uYWRhXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qgd2lkdGggPSBvcHRpb25zPy53aWR0aCB8fCA2NDA7XG4gICAgICAgIGNvbnN0IGhlaWdodCA9IG9wdGlvbnM/LmhlaWdodCB8fCAzNjA7XG4gICAgICAgIGNvbnN0IHN0YXJ0VGltZSA9IG9wdGlvbnM/LnN0YXJ0VGltZSB8fCAwOyAvLyBQb3IgZGVmZWN0byBhbCBpbmljaW9cbiAgICAgICAgY29uc3QgZW5kVGltZSA9IG9wdGlvbnM/LmVuZFRpbWUgfHwgMTA7IC8vIFBvciBkZWZlY3RvIDEwIHNlZ3VuZG9zIGRlIGR1cmFjacOzblxuXG4gICAgICAgIC8vIERldGVjdGFyIHNpIGVzIHVuIGFyY2hpdm8gQVZJIG8gQVBORyBwYXJhIHRyYXRhbWllbnRvIGVzcGVjaWFsXG4gICAgICAgIGNvbnN0IGlzQVZJID0gdXJsLnRvTG93ZXJDYXNlKCkuZW5kc1dpdGgoJy5hdmknKTtcbiAgICAgICAgY29uc3QgaXNBUE5HID0gdXJsLnRvTG93ZXJDYXNlKCkuZW5kc1dpdGgoJy5hcG5nJyk7XG4gICAgICAgIC8vIE1hcmNhZG9yIHBhc2FkbyBleHBsw61jaXRhbWVudGUgLSBtYXlvciBwcmlvcmlkYWQgcXVlIGxhIGV4dGVuc2nDs25cbiAgICAgICAgY29uc3QgaXNFeHBsaWNpdEFQTkcgPSBvcHRpb25zPy5pc0FQTkcgPT09IHRydWU7XG5cbiAgICAgICAgY29uc29sZS5sb2coXCJGb3JtYXRvIGRldGVjdGFkbzpcIixcbiAgICAgICAgICBpc0FWSSA/IFwiQVZJXCIgOiBpc0FQTkcgPyBcIkFQTkdcIiA6IGlzRXhwbGljaXRBUE5HID8gXCJFeHBsw61jaXRhbWVudGUgbWFyY2FkbyBjb21vIEFQTkdcIiA6IFwiRm9ybWF0byBlc3TDoW5kYXJcIik7XG5cbiAgICAgICAgLy8gU2kgZXMgQVBORyBzZWfDum4gYWxnw7puIGNyaXRlcmlvXG4gICAgICAgIGNvbnN0IHRyZWF0QXNBUE5HID0gaXNBUE5HIHx8IGlzRXhwbGljaXRBUE5HO1xuICAgICAgICBjb25zdCB1c2VGdWxsU2NyZWVuID0gaXNBVkkgfHwgdHJlYXRBc0FQTkcgfHwgKG9wdGlvbnM/LnNjYWxlTW9kZSA9PT0gXCJjb3ZlclwiKTtcblxuICAgICAgICAvLyBQYXJhIGFyY2hpdm9zIEFWSSB5IEFQTkcsIHJlc3BlY3RhciBkdXJhY2nDs24gbmF0dXJhbCBzaSBubyBzZSBlc3BlY2lmaWNhXG4gICAgICAgIGNvbnN0IHJlc3BlY3ROYXRpdmVEdXJhdGlvbiA9IChpc0FWSSB8fCB0cmVhdEFzQVBORykgJiYgIW9wdGlvbnM/LmVuZFRpbWU7XG4gICAgICAgIGNvbnN0IGZpbmFsRW5kVGltZSA9IHJlc3BlY3ROYXRpdmVEdXJhdGlvbiA/IHVuZGVmaW5lZCA6IGVuZFRpbWU7XG5cbiAgICAgICAgLy8gTG9nIHBhcmEgZGVwdXJhclxuICAgICAgICBpZiAodHJlYXRBc0FQTkcpIHtcbiAgICAgICAgICBjb25zb2xlLmxvZyhg8J+UtyBBw7FhZGllbmRvIEFQTkcgY29tbyBWSURFTyBzaW5jcm9uaXphZG8gZGVzZGUgJHtzdGFydFRpbWV9cyBjb24gZHVyYWNpw7NuICR7cmVzcGVjdE5hdGl2ZUR1cmF0aW9uID8gJ25hdHVyYWwnIDogZmluYWxFbmRUaW1lICsgJ3MnfWApO1xuICAgICAgICAgIGNvbnNvbGUubG9nKGDwn5S3IENvbmZpZ3VyYWNpb25lcyBlc3BlY2lhbGVzIGRlIEFQTkcgLSB1c2VGdWxsU2NyZWVuOiAke3VzZUZ1bGxTY3JlZW59LCBzeW5jV2l0aFRpbWVsaW5lOiAke29wdGlvbnM/LnN5bmNXaXRoVGltZWxpbmUgfHwgdHJ1ZX1gKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc0FWSSkge1xuICAgICAgICAgIGNvbnNvbGUubG9nKGDwn46sIEHDsWFkaWVuZG8gQVZJIGNvbiBkdXJhY2nDs24gJHtyZXNwZWN0TmF0aXZlRHVyYXRpb24gPyAnbmF0dXJhbCcgOiAnZXNwZWNpZmljYWRhOiAnICsgZmluYWxFbmRUaW1lfXNgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIE1hbmVqYXIgQVBORyB1c2FuZG8gdW4gZW5mb3F1ZSBlc3BlY2lhbCAtIGludGVudGFyIGNvbiB1biBtw6l0b2RvIGFsdGVybmF0aXZvIHNpIGVzIHBvc2libGVcbiAgICAgICAgaWYgKHRyZWF0QXNBUE5HKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIEludGVudGFyIGNyZWFyIHVuIHBheWxvYWQgZXNwZWNpYWwgcGFyYSBBUE5HIHF1ZSBmdW5jaW9uZSBjb21vIGFuaW1hY2nDs25cbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiUHJvYmFuZG8gY29uIHVuYSBjb25maWd1cmFjacOzbiBlc3BlY2lhbCBwYXJhIEFQTkcuLi5cIik7XG5cbiAgICAgICAgICAgIC8vIENvbmZpZ3VyYWNpw7NuIGRlIG9wY2lvbmVzIGltcG9ydGFudGUgcGFyYSBhcmNoaXZvcyBBUE5HXG4gICAgICAgICAgICBjb25zdCBhcG5nVmlkZW9QYXlsb2FkID0ge1xuICAgICAgICAgICAgaWQ6IGdlbmVyYXRlSWQoKSxcbiAgICAgICAgICAgIGRpc3BsYXk6IHtcbiAgICAgICAgICAgICAgZnJvbTogc3RhcnRUaW1lICogMTAwMCwgLy8gQ29udmVydGlyIGEgbWlsaXNlZ3VuZG9zXG4gICAgICAgICAgICAgICAgdG86IGZpbmFsRW5kVGltZSA/IGZpbmFsRW5kVGltZSAqIDEwMDAgOiAoc3RhcnRUaW1lICsgMykgKiAxMDAwIC8vIDMgc2VndW5kb3MgcG9yIGRlZmVjdG8gc2kgbm8gaGF5IGR1cmFjacOzblxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgLy8gUHJvYmFtb3MgdW5hIG51ZXZhIGVzdHJhdGVnaWE6IHRyYXRhcmxvIGNvbW8gaW1hZ2VuIGVuIGx1Z2FyIGRlIHZpZGVvXG4gICAgICAgICAgICB0eXBlOiAnaW1hZ2UnLFxuICAgICAgICAgICAgZGV0YWlsczoge1xuICAgICAgICAgICAgICBzcmM6IHVybCxcbiAgICAgICAgICAgICAgICB3aWR0aDogMTkyMCwgLy8gQW5jaG8gcGFyYSBwYW50YWxsYSBjb21wbGV0YVxuICAgICAgICAgICAgICAgIGhlaWdodDogMTA4MCwgLy8gQWx0byBwYXJhIHBhbnRhbGxhIGNvbXBsZXRhXG4gICAgICAgICAgICAgIG9wYWNpdHk6IDEwMCxcbiAgICAgICAgICAgICAgICBzY2FsZU1vZGU6IFwiY292ZXJcIiwgLy8gUGFyYSBsbGVuYXIgdG9kYSBsYSBwYW50YWxsYVxuICAgICAgICAgICAgICAgIGxlZnQ6IDAuNSwgLy8gQ2VudHJhZG8gaG9yaXpvbnRhbG1lbnRlXG4gICAgICAgICAgICAgICAgdG9wOiAwLjUsICAvLyBDZW50cmFkbyB2ZXJ0aWNhbG1lbnRlXG4gICAgICAgICAgICAgICAgb3JpZ2luWDogXCJjZW50ZXJcIiwgLy8gT3JpZ2VuIGVuIGVsIGNlbnRyb1xuICAgICAgICAgICAgICAgIG9yaWdpblk6IFwiY2VudGVyXCIsIC8vIE9yaWdlbiBlbiBlbCBjZW50cm9cbiAgICAgICAgICAgICAgICAvLyBQcm9waWVkYWRlcyBwYXJhIGFuaW1hclxuICAgICAgICAgICAgICAgIGlzQW5pbWF0ZWQ6IHRydWVcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiUGF5bG9hZCBwYXJhIEFQTkcgY29tbyBpbWFnZW4gYW5pbWFkYTpcIiwgSlNPTi5zdHJpbmdpZnkoYXBuZ1ZpZGVvUGF5bG9hZCwgbnVsbCwgMikpO1xuXG4gICAgICAgICAgICAvLyBVc2FyIEFERF9JTUFHRSBlbiBsdWdhciBkZSBBRERfVklERU9cbiAgICAgICAgICBkaXNwYXRjaChBRERfSU1BR0UsIHtcbiAgICAgICAgICAgICAgcGF5bG9hZDogYXBuZ1ZpZGVvUGF5bG9hZCxcbiAgICAgICAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgICAgICAgICBzY2FsZU1vZGU6IFwiY292ZXJcIixcbiAgICAgICAgICAgICAgICBwb3NpdGlvbjogeyB4OiAwLjUsIHk6IDAuNSB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIuKchSBBUE5HIGHDsWFkaWRvIGNvbW8gaW1hZ2VuIGFuaW1hZGEgY29uIMOpeGl0b1wiKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9IGNhdGNoIChhcG5nRXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCLinYwgRXJyb3IgYWwgYcOxYWRpciBBUE5HIGNvbW8gaW1hZ2VuIGFuaW1hZGE6XCIsIGFwbmdFcnJvcik7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiRGV0YWxsZXM6XCIsIGFwbmdFcnJvci5tZXNzYWdlKTtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJUcmF6YTpcIiwgYXBuZ0Vycm9yLnN0YWNrKTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwi8J+UhCBDb250aW51YW5kbyBjb24gZWwgbcOpdG9kbyBlc3TDoW5kYXIgY29tbyByZXNwYWxkby4uLlwiKTtcbiAgICAgICAgICAgIC8vIENvbnRpbnVhciBjb24gZWwgbcOpdG9kbyBlc3TDoW5kYXIgY29tbyByZXNwYWxkb1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAvLyBDcmVhciBwYXlsb2FkIHBhcmEgZWwgdmlkZW9cbiAgICAgIGNvbnN0IHZpZGVvUGF5bG9hZCA9IHtcbiAgICAgICAgaWQ6IGdlbmVyYXRlSWQoKSxcbiAgICAgICAgZGlzcGxheToge1xuICAgICAgICAgIGZyb206IHN0YXJ0VGltZSAqIDEwMDAsIC8vIENvbnZlcnRpciBhIG1pbGlzZWd1bmRvc1xuICAgICAgICAgICAgdG86IGZpbmFsRW5kVGltZSA/IGZpbmFsRW5kVGltZSAqIDEwMDAgOiB1bmRlZmluZWQgLy8gVXNhciB1bmRlZmluZWQgc2kgcXVlcmVtb3MgcmVzcGV0YXIgbGEgZHVyYWNpw7NuIG5hdHVyYWxcbiAgICAgICAgfSxcbiAgICAgICAgdHlwZTogJ3ZpZGVvJyxcbiAgICAgICAgZGV0YWlsczoge1xuICAgICAgICAgIHNyYzogdXJsLFxuICAgICAgICAgIHdpZHRoOiB3aWR0aCxcbiAgICAgICAgICBoZWlnaHQ6IGhlaWdodCxcbiAgICAgICAgICBvcGFjaXR5OiAxMDAsXG4gICAgICAgICAgICAvLyBQYXJhIGFyY2hpdm9zIEFQTkcgeSBBVkksIGNvbmZpZ3VyYXIgcHJvcGllZGFkZXMgZXNwZWPDrWZpY2FzIHBhcmEgcGFudGFsbGEgY29tcGxldGFcbiAgICAgICAgICAgIC4uLih1c2VGdWxsU2NyZWVuICYmIHtcbiAgICAgICAgICAgICAgc2NhbGVNb2RlOiBcImNvdmVyXCIsIC8vIFVzYXIgXCJjb3ZlclwiIGVuIGx1Z2FyIGRlIFwiZml0XCIgcGFyYSBhc2VndXJhciBxdWUgY3VicmEgdG9kb1xuICAgICAgICAgICAgICBsZWZ0OiAwLjUsIC8vIENlbnRyYWRvIGhvcml6b250YWxtZW50ZVxuICAgICAgICAgICAgICB0b3A6IDAuNSwgIC8vIENlbnRyYWRvIHZlcnRpY2FsbWVudGVcbiAgICAgICAgICAgICAgb3JpZ2luWDogXCJjZW50ZXJcIiwgLy8gT3JpZ2VuIGVuIGVsIGNlbnRyb1xuICAgICAgICAgICAgICBvcmlnaW5ZOiBcImNlbnRlclwiLCAvLyBPcmlnZW4gZW4gZWwgY2VudHJvXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIC8vIFByb3BpZWRhZGVzIGVzcGVjaWFsZXMgcGFyYSBBUE5HXG4gICAgICAgICAgICAuLi4odHJlYXRBc0FQTkcgJiYge1xuICAgICAgICAgICAgICBpc0FQTkc6IHRydWUsXG4gICAgICAgICAgICAgIGF1dG9QbGF5OiB0cnVlLFxuICAgICAgICAgICAgICBsb29wOiBmYWxzZSxcbiAgICAgICAgICAgICAgc3luY1dpdGhUaW1lbGluZTogb3B0aW9ucz8uc3luY1dpdGhUaW1lbGluZSB8fCB0cnVlXG4gICAgICAgICAgICB9KVxuICAgICAgICAgIH0sXG4gICAgICAgIH07XG5cbiAgICAgICAgY29uc29sZS5sb2coXCJQYXlsb2FkIGRlIHZpZGVvIGVzdMOhbmRhcjpcIiwgSlNPTi5zdHJpbmdpZnkodmlkZW9QYXlsb2FkLCBudWxsLCAyKSk7XG5cbiAgICAgICAgLy8gQ29uZmlndXJhY2lvbmVzIGFkaWNpb25hbGVzIHBhcmEgZWwgZGlzcGF0Y2hcbiAgICAgICAgY29uc3QgZGlzcGF0Y2hPcHRpb25zID0ge1xuICAgICAgICAgIHJlc291cmNlSWQ6IFwibWFpblwiLFxuICAgICAgICAgIHNjYWxlTW9kZTogdXNlRnVsbFNjcmVlbiA/IFwiY292ZXJcIiA6IFwiZml0XCIsIC8vIFVzYXIgY292ZXIgcGFyYSBwYW50YWxsYSBjb21wbGV0YSwgZml0IHBhcmEgb3Ryb3MgdmlkZW9zXG4gICAgICAgICAgLi4uKHVzZUZ1bGxTY3JlZW4gJiYge1xuICAgICAgICAgICAgcG9zaXRpb246IHsgeDogMC41LCB5OiAwLjUgfSAvLyBDZW50cmFyIHBhcmEgdmlkZW9zIGEgcGFudGFsbGEgY29tcGxldGFcbiAgICAgICAgICB9KSxcbiAgICAgICAgICByZXNwZWN0TmF0aXZlRHVyYXRpb246IHJlc3BlY3ROYXRpdmVEdXJhdGlvbixcbiAgICAgICAgICAvLyBQcm9waWVkYWRlcyBlc3BlY8OtZmljYXMgcGFyYSBzaW5jcm9uaXphY2nDs24gZGUgQVBOR1xuICAgICAgICAgIC4uLih0cmVhdEFzQVBORyAmJiB7XG4gICAgICAgICAgICBpc0FQTkc6IHRydWUsXG4gICAgICAgICAgICBzeW5jV2l0aFRpbWVsaW5lOiBvcHRpb25zPy5zeW5jV2l0aFRpbWVsaW5lIHx8IHRydWUsXG4gICAgICAgICAgICBwbGF5YmFja0JlaGF2aW9yOiBvcHRpb25zPy5wbGF5YmFja0JlaGF2aW9yIHx8IFwic3luY1wiXG4gICAgICAgICAgfSlcbiAgICAgICAgfTtcblxuICAgICAgICBjb25zb2xlLmxvZyhcIk9wY2lvbmVzIGRlIGRpc3BhdGNoOlwiLCBKU09OLnN0cmluZ2lmeShkaXNwYXRjaE9wdGlvbnMsIG51bGwsIDIpKTtcblxuICAgICAgLy8gQWdyZWdhciB2aWRlbyBhbCB0aW1lbGluZVxuICAgICAgZGlzcGF0Y2goQUREX1ZJREVPLCB7XG4gICAgICAgIHBheWxvYWQ6IHZpZGVvUGF5bG9hZCxcbiAgICAgICAgICBvcHRpb25zOiBkaXNwYXRjaE9wdGlvbnMsXG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIE1lbnNhamUgZGUgbG9nIGFkYXB0YWRvIGFsIHRpcG8gZGUgYXJjaGl2b1xuICAgICAgICBpZiAodHJlYXRBc0FQTkcpIHtcbiAgICAgICAgICBjb25zb2xlLmxvZyhg4pyFIFRyYW5zaWNpw7NuIEFQTkcgYcOxYWRpZGEgY29tbyBWSURFTyBTSU5DUk9OSVpBRE8gYWwgdGltZWxpbmUgZGVzZGUgJHtzdGFydFRpbWV9cyAke2ZpbmFsRW5kVGltZSA/IGBoYXN0YSAke2ZpbmFsRW5kVGltZX1zYCA6ICdjb24gZHVyYWNpw7NuIG5hdHVyYWwnfS4gRGltZW5zaW9uZXM6ICR7d2lkdGh9eCR7aGVpZ2h0fWApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnNvbGUubG9nKGDinIUgVmlkZW8gJHtpc0FWSSA/ICdBVkknIDogJyd9IGHDsWFkaWRvIGFsIHRpbWVsaW5lIGRlc2RlICR7c3RhcnRUaW1lfXMke2ZpbmFsRW5kVGltZSA/IGAgaGFzdGEgJHtmaW5hbEVuZFRpbWV9c2AgOiAnIGNvbiBkdXJhY2nDs24gbmF0dXJhbCd9LiBEaW1lbnNpb25lczogJHt3aWR0aH14JHtoZWlnaHR9YCk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCLinYwgRVJST1IgQ1LDjVRJQ08gYWwgYcOxYWRpciB2aWRlbzpcIiwgZXJyb3IpO1xuICAgICAgICBjb25zb2xlLmVycm9yKFwiRGV0YWxsZXMgY29tcGxldG9zOlwiLCBlcnJvci5tZXNzYWdlKTtcbiAgICAgICAgY29uc29sZS5lcnJvcihcIlRyYXphOlwiLCBlcnJvci5zdGFjayk7XG4gICAgICAgIHRocm93IGVycm9yOyAvLyBQcm9wYWdhciBlbCBlcnJvciBwYXJhIG1hbmVqbyBzdXBlcmlvclxuICAgICAgfVxuICAgIH0sXG5cbiAgICBjaGFuZ2VEdXJhdGlvbjogKGVsZW1lbnRJZDogc3RyaW5nLCBkdXJhdGlvbjogbnVtYmVyKSA9PiB7XG4gICAgICAvLyBTaW11bGFjacOzbiBkZSBjYW1iaW8gZGUgZHVyYWNpw7NuIChsYSBpbXBsZW1lbnRhY2nDs24gcmVhbCBkZXBlbmRlcsOhIGRlIGxhIGVzdHJ1Y3R1cmEgZGVsIHByb3llY3RvKVxuICAgICAgY29uc29sZS5sb2coYENhbWJpYW5kbyBkdXJhY2nDs24gZGVsIGVsZW1lbnRvICR7ZWxlbWVudElkfSBhICR7ZHVyYXRpb259c2ApO1xuXG4gICAgICAvLyBBcXXDrSBpcsOtYSBsYSBsw7NnaWNhIHJlYWwgcGFyYSBjYW1iaWFyIGxhIGR1cmFjacOzbiBkZSB1biBlbGVtZW50b1xuICAgIH0sXG5cbiAgICBjaGFuZ2VUcmFuc2l0aW9uOiAoZWxlbWVudElkOiBzdHJpbmcsIHRyYW5zaXRpb246IHN0cmluZykgPT4ge1xuICAgICAgLy8gU2ltdWxhY2nDs24gZGUgY2FtYmlvIGRlIHRyYW5zaWNpw7NuIChsYSBpbXBsZW1lbnRhY2nDs24gcmVhbCBkZXBlbmRlcsOhIGRlIGxhIGVzdHJ1Y3R1cmEgZGVsIHByb3llY3RvKVxuICAgICAgY29uc29sZS5sb2coYENhbWJpYW5kbyB0cmFuc2ljacOzbiBkZWwgZWxlbWVudG8gJHtlbGVtZW50SWR9IGEgJHt0cmFuc2l0aW9ufWApO1xuXG4gICAgICAvLyBBcXXDrSBpcsOtYSBsYSBsw7NnaWNhIHJlYWwgcGFyYSBjYW1iaWFyIGxhIHRyYW5zaWNpw7NuIGRlIHVuIGVsZW1lbnRvXG4gICAgfSxcblxuICAgIGFkZFN1YnRpdGxlczogYXN5bmMgKG9wdGlvbnM/OiBTdWJ0aXRsZU9wdGlvbnMpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiQcOxYWRpZW5kbyBzdWJ0w610dWxvcyBkaXJlY3RhbWVudGUgc2luIGRlcGVuZGVyIGRlbCBib3TDs25cIik7XG5cbiAgICAgICAgLy8gVGlwbyBwYXJhIHJlcHJlc2VudGFyIHVuIHNlZ21lbnRvIGRlIHN1YnTDrXR1bG9cbiAgICAgICAgaW50ZXJmYWNlIFN1YnRpdGxlU2VnbWVudCB7XG4gICAgICAgICAgaWQ6IG51bWJlcjtcbiAgICAgICAgICBzdGFydFRpbWU6IG51bWJlcjsgLy8gZW4gbWlsaXNlZ3VuZG9zXG4gICAgICAgICAgZW5kVGltZTogbnVtYmVyOyAgIC8vIGVuIG1pbGlzZWd1bmRvc1xuICAgICAgICAgIHRleHQ6IHN0cmluZztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEZ1bmNpw7NuIHBhcmEgcGFyc2VhciBlbCB0aWVtcG8gZGUgZm9ybWF0byBTUlQgYSBtaWxpc2VndW5kb3NcbiAgICAgICAgY29uc3QgcGFyc2VUaW1lVG9NcyA9ICh0aW1lU3RyaW5nOiBzdHJpbmcpOiBudW1iZXIgPT4ge1xuICAgICAgICAgIGNvbnN0IFtob3VycywgbWludXRlcywgc2Vjb25kc0FuZE1zXSA9IHRpbWVTdHJpbmcuc3BsaXQoJzonKTtcbiAgICAgICAgICBjb25zdCBbc2Vjb25kcywgbXNdID0gc2Vjb25kc0FuZE1zLnNwbGl0KCcsJyk7XG5cbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgcGFyc2VJbnQoaG91cnMpICogMzYwMDAwMCArXG4gICAgICAgICAgICBwYXJzZUludChtaW51dGVzKSAqIDYwMDAwICtcbiAgICAgICAgICAgIHBhcnNlSW50KHNlY29uZHMpICogMTAwMCArXG4gICAgICAgICAgICBwYXJzZUludChtcylcbiAgICAgICAgICApO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIEZ1bmNpw7NuIHBhcmEgcGFyc2VhciBlbCBhcmNoaXZvIFNSVFxuICAgICAgICBjb25zdCBwYXJzZVNSVCA9IChzcnRDb250ZW50OiBzdHJpbmcpOiBTdWJ0aXRsZVNlZ21lbnRbXSA9PiB7XG4gICAgICAgICAgY29uc3Qgc2VnbWVudHM6IFN1YnRpdGxlU2VnbWVudFtdID0gW107XG4gICAgICAgICAgY29uc3QgYmxvY2tzID0gc3J0Q29udGVudC50cmltKCkuc3BsaXQoJ1xcblxcbicpO1xuXG4gICAgICAgICAgYmxvY2tzLmZvckVhY2goYmxvY2sgPT4ge1xuICAgICAgICAgICAgY29uc3QgbGluZXMgPSBibG9jay5zcGxpdCgnXFxuJyk7XG4gICAgICAgICAgICBpZiAobGluZXMubGVuZ3RoID49IDMpIHtcbiAgICAgICAgICAgICAgY29uc3QgaWQgPSBwYXJzZUludChsaW5lc1swXSk7XG4gICAgICAgICAgICAgIGNvbnN0IHRpbWVSYW5nZSA9IGxpbmVzWzFdLnNwbGl0KCcgLS0+ICcpO1xuICAgICAgICAgICAgICBjb25zdCBzdGFydFRpbWUgPSBwYXJzZVRpbWVUb01zKHRpbWVSYW5nZVswXSk7XG4gICAgICAgICAgICAgIGNvbnN0IGVuZFRpbWUgPSBwYXJzZVRpbWVUb01zKHRpbWVSYW5nZVsxXSk7XG4gICAgICAgICAgICAgIGNvbnN0IHRleHQgPSBsaW5lcy5zbGljZSgyKS5qb2luKCdcXG4nKTsgLy8gVW5pciB0b2RhcyBsYXMgbMOtbmVhcyBkZSB0ZXh0b1xuXG4gICAgICAgICAgICAgIHNlZ21lbnRzLnB1c2goe1xuICAgICAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgICAgIHN0YXJ0VGltZSxcbiAgICAgICAgICAgICAgICBlbmRUaW1lLFxuICAgICAgICAgICAgICAgIHRleHRcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICByZXR1cm4gc2VnbWVudHM7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gRnVuY2nDs24gcGFyYSBkaXZpZGlyIHVuIHRleHRvIGVuIGdydXBvcyBkZSBhcHJveGltYWRhbWVudGUgMyBwYWxhYnJhc1xuICAgICAgICBjb25zdCBzcGxpdFRleHRJbnRvR3JvdXBzID0gKHRleHQ6IHN0cmluZywgd29yZHNQZXJHcm91cCA9IDMpOiBzdHJpbmdbXSA9PiB7XG4gICAgICAgICAgY29uc3Qgd29yZHMgPSB0ZXh0LnNwbGl0KC9cXHMrLyk7XG4gICAgICAgICAgY29uc3QgZ3JvdXBzOiBzdHJpbmdbXSA9IFtdO1xuXG4gICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB3b3Jkcy5sZW5ndGg7IGkgKz0gd29yZHNQZXJHcm91cCkge1xuICAgICAgICAgICAgY29uc3QgZ3JvdXAgPSB3b3Jkcy5zbGljZShpLCBpICsgd29yZHNQZXJHcm91cCkuam9pbignICcpO1xuICAgICAgICAgICAgZ3JvdXBzLnB1c2goZ3JvdXApO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBncm91cHM7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gRnVuY2nDs24gcGFyYSBwcm9jZXNhciB1biBzZWdtZW50byB5IGRpdmlkaXJsbyBlbiBtw7psdGlwbGVzIHNlZ21lbnRvcyBzaSBlcyBuZWNlc2FyaW9cbiAgICAgICAgY29uc3QgcHJvY2Vzc1NlZ21lbnQgPSAoc2VnbWVudDogU3VidGl0bGVTZWdtZW50KTogU3VidGl0bGVTZWdtZW50W10gPT4ge1xuICAgICAgICAgIGNvbnN0IHRleHRHcm91cHMgPSBzcGxpdFRleHRJbnRvR3JvdXBzKHNlZ21lbnQudGV4dCk7XG5cbiAgICAgICAgICAvLyBTaSBzb2xvIGhheSB1biBncnVwbywgZGV2b2x2ZXIgZWwgc2VnbWVudG8gb3JpZ2luYWxcbiAgICAgICAgICBpZiAodGV4dEdyb3Vwcy5sZW5ndGggPD0gMSkge1xuICAgICAgICAgICAgcmV0dXJuIFtzZWdtZW50XTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBDYWxjdWxhciBsYSBkdXJhY2nDs24gZGUgY2FkYSBncnVwb1xuICAgICAgICAgIGNvbnN0IHRvdGFsRHVyYXRpb24gPSBzZWdtZW50LmVuZFRpbWUgLSBzZWdtZW50LnN0YXJ0VGltZTtcbiAgICAgICAgICBjb25zdCBncm91cER1cmF0aW9uID0gdG90YWxEdXJhdGlvbiAvIHRleHRHcm91cHMubGVuZ3RoO1xuXG4gICAgICAgICAgLy8gQ3JlYXIgdW4gbnVldm8gc2VnbWVudG8gcGFyYSBjYWRhIGdydXBvXG4gICAgICAgICAgcmV0dXJuIHRleHRHcm91cHMubWFwKChncm91cFRleHQsIGluZGV4KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBzdGFydFRpbWUgPSBzZWdtZW50LnN0YXJ0VGltZSArIChpbmRleCAqIGdyb3VwRHVyYXRpb24pO1xuICAgICAgICAgICAgY29uc3QgZW5kVGltZSA9IHN0YXJ0VGltZSArIGdyb3VwRHVyYXRpb247XG5cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIGlkOiBzZWdtZW50LmlkICogMTAwMCArIGluZGV4LCAvLyBHZW5lcmFyIHVuIElEIMO6bmljb1xuICAgICAgICAgICAgICBzdGFydFRpbWUsXG4gICAgICAgICAgICAgIGVuZFRpbWUsXG4gICAgICAgICAgICAgIHRleHQ6IGdyb3VwVGV4dFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBGdW5jacOzbiBwYXJhIGNyZWFyIGVsIHBheWxvYWQgZGUgdGV4dG8gcGFyYSBzdWJ0w610dWxvc1xuICAgICAgICBjb25zdCBjcmVhdGVTdWJ0aXRsZVBheWxvYWQgPSAodGV4dDogc3RyaW5nLCBzdGFydFRpbWU6IG51bWJlciwgZW5kVGltZTogbnVtYmVyKSA9PiAoe1xuICAgICAgICAgIGlkOiBnZW5lcmF0ZUlkKCksXG4gICAgICAgICAgZGlzcGxheToge1xuICAgICAgICAgICAgZnJvbTogc3RhcnRUaW1lLFxuICAgICAgICAgICAgdG86IGVuZFRpbWUsXG4gICAgICAgICAgfSxcbiAgICAgICAgICB0eXBlOiAndGV4dCcsXG4gICAgICAgICAgZGV0YWlsczoge1xuICAgICAgICAgICAgdGV4dDogdGV4dC50b1VwcGVyQ2FzZSgpLCAvLyBDb252ZXJ0aXIgYSBtYXnDunNjdWxhcyBjb21vIE1yQmVhc3RcbiAgICAgICAgICAgIGZvbnRTaXplOiA4MCwgLy8gVGFtYcOxbyBtw6FzIGdyYW5kZSBwYXJhIGVzdGlsbyBNckJlYXN0XG4gICAgICAgICAgICB3aWR0aDogOTAwLFxuICAgICAgICAgICAgZm9udFVybDogJy9mb250cy9tcmJlYXN0LnR0ZicsIC8vIFVzYXIgbGEgZnVlbnRlIE1yQmVhc3RcbiAgICAgICAgICAgIGZvbnRGYW1pbHk6ICdNckJlYXN0JywgLy8gTm9tYnJlIGRlIGxhIGZ1ZW50ZSBNckJlYXN0XG4gICAgICAgICAgICBjb2xvcjogJyNGRkZGMDAnLCAvLyBBbWFyaWxsbyBicmlsbGFudGVcbiAgICAgICAgICAgIHdvcmRXcmFwOiAnYnJlYWstd29yZCcsXG4gICAgICAgICAgICB0ZXh0QWxpZ246ICdjZW50ZXInLFxuICAgICAgICAgICAgYm9yZGVyV2lkdGg6IDIwLCAvLyBTdHJva2UgbmVncm8gZ3J1ZXNvXG4gICAgICAgICAgICBib3JkZXJDb2xvcjogJyMwMDAwMDAnLFxuICAgICAgICAgICAgYm94U2hhZG93OiB7XG4gICAgICAgICAgICAgIGNvbG9yOiAnIzAwMDAwMCcsXG4gICAgICAgICAgICAgIHg6IDMsXG4gICAgICAgICAgICAgIHk6IDMsXG4gICAgICAgICAgICAgIGJsdXI6IDAsIC8vIFNpbiBkZXNlbmZvcXVlIHBhcmEgdW4gZXN0aWxvIG3DoXMgaW1wYWN0YW50ZVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogJ3RyYW5zcGFyZW50JywgLy8gU2luIGZvbmRvIHBhcmEgcXVlIGRlc3RhcXVlIG3DoXNcbiAgICAgICAgICAgIHBhZGRpbmc6IDEwLFxuICAgICAgICAgICAgYm9yZGVyUmFkaXVzOiAwLCAvLyBTaW4gYm9yZGVzIHJlZG9uZGVhZG9zIHBhcmEgdW4gZXN0aWxvIG3DoXMgaW1wYWN0YW50ZVxuICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIEZ1bmNpw7NuIHBhcmEgZW5jb250cmFyIHVuIHRyYWNrIGFkZWN1YWRvIHBhcmEgc3VidMOtdHVsb3NcbiAgICAgICAgY29uc3QgZ2V0U3VidGl0bGVUcmFja0lkID0gKCkgPT4ge1xuICAgICAgICAgIC8vIE9idGVuZXIgZWwgZXN0YWRvIGFjdHVhbFxuICAgICAgICAgIGNvbnN0IHN0YXRlID0gc3RhdGVNYW5hZ2VyLmdldFN0YXRlKCk7XG5cbiAgICAgICAgICAvLyBJbnNwZWNjaW9uYXIgZWwgZXN0YWRvIGNvbXBsZXRvIHBhcmEgZGVwdXJhY2nDs25cbiAgICAgICAgICBjb25zb2xlLmxvZyhcIkNsYXZlcyBkaXNwb25pYmxlcyBlbiBlbCBlc3RhZG86XCIsIE9iamVjdC5rZXlzKHN0YXRlKSk7XG5cbiAgICAgICAgICAvLyBJbnRlbnRhciB2YXJpYXMgZXN0cmF0ZWdpYXMgcGFyYSBlbmNvbnRyYXIgbG9zIHRyYWNrc1xuXG4gICAgICAgICAgLy8gRXN0cmF0ZWdpYSAxOiBCdXNjYXIgZGlyZWN0YW1lbnRlIGVuIHN0YXRlLnRyYWNrc1xuICAgICAgICAgIGxldCB0cmFja3MgPSBzdGF0ZS50cmFja3MgfHwgW107XG4gICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhY2tzKSAmJiB0cmFja3MubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coYEVuY29udHJhZG9zICR7dHJhY2tzLmxlbmd0aH0gdHJhY2tzIGVuIHN0YXRlLnRyYWNrc2ApO1xuICAgICAgICAgICAgY29uc3QgdGV4dFRyYWNrID0gdHJhY2tzLmZpbmQodHJhY2sgPT4gdHJhY2sudHlwZSA9PT0gJ3RleHQnICYmIHRyYWNrLmFjY2VwdHMgJiYgdHJhY2suYWNjZXB0cy5pbmNsdWRlcygndGV4dCcpKTtcbiAgICAgICAgICAgIGlmICh0ZXh0VHJhY2spIHtcbiAgICAgICAgICAgICAgY29uc29sZS5sb2coYEVuY29udHJhZG8gdHJhY2sgZGUgdGV4dG8gY29uIElEOiAke3RleHRUcmFjay5pZH1gKTtcbiAgICAgICAgICAgICAgcmV0dXJuIHRleHRUcmFjay5pZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc29sZS5sb2coXCJObyBzZSBlbmNvbnRyYXJvbiB0cmFja3MgZW4gc3RhdGUudHJhY2tzXCIpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIEVzdHJhdGVnaWEgMjogQnVzY2FyIGVuIGxhIGVzdHJ1Y3R1cmEgZGVsIHRpbWVsaW5lXG4gICAgICAgICAgaWYgKHN0YXRlLnRpbWVsaW5lKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIlRpbWVsaW5lIGVuY29udHJhZG8gZW4gZWwgZXN0YWRvXCIpO1xuXG4gICAgICAgICAgICAvLyBSZXZpc2FyIHNpIGhheSBjYW52YXMgeSB0cmFja3MgZW4gZWwgdGltZWxpbmVcbiAgICAgICAgICAgIGlmIChzdGF0ZS50aW1lbGluZS5jYW52YXMgJiYgc3RhdGUudGltZWxpbmUuY2FudmFzLnRyYWNrcykge1xuICAgICAgICAgICAgICBjb25zdCBjYW52YXNUcmFja3MgPSBzdGF0ZS50aW1lbGluZS5jYW52YXMudHJhY2tzO1xuICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShjYW52YXNUcmFja3MpICYmIGNhbnZhc1RyYWNrcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coYEVuY29udHJhZG9zICR7Y2FudmFzVHJhY2tzLmxlbmd0aH0gdHJhY2tzIGVuIHRpbWVsaW5lLmNhbnZhcy50cmFja3NgKTtcbiAgICAgICAgICAgICAgICBjb25zdCB0cmFja0lkID0gY2FudmFzVHJhY2tzWzBdLmlkO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBVc2FuZG8gcHJpbWVyIHRyYWNrIGRlIGNhbnZhczogJHt0cmFja0lkfWApO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cmFja0lkO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEFsdGVybmF0aXZhOiBidXNjYXIgZW4gb3RyYXMgcHJvcGllZGFkZXMgZGVsIHRpbWVsaW5lXG4gICAgICAgICAgICBpZiAoc3RhdGUudGltZWxpbmUudHJhY2tzKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHRpbWVsaW5lVHJhY2tzID0gc3RhdGUudGltZWxpbmUudHJhY2tzO1xuICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0aW1lbGluZVRyYWNrcykgJiYgdGltZWxpbmVUcmFja3MubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBFbmNvbnRyYWRvcyAke3RpbWVsaW5lVHJhY2tzLmxlbmd0aH0gdHJhY2tzIGVuIHRpbWVsaW5lLnRyYWNrc2ApO1xuICAgICAgICAgICAgICAgIGNvbnN0IHRyYWNrSWQgPSB0aW1lbGluZVRyYWNrc1swXS5pZDtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgVXNhbmRvIHByaW1lciB0cmFjayBkZSB0aW1lbGluZS50cmFja3M6ICR7dHJhY2tJZH1gKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJhY2tJZDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIk5vIHNlIGVuY29udHLDsyB0aW1lbGluZSBlbiBlbCBlc3RhZG9cIik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gRXN0cmF0ZWdpYSAzOiBCdXNjYXIgZWxlbWVudG9zIGFjdGl2b3MgeSB1c2FyIHN1IHRyYWNrSWRcbiAgICAgICAgICBpZiAoc3RhdGUuYWN0aXZlSWRzICYmIHN0YXRlLmFjdGl2ZUlkcy5sZW5ndGggPiAwICYmIHN0YXRlLnRyYWNrSXRlbXNNYXApIHtcbiAgICAgICAgICAgIGNvbnN0IGFjdGl2ZUVsZW1lbnQgPSBzdGF0ZS50cmFja0l0ZW1zTWFwW3N0YXRlLmFjdGl2ZUlkc1swXV07XG4gICAgICAgICAgICBpZiAoYWN0aXZlRWxlbWVudCAmJiBhY3RpdmVFbGVtZW50LnRyYWNrSWQpIHtcbiAgICAgICAgICAgICAgY29uc29sZS5sb2coYFVzYW5kbyB0cmFja0lkIGRlbCBlbGVtZW50byBhY3Rpdm86ICR7YWN0aXZlRWxlbWVudC50cmFja0lkfWApO1xuICAgICAgICAgICAgICByZXR1cm4gYWN0aXZlRWxlbWVudC50cmFja0lkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIEVzdHJhdGVnaWEgNDogRXhwbG9yYXIgdHJhY2tJdGVtc01hcCBwYXJhIGVuY29udHJhciB1biB0aXBvIGRlIHRyYWNrXG4gICAgICAgICAgaWYgKHN0YXRlLnRyYWNrSXRlbXNNYXAgJiYgT2JqZWN0LmtleXMoc3RhdGUudHJhY2tJdGVtc01hcCkubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coYEV4cGxvcmFuZG8gJHtPYmplY3Qua2V5cyhzdGF0ZS50cmFja0l0ZW1zTWFwKS5sZW5ndGh9IGVsZW1lbnRvcyBlbiB0cmFja0l0ZW1zTWFwYCk7XG5cbiAgICAgICAgICAgIC8vIEJ1c2NhciB1biBlbGVtZW50byBkZSB0aXBvIHRleHRvIHkgdXNhciBzdSB0cmFja0lkXG4gICAgICAgICAgICBjb25zdCB0ZXh0SXRlbXMgPSBPYmplY3QudmFsdWVzKHN0YXRlLnRyYWNrSXRlbXNNYXApXG4gICAgICAgICAgICAgIC5maWx0ZXIoaXRlbSA9PiBpdGVtLnR5cGUgPT09ICd0ZXh0Jyk7XG5cbiAgICAgICAgICAgIGlmICh0ZXh0SXRlbXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICBjb25zdCB0cmFja0lkID0gdGV4dEl0ZW1zWzBdLnRyYWNrSWQ7XG4gICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBFbmNvbnRyYWRvIHRyYWNrSWQgJHt0cmFja0lkfSBkZSB1biBlbGVtZW50byBkZSB0ZXh0byBleGlzdGVudGVgKTtcbiAgICAgICAgICAgICAgcmV0dXJuIHRyYWNrSWQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFNpIG5vIGhheSBlbGVtZW50b3MgZGUgdGV4dG8sIHVzYXIgZWwgcHJpbWVyIHRyYWNrSWQgZGlzcG9uaWJsZVxuICAgICAgICAgICAgY29uc3QgZmlyc3RJdGVtID0gT2JqZWN0LnZhbHVlcyhzdGF0ZS50cmFja0l0ZW1zTWFwKVswXTtcbiAgICAgICAgICAgIGlmIChmaXJzdEl0ZW0gJiYgZmlyc3RJdGVtLnRyYWNrSWQpIHtcbiAgICAgICAgICAgICAgY29uc29sZS5sb2coYFVzYW5kbyBwcmltZXIgdHJhY2tJZCBkaXNwb25pYmxlOiAke2ZpcnN0SXRlbS50cmFja0lkfWApO1xuICAgICAgICAgICAgICByZXR1cm4gZmlyc3RJdGVtLnRyYWNrSWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gRXN0cmF0ZWdpYSA1OiBCdXNjYXIgZW4gb3RyYXMgcHJvcGllZGFkZXMgZGVsIGVzdGFkbyBxdWUgcG9kcsOtYW4gY29udGVuZXIgdHJhY2tzXG4gICAgICAgICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMoc3RhdGUpKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHN0YXRlW2tleV0gPT09ICdvYmplY3QnICYmIHN0YXRlW2tleV0gIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgLy8gQnVzY2FyIHByb3BpZWRhZGVzIHF1ZSBwYXJlemNhbiBjb250ZW5lciB0cmFja3NcbiAgICAgICAgICAgICAgaWYgKHN0YXRlW2tleV0udHJhY2tzICYmIEFycmF5LmlzQXJyYXkoc3RhdGVba2V5XS50cmFja3MpICYmIHN0YXRlW2tleV0udHJhY2tzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgRW5jb250cmFkb3MgdHJhY2tzIGVuIHN0YXRlLiR7a2V5fS50cmFja3NgKTtcbiAgICAgICAgICAgICAgICBjb25zdCB0cmFja0lkID0gc3RhdGVba2V5XS50cmFja3NbMF0uaWQ7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coYFVzYW5kbyB0cmFjayBkZSBzdGF0ZS4ke2tleX0udHJhY2tzOiAke3RyYWNrSWR9YCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRyYWNrSWQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb25zb2xlLmxvZyhcIk5vIHNlIGVuY29udHLDsyBuaW5nw7puIHRyYWNrIGFkZWN1YWRvIGRlc3B1w6lzIGRlIGludGVudGFyIG3Dumx0aXBsZXMgZXN0cmF0ZWdpYXNcIik7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gQ2FyZ2FyIGVsIGFyY2hpdm8gU1JUXG4gICAgICAgIGNvbnNvbGUubG9nKFwiQ2FyZ2FuZG8gYXJjaGl2byBTUlQuLi5cIik7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goJy90cmFuc2NyaXB0aW9ucy90cmFuc2NyaXB0aW9uMS5zcnQnKTtcbiAgICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRXJyb3IgYWwgY2FyZ2FyIGVsIGFyY2hpdm8gU1JUOiAke3Jlc3BvbnNlLnN0YXR1c31gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHNydENvbnRlbnQgPSBhd2FpdCByZXNwb25zZS50ZXh0KCk7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiQXJjaGl2byBTUlQgY2FyZ2FkbyBjb3JyZWN0YW1lbnRlXCIpO1xuXG4gICAgICAgIC8vIFBhcnNlYXIgZWwgYXJjaGl2byBTUlRcbiAgICAgICAgbGV0IHNlZ21lbnRzID0gcGFyc2VTUlQoc3J0Q29udGVudCk7XG4gICAgICAgIGNvbnNvbGUubG9nKGBTZSBlbmNvbnRyYXJvbiAke3NlZ21lbnRzLmxlbmd0aH0gc2VnbWVudG9zIGRlIHN1YnTDrXR1bG9zYCk7XG5cbiAgICAgICAgLy8gU2llbXByZSB1c2FyIGVsIG1vZG8gYWdydXBhZG8gKGRpdmlkaXIgZW4gZ3J1cG9zIGRlIDMgcGFsYWJyYXMpXG4gICAgICAgIHNlZ21lbnRzID0gc2VnbWVudHMuZmxhdE1hcChwcm9jZXNzU2VnbWVudCk7XG4gICAgICAgIGNvbnNvbGUubG9nKGBEZXNwdcOpcyBkZSBwcm9jZXNhciwgaGF5ICR7c2VnbWVudHMubGVuZ3RofSBzZWdtZW50b3MgZGUgc3VidMOtdHVsb3NgKTtcblxuICAgICAgICAvLyBGaWx0cmFyIHBvciB0aWVtcG8gc2kgZXMgbmVjZXNhcmlvXG4gICAgICAgIGlmIChvcHRpb25zPy5zdGFydFRpbWUgIT09IHVuZGVmaW5lZCB8fCBvcHRpb25zPy5lbmRUaW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBjb25zdCBvcmlnaW5hbExlbmd0aCA9IHNlZ21lbnRzLmxlbmd0aDtcbiAgICAgICAgICBzZWdtZW50cyA9IHNlZ21lbnRzLmZpbHRlcihzZWdtZW50ID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHBhc3Nlc1N0YXJ0RmlsdGVyID0gb3B0aW9ucy5zdGFydFRpbWUgPT09IHVuZGVmaW5lZCB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlZ21lbnQuc3RhcnRUaW1lID49IChvcHRpb25zLnN0YXJ0VGltZSAqIDEwMDApO1xuICAgICAgICAgICAgY29uc3QgcGFzc2VzRW5kRmlsdGVyID0gb3B0aW9ucy5lbmRUaW1lID09PSB1bmRlZmluZWQgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VnbWVudC5lbmRUaW1lIDw9IChvcHRpb25zLmVuZFRpbWUgKiAxMDAwKTtcbiAgICAgICAgICAgIHJldHVybiBwYXNzZXNTdGFydEZpbHRlciAmJiBwYXNzZXNFbmRGaWx0ZXI7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgY29uc29sZS5sb2coYEZpbHRyYWRvIHBvciB0aWVtcG86IGRlICR7b3JpZ2luYWxMZW5ndGh9IGEgJHtzZWdtZW50cy5sZW5ndGh9IHNlZ21lbnRvc2ApO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gT2J0ZW5lciBlbCBJRCBkZWwgdHJhY2sgcGFyYSBzdWJ0w610dWxvc1xuICAgICAgICBsZXQgdHJhY2tJZCA9IGdldFN1YnRpdGxlVHJhY2tJZCgpO1xuXG4gICAgICAgIC8vIEVuZm9xdWUgYWRhcHRhdGl2bzogc2kgbm8gaGF5IHVuIHRyYWNrIGlkZW50aWZpY2FkbywgYWdyZWdhciBlbCBwcmltZXIgc3VidMOtdHVsbyxcbiAgICAgICAgLy8gb2J0ZW5lciBzdSB0cmFja0lkLCB5IGx1ZWdvIGFncmVnYXIgZWwgcmVzdG9cbiAgICAgICAgaWYgKCF0cmFja0lkICYmIHNlZ21lbnRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBjb25zb2xlLmxvZyhcIk5vIHNlIGlkZW50aWZpY8OzIHVuIHRyYWNrIGFkZWN1YWRvLiBVc2FuZG8gZW5mb3F1ZSBhZGFwdGF0aXZvOiBhw7FhZGlyIHByaW1lciBzdWJ0w610dWxvIHkgb2J0ZW5lciBzdSB0cmFja0lkXCIpO1xuXG4gICAgICAgICAgLy8gQ3JlYXIgdW5hIHByb21lc2EgcGFyYSBtYW5lamFyIGVzdGUgcHJvY2VzbyBhc8OtbmNyb25vXG4gICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAgICAgICAvLyBFeHRyYWVyIGVsIHByaW1lciBzdWJ0w610dWxvXG4gICAgICAgICAgICBjb25zdCBmaXJzdFNlZ21lbnQgPSBzZWdtZW50c1swXTtcbiAgICAgICAgICAgIGNvbnN0IHJlbWFpbmluZ1NlZ21lbnRzID0gc2VnbWVudHMuc2xpY2UoMSk7XG5cbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiQcOxYWRpZW5kbyBwcmltZXIgc3VidMOtdHVsbyBjb21vIGVsZW1lbnRvIGluaWNpYWwgcGFyYSBpZGVudGlmaWNhciB1biB0cmFjay4uLlwiKTtcblxuICAgICAgICAgICAgLy8gQcOxYWRpciBlbCBwcmltZXIgc3VidMOtdHVsb1xuICAgICAgICAgICAgZGlzcGF0Y2goQUREX1RFWFQsIHtcbiAgICAgICAgICAgICAgcGF5bG9hZDogY3JlYXRlU3VidGl0bGVQYXlsb2FkKGZpcnN0U2VnbWVudC50ZXh0LCBmaXJzdFNlZ21lbnQuc3RhcnRUaW1lLCBmaXJzdFNlZ21lbnQuZW5kVGltZSksXG4gICAgICAgICAgICAgIG9wdGlvbnM6IHt9LCAvLyBTaW4gdHJhY2tJZCBlc3BlY8OtZmljb1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vIEVzcGVyYXIgMyBzZWd1bmRvcyBwYXJhIHF1ZSBlbCBlbGVtZW50byBzZSBjcmVlIHkgZXN0w6kgZGlzcG9uaWJsZSBlbiBlbCBlc3RhZG9cbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiRXNwZXJhbmRvIDMgc2VndW5kb3MgcGFyYSBxdWUgZWwgcHJpbWVyIHN1YnTDrXR1bG8gc2UgY3JlZSBjb21wbGV0YW1lbnRlLi4uXCIpO1xuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgIC8vIE9idGVuZXIgZWwgZXN0YWRvIGFjdHVhbGl6YWRvXG4gICAgICAgICAgICAgIGNvbnN0IHVwZGF0ZWRTdGF0ZSA9IHN0YXRlTWFuYWdlci5nZXRTdGF0ZSgpO1xuXG4gICAgICAgICAgICAgIC8vIEJ1c2NhciBlbGVtZW50b3MgZGUgdGlwbyB0ZXh0byByZWNpw6luIGHDsWFkaWRvc1xuICAgICAgICAgICAgICBsZXQgbmV3VHJhY2tJZCA9IG51bGw7XG5cbiAgICAgICAgICAgICAgLy8gT3BjaW9uZXMgcGFyYSBlbmNvbnRyYXIgZWwgbnVldm8gdHJhY2tJZFxuICAgICAgICAgICAgICBpZiAodXBkYXRlZFN0YXRlLnRyYWNrSXRlbXNNYXApIHtcbiAgICAgICAgICAgICAgICBjb25zdCB0ZXh0SXRlbXMgPSBPYmplY3QudmFsdWVzKHVwZGF0ZWRTdGF0ZS50cmFja0l0ZW1zTWFwKVxuICAgICAgICAgICAgICAgICAgLmZpbHRlcihpdGVtID0+XG4gICAgICAgICAgICAgICAgICAgIGl0ZW0udHlwZSA9PT0gJ3RleHQnICYmXG4gICAgICAgICAgICAgICAgICAgIGl0ZW0uZGV0YWlscyAmJlxuICAgICAgICAgICAgICAgICAgICBpdGVtLmRldGFpbHMudGV4dCA9PT0gZmlyc3RTZWdtZW50LnRleHQudG9VcHBlckNhc2UoKVxuICAgICAgICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgICAgIGlmICh0ZXh0SXRlbXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgbmV3VHJhY2tJZCA9IHRleHRJdGVtc1swXS50cmFja0lkO1xuICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coYFN1YnTDrXR1bG8gaWRlbnRpZmljYWRvIGVuIHRyYWNrOiAke25ld1RyYWNrSWR9YCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIC8vIEFsdGVybmF0aXZhOiBidXNjYXIgZWwgZWxlbWVudG8gbcOhcyByZWNpZW50ZVxuICAgICAgICAgICAgICAgICAgY29uc3QgYWxsSXRlbXMgPSBPYmplY3QudmFsdWVzKHVwZGF0ZWRTdGF0ZS50cmFja0l0ZW1zTWFwKTtcbiAgICAgICAgICAgICAgICAgIGlmIChhbGxJdGVtcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG1vc3RSZWNlbnRJdGVtID0gYWxsSXRlbXMuc29ydCgoYSwgYikgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgIC8vIE9yZGVuYXIgcG9yIHRpbWVzdGFtcCBkZSBjcmVhY2nDs24gc2kgZXhpc3RlLCBvIHBvciByYW5nbyBkZSB0aWVtcG9cbiAgICAgICAgICAgICAgICAgICAgICBjb25zdCBhVGltZSA9IGEudGltZXN0YW1wIHx8IChhLmRpc3BsYXkgPyBhLmRpc3BsYXkuZnJvbSA6IDApO1xuICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGJUaW1lID0gYi50aW1lc3RhbXAgfHwgKGIuZGlzcGxheSA/IGIuZGlzcGxheS5mcm9tIDogMCk7XG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJUaW1lIC0gYVRpbWU7IC8vIE9yZGVuIGRlc2NlbmRlbnRlIChtw6FzIHJlY2llbnRlIHByaW1lcm8pXG4gICAgICAgICAgICAgICAgICAgIH0pWzBdO1xuXG4gICAgICAgICAgICAgICAgICAgIG5ld1RyYWNrSWQgPSBtb3N0UmVjZW50SXRlbS50cmFja0lkO1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgVXNhbmRvIHRyYWNrIGRlbCBlbGVtZW50byBtw6FzIHJlY2llbnRlOiAke25ld1RyYWNrSWR9YCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgLy8gTWFyY2FyIGVsIHByaW1lciBzdWJ0w610dWxvIGNvbW8gYcOxYWRpZG9cbiAgICAgICAgICAgICAgY29uc29sZS5sb2coYFByaW1lciBzdWJ0w610dWxvIGHDsWFkaWRvIGNvbW8gcmVmZXJlbmNpYS4gVHJhY2sgaWRlbnRpZmljYWRvOiAke25ld1RyYWNrSWQgfHwgJ25pbmd1bm8nfWApO1xuXG4gICAgICAgICAgICAgIC8vIFNpIG5vIHNlIGVuY29udHLDsyB0cmFja0lkLCBpbnRlbnRhciBjb24gZWwgbcOpdG9kbyBvcmlnaW5hbCB1bmEgdmV6IG3DoXNcbiAgICAgICAgICAgICAgaWYgKCFuZXdUcmFja0lkKSB7XG4gICAgICAgICAgICAgICAgbmV3VHJhY2tJZCA9IGdldFN1YnRpdGxlVHJhY2tJZCgpO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBSZWludGVudGFuZG8gb2J0ZW5lciB0cmFja0lkOiAke25ld1RyYWNrSWQgfHwgJ2ZhbGxpZG8nfWApO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgLy8gQcOxYWRpciBlbCByZXN0byBkZSBsb3Mgc3VidMOtdHVsb3MgY29uIGVsIHRyYWNrSWQgaWRlbnRpZmljYWRvXG4gICAgICAgICAgICAgIGlmIChyZW1haW5pbmdTZWdtZW50cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coYEHDsWFkaWVuZG8gbG9zICR7cmVtYWluaW5nU2VnbWVudHMubGVuZ3RofSBzdWJ0w610dWxvcyByZXN0YW50ZXMke25ld1RyYWNrSWQgPyBgIGFsIHRyYWNrICR7bmV3VHJhY2tJZH1gIDogJyd9Li4uYCk7XG5cbiAgICAgICAgICAgICAgICAvLyBBbG1hY2VuYXIgbG9zIHRyYWNrcyB1c2Fkb3MgcGFyYSBkZXRlY3RhciB0cmFja3Mgc2VjdW5kYXJpb3NcbiAgICAgICAgICAgICAgICBjb25zdCB1c2VkVHJhY2tzID0gbmV3IFNldDxzdHJpbmc+KCk7XG4gICAgICAgICAgICAgICAgaWYgKG5ld1RyYWNrSWQpIHVzZWRUcmFja3MuYWRkKG5ld1RyYWNrSWQpO1xuXG4gICAgICAgICAgICAgICAgLy8gTWFwYSBwYXJhIGxsZXZhciByZWdpc3RybyBkZSBsYXMgcG9zaWNpb25lcyB5IG9jdXBhY2nDs24gZGUgdGllbXBvIHBvciB0cmFja1xuICAgICAgICAgICAgICAgIGNvbnN0IHRyYWNrVGltZU1hcDogUmVjb3JkPHN0cmluZywgQXJyYXk8e2Zyb206IG51bWJlciwgdG86IG51bWJlcn0+PiA9IHt9O1xuXG4gICAgICAgICAgICAgICAgLy8gRnVuY2nDs24gcGFyYSBjb21wcm9iYXIgc2kgdW4gc2VnbWVudG8gc2Ugc29sYXBhIGNvbiBsb3MgZXhpc3RlbnRlcyBlbiB1biB0cmFja1xuICAgICAgICAgICAgICAgIGNvbnN0IGNoZWNrT3ZlcmxhcCA9ICh0cmFja0lkOiBzdHJpbmcsIGZyb206IG51bWJlciwgdG86IG51bWJlcik6IGJvb2xlYW4gPT4ge1xuICAgICAgICAgICAgICAgICAgaWYgKCF0cmFja1RpbWVNYXBbdHJhY2tJZF0pIHJldHVybiBmYWxzZTsgLy8gU2kgZWwgdHJhY2sgbm8gdGllbmUgZWxlbWVudG9zLCBubyBoYXkgc29sYXBhbWllbnRvXG5cbiAgICAgICAgICAgICAgICAgIHJldHVybiB0cmFja1RpbWVNYXBbdHJhY2tJZF0uc29tZSh0aW1lU2xvdCA9PiB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFZlcmlmaWNhciBzaSBoYXkgc29sYXBhbWllbnRvIChoYXkgdmFyaWFzIGZvcm1hcyBlbiBxdWUgZG9zIGludGVydmFsb3MgcHVlZGVuIHN1cGVycG9uZXJzZSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChmcm9tID49IHRpbWVTbG90LmZyb20gJiYgZnJvbSA8IHRpbWVTbG90LnRvKSB8fCAvLyBJbmljaW8gZGVudHJvIGRlIHVuIHNsb3QgZXhpc3RlbnRlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAodG8gPiB0aW1lU2xvdC5mcm9tICYmIHRvIDw9IHRpbWVTbG90LnRvKSB8fCAgICAvLyBGaW4gZGVudHJvIGRlIHVuIHNsb3QgZXhpc3RlbnRlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAoZnJvbSA8PSB0aW1lU2xvdC5mcm9tICYmIHRvID49IHRpbWVTbG90LnRvKTsgICAvLyBBYmFyY2EgY29tcGxldGFtZW50ZSB1biBzbG90IGV4aXN0ZW50ZVxuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIC8vIEZ1bmNpw7NuIHBhcmEgYcOxYWRpciB1biByZWdpc3RybyBkZSB0aWVtcG8gdXRpbGl6YWRvIGVuIHVuIHRyYWNrXG4gICAgICAgICAgICAgICAgY29uc3QgYWRkVGltZVNsb3QgPSAodHJhY2tJZDogc3RyaW5nLCBmcm9tOiBudW1iZXIsIHRvOiBudW1iZXIpID0+IHtcbiAgICAgICAgICAgICAgICAgIGlmICghdHJhY2tUaW1lTWFwW3RyYWNrSWRdKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyYWNrVGltZU1hcFt0cmFja0lkXSA9IFtdO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgdHJhY2tUaW1lTWFwW3RyYWNrSWRdLnB1c2goeyBmcm9tLCB0byB9KTtcblxuICAgICAgICAgICAgICAgICAgLy8gT3JkZW5hciBwYXJhIGZhY2lsaXRhciBiw7pzcXVlZGFzIGZ1dHVyYXNcbiAgICAgICAgICAgICAgICAgIHRyYWNrVGltZU1hcFt0cmFja0lkXS5zb3J0KChhLCBiKSA9PiBhLmZyb20gLSBiLmZyb20pO1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAvLyBQYXJhIG1vbml0b3JlYXIgdHJhY2tzIGFkaWNpb25hbGVzIHF1ZSBzZSBjcmVlblxuICAgICAgICAgICAgICAgIGNvbnN0IGNoZWNrRm9yTmV3VHJhY2tzID0gKHByZXZTdGF0ZTogYW55LCBjdXJyZW50U3RhdGU6IGFueSkgPT4ge1xuICAgICAgICAgICAgICAgICAgaWYgKCFjdXJyZW50U3RhdGUudHJhY2tJdGVtc01hcCkgcmV0dXJuIG51bGw7XG5cbiAgICAgICAgICAgICAgICAgIC8vIEJ1c2NhciBlbGVtZW50b3MgbnVldm9zIHF1ZSBubyBlc3RhYmFuIGVuIGVsIGVzdGFkbyBhbnRlcmlvclxuICAgICAgICAgICAgICAgICAgY29uc3QgcHJldkl0ZW1zID0gcHJldlN0YXRlLnRyYWNrSXRlbXNNYXAgPyBPYmplY3Qua2V5cyhwcmV2U3RhdGUudHJhY2tJdGVtc01hcCkgOiBbXTtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRJdGVtcyA9IE9iamVjdC5rZXlzKGN1cnJlbnRTdGF0ZS50cmFja0l0ZW1zTWFwKTtcblxuICAgICAgICAgICAgICAgICAgLy8gRW5jb250cmFyIGxvcyBJRHMgZGUgZWxlbWVudG9zIG51ZXZvc1xuICAgICAgICAgICAgICAgICAgY29uc3QgbmV3SXRlbUlkcyA9IGN1cnJlbnRJdGVtcy5maWx0ZXIoaWQgPT4gIXByZXZJdGVtcy5pbmNsdWRlcyhpZCkpO1xuXG4gICAgICAgICAgICAgICAgICBpZiAobmV3SXRlbUlkcy5sZW5ndGggPT09IDApIHJldHVybiBudWxsO1xuXG4gICAgICAgICAgICAgICAgICAvLyBPYnRlbmVyIGluZm9ybWFjacOzbiBkZSBsb3MgbnVldm9zIGVsZW1lbnRvc1xuICAgICAgICAgICAgICAgICAgY29uc3QgbmV3SXRlbXMgPSBuZXdJdGVtSWRzLm1hcChpZCA9PiBjdXJyZW50U3RhdGUudHJhY2tJdGVtc01hcFtpZF0pO1xuXG4gICAgICAgICAgICAgICAgICAvLyBCdXNjYXIgdHJhY2tJZHMgcXVlIG5vIGhheWFtb3MgdmlzdG8gYW50ZXNcbiAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgaXRlbSBvZiBuZXdJdGVtcykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXRlbS50cmFja0lkICYmICF1c2VkVHJhY2tzLmhhcyhpdGVtLnRyYWNrSWQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coYERldGVjdGFkbyBudWV2byB0cmFjayBzZWN1bmRhcmlvOiAke2l0ZW0udHJhY2tJZH1gKTtcbiAgICAgICAgICAgICAgICAgICAgICB1c2VkVHJhY2tzLmFkZChpdGVtLnRyYWNrSWQpO1xuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBpdGVtLnRyYWNrSWQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIC8vIFByb2Nlc2FyIGxvcyBzdWJ0w610dWxvcyByZXN0YW50ZXMgY29uIHNlZ3VpbWllbnRvIGRlIGVzdGFkb1xuICAgICAgICAgICAgICAgIGxldCBjdXJyZW50U3RhdGUgPSB1cGRhdGVkU3RhdGU7XG4gICAgICAgICAgICAgICAgbGV0IHJlY2VudFRyYWNrSWQgPSBuZXdUcmFja0lkO1xuXG4gICAgICAgICAgICAgICAgY29uc3QgcHJvY2Vzc1NlZ21lbnRXaXRoVHJhY2tpbmcgPSAoaW5kZXg6IG51bWJlcikgPT4ge1xuICAgICAgICAgICAgICAgICAgaWYgKGluZGV4ID49IHJlbWFpbmluZ1NlZ21lbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIlByb2Nlc28gZGUgYcOxYWRpciBzdWJ0w610dWxvcyBjb21wbGV0YWRvIGNvbiDDqXhpdG9cIik7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUodHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgY29uc3Qgc2VnbWVudCA9IHJlbWFpbmluZ1NlZ21lbnRzW2luZGV4XTtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IGZyb20gPSBzZWdtZW50LnN0YXJ0VGltZTtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IHRvID0gc2VnbWVudC5lbmRUaW1lO1xuXG4gICAgICAgICAgICAgICAgICAvLyBDb21wcm9iYXIgc3VwZXJwb3NpY2nDs24gZW4gbG9zIHRyYWNrcyBkaXNwb25pYmxlc1xuICAgICAgICAgICAgICAgICAgbGV0IHNlbGVjdGVkVHJhY2tJZCA9IHJlY2VudFRyYWNrSWQ7XG5cbiAgICAgICAgICAgICAgICAgIC8vIFZlcmlmaWNhciBzaSBoYXkgc3VwZXJwb3NpY2nDs24gZW4gZWwgdHJhY2sgcHJpbmNpcGFsXG4gICAgICAgICAgICAgICAgICBsZXQgaGFzT3ZlcmxhcCA9IHNlbGVjdGVkVHJhY2tJZCA/IGNoZWNrT3ZlcmxhcChzZWxlY3RlZFRyYWNrSWQsIGZyb20sIHRvKSA6IGZhbHNlO1xuXG4gICAgICAgICAgICAgICAgICAvLyBTaSBoYXkgc3VwZXJwb3NpY2nDs24sIGJ1c2NhciBvdHJvIHRyYWNrIGRvbmRlIG5vIGhheWEgc3VwZXJwb3NpY2nDs25cbiAgICAgICAgICAgICAgICAgIGlmIChoYXNPdmVybGFwKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBTdXBlcnBvc2ljacOzbiBkZXRlY3RhZGEgZW4gdHJhY2sgJHtzZWxlY3RlZFRyYWNrSWR9IHBhcmEgZWwgc2VnbWVudG8gJHtpbmRleCsxfWApO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIEludGVudGFyIG90cm9zIHRyYWNrcyBxdWUgeWEgY29ub2NlbW9zXG4gICAgICAgICAgICAgICAgICAgIGxldCBmb3VuZE5vbk92ZXJsYXBwaW5nVHJhY2sgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCB0cmFja0lkIG9mIHVzZWRUcmFja3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICBpZiAodHJhY2tJZCAhPT0gc2VsZWN0ZWRUcmFja0lkICYmICFjaGVja092ZXJsYXAodHJhY2tJZCwgZnJvbSwgdG8pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgVXNhbmRvIHRyYWNrIGFsdGVybmF0aXZvICR7dHJhY2tJZH0gcGFyYSBldml0YXIgc3VwZXJwb3NpY2nDs25gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdGVkVHJhY2tJZCA9IHRyYWNrSWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3VuZE5vbk92ZXJsYXBwaW5nVHJhY2sgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gU2kgbm8gc2UgZW5jb250csOzIHVuIHRyYWNrIHNpbiBzdXBlcnBvc2ljacOzbiwgbWFudGVuZXIgZWwgb3JpZ2luYWxcbiAgICAgICAgICAgICAgICAgICAgLy8gRWwgc2lzdGVtYSBwb2Ryw61hIGNyZWFyIHVuIG51ZXZvIHRyYWNrIGF1dG9tw6F0aWNhbWVudGVcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFmb3VuZE5vbk92ZXJsYXBwaW5nVHJhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgTm8gc2UgZW5jb250csOzIHRyYWNrIGFsdGVybmF0aXZvLCBwZXJtaXRpZW5kbyBxdWUgZWwgc2lzdGVtYSBjcmVlIHVubyBudWV2b2ApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgIC8vIENvcGlhciBlbCBlc3RhZG8gYWN0dWFsIGFudGVzIGRlIGxhIGFjY2nDs25cbiAgICAgICAgICAgICAgICAgIGNvbnN0IHByZXZTdGF0ZSA9IHsgLi4uY3VycmVudFN0YXRlIH07XG5cbiAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBBw7FhZGllbmRvIHN1YnTDrXR1bG8gJHtpbmRleCsxfS8ke3JlbWFpbmluZ1NlZ21lbnRzLmxlbmd0aH0gYWwgdHJhY2sgJHtzZWxlY3RlZFRyYWNrSWQgfHwgJ2F1dG9tw6F0aWNvJ31gKTtcblxuICAgICAgICAgICAgICAgICAgLy8gQcOxYWRpciBlbCBzdWJ0w610dWxvXG4gICAgICAgICAgICAgICAgICBkaXNwYXRjaChBRERfVEVYVCwge1xuICAgICAgICAgICAgICAgICAgICBwYXlsb2FkOiBjcmVhdGVTdWJ0aXRsZVBheWxvYWQoc2VnbWVudC50ZXh0LCBmcm9tLCB0byksXG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnM6IHNlbGVjdGVkVHJhY2tJZCA/IHsgdHJhY2tJZDogc2VsZWN0ZWRUcmFja0lkIH0gOiB7fSxcbiAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAvLyBFc3BlcmFyIHVuIHBvY28gcGFyYSBxdWUgc2UgYWN0dWFsaWNlIGVsIGVzdGFkb1xuICAgICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIC8vIE9idGVuZXIgZXN0YWRvIGFjdHVhbGl6YWRvXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRTdGF0ZSA9IHN0YXRlTWFuYWdlci5nZXRTdGF0ZSgpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIENvbXByb2JhciBzaSBzZSBoYSBjcmVhZG8gdW4gbnVldm8gdHJhY2tcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbmV3VHJhY2sgPSBjaGVja0Zvck5ld1RyYWNrcyhwcmV2U3RhdGUsIGN1cnJlbnRTdGF0ZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChuZXdUcmFjaykge1xuICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBFbCBzaXN0ZW1hIGhhIGNyZWFkbyB1biBudWV2byB0cmFjazogJHtuZXdUcmFja31gKTtcbiAgICAgICAgICAgICAgICAgICAgICByZWNlbnRUcmFja0lkID0gbmV3VHJhY2s7XG5cbiAgICAgICAgICAgICAgICAgICAgICAvLyBObyBuZWNlc2l0YW1vcyByZWdpc3RyYXIgZWwgdGllbXBvIGVuIGVsIHRyYWNrIGFudGVyaW9yXG4gICAgICAgICAgICAgICAgICAgICAgLy8geWEgcXVlIGVsIHNpc3RlbWEgbW92acOzIGVsIGVsZW1lbnRvIGEgdW4gbnVldm8gdHJhY2tcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAvLyBSZWdpc3RyYXIgZWwgdGllbXBvIG9jdXBhZG8gZW4gZWwgdHJhY2sgdXRpbGl6YWRvXG4gICAgICAgICAgICAgICAgICAgICAgYWRkVGltZVNsb3Qoc2VsZWN0ZWRUcmFja0lkLCBmcm9tLCB0byk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBSZXBvcnRhciBwcm9ncmVzb1xuICAgICAgICAgICAgICAgICAgICBpZiAoKGluZGV4ICsgMSkgJSAxMCA9PT0gMCB8fCBpbmRleCA9PT0gcmVtYWluaW5nU2VnbWVudHMubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBQcm9ncmVzbzogJHtpbmRleCArIDF9LyR7cmVtYWluaW5nU2VnbWVudHMubGVuZ3RofSBzdWJ0w610dWxvcyBhZGljaW9uYWxlcyBhw7FhZGlkb3NgKTtcbiAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgVHJhY2tzIHV0aWxpemFkb3MgaGFzdGEgYWhvcmE6ICR7QXJyYXkuZnJvbSh1c2VkVHJhY2tzKS5qb2luKCcsICcpfWApO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gUHJvY2VzYXIgZWwgc2lndWllbnRlIHNlZ21lbnRvXG4gICAgICAgICAgICAgICAgICAgIHByb2Nlc3NTZWdtZW50V2l0aFRyYWNraW5nKGluZGV4ICsgMSk7XG4gICAgICAgICAgICAgICAgICB9LCAyMDApOyAvLyBQZXF1ZcOxYSBlc3BlcmEgcGFyYSBxdWUgZWwgZXN0YWRvIHNlIGFjdHVhbGljZVxuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAvLyBJbmljaWFyIGVsIHByb2Nlc2FtaWVudG8gZGVsIHByaW1lciBzZWdtZW50byByZXN0YW50ZVxuICAgICAgICAgICAgICAgIHByb2Nlc3NTZWdtZW50V2l0aFRyYWNraW5nKDApO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiTm8gaGF5IHN1YnTDrXR1bG9zIGFkaWNpb25hbGVzIHBhcmEgYcOxYWRpclwiKTtcbiAgICAgICAgICAgICAgICByZXNvbHZlKHRydWUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCAzMDAwKTsgLy8gRXNwZXJhciAzIHNlZ3VuZG9zXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBFbmZvcXVlIG9yaWdpbmFsIHNpIHlhIHRlbmVtb3MgdW4gdHJhY2tJZCBpZGVudGlmaWNhZG9cbiAgICAgICAgY29uc29sZS5sb2coYEHDsWFkaWVuZG8gJHtzZWdtZW50cy5sZW5ndGh9IHNlZ21lbnRvcyBkZSBzdWJ0w610dWxvcyBhbCB0aW1lbGluZSR7dHJhY2tJZCA/IGAgZW4gZWwgdHJhY2sgJHt0cmFja0lkfWAgOiAnJ30uLi5gKTtcblxuICAgICAgICAvLyBDcmVhciB1bmEgcHJvbWVzYSBwYXJhIGVsIGVuZm9xdWUgdHJhZGljaW9uYWxcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAgICAgbGV0IGNvbXBsZXRlZENvdW50ID0gMDtcblxuICAgICAgICAgIC8vIEFsbWFjZW5hciBsb3MgdHJhY2tzIHVzYWRvcyBwYXJhIGRldGVjdGFyIHRyYWNrcyBzZWN1bmRhcmlvc1xuICAgICAgICAgIGNvbnN0IHVzZWRUcmFja3MgPSBuZXcgU2V0PHN0cmluZz4oKTtcbiAgICAgICAgICBpZiAodHJhY2tJZCkgdXNlZFRyYWNrcy5hZGQodHJhY2tJZCk7XG5cbiAgICAgICAgICAvLyBNYXBhIHBhcmEgbGxldmFyIHJlZ2lzdHJvIGRlIGxhcyBwb3NpY2lvbmVzIHkgb2N1cGFjacOzbiBkZSB0aWVtcG8gcG9yIHRyYWNrXG4gICAgICAgICAgY29uc3QgdHJhY2tUaW1lTWFwOiBSZWNvcmQ8c3RyaW5nLCBBcnJheTx7ZnJvbTogbnVtYmVyLCB0bzogbnVtYmVyfT4+ID0ge307XG5cbiAgICAgICAgICAvLyBGdW5jacOzbiBwYXJhIGNvbXByb2JhciBzaSB1biBzZWdtZW50byBzZSBzb2xhcGEgY29uIGxvcyBleGlzdGVudGVzIGVuIHVuIHRyYWNrXG4gICAgICAgICAgY29uc3QgY2hlY2tPdmVybGFwID0gKHRyYWNrSWQ6IHN0cmluZywgZnJvbTogbnVtYmVyLCB0bzogbnVtYmVyKTogYm9vbGVhbiA9PiB7XG4gICAgICAgICAgICBpZiAoIXRyYWNrVGltZU1hcFt0cmFja0lkXSkgcmV0dXJuIGZhbHNlOyAvLyBTaSBlbCB0cmFjayBubyB0aWVuZSBlbGVtZW50b3MsIG5vIGhheSBzb2xhcGFtaWVudG9cblxuICAgICAgICAgICAgcmV0dXJuIHRyYWNrVGltZU1hcFt0cmFja0lkXS5zb21lKHRpbWVTbG90ID0+IHtcbiAgICAgICAgICAgICAgLy8gVmVyaWZpY2FyIHNpIGhheSBzb2xhcGFtaWVudG9cbiAgICAgICAgICAgICAgcmV0dXJuIChmcm9tID49IHRpbWVTbG90LmZyb20gJiYgZnJvbSA8IHRpbWVTbG90LnRvKSB8fCAvLyBJbmljaW8gZGVudHJvIGRlIHVuIHNsb3QgZXhpc3RlbnRlXG4gICAgICAgICAgICAgICAgICAgICAodG8gPiB0aW1lU2xvdC5mcm9tICYmIHRvIDw9IHRpbWVTbG90LnRvKSB8fCAgICAvLyBGaW4gZGVudHJvIGRlIHVuIHNsb3QgZXhpc3RlbnRlXG4gICAgICAgICAgICAgICAgICAgICAoZnJvbSA8PSB0aW1lU2xvdC5mcm9tICYmIHRvID49IHRpbWVTbG90LnRvKTsgICAvLyBBYmFyY2EgY29tcGxldGFtZW50ZSB1biBzbG90IGV4aXN0ZW50ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfTtcblxuICAgICAgICAgIC8vIEZ1bmNpw7NuIHBhcmEgYcOxYWRpciB1biByZWdpc3RybyBkZSB0aWVtcG8gdXRpbGl6YWRvIGVuIHVuIHRyYWNrXG4gICAgICAgICAgY29uc3QgYWRkVGltZVNsb3QgPSAodHJhY2tJZDogc3RyaW5nLCBmcm9tOiBudW1iZXIsIHRvOiBudW1iZXIpID0+IHtcbiAgICAgICAgICAgIGlmICghdHJhY2tUaW1lTWFwW3RyYWNrSWRdKSB7XG4gICAgICAgICAgICAgIHRyYWNrVGltZU1hcFt0cmFja0lkXSA9IFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHJhY2tUaW1lTWFwW3RyYWNrSWRdLnB1c2goeyBmcm9tLCB0byB9KTtcblxuICAgICAgICAgICAgLy8gT3JkZW5hciBwYXJhIGZhY2lsaXRhciBiw7pzcXVlZGFzIGZ1dHVyYXNcbiAgICAgICAgICAgIHRyYWNrVGltZU1hcFt0cmFja0lkXS5zb3J0KChhLCBiKSA9PiBhLmZyb20gLSBiLmZyb20pO1xuICAgICAgICAgIH07XG5cbiAgICAgICAgICAvLyBQYXJhIG1vbml0b3JlYXIgdHJhY2tzIGFkaWNpb25hbGVzIHF1ZSBzZSBjcmVlblxuICAgICAgICAgIGNvbnN0IGNoZWNrRm9yTmV3VHJhY2tzID0gKHByZXZTdGF0ZTogYW55LCBjdXJyZW50U3RhdGU6IGFueSkgPT4ge1xuICAgICAgICAgICAgaWYgKCFjdXJyZW50U3RhdGUudHJhY2tJdGVtc01hcCkgcmV0dXJuIG51bGw7XG5cbiAgICAgICAgICAgIC8vIEJ1c2NhciBlbGVtZW50b3MgbnVldm9zIHF1ZSBubyBlc3RhYmFuIGVuIGVsIGVzdGFkbyBhbnRlcmlvclxuICAgICAgICAgICAgY29uc3QgcHJldkl0ZW1zID0gcHJldlN0YXRlLnRyYWNrSXRlbXNNYXAgPyBPYmplY3Qua2V5cyhwcmV2U3RhdGUudHJhY2tJdGVtc01hcCkgOiBbXTtcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRJdGVtcyA9IE9iamVjdC5rZXlzKGN1cnJlbnRTdGF0ZS50cmFja0l0ZW1zTWFwKTtcblxuICAgICAgICAgICAgLy8gRW5jb250cmFyIGxvcyBJRHMgZGUgZWxlbWVudG9zIG51ZXZvc1xuICAgICAgICAgICAgY29uc3QgbmV3SXRlbUlkcyA9IGN1cnJlbnRJdGVtcy5maWx0ZXIoaWQgPT4gIXByZXZJdGVtcy5pbmNsdWRlcyhpZCkpO1xuXG4gICAgICAgICAgICBpZiAobmV3SXRlbUlkcy5sZW5ndGggPT09IDApIHJldHVybiBudWxsO1xuXG4gICAgICAgICAgICAvLyBPYnRlbmVyIGluZm9ybWFjacOzbiBkZSBsb3MgbnVldm9zIGVsZW1lbnRvc1xuICAgICAgICAgICAgY29uc3QgbmV3SXRlbXMgPSBuZXdJdGVtSWRzLm1hcChpZCA9PiBjdXJyZW50U3RhdGUudHJhY2tJdGVtc01hcFtpZF0pO1xuXG4gICAgICAgICAgICAvLyBCdXNjYXIgdHJhY2tJZHMgcXVlIG5vIGhheWFtb3MgdmlzdG8gYW50ZXNcbiAgICAgICAgICAgIGZvciAoY29uc3QgaXRlbSBvZiBuZXdJdGVtcykge1xuICAgICAgICAgICAgICBpZiAoaXRlbS50cmFja0lkICYmICF1c2VkVHJhY2tzLmhhcyhpdGVtLnRyYWNrSWQpKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coYERldGVjdGFkbyBudWV2byB0cmFjayBzZWN1bmRhcmlvOiAke2l0ZW0udHJhY2tJZH1gKTtcbiAgICAgICAgICAgICAgICB1c2VkVHJhY2tzLmFkZChpdGVtLnRyYWNrSWQpO1xuICAgICAgICAgICAgICAgIHJldHVybiBpdGVtLnRyYWNrSWQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgfTtcblxuICAgICAgICAgIC8vIFByb2Nlc2FyIGxvcyBzdWJ0w610dWxvcyBjb24gc2VndWltaWVudG8gZGUgZXN0YWRvXG4gICAgICAgICAgbGV0IGN1cnJlbnRTdGF0ZSA9IHN0YXRlTWFuYWdlci5nZXRTdGF0ZSgpO1xuICAgICAgICAgIGxldCByZWNlbnRUcmFja0lkID0gdHJhY2tJZDtcblxuICAgICAgICAgIGNvbnN0IHByb2Nlc3NTZWdtZW50V2l0aFRyYWNraW5nID0gKGluZGV4OiBudW1iZXIpID0+IHtcbiAgICAgICAgICAgIGlmIChpbmRleCA+PSBzZWdtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJQcm9jZXNvIGRlIGHDsWFkaXIgc3VidMOtdHVsb3MgY29tcGxldGFkbyBjb24gw6l4aXRvXCIpO1xuICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgVHJhY2tzIHV0aWxpemFkb3M6ICR7QXJyYXkuZnJvbSh1c2VkVHJhY2tzKS5qb2luKCcsICcpfWApO1xuICAgICAgICAgICAgICByZXNvbHZlKHRydWUpO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IHNlZ21lbnQgPSBzZWdtZW50c1tpbmRleF07XG4gICAgICAgICAgICBjb25zdCBmcm9tID0gc2VnbWVudC5zdGFydFRpbWU7XG4gICAgICAgICAgICBjb25zdCB0byA9IHNlZ21lbnQuZW5kVGltZTtcblxuICAgICAgICAgICAgLy8gQ29tcHJvYmFyIHN1cGVycG9zaWNpw7NuIGVuIGxvcyB0cmFja3MgZGlzcG9uaWJsZXNcbiAgICAgICAgICAgIGxldCBzZWxlY3RlZFRyYWNrSWQgPSByZWNlbnRUcmFja0lkO1xuXG4gICAgICAgICAgICAvLyBWZXJpZmljYXIgc2kgaGF5IHN1cGVycG9zaWNpw7NuIGVuIGVsIHRyYWNrIHByaW5jaXBhbFxuICAgICAgICAgICAgbGV0IGhhc092ZXJsYXAgPSBzZWxlY3RlZFRyYWNrSWQgPyBjaGVja092ZXJsYXAoc2VsZWN0ZWRUcmFja0lkLCBmcm9tLCB0bykgOiBmYWxzZTtcblxuICAgICAgICAgICAgLy8gU2kgaGF5IHN1cGVycG9zaWNpw7NuLCBidXNjYXIgb3RybyB0cmFjayBkb25kZSBubyBoYXlhIHN1cGVycG9zaWNpw7NuXG4gICAgICAgICAgICBpZiAoaGFzT3ZlcmxhcCkge1xuICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgU3VwZXJwb3NpY2nDs24gZGV0ZWN0YWRhIGVuIHRyYWNrICR7c2VsZWN0ZWRUcmFja0lkfSBwYXJhIGVsIHNlZ21lbnRvICR7aW5kZXgrMX1gKTtcblxuICAgICAgICAgICAgICAvLyBJbnRlbnRhciBvdHJvcyB0cmFja3MgcXVlIHlhIGNvbm9jZW1vc1xuICAgICAgICAgICAgICBsZXQgZm91bmROb25PdmVybGFwcGluZ1RyYWNrID0gZmFsc2U7XG4gICAgICAgICAgICAgIGZvciAoY29uc3QgdHJhY2tJZCBvZiB1c2VkVHJhY2tzKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRyYWNrSWQgIT09IHNlbGVjdGVkVHJhY2tJZCAmJiAhY2hlY2tPdmVybGFwKHRyYWNrSWQsIGZyb20sIHRvKSkge1xuICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coYFVzYW5kbyB0cmFjayBhbHRlcm5hdGl2byAke3RyYWNrSWR9IHBhcmEgZXZpdGFyIHN1cGVycG9zaWNpw7NuYCk7XG4gICAgICAgICAgICAgICAgICBzZWxlY3RlZFRyYWNrSWQgPSB0cmFja0lkO1xuICAgICAgICAgICAgICAgICAgZm91bmROb25PdmVybGFwcGluZ1RyYWNrID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIC8vIFNpIG5vIHNlIGVuY29udHLDsyB1biB0cmFjayBzaW4gc3VwZXJwb3NpY2nDs24sIG1hbnRlbmVyIGVsIG9yaWdpbmFsXG4gICAgICAgICAgICAgIC8vIEVsIHNpc3RlbWEgcG9kcsOtYSBjcmVhciB1biBudWV2byB0cmFjayBhdXRvbcOhdGljYW1lbnRlXG4gICAgICAgICAgICAgIGlmICghZm91bmROb25PdmVybGFwcGluZ1RyYWNrKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coYE5vIHNlIGVuY29udHLDsyB0cmFjayBhbHRlcm5hdGl2bywgcGVybWl0aWVuZG8gcXVlIGVsIHNpc3RlbWEgY3JlZSB1bm8gbnVldm9gKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBDb3BpYXIgZWwgZXN0YWRvIGFjdHVhbCBhbnRlcyBkZSBsYSBhY2Npw7NuXG4gICAgICAgICAgICBjb25zdCBwcmV2U3RhdGUgPSB7IC4uLmN1cnJlbnRTdGF0ZSB9O1xuXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhgQcOxYWRpZW5kbyBzdWJ0w610dWxvICR7aW5kZXgrMX0vJHtzZWdtZW50cy5sZW5ndGh9IGFsIHRyYWNrICR7c2VsZWN0ZWRUcmFja0lkIHx8ICdhdXRvbcOhdGljbyd9YCk7XG5cbiAgICAgICAgICAgIC8vIEHDsWFkaXIgZWwgc3VidMOtdHVsb1xuICAgICAgICAgICAgZGlzcGF0Y2goQUREX1RFWFQsIHtcbiAgICAgICAgICAgICAgcGF5bG9hZDogY3JlYXRlU3VidGl0bGVQYXlsb2FkKHNlZ21lbnQudGV4dCwgZnJvbSwgdG8pLFxuICAgICAgICAgICAgICBvcHRpb25zOiBzZWxlY3RlZFRyYWNrSWQgPyB7IHRyYWNrSWQ6IHNlbGVjdGVkVHJhY2tJZCB9IDoge30sXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgLy8gRXNwZXJhciB1biBwb2NvIHBhcmEgcXVlIHNlIGFjdHVhbGljZSBlbCBlc3RhZG9cbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAvLyBPYnRlbmVyIGVzdGFkbyBhY3R1YWxpemFkb1xuICAgICAgICAgICAgICBjdXJyZW50U3RhdGUgPSBzdGF0ZU1hbmFnZXIuZ2V0U3RhdGUoKTtcblxuICAgICAgICAgICAgICAvLyBDb21wcm9iYXIgc2kgc2UgaGEgY3JlYWRvIHVuIG51ZXZvIHRyYWNrXG4gICAgICAgICAgICAgIGNvbnN0IG5ld1RyYWNrID0gY2hlY2tGb3JOZXdUcmFja3MocHJldlN0YXRlLCBjdXJyZW50U3RhdGUpO1xuICAgICAgICAgICAgICBpZiAobmV3VHJhY2spIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgRWwgc2lzdGVtYSBoYSBjcmVhZG8gdW4gbnVldm8gdHJhY2s6ICR7bmV3VHJhY2t9YCk7XG4gICAgICAgICAgICAgICAgcmVjZW50VHJhY2tJZCA9IG5ld1RyYWNrO1xuXG4gICAgICAgICAgICAgICAgLy8gTm8gbmVjZXNpdGFtb3MgcmVnaXN0cmFyIGVsIHRpZW1wbyBlbiBlbCB0cmFjayBhbnRlcmlvclxuICAgICAgICAgICAgICAgIC8vIHlhIHF1ZSBlbCBzaXN0ZW1hIG1vdmnDsyBlbCBlbGVtZW50byBhIHVuIG51ZXZvIHRyYWNrXG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gUmVnaXN0cmFyIGVsIHRpZW1wbyBvY3VwYWRvIGVuIGVsIHRyYWNrIHV0aWxpemFkb1xuICAgICAgICAgICAgICAgIGlmIChzZWxlY3RlZFRyYWNrSWQpIHtcbiAgICAgICAgICAgICAgICAgIGFkZFRpbWVTbG90KHNlbGVjdGVkVHJhY2tJZCwgZnJvbSwgdG8pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIC8vIFJlcG9ydGFyIHByb2dyZXNvXG4gICAgICAgICAgICAgIGNvbXBsZXRlZENvdW50Kys7XG4gICAgICAgICAgICAgIGlmIChjb21wbGV0ZWRDb3VudCAlIDEwID09PSAwIHx8IGNvbXBsZXRlZENvdW50ID09PSBzZWdtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgUHJvZ3Jlc286ICR7Y29tcGxldGVkQ291bnR9LyR7c2VnbWVudHMubGVuZ3RofSBzdWJ0w610dWxvcyBhw7FhZGlkb3NgKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIC8vIFByb2Nlc2FyIGVsIHNpZ3VpZW50ZSBzZWdtZW50b1xuICAgICAgICAgICAgICBwcm9jZXNzU2VnbWVudFdpdGhUcmFja2luZyhpbmRleCArIDEpO1xuICAgICAgICAgICAgfSwgMjAwKTsgLy8gUGVxdWXDsWEgZXNwZXJhIHBhcmEgcXVlIGVsIGVzdGFkbyBzZSBhY3R1YWxpY2VcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgLy8gSW5pY2lhciBlbCBwcm9jZXNhbWllbnRvIGRlbCBwcmltZXIgc2VnbWVudG9cbiAgICAgICAgICBwcm9jZXNzU2VnbWVudFdpdGhUcmFja2luZygwKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgYWwgYcOxYWRpciBzdWJ0w610dWxvczpcIiwgZXJyb3IpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfSxcblxuICAgIGdldEFjdGl2ZUVsZW1lbnRzOiBhc3luYyAoKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICAvLyBPYnRlbmVyIGVsIGVzdGFkbyBhY3R1YWxcbiAgICAgICAgY29uc3Qgc3RhdGUgPSBzdGF0ZU1hbmFnZXIuZ2V0U3RhdGUoKTtcblxuICAgICAgICAvLyBWZXJpZmljYXIgc2kgaGF5IElEcyBhY3Rpdm9zXG4gICAgICAgIGlmICghc3RhdGUuYWN0aXZlSWRzIHx8IHN0YXRlLmFjdGl2ZUlkcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICBjb25zb2xlLmxvZyhcIk5vIGhheSBlbGVtZW50b3MgYWN0aXZvcyBzZWxlY2Npb25hZG9zXCIpO1xuICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFZlcmlmaWNhciBzaSBoYXkgZWxlbWVudG9zIGVuIGVsIHRyYWNrSXRlbXNNYXBcbiAgICAgICAgaWYgKCFzdGF0ZS50cmFja0l0ZW1zTWFwKSB7XG4gICAgICAgICAgY29uc29sZS5sb2coXCJObyBoYXkgdHJhY2tJdGVtc01hcCBkaXNwb25pYmxlXCIpO1xuICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIE9idGVuZXIgaW5mb3JtYWNpw7NuIGRlIGxvcyBlbGVtZW50b3MgYWN0aXZvc1xuICAgICAgICBjb25zdCBhY3RpdmVFbGVtZW50cyA9IHN0YXRlLmFjdGl2ZUlkc1xuICAgICAgICAgIC5maWx0ZXIoaWQgPT4gc3RhdGUudHJhY2tJdGVtc01hcFtpZF0pXG4gICAgICAgICAgLm1hcChpZCA9PiB7XG4gICAgICAgICAgICBjb25zdCBpdGVtID0gc3RhdGUudHJhY2tJdGVtc01hcFtpZF07XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICBpZCxcbiAgICAgICAgICAgICAgdHJhY2tJZDogaXRlbS50cmFja0lkLFxuICAgICAgICAgICAgICB0eXBlOiBpdGVtLnR5cGUsXG4gICAgICAgICAgICAgIGZyb206IGl0ZW0uZGlzcGxheT8uZnJvbSxcbiAgICAgICAgICAgICAgdG86IGl0ZW0uZGlzcGxheT8udG8sXG4gICAgICAgICAgICAgIGR1cmF0aW9uOiBpdGVtLmRpc3BsYXkgPyAoaXRlbS5kaXNwbGF5LnRvIC0gaXRlbS5kaXNwbGF5LmZyb20pIDogMCxcbiAgICAgICAgICAgICAgZGV0YWlsczogaXRlbS5kZXRhaWxzXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgIGNvbnNvbGUubG9nKGBTZSBlbmNvbnRyYXJvbiAke2FjdGl2ZUVsZW1lbnRzLmxlbmd0aH0gZWxlbWVudG9zIGFjdGl2b3NgKTtcbiAgICAgICAgcmV0dXJuIGFjdGl2ZUVsZW1lbnRzO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIGFsIG9idGVuZXIgZWxlbWVudG9zIGFjdGl2b3M6XCIsIGVycm9yKTtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBnZXRBbGxUaW1lbGluZUVsZW1lbnRzOiBhc3luYyAoKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICAvLyBPYnRlbmVyIGVsIGVzdGFkbyBhY3R1YWxcbiAgICAgICAgY29uc3Qgc3RhdGUgPSBzdGF0ZU1hbmFnZXIuZ2V0U3RhdGUoKTtcblxuICAgICAgICAvLyBWZXJpZmljYXIgc2kgaGF5IGVsZW1lbnRvcyBlbiBlbCB0cmFja0l0ZW1zTWFwXG4gICAgICAgIGlmICghc3RhdGUudHJhY2tJdGVtc01hcCB8fCBPYmplY3Qua2V5cyhzdGF0ZS50cmFja0l0ZW1zTWFwKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICBjb25zb2xlLmxvZyhcIk5vIGhheSBlbGVtZW50b3MgZW4gZWwgdHJhY2tJdGVtc01hcFwiKTtcblxuICAgICAgICAgIC8vIEJ1c2NhciBlbGVtZW50b3MgZW4gb3RyYXMgcHJvcGllZGFkZXMgZGVsIGVzdGFkb1xuICAgICAgICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKHN0YXRlKSkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBzdGF0ZVtrZXldID09PSAnb2JqZWN0JyAmJiBzdGF0ZVtrZXldICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgIGNvbnN0IG9ialZhbHVlID0gc3RhdGVba2V5XTtcbiAgICAgICAgICAgICAgY29uc29sZS5sb2coYEV4cGxvcmFuZG8gcHJvcGllZGFkIGFsdGVybmF0aXZhOiAke2tleX1gKTtcblxuICAgICAgICAgICAgICAvLyBWZXJpZmljYXIgc2kgcGFyZWNlIHNlciB1biBtYXBhIGRlIGVsZW1lbnRvc1xuICAgICAgICAgICAgICBpZiAoT2JqZWN0LmtleXMob2JqVmFsdWUpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzYW1wbGUgPSBvYmpWYWx1ZVtPYmplY3Qua2V5cyhvYmpWYWx1ZSlbMF1dO1xuICAgICAgICAgICAgICAgIGlmIChzYW1wbGUgJiYgc2FtcGxlLmRpc3BsYXkgJiYgc2FtcGxlLnR5cGUpIHtcbiAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBFbmNvbnRyYWRhIHBvc2libGUgZnVlbnRlIGFsdGVybmF0aXZhIGRlIGVsZW1lbnRvcyBlbiBwcm9waWVkYWQgJHtrZXl9YCk7XG5cbiAgICAgICAgICAgICAgICAgIC8vIFByb2Nlc2FyIGVsZW1lbnRvcyBkZSBlc3RhIHByb3BpZWRhZCBhbHRlcm5hdGl2YVxuICAgICAgICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKG9ialZhbHVlKVxuICAgICAgICAgICAgICAgICAgICAuZmlsdGVyKChbXywgaXRlbV0pID0+IGl0ZW0gJiYgaXRlbS5kaXNwbGF5KVxuICAgICAgICAgICAgICAgICAgICAubWFwKChbaWQsIGl0ZW1dKSA9PiAoe1xuICAgICAgICAgICAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgICAgICAgICAgIHRyYWNrSWQ6IGl0ZW0udHJhY2tJZCxcbiAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBpdGVtLnR5cGUsXG4gICAgICAgICAgICAgICAgICAgICAgZnJvbTogaXRlbS5kaXNwbGF5Py5mcm9tLFxuICAgICAgICAgICAgICAgICAgICAgIHRvOiBpdGVtLmRpc3BsYXk/LnRvLFxuICAgICAgICAgICAgICAgICAgICAgIGR1cmF0aW9uOiBpdGVtLmRpc3BsYXkgPyAoaXRlbS5kaXNwbGF5LnRvIC0gaXRlbS5kaXNwbGF5LmZyb20pIDogMCxcbiAgICAgICAgICAgICAgICAgICAgICBkZXRhaWxzOiBpdGVtLmRldGFpbHNcbiAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIE9idGVuZXIgdG9kb3MgbG9zIGVsZW1lbnRvc1xuICAgICAgICBjb25zdCBhbGxFbGVtZW50cyA9IE9iamVjdC5lbnRyaWVzKHN0YXRlLnRyYWNrSXRlbXNNYXApXG4gICAgICAgICAgLmZpbHRlcigoW18sIGl0ZW1dKSA9PiBpdGVtICYmIGl0ZW0uZGlzcGxheSlcbiAgICAgICAgICAubWFwKChbaWQsIGl0ZW1dKSA9PiAoe1xuICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICB0cmFja0lkOiBpdGVtLnRyYWNrSWQsXG4gICAgICAgICAgICB0eXBlOiBpdGVtLnR5cGUsXG4gICAgICAgICAgICBmcm9tOiBpdGVtLmRpc3BsYXk/LmZyb20sXG4gICAgICAgICAgICB0bzogaXRlbS5kaXNwbGF5Py50byxcbiAgICAgICAgICAgIGR1cmF0aW9uOiBpdGVtLmRpc3BsYXkgPyAoaXRlbS5kaXNwbGF5LnRvIC0gaXRlbS5kaXNwbGF5LmZyb20pIDogMCxcbiAgICAgICAgICAgIGRldGFpbHM6IGl0ZW0uZGV0YWlsc1xuICAgICAgICAgIH0pKVxuICAgICAgICAgIC5zb3J0KChhLCBiKSA9PiAoYS5mcm9tIHx8IDApIC0gKGIuZnJvbSB8fCAwKSk7XG5cbiAgICAgICAgY29uc29sZS5sb2coYFNlIGVuY29udHJhcm9uICR7YWxsRWxlbWVudHMubGVuZ3RofSBlbGVtZW50b3MgZW4gZWwgdGltZWxpbmVgKTtcbiAgICAgICAgcmV0dXJuIGFsbEVsZW1lbnRzO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIGFsIG9idGVuZXIgdG9kb3MgbG9zIGVsZW1lbnRvcyBkZWwgdGltZWxpbmU6XCIsIGVycm9yKTtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICByZW1vdmVTZWdtZW50czogYXN5bmMgKHNlZ21lbnRzOiBUaW1lU2VnbWVudFtdKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zb2xlLmxvZyhcIkluaWNpYW5kbyBlbGltaW5hY2nDs24gZGUgc2VnbWVudG9zIG3Dumx0aXBsZXNcIik7XG5cbiAgICAgICAgLy8gT2J0ZW5lciBlbCBlc3RhZG8gYWN0dWFsXG4gICAgICAgIGNvbnN0IHN0YXRlID0gc3RhdGVNYW5hZ2VyLmdldFN0YXRlKCk7XG5cbiAgICAgICAgLy8gVmFsaWRhciBxdWUgaGF5YSBlbGVtZW50b3MgZW4gbGEgdGltZWxpbmVcbiAgICAgICAgaWYgKCFzdGF0ZS5hY3RpdmVJZHMgfHwgc3RhdGUuYWN0aXZlSWRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJObyBoYXkgZWxlbWVudG9zIHNlbGVjY2lvbmFkb3MgZW4gbGEgdGltZWxpbmVcIik7XG5cbiAgICAgICAgICAvLyBCdXNjYXIgZWwgcHJpbWVyIGVsZW1lbnRvIGRpc3BvbmlibGUgZW4gbGEgdGltZWxpbmVcbiAgICAgICAgICBjb25zdCB0cmFja0l0ZW1zTWFwID0gc3RhdGUudHJhY2tJdGVtc01hcCB8fCB7fTtcbiAgICAgICAgICBjb25zdCB0cmFja0l0ZW1zID0gT2JqZWN0LmtleXModHJhY2tJdGVtc01hcCk7XG5cbiAgICAgICAgICBpZiAodHJhY2tJdGVtcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJObyBoYXkgZWxlbWVudG9zIGVuIGxhIHRpbWVsaW5lIHBhcmEgZWxpbWluYXIgc2VnbWVudG9zXCIpO1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gaGF5IGVsZW1lbnRvcyBlbiBsYSB0aW1lbGluZVwiKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBTZWxlY2Npb25hciBlbCBwcmltZXIgZWxlbWVudG8gZGlzcG9uaWJsZVxuICAgICAgICAgIGNvbnN0IGZpcnN0SXRlbUlkID0gdHJhY2tJdGVtc1swXTtcbiAgICAgICAgICBjb25zb2xlLmxvZyhgU2VsZWNjaW9uYW5kbyBhdXRvbcOhdGljYW1lbnRlIGVsIGVsZW1lbnRvIGNvbiBJRDogJHtmaXJzdEl0ZW1JZH1gKTtcblxuICAgICAgICAgIGRpc3BhdGNoKExBWUVSX1NFTEVDVCwge1xuICAgICAgICAgICAgcGF5bG9hZDoge1xuICAgICAgICAgICAgICBpZHM6IFtmaXJzdEl0ZW1JZF1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIC8vIEVzcGVyYXIgYSBxdWUgc2UgYXBsaXF1ZSBsYSBzZWxlY2Npw7NuXG4gICAgICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDMwMCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQWxtYWNlbmFtb3MgaW5mb3JtYWNpw7NuIGRlbCBlbGVtZW50byBzZWxlY2Npb25hZG9cbiAgICAgICAgY29uc3QgY3VycmVudFN0YXRlID0gc3RhdGVNYW5hZ2VyLmdldFN0YXRlKCk7XG4gICAgICAgIGlmICghY3VycmVudFN0YXRlLmFjdGl2ZUlkcyB8fCBjdXJyZW50U3RhdGUuYWN0aXZlSWRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIHNlIHB1ZG8gc2VsZWNjaW9uYXIgbmluZ8O6biBlbGVtZW50byBlbiBsYSB0aW1lbGluZVwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IG9yaWdpbmFsSXRlbUlkID0gY3VycmVudFN0YXRlLmFjdGl2ZUlkc1swXTtcbiAgICAgICAgY29uc3Qgb3JpZ2luYWxJdGVtID0gY3VycmVudFN0YXRlLnRyYWNrSXRlbXNNYXBbb3JpZ2luYWxJdGVtSWRdO1xuICAgICAgICBjb25zdCB0cmFja1R5cGUgPSBvcmlnaW5hbEl0ZW0udHlwZTtcbiAgICAgICAgY29uc3QgdHJhY2tJZCA9IG9yaWdpbmFsSXRlbS50cmFja0lkO1xuXG4gICAgICAgIGNvbnNvbGUubG9nKGBFbGVtZW50byBzZWxlY2Npb25hZG86IElEPSR7b3JpZ2luYWxJdGVtSWR9LCB0aXBvPSR7dHJhY2tUeXBlfSwgdHJhY2tJZD0ke3RyYWNrSWR9YCk7XG5cbiAgICAgICAgLy8gUHJvY2VzYXIgY2FkYSBzZWdtZW50byBlbiBvcmRlbiAoZGUgZmluYWwgYSBwcmluY2lwaW8gcGFyYSBldml0YXIgYWZlY3RhciBwb3NpY2lvbmVzKVxuICAgICAgICBmb3IgKGxldCBpID0gc2VnbWVudHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICBjb25zdCBzZWdtZW50ID0gc2VnbWVudHNbaV07XG4gICAgICAgICAgY29uc29sZS5sb2coYFByb2Nlc2FuZG8gc2VnbWVudG8gJHtpKzF9LyR7c2VnbWVudHMubGVuZ3RofTogJHtzZWdtZW50LnN0YXJ0VGltZX1zIC0gJHtzZWdtZW50LmVuZFRpbWV9c2ApO1xuXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFBBU08gMTogSGFjZXIgdW4gY29ydGUgZW4gZWwgdGllbXBvIGZpbmFsXG4gICAgICAgICAgICBjb25zdCBlbmRNcyA9IHNlZ21lbnQuZW5kVGltZSAqIDEwMDA7XG4gICAgICAgICAgICBkaXNwYXRjaChBQ1RJVkVfU1BMSVQsIHtcbiAgICAgICAgICAgICAgcGF5bG9hZDoge30sXG4gICAgICAgICAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgICAgICAgICB0aW1lOiBlbmRNcyxcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc29sZS5sb2coYFBhc28gMTogQ29ydGUgYXBsaWNhZG8gZW4gdGllbXBvIGZpbmFsICR7c2VnbWVudC5lbmRUaW1lfXNgKTtcblxuICAgICAgICAgICAgLy8gRXNwZXJhciBhIHF1ZSBzZSBwcm9jZXNlIGVsIHByaW1lciBjb3J0ZVxuICAgICAgICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDUwMCkpO1xuXG4gICAgICAgICAgICAvLyBPYnRlbmVtb3MgZWwgZXN0YWRvIGRlc3B1w6lzIGRlbCBwcmltZXIgY29ydGVcbiAgICAgICAgICAgIGNvbnN0IHN0YXRlQWZ0ZXJGaXJzdEN1dCA9IHN0YXRlTWFuYWdlci5nZXRTdGF0ZSgpO1xuICAgICAgICAgICAgY29uc3QgZWxlbWVudHNBZnRlckZpcnN0Q3V0ID0gT2JqZWN0LmVudHJpZXMoc3RhdGVBZnRlckZpcnN0Q3V0LnRyYWNrSXRlbXNNYXApXG4gICAgICAgICAgICAgIC5maWx0ZXIoKFtfLCBpdGVtXSkgPT5cbiAgICAgICAgICAgICAgICBpdGVtLnR5cGUgPT09IHRyYWNrVHlwZSAmJlxuICAgICAgICAgICAgICAgIGl0ZW0udHJhY2tJZCA9PT0gdHJhY2tJZCAmJlxuICAgICAgICAgICAgICAgIGl0ZW0uZGlzcGxheSAmJlxuICAgICAgICAgICAgICAgICFpc05hTihpdGVtLmRpc3BsYXkuZnJvbSkgJiZcbiAgICAgICAgICAgICAgICAhaXNOYU4oaXRlbS5kaXNwbGF5LnRvKVxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgIC5tYXAoKFtpZCwgaXRlbV0pID0+ICh7XG4gICAgICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICAgICAgZnJvbTogaXRlbS5kaXNwbGF5LmZyb20sXG4gICAgICAgICAgICAgICAgdG86IGl0ZW0uZGlzcGxheS50byxcbiAgICAgICAgICAgICAgICBkdXJhY2nDs246IGl0ZW0uZGlzcGxheS50byAtIGl0ZW0uZGlzcGxheS5mcm9tXG4gICAgICAgICAgICAgIH0pKVxuICAgICAgICAgICAgICAuc29ydCgoYSwgYikgPT4gYS5mcm9tIC0gYi5mcm9tKTtcblxuICAgICAgICAgICAgY29uc29sZS5sb2coXCJFbGVtZW50b3MgZGVzcHXDqXMgZGVsIHByaW1lciBjb3J0ZTpcIiwgZWxlbWVudHNBZnRlckZpcnN0Q3V0KTtcblxuICAgICAgICAgICAgLy8gUEFTTyAyOiBJZGVudGlmaWNhciBlbCBlbGVtZW50byBpenF1aWVyZG8gcXVlIGNvbnRpZW5lIGVsIHRpZW1wbyBpbmljaWFsXG4gICAgICAgICAgICBjb25zdCBzdGFydE1zID0gc2VnbWVudC5zdGFydFRpbWUgKiAxMDAwO1xuICAgICAgICAgICAgY29uc3QgbGVmdEVsZW1lbnQgPSBlbGVtZW50c0FmdGVyRmlyc3RDdXQuZmluZChlbGVtID0+XG4gICAgICAgICAgICAgIGVsZW0uZnJvbSA8PSBzdGFydE1zICYmIGVsZW0udG8gPj0gc3RhcnRNc1xuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgaWYgKCFsZWZ0RWxlbWVudCkge1xuICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGBObyBzZSBwdWRvIGlkZW50aWZpY2FyIGVsIGVsZW1lbnRvIGl6cXVpZXJkbyBwYXJhIGVsIHNlZ21lbnRvICR7aSsxfWApO1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc29sZS5sb2coYFBhc28gMjogRWxlbWVudG8gaXpxdWllcmRvIGlkZW50aWZpY2FkbyAoSUQ6ICR7bGVmdEVsZW1lbnQuaWR9KWApO1xuXG4gICAgICAgICAgICAvLyBQQVNPIDM6IFNlbGVjY2lvbmFyIGVsIGVsZW1lbnRvIGl6cXVpZXJkbyB5IGhhY2VyIGNvcnRlIGVuIHRpZW1wbyBpbmljaWFsXG4gICAgICAgICAgICBkaXNwYXRjaChMQVlFUl9TRUxFQ1QsIHtcbiAgICAgICAgICAgICAgcGF5bG9hZDoge1xuICAgICAgICAgICAgICAgIGlkczogW2xlZnRFbGVtZW50LmlkXVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgLy8gRXNwZXJhciBhIHF1ZSBzZSBhcGxpcXVlIGxhIHNlbGVjY2nDs25cbiAgICAgICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCAzMDApKTtcblxuICAgICAgICAgICAgLy8gQXBsaWNhciBlbCBjb3J0ZSBlbiBlbCB0aWVtcG8gaW5pY2lhbFxuICAgICAgICAgICAgZGlzcGF0Y2goQUNUSVZFX1NQTElULCB7XG4gICAgICAgICAgICAgIHBheWxvYWQ6IHt9LFxuICAgICAgICAgICAgICBvcHRpb25zOiB7XG4gICAgICAgICAgICAgICAgdGltZTogc3RhcnRNcyxcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc29sZS5sb2coYFBhc28gMzogU2VndW5kbyBjb3J0ZSBhcGxpY2FkbyBlbiB0aWVtcG8gaW5pY2lhbCAke3NlZ21lbnQuc3RhcnRUaW1lfXNgKTtcblxuICAgICAgICAgICAgLy8gRXNwZXJhciBhIHF1ZSBzZSBwcm9jZXNlIGVsIHNlZ3VuZG8gY29ydGVcbiAgICAgICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCA1MDApKTtcblxuICAgICAgICAgICAgLy8gT2J0ZW5lbW9zIGVsIGVzdGFkbyBkZXNwdcOpcyBkZWwgc2VndW5kbyBjb3J0ZVxuICAgICAgICAgICAgY29uc3Qgc3RhdGVBZnRlclNlY29uZEN1dCA9IHN0YXRlTWFuYWdlci5nZXRTdGF0ZSgpO1xuICAgICAgICAgICAgY29uc3QgZWxlbWVudHNBZnRlclNlY29uZEN1dCA9IE9iamVjdC5lbnRyaWVzKHN0YXRlQWZ0ZXJTZWNvbmRDdXQudHJhY2tJdGVtc01hcClcbiAgICAgICAgICAgICAgLmZpbHRlcigoW18sIGl0ZW1dKSA9PlxuICAgICAgICAgICAgICAgIGl0ZW0udHlwZSA9PT0gdHJhY2tUeXBlICYmXG4gICAgICAgICAgICAgICAgaXRlbS50cmFja0lkID09PSB0cmFja0lkICYmXG4gICAgICAgICAgICAgICAgaXRlbS5kaXNwbGF5ICYmXG4gICAgICAgICAgICAgICAgIWlzTmFOKGl0ZW0uZGlzcGxheS5mcm9tKSAmJlxuICAgICAgICAgICAgICAgICFpc05hTihpdGVtLmRpc3BsYXkudG8pXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgLm1hcCgoW2lkLCBpdGVtXSkgPT4gKHtcbiAgICAgICAgICAgICAgICBpZCxcbiAgICAgICAgICAgICAgICBmcm9tOiBpdGVtLmRpc3BsYXkuZnJvbSxcbiAgICAgICAgICAgICAgICB0bzogaXRlbS5kaXNwbGF5LnRvLFxuICAgICAgICAgICAgICAgIGR1cmFjacOzbjogaXRlbS5kaXNwbGF5LnRvIC0gaXRlbS5kaXNwbGF5LmZyb21cbiAgICAgICAgICAgICAgfSkpXG4gICAgICAgICAgICAgIC5zb3J0KChhLCBiKSA9PiBhLmZyb20gLSBiLmZyb20pO1xuXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIkVsZW1lbnRvcyBkZXNwdcOpcyBkZWwgc2VndW5kbyBjb3J0ZTpcIiwgZWxlbWVudHNBZnRlclNlY29uZEN1dCk7XG5cbiAgICAgICAgICAgIC8vIFBBU08gNDogSWRlbnRpZmljYXIgZWwgZWxlbWVudG8gZGVsIG1lZGlvIHVzYW5kbyBjcml0ZXJpb3MgbcOhcyBwcmVjaXNvc1xuICAgICAgICAgICAgY29uc3QgbWlkZGxlRWxlbWVudHMgPSBlbGVtZW50c0FmdGVyU2Vjb25kQ3V0LmZpbHRlcihlbGVtID0+XG4gICAgICAgICAgICAgIE1hdGguYWJzKGVsZW0uZnJvbSAtIHN0YXJ0TXMpIDwgNTAgJiYgTWF0aC5hYnMoZWxlbS50byAtIGVuZE1zKSA8IDUwXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIkVsZW1lbnRvcyBxdWUgY29pbmNpZGVuIGNvbiBsb3MgY3JpdGVyaW9zIGRlbCBtZWRpbzpcIiwgbWlkZGxlRWxlbWVudHMpO1xuXG4gICAgICAgICAgICBpZiAobWlkZGxlRWxlbWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYE5vIHNlIHB1ZG8gaWRlbnRpZmljYXIgZWwgZWxlbWVudG8gZGVsIG1lZGlvIHBhcmEgZWwgc2VnbWVudG8gJHtpKzF9YCk7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBTaSBoYXkgbcOhcyBkZSB1biBlbGVtZW50byBxdWUgY29pbmNpZGUsIHRvbWFtb3MgZWwgcHJpbWVyb1xuICAgICAgICAgICAgY29uc3QgbWlkZGxlRWxlbWVudCA9IG1pZGRsZUVsZW1lbnRzWzBdO1xuICAgICAgICAgICAgY29uc29sZS5sb2coYFBhc28gNDogRWxlbWVudG8gZGVsIG1lZGlvIGlkZW50aWZpY2FkbyAoSUQ6ICR7bWlkZGxlRWxlbWVudC5pZH0pYCk7XG5cbiAgICAgICAgICAgIC8vIFBBU08gNTogU2VsZWNjaW9uYXIgeSBlbGltaW5hciBlbCBlbGVtZW50byBkZWwgbWVkaW9cbiAgICAgICAgICAgIGRpc3BhdGNoKExBWUVSX1NFTEVDVCwge1xuICAgICAgICAgICAgICBwYXlsb2FkOiB7XG4gICAgICAgICAgICAgICAgaWRzOiBbbWlkZGxlRWxlbWVudC5pZF1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vIEVzcGVyYXIgYSBxdWUgc2UgYXBsaXF1ZSBsYSBzZWxlY2Npw7NuXG4gICAgICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgMzAwKSk7XG5cbiAgICAgICAgICAgIC8vIFZlcmlmaWNhciBxdWUgZWwgZWxlbWVudG8gZXN0w6Egc2VsZWNjaW9uYWRvIGFudGVzIGRlIGVsaW1pbmFybG9cbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRTdGF0ZSA9IHN0YXRlTWFuYWdlci5nZXRTdGF0ZSgpO1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRTdGF0ZS5hY3RpdmVJZHMgJiYgY3VycmVudFN0YXRlLmFjdGl2ZUlkcy5pbmNsdWRlcyhtaWRkbGVFbGVtZW50LmlkKSkge1xuICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgRWxlbWVudG8gZGVsIG1lZGlvIGNvcnJlY3RhbWVudGUgc2VsZWNjaW9uYWRvLCBwcm9jZWRpZW5kbyBjb24gZWxpbWluYWNpw7NuYCk7XG4gICAgICAgICAgICAgIGRpc3BhdGNoKExBWUVSX0RFTEVURSk7XG4gICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBFbGVtZW50byBlbGltaW5hZG8gY29ycmVjdGFtZW50ZTogJHttaWRkbGVFbGVtZW50LmlkfWApO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgY29uc29sZS5sb2coYE5vIHNlIHB1ZG8gc2VsZWNjaW9uYXIgbm9ybWFsbWVudGUsIGludGVudGFuZG8gbcOpdG9kbyBhbHRlcm5hdGl2b2ApO1xuXG4gICAgICAgICAgICAgIC8vIEVuZm9xdWUgYWx0ZXJuYXRpdm86IFVzYXIgZWwgRURJVF9PQkpFQ1QgcGFyYSBcIm9jdWx0YXJcIiBlbCBzZWdtZW50b1xuICAgICAgICAgICAgICBkaXNwYXRjaChFRElUX09CSkVDVCwge1xuICAgICAgICAgICAgICAgIHBheWxvYWQ6IHtcbiAgICAgICAgICAgICAgICAgIFttaWRkbGVFbGVtZW50LmlkXToge1xuICAgICAgICAgICAgICAgICAgICBkaXNwbGF5OiB7XG4gICAgICAgICAgICAgICAgICAgICAgZnJvbTogLTk5OTk5LCAvLyBVbiB2YWxvciBmdWVyYSBkZWwgcmFuZ28gdmlzaWJsZVxuICAgICAgICAgICAgICAgICAgICAgIHRvOiAtOTk5OTBcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgdmlzaWJsZTogZmFsc2UgLy8gQWRpY2lvbmFsbWVudGUgbWFyY2FybG8gY29tbyBubyB2aXNpYmxlXG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgY29uc29sZS5sb2coYEFwbGljYWRvIG3DqXRvZG8gYWx0ZXJuYXRpdm8gcGFyYSBvY3VsdGFyIGVsIHNlZ21lbnRvYCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEVzcGVyYXIgYSBxdWUgc2UgcHJvY2VzZSBsYSBlbGltaW5hY2nDs25cbiAgICAgICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCA1MDApKTtcblxuICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGBFcnJvciBhbCBwcm9jZXNhciBlbCBzZWdtZW50byAke2krMX06YCwgZXJyb3IpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIFBhdXNhIGVudHJlIHNlZ21lbnRvc1xuICAgICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCA1MDApKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEFjdHVhbGl6YXIgbGEgZXNjYWxhIHBhcmEgcmVmcmVzY2FyIGxhIHZpc3RhXG4gICAgICAgIGNvbnN0IHsgc2NhbGUgfSA9IHN0YXRlTWFuYWdlci5nZXRTdGF0ZSgpO1xuICAgICAgICBpZiAoc2NhbGUpIHtcbiAgICAgICAgICBjb25zb2xlLmxvZyhcIkFjdHVhbGl6YW5kbyBlc2NhbGEgcGFyYSByZWZyZXNjYXIgbGEgdmlzdGFcIik7XG5cbiAgICAgICAgICAvLyBHdWFyZGFyIGVsIHZhbG9yIGFjdHVhbCBkZSBzY2FsZS51bml0XG4gICAgICAgICAgY29uc3Qgb3JpZ2luYWxVbml0ID0gc2NhbGUudW5pdDtcblxuICAgICAgICAgIC8vIEluY3JlbWVudGFyIGVsIHZhbG9yXG4gICAgICAgICAgc2NhbGUudW5pdCArPSAxO1xuICAgICAgICAgIGNvbnNvbGUubG9nKGBTY2FsZSBjYW1iaWFkYTogJHtvcmlnaW5hbFVuaXR9IC0+ICR7c2NhbGUudW5pdH1gKTtcblxuICAgICAgICAgIC8vIEFzZWd1cmFyIHF1ZSBlbCBjYW1iaW8gc2VhIG5vdGFkbyBwb3IgZWwgc2lzdGVtYVxuICAgICAgICAgIGRpc3BhdGNoKFRJTUVMSU5FX1NDQUxFX0NIQU5HRUQsIHtcbiAgICAgICAgICAgIHBheWxvYWQ6IHtcbiAgICAgICAgICAgICAgc2NhbGU6IHtcbiAgICAgICAgICAgICAgICAuLi5zY2FsZSwgIC8vIEluY2x1aXIgdG9kYXMgbGFzIHByb3BpZWRhZGVzIGRlIHNjYWxlXG4gICAgICAgICAgICAgICAgdW5pdDogc2NhbGUudW5pdCAgLy8gRXhwbMOtY2l0YW1lbnRlIGVzdGFibGVjZXIgZWwgbnVldm8gdmFsb3JcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICAvLyBGb3J6YXIgdW5hIGFjdHVhbGl6YWNpw7NuIGFkaWNpb25hbCB2b2x2aWVuZG8gYWwgdmFsb3Igb3JpZ2luYWwgZGVzcHXDqXMgZGUgdW4gbW9tZW50b1xuICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgY3VycmVudFN0YXRlID0gc3RhdGVNYW5hZ2VyLmdldFN0YXRlKCk7XG4gICAgICAgICAgICBpZiAoY3VycmVudFN0YXRlLnNjYWxlKSB7XG4gICAgICAgICAgICAgIGRpc3BhdGNoKFRJTUVMSU5FX1NDQUxFX0NIQU5HRUQsIHtcbiAgICAgICAgICAgICAgICBwYXlsb2FkOiB7XG4gICAgICAgICAgICAgICAgICBzY2FsZToge1xuICAgICAgICAgICAgICAgICAgICAuLi5jdXJyZW50U3RhdGUuc2NhbGUsXG4gICAgICAgICAgICAgICAgICAgIHVuaXQ6IG9yaWdpbmFsVW5pdCAgLy8gVm9sdmVyIGFsIHZhbG9yIG9yaWdpbmFsXG4gICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBSZXN0YXVyYWRvIHNjYWxlIGEgdmFsb3Igb3JpZ2luYWw6ICR7b3JpZ2luYWxVbml0fWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sIDMwMCk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zb2xlLmxvZyhcIkVsaW1pbmFjacOzbiBkZSBzZWdtZW50b3MgY29tcGxldGFkYVwiKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgYWwgZWxpbWluYXIgc2VnbWVudG9zOlwiLCBlcnJvcik7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgY29tcGFjdFRpbWVsaW5lOiBhc3luYyAoKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zb2xlLmxvZyhcIj09PSBJTklDSUFORE8gQ09NUEFDVEFDScOTTiBERSBMw41ORUEgREUgVElFTVBPIERFU0RFIElBID09PVwiKTtcblxuICAgICAgICAvLyBPYnRlbmVyIGVsIGVzdGFkbyBhY3R1YWxcbiAgICAgICAgY29uc3QgZXN0YWRvID0gc3RhdGVNYW5hZ2VyLmdldFN0YXRlKCk7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiRXN0YWRvIHBhcmEgY29tcGFjdGFjacOzbjpcIiwgT2JqZWN0LmtleXMoZXN0YWRvKSk7XG5cbiAgICAgICAgLy8gQcOxYWRpciB1biB0aWVtcG8gZGUgZXNwZXJhIGluaWNpYWwgcGFyYSBhc2VndXJhciBxdWUgZWwgZXN0YWRvIGVzdMOhIGFjdHVhbGl6YWRvXG4gICAgICAgIGNvbnNvbGUubG9nKFwiRXNwZXJhbmRvIDEgc2VndW5kbyBwYXJhIGFzZWd1cmFyIGNvbnNpc3RlbmNpYSBkZWwgZXN0YWRvLi4uXCIpO1xuICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgMTAwMCkpO1xuXG4gICAgICAgIC8vIFZlcmlmaWNhY2nDs24gYWRpY2lvbmFsIHBhcmEgYXNlZ3VyYXJub3MgcXVlIGxvcyBjYW1iaW9zIGVuIGxhIHRpbWVsaW5lIHlhIHNlIGFwbGljYXJvblxuICAgICAgICBjb25zb2xlLmxvZyhcIlZlcmlmaWNhbmRvIHF1ZSBsb3MgZWxlbWVudG9zIGVuIGxhIHRpbWVsaW5lIHJlZmxlamVuIGxvcyBjYW1iaW9zIG3DoXMgcmVjaWVudGVzLi4uXCIpO1xuXG4gICAgICAgIC8vIFBlcXVlw7FhIHBhdXNhIGFkaWNpb25hbCBwYXJhIGFzZWd1cmFyIGNvbnNpc3RlbmNpYSBkZWwgZXN0YWRvXG4gICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCA1MDApKTtcblxuICAgICAgICAvLyBCdXNjYXIgbG9zIGVsZW1lbnRvcyBkZWwgdGltZWxpbmUgLSB1c2FuZG8gbGEgcmVmZXJlbmNpYSBhbCBtw6l0b2RvIGRlbnRybyBkZWwgbWlzbW8gb2JqZXRvXG4gICAgICAgIGNvbnN0IHRvZG9zRWxlbWVudG9zID0gYXdhaXQgZXhlY3V0b3IuZ2V0QWxsVGltZWxpbmVFbGVtZW50cygpO1xuICAgICAgICBjb25zb2xlLmxvZyhgRW5jb250cmFkb3MgJHt0b2Rvc0VsZW1lbnRvcy5sZW5ndGh9IGVsZW1lbnRvcyBlbiBsYSB0aW1lbGluZWApO1xuXG4gICAgICAgIC8vIExvZ2dpbmcgZGUgZWxlbWVudG9zIHBhcmEgZGlhZ27Ds3N0aWNvXG4gICAgICAgIHRvZG9zRWxlbWVudG9zLmZvckVhY2goKGVsZW0sIGluZGV4KSA9PiB7XG4gICAgICAgICAgY29uc29sZS5sb2coYEVsZW1lbnRvICR7aW5kZXggKyAxfTogSUQ9JHtlbGVtLmlkfSwgVGlwbz0ke2VsZW0udHlwZX0sIFRyYWNrPSR7ZWxlbS50cmFja0lkfSwgVGllbXBvPSR7ZWxlbS5mcm9tfW1zLSR7ZWxlbS50b31tcyAoZHVyYWNpw7NuPSR7ZWxlbS50by1lbGVtLmZyb219bXMpYCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIFNpIG5vIGhheSBlbGVtZW50b3MsIG5vIHBvZGVtb3MgY29tcGFjdGFyXG4gICAgICAgIGlmICh0b2Rvc0VsZW1lbnRvcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICBjb25zb2xlLmxvZyhcIk5vIGhheSBlbGVtZW50b3MgZW4gZWwgdGltZWxpbmUgcGFyYSBjb21wYWN0YXJcIik7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQWdydXBhciBlbGVtZW50b3MgcG9yIHRyYWNrIHBhcmEgYW7DoWxpc2lzXG4gICAgICAgIGNvbnN0IGVsZW1lbnRvc1BvclRyYWNrID0ge307XG4gICAgICAgIHRvZG9zRWxlbWVudG9zLmZvckVhY2goZWxlbSA9PiB7XG4gICAgICAgICAgaWYgKGVsZW0udHJhY2tJZCkge1xuICAgICAgICAgICAgaWYgKCFlbGVtZW50b3NQb3JUcmFja1tlbGVtLnRyYWNrSWRdKSB7XG4gICAgICAgICAgICAgIGVsZW1lbnRvc1BvclRyYWNrW2VsZW0udHJhY2tJZF0gPSBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsZW1lbnRvc1BvclRyYWNrW2VsZW0udHJhY2tJZF0ucHVzaChlbGVtKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIE9yZGVuYXIgZWxlbWVudG9zIGVuIGNhZGEgdHJhY2sgcG9yIHRpZW1wb1xuICAgICAgICBPYmplY3Qua2V5cyhlbGVtZW50b3NQb3JUcmFjaykuZm9yRWFjaCh0cmFja0lkID0+IHtcbiAgICAgICAgICBlbGVtZW50b3NQb3JUcmFja1t0cmFja0lkXS5zb3J0KChhLCBiKSA9PiBhLmZyb20gLSBiLmZyb20pO1xuICAgICAgICB9KTtcblxuICAgICAgICBjb25zb2xlLmxvZyhcIkVsZW1lbnRvcyBhZ3J1cGFkb3MgcG9yIHRyYWNrOlwiLCBPYmplY3Qua2V5cyhlbGVtZW50b3NQb3JUcmFjaykubGVuZ3RoKTtcblxuICAgICAgICAvLyBMb2dnaW5nIGRlIHRyYWNrcyBwYXJhIGRpYWduw7NzdGljb1xuICAgICAgICBPYmplY3Qua2V5cyhlbGVtZW50b3NQb3JUcmFjaykuZm9yRWFjaCh0cmFja0lkID0+IHtcbiAgICAgICAgICBjb25zb2xlLmxvZyhgVHJhY2sgJHt0cmFja0lkfTogJHtlbGVtZW50b3NQb3JUcmFja1t0cmFja0lkXS5sZW5ndGh9IGVsZW1lbnRvc2ApO1xuICAgICAgICAgIC8vIE1vc3RyYXIgbG9zIGVsZW1lbnRvcyBlbiBlc3RlIHRyYWNrIG9yZGVuYWRvc1xuICAgICAgICAgIGVsZW1lbnRvc1BvclRyYWNrW3RyYWNrSWRdLmZvckVhY2goKGVsZW0sIGlkeCkgPT4ge1xuICAgICAgICAgICAgY29uc29sZS5sb2coYCAgJHtpZHgrMX0uIElEPSR7ZWxlbS5pZC5zdWJzdHJpbmcoMCw4KX0uLi4gVGllbXBvPSR7ZWxlbS5mcm9tfW1zLSR7ZWxlbS50b31tcyAoZHVyYWNpw7NuOiAke2VsZW0udG8tZWxlbS5mcm9tfW1zKWApO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBCdXNjYXIgZXNwYWNpb3MgdmFjw61vcyBlbiBjYWRhIHRyYWNrXG4gICAgICAgIGNvbnN0IGVzcGFjaW9zVmFjaW9zID0gW107XG5cbiAgICAgICAgT2JqZWN0LmtleXMoZWxlbWVudG9zUG9yVHJhY2spLmZvckVhY2godHJhY2tJZCA9PiB7XG4gICAgICAgICAgY29uc3QgZWxlbWVudG9zID0gZWxlbWVudG9zUG9yVHJhY2tbdHJhY2tJZF07XG5cbiAgICAgICAgICAvLyBTaSBoYXkgYWwgbWVub3MgMiBlbGVtZW50b3MsIHBvZGVtb3MgYnVzY2FyIGVzcGFjaW9zXG4gICAgICAgICAgaWYgKGVsZW1lbnRvcy5sZW5ndGggPj0gMikge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBlbGVtZW50b3MubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICAgICAgICAgIGNvbnN0IGVsZW1lbnRvQWN0dWFsID0gZWxlbWVudG9zW2ldO1xuICAgICAgICAgICAgICBjb25zdCBlbGVtZW50b1NpZ3VpZW50ZSA9IGVsZW1lbnRvc1tpICsgMV07XG5cbiAgICAgICAgICAgICAgLy8gVmVyaWZpY2FyIHNpIGhheSB1biBlc3BhY2lvIGVudHJlIGVsIGZpbiBkZWwgZWxlbWVudG8gYWN0dWFsIHkgZWwgaW5pY2lvIGRlbCBzaWd1aWVudGVcbiAgICAgICAgICAgICAgY29uc3QgZXNwYWNpbyA9IGVsZW1lbnRvU2lndWllbnRlLmZyb20gLSBlbGVtZW50b0FjdHVhbC50bztcblxuICAgICAgICAgICAgICAvLyBTaSBlbCBlc3BhY2lvIGVzIHNpZ25pZmljYXRpdm8gKG3DoXMgZGUgMTAwbXMpXG4gICAgICAgICAgICAgIGlmIChlc3BhY2lvID4gMTAwKSB7XG4gICAgICAgICAgICAgICAgZXNwYWNpb3NWYWNpb3MucHVzaCh7XG4gICAgICAgICAgICAgICAgICB0cmFja0lkLFxuICAgICAgICAgICAgICAgICAgc3RhcnQ6IGVsZW1lbnRvQWN0dWFsLnRvLFxuICAgICAgICAgICAgICAgICAgZW5kOiBlbGVtZW50b1NpZ3VpZW50ZS5mcm9tLFxuICAgICAgICAgICAgICAgICAgc2l6ZTogZXNwYWNpbyxcbiAgICAgICAgICAgICAgICAgIGVsZW1lbnRvQW50ZXM6IGVsZW1lbnRvQWN0dWFsLmlkLFxuICAgICAgICAgICAgICAgICAgZWxlbWVudG9EZXNwdWVzOiBlbGVtZW50b1NpZ3VpZW50ZS5pZFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBFbmNvbnRyYWRvIGVzcGFjaW8gZGUgJHtlc3BhY2lvfW1zICgke2VzcGFjaW8vMTAwMH1zKSBlbiB0cmFjayAke3RyYWNrSWR9IGVudHJlIGVsZW1lbnRvcyAke2VsZW1lbnRvQWN0dWFsLmlkLnN1YnN0cmluZygwLDgpfS4uLiB5ICR7ZWxlbWVudG9TaWd1aWVudGUuaWQuc3Vic3RyaW5nKDAsOCl9Li4uYCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNvbnNvbGUubG9nKGBTZSBlbmNvbnRyYXJvbiAke2VzcGFjaW9zVmFjaW9zLmxlbmd0aH0gZXNwYWNpb3MgdmFjw61vc2ApO1xuXG4gICAgICAgIC8vIFNpIG5vIGhheSBlc3BhY2lvcywgbm8gbmVjZXNpdGFtb3MgY29tcGFjdGFyXG4gICAgICAgIGlmIChlc3BhY2lvc1ZhY2lvcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICBjb25zb2xlLmxvZyhcIk5vIGhheSBlc3BhY2lvcyBzaWduaWZpY2F0aXZvcyBwYXJhIGNvbXBhY3RhclwiKTtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTsgLy8gRGV2b2x2ZW1vcyB0cnVlIHBvcnF1ZSB0w6ljbmljYW1lbnRlIGVzdMOhIGNvbXBhY3RhZG9cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIE9yZGVuYXIgZXNwYWNpb3MgcG9yIHBvc2ljacOzbiAoZGUgaXpxdWllcmRhIGEgZGVyZWNoYSlcbiAgICAgICAgZXNwYWNpb3NWYWNpb3Muc29ydCgoYSwgYikgPT4gYS5zdGFydCAtIGIuc3RhcnQpO1xuXG4gICAgICAgIC8vIENhbGN1bGFyIGVsIGVzcGFjaW8gdG90YWwgYSBjb21wYWN0YXJcbiAgICAgICAgbGV0IGVzcGFjaW9Ub3RhbCA9IDA7XG4gICAgICAgIGVzcGFjaW9zVmFjaW9zLmZvckVhY2goZXNwYWNpbyA9PiB7XG4gICAgICAgICAgZXNwYWNpb1RvdGFsICs9IGVzcGFjaW8uc2l6ZTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgY29uc29sZS5sb2coYEVzcGFjaW8gdG90YWwgYSBjb21wYWN0YXI6ICR7ZXNwYWNpb1RvdGFsfW1zICgke2VzcGFjaW9Ub3RhbC8xMDAwfXMpYCk7XG4gICAgICAgIGNvbnNvbGUubG9nKGBQcmVwYXJhbmRvIGFjdHVhbGl6YWNpb25lcyBwYXJhICR7dG9kb3NFbGVtZW50b3MubGVuZ3RofSBlbGVtZW50b3MuLi5gKTtcblxuICAgICAgICAvLyBQcmVwYXJhciBhY3R1YWxpemFjaW9uZXMgcGFyYSBjYWRhIGVsZW1lbnRvXG4gICAgICAgIGNvbnN0IGFjdHVhbGl6YWNpb25lcyA9IHt9O1xuICAgICAgICBsZXQgZWxlbWVudG9zQU1vdmVyID0gMDtcblxuICAgICAgICAvLyBQYXJhIGNhZGEgZWxlbWVudG8sIGNhbGN1bGFtb3MgZWwgZGVzcGxhemFtaWVudG8gYmFzYWRvIGVuIGxvcyBlc3BhY2lvcyBhbnRlcmlvcmVzXG4gICAgICAgIHRvZG9zRWxlbWVudG9zLmZvckVhY2goZWxlbWVudG8gPT4ge1xuICAgICAgICAgIGxldCBkZXNwbGF6YW1pZW50byA9IDA7XG5cbiAgICAgICAgICAvLyBDYWxjdWxhciBjdcOhbnRvIGRlYmUgbW92ZXJzZSBiYXNhZG8gZW4gbG9zIGVzcGFjaW9zIHZhY8Otb3MgYW50ZXJpb3Jlc1xuICAgICAgICAgIGZvciAoY29uc3QgZXNwYWNpbyBvZiBlc3BhY2lvc1ZhY2lvcykge1xuICAgICAgICAgICAgLy8gU2kgZWwgZWxlbWVudG8gZXN0w6EgZGVzcHXDqXMgZGVsIGVzcGFjaW8gdmFjw61vLCBkZWJlIG1vdmVyc2VcbiAgICAgICAgICAgIGlmIChlbGVtZW50by5mcm9tID4gZXNwYWNpby5lbmQpIHtcbiAgICAgICAgICAgICAgZGVzcGxhemFtaWVudG8gKz0gZXNwYWNpby5zaXplO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIFNpIGhheSBkZXNwbGF6YW1pZW50bywgYcOxYWRpciBhIGxhcyBhY3R1YWxpemFjaW9uZXNcbiAgICAgICAgICBpZiAoZGVzcGxhemFtaWVudG8gPiAwKSB7XG4gICAgICAgICAgICBjb25zdCBudWV2b0Zyb20gPSBlbGVtZW50by5mcm9tIC0gZGVzcGxhemFtaWVudG87XG4gICAgICAgICAgICBjb25zdCBudWV2b1RvID0gZWxlbWVudG8udG8gLSBkZXNwbGF6YW1pZW50bztcblxuICAgICAgICAgICAgY29uc29sZS5sb2coYEVsZW1lbnRvICR7ZWxlbWVudG8uaWQuc3Vic3RyaW5nKDAsOCl9Li4uIHNlIG1vdmVyw6E6ICR7ZWxlbWVudG8uZnJvbX1tcyAtPiAke251ZXZvRnJvbX1tcyAoZGVzcGxhemFtaWVudG86ICR7ZGVzcGxhemFtaWVudG99bXMpYCk7XG5cbiAgICAgICAgICAgIGFjdHVhbGl6YWNpb25lc1tlbGVtZW50by5pZF0gPSB7XG4gICAgICAgICAgICAgIGRpc3BsYXk6IHtcbiAgICAgICAgICAgICAgICBmcm9tOiBudWV2b0Zyb20sXG4gICAgICAgICAgICAgICAgdG86IG51ZXZvVG9cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGVsZW1lbnRvc0FNb3ZlcisrO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgY29uc29sZS5sb2coYEVsZW1lbnRvcyBhIG1vdmVyOiAke2VsZW1lbnRvc0FNb3Zlcn0gZGUgJHt0b2Rvc0VsZW1lbnRvcy5sZW5ndGh9IHRvdGFsYCk7XG5cbiAgICAgICAgLy8gQXBsaWNhciBsYXMgYWN0dWFsaXphY2lvbmVzXG4gICAgICAgIGlmIChlbGVtZW50b3NBTW92ZXIgPiAwKSB7XG4gICAgICAgICAgY29uc29sZS5sb2coXCJBcGxpY2FuZG8gYWN0dWFsaXphY2lvbmVzIHBhcmEgY29tcGFjdGFyIHRpbWVsaW5lLi4uXCIpO1xuXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGRpc3BhdGNoKEVESVRfT0JKRUNULCB7XG4gICAgICAgICAgICAgIHBheWxvYWQ6IGFjdHVhbGl6YWNpb25lc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIkFjdHVhbGl6YWNpb25lcyBhcGxpY2FkYXMgY29uIMOpeGl0b1wiKTtcbiAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIGFsIGFwbGljYXIgYWN0dWFsaXphY2lvbmVzOlwiLCBlcnJvcik7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gUmVmcmVzY2FyIGxhIHZpc3RhXG4gICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBjb25zdCB7IHNjYWxlIH0gPSBzdGF0ZU1hbmFnZXIuZ2V0U3RhdGUoKTtcbiAgICAgICAgICAgICAgaWYgKHNjYWxlKSB7XG4gICAgICAgICAgICAgICAgLy8gSGFjZXIgdW4gcGVxdWXDsW8gY2FtYmlvIGVuIGxhIGVzY2FsYSBwYXJhIGZvcnphciBsYSBhY3R1YWxpemFjacOzblxuICAgICAgICAgICAgICAgIGNvbnN0IHVwZGF0ZWRTY2FsZSA9IHsgLi4uc2NhbGUgfTtcblxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdXBkYXRlZFNjYWxlLnVuaXQgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgICB1cGRhdGVkU2NhbGUudW5pdCA9ICh1cGRhdGVkU2NhbGUudW5pdCB8fCAwKSArIDE7XG5cbiAgICAgICAgICAgICAgICAgIGRpc3BhdGNoKFRJTUVMSU5FX1NDQUxFX0NIQU5HRUQsIHtcbiAgICAgICAgICAgICAgICAgICAgcGF5bG9hZDogeyBzY2FsZTogdXBkYXRlZFNjYWxlIH1cbiAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAvLyBWb2x2ZXIgYSBsYSBlc2NhbGEgb3JpZ2luYWxcbiAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjdXJyZW50U2NhbGUgPSB7IC4uLnN0YXRlTWFuYWdlci5nZXRTdGF0ZSgpLnNjYWxlIH07XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRTY2FsZS51bml0ID0gKGN1cnJlbnRTY2FsZS51bml0IHx8IDEpIC0gMTtcbiAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2goVElNRUxJTkVfU0NBTEVfQ0hBTkdFRCwge1xuICAgICAgICAgICAgICAgICAgICAgIHBheWxvYWQ6IHsgc2NhbGU6IGN1cnJlbnRTY2FsZSB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgfSwgMzAwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBhbCByZWZyZXNjYXIgbGEgdmlzdGE6XCIsIGVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LCA1MDApO1xuXG4gICAgICAgICAgY29uc29sZS5sb2coXCJDb21wYWN0YWNpw7NuIGNvbXBsZXRhZGEgY29uIMOpeGl0b1wiKTtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zb2xlLmxvZyhcIk5vIGhheSBlbGVtZW50b3MgcXVlIG5lY2VzaXRlbiBtb3ZlcnNlXCIpO1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgYWwgY29tcGFjdGFyIGxhIGzDrW5lYSBkZSB0aWVtcG86XCIsIGVycm9yKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBzbWFydFRyaW06IGFzeW5jICgpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiPT09IElOSUNJQU5ETyBQUk9DRVNPIERFIFJFQ09SVEUgSU5URUxJR0VOVEUgREVTREUgSUEgPT09XCIpO1xuXG4gICAgICAgIC8vIDEuIFJlYWxpemFyIGxhIGxsYW1hZGEgYWwgQVBJIHBhcmEgYW5hbGl6YXIgbGEgdHJhbnNjcmlwY2nDs25cbiAgICAgICAgY29uc29sZS5sb2coXCJTb2xpY2l0YW5kbyBhbsOhbGlzaXMgZGUgdHJhbnNjcmlwY2nDs24uLi5cIik7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goJy9hcGkvc21hcnQtdHJpbScpO1xuXG4gICAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEVycm9yIGFsIGFuYWxpemFyIGxhIHRyYW5zY3JpcGNpw7NuOiAke3Jlc3BvbnNlLnN0YXR1c31gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiQW7DoWxpc2lzIGRlIHRyYW5zY3JpcGNpw7NuIGNvbXBsZXRhZG86XCIsIGRhdGEpO1xuXG4gICAgICAgIGlmICghZGF0YS5yZW1vdmVTZWdtZW50cyB8fCAhQXJyYXkuaXNBcnJheShkYXRhLnJlbW92ZVNlZ21lbnRzKSB8fCBkYXRhLnJlbW92ZVNlZ21lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIGNvbnNvbGUubG9nKFwiTm8gc2UgZW5jb250cmFyb24gc2VnbWVudG9zIHBhcmEgZWxpbWluYXJcIik7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gMi4gQ29udmVydGlyIGxvcyBzZWdtZW50b3MgYWwgZm9ybWF0byBxdWUgZXNwZXJhIHJlbW92ZVNlZ21lbnRzXG4gICAgICAgIGNvbnN0IHNlZ21lbnRzID0gZGF0YS5yZW1vdmVTZWdtZW50cy5tYXAoc2VnbWVudCA9PiAoe1xuICAgICAgICAgIHN0YXJ0VGltZTogc2VnbWVudC5zdGFydFRpbWUsIC8vIFlhIGVzdMOhIGVuIHNlZ3VuZG9zXG4gICAgICAgICAgZW5kVGltZTogc2VnbWVudC5lbmRUaW1lICAgICAgLy8gWWEgZXN0w6EgZW4gc2VndW5kb3NcbiAgICAgICAgfSkpO1xuXG4gICAgICAgIGNvbnNvbGUubG9nKGBTZSBlbGltaW5hcsOhbiAke3NlZ21lbnRzLmxlbmd0aH0gc2VnbWVudG9zOmAsXG4gICAgICAgICAgc2VnbWVudHMubWFwKHMgPT4gYCR7cy5zdGFydFRpbWV9cy0ke3MuZW5kVGltZX1zYCkuam9pbignLCAnKSk7XG5cbiAgICAgICAgLy8gQWxtYWNlbmFyIGluZm9ybWFjacOzbiBkZWwgZXN0YWRvIHByZXZpbyBwYXJhIGlkZW50aWZpY2FyIHRyYWNrcyB5IGVsZW1lbnRvc1xuICAgICAgICBjb25zb2xlLmxvZyhcIk9idGVuaWVuZG8gaW5mb3JtYWNpw7NuIGRlbCBlc3RhZG8gYW50ZXMgZGUgZWxpbWluYXIgc2VnbWVudG9zLi4uXCIpO1xuICAgICAgICBjb25zdCBlc3RhZG9QcmV2aW8gPSBzdGF0ZU1hbmFnZXIuZ2V0U3RhdGUoKTtcbiAgICAgICAgY29uc3QgZWxlbWVudG9zUHJldmlvcyA9IGF3YWl0IGV4ZWN1dG9yLmdldEFsbFRpbWVsaW5lRWxlbWVudHMoKTtcblxuICAgICAgICAvLyBEZXRlcm1pbmFyIGVsIHRyYWNrSWQgcHJpbmNpcGFsIGJhc2FkbyBlbiBsb3MgZWxlbWVudG9zXG4gICAgICAgIGNvbnN0IGNvbnRhZG9yVHJhY2tzID0ge307XG4gICAgICAgIGVsZW1lbnRvc1ByZXZpb3MuZm9yRWFjaChlbGVtID0+IHtcbiAgICAgICAgICBpZiAoZWxlbS50cmFja0lkKSB7XG4gICAgICAgICAgICBjb250YWRvclRyYWNrc1tlbGVtLnRyYWNrSWRdID0gKGNvbnRhZG9yVHJhY2tzW2VsZW0udHJhY2tJZF0gfHwgMCkgKyAxO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gRW5jb250cmFyIGVsIHRyYWNrIGNvbiBtw6FzIGVsZW1lbnRvc1xuICAgICAgICBsZXQgdHJhY2tJZFByaW5jaXBhbCA9IFwiXCI7XG4gICAgICAgIGlmIChPYmplY3Qua2V5cyhjb250YWRvclRyYWNrcykubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGNvbnN0IHRyYWNrc1BvclVzbyA9IE9iamVjdC5lbnRyaWVzKGNvbnRhZG9yVHJhY2tzKVxuICAgICAgICAgICAgLnNvcnQoKGEsIGIpID0+IGJbMV0gLSBhWzFdKTtcblxuICAgICAgICAgIGlmICh0cmFja3NQb3JVc28ubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdHJhY2tJZFByaW5jaXBhbCA9IHRyYWNrc1BvclVzb1swXVswXTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGBVc2FuZG8gdHJhY2tJZCBwcmluY2lwYWw6ICR7dHJhY2tJZFByaW5jaXBhbH1gKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyAzLiBFbGltaW5hciBsb3Mgc2VnbWVudG9zXG4gICAgICAgIGNvbnNvbGUubG9nKFwiRWplY3V0YW5kbyBlbGltaW5hY2nDs24gZGUgc2VnbWVudG9zLi4uXCIpO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBleGVjdXRvci5yZW1vdmVTZWdtZW50cyhzZWdtZW50cyk7XG5cbiAgICAgICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgICAgICBjb25zb2xlLmxvZyhcIkVycm9yIGFsIGVsaW1pbmFyIGxvcyBzZWdtZW50b3NcIik7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc29sZS5sb2coXCJTZWdtZW50b3MgZWxpbWluYWRvcyBjb3JyZWN0YW1lbnRlXCIpO1xuXG4gICAgICAgIC8vIDQuIENyZWFyIHJlZ2lzdHJvIGRlIGxvcyBzZWdtZW50b3MgZWxpbWluYWRvcyBwYXJhIGNvbXBhY3RhY2nDs25cbiAgICAgICAgY29uc3Qgc2VnbWVudG9zRWxpbWluYWRvcyA9IHNlZ21lbnRzLm1hcChzZWdtZW50ID0+ICh7XG4gICAgICAgICAgc3RhcnQ6IHNlZ21lbnQuc3RhcnRUaW1lICogMTAwMCwgIC8vIENvbnZlcnRpciBhIG1zXG4gICAgICAgICAgZW5kOiBzZWdtZW50LmVuZFRpbWUgKiAxMDAwLCAgICAgIC8vIENvbnZlcnRpciBhIG1zXG4gICAgICAgICAgdHJhY2tJZDogdHJhY2tJZFByaW5jaXBhbCxcbiAgICAgICAgICBzaXplOiAoc2VnbWVudC5lbmRUaW1lIC0gc2VnbWVudC5zdGFydFRpbWUpICogMTAwMFxuICAgICAgICB9KSk7XG5cbiAgICAgICAgY29uc29sZS5sb2coXCJTZWdtZW50b3MgcmVnaXN0cmFkb3MgcGFyYSBjb21wYWN0YWNpw7NuOlwiLCBzZWdtZW50b3NFbGltaW5hZG9zKTtcblxuICAgICAgICAvLyA1LiBFc3BlcmFyIHVuIG1vbWVudG8gcGFyYSBxdWUgc2UgY29tcGxldGVuIGxhcyBhY3R1YWxpemFjaW9uZXMgZGVsIERPTSB5IGVsIGVzdGFkb1xuICAgICAgICBjb25zb2xlLmxvZyhcIkVzcGVyYW5kbyA1IHNlZ3VuZG9zIHBhcmEgYXNlZ3VyYXIgcXVlIGxvcyBjYW1iaW9zIGVuIGxhIHRpbWVsaW5lIGVzdMOpbiBjb21wbGV0b3MgYW50ZXMgZGUgY29tcGFjdGFyLi4uXCIpO1xuICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgNTAwMCkpO1xuXG4gICAgICAgIC8vIDYuIENvbXBhY3RhciBlbCB0aW1lbGluZSB1c2FuZG8gZWwgZW5mb3F1ZSBkZSBzZWdtZW50b3MgcmVnaXN0cmFkb3NcbiAgICAgICAgY29uc29sZS5sb2coXCJDb21wYWN0YW5kbyB0aW1lbGluZSBiYXNhZG8gZW4gc2VnbWVudG9zIGVsaW1pbmFkb3MuLi5cIik7XG5cbiAgICAgICAgLy8gT2J0ZW5lciBlbGVtZW50b3MgYWN0dWFsZXMgZGVzcHXDqXMgZGUgbGEgZWxpbWluYWNpw7NuXG4gICAgICAgIGNvbnN0IGVsZW1lbnRvc0FjdHVhbGVzID0gYXdhaXQgZXhlY3V0b3IuZ2V0QWxsVGltZWxpbmVFbGVtZW50cygpO1xuICAgICAgICBjb25zb2xlLmxvZyhgU2UgZW5jb250cmFyb24gJHtlbGVtZW50b3NBY3R1YWxlcy5sZW5ndGh9IGVsZW1lbnRvcyBlbiBsYSB0aW1lbGluZSBkZXNwdcOpcyBkZSBlbGltaW5hciBzZWdtZW50b3NgKTtcblxuICAgICAgICAvLyBDYWxjdWxhciBlbCBlc3BhY2lvIHRvdGFsIGEgY29tcGFjdGFyXG4gICAgICAgIGxldCBlc3BhY2lvVG90YWwgPSAwO1xuICAgICAgICBzZWdtZW50b3NFbGltaW5hZG9zLmZvckVhY2goc2VnbWVudG8gPT4ge1xuICAgICAgICAgIGVzcGFjaW9Ub3RhbCArPSBzZWdtZW50by5zaXplO1xuICAgICAgICB9KTtcblxuICAgICAgICBjb25zb2xlLmxvZyhgRXNwYWNpbyB0b3RhbCBhIGNvbXBhY3RhcjogJHtlc3BhY2lvVG90YWx9bXMgKCR7ZXNwYWNpb1RvdGFsLzEwMDB9cylgKTtcblxuICAgICAgICAvLyBQcmVwYXJhciBhY3R1YWxpemFjaW9uZXMgcGFyYSBjYWRhIGVsZW1lbnRvXG4gICAgICAgIGNvbnN0IGFjdHVhbGl6YWNpb25lcyA9IHt9O1xuICAgICAgICBsZXQgZWxlbWVudG9zQU1vdmVyID0gMDtcblxuICAgICAgICAvLyBPcmRlbmFyIHNlZ21lbnRvcyBwb3IgcG9zaWNpw7NuIGRlIGluaWNpb1xuICAgICAgICBjb25zdCBzZWdtZW50b3NPcmRlbmFkb3MgPSBbLi4uc2VnbWVudG9zRWxpbWluYWRvc10uc29ydCgoYSwgYikgPT4gYS5zdGFydCAtIGIuc3RhcnQpO1xuXG4gICAgICAgIC8vIFBhcmEgY2FkYSBlbGVtZW50bywgY2FsY3VsYXIgZWwgZGVzcGxhemFtaWVudG8gYmFzYWRvIGVuIGxvcyBzZWdtZW50b3MgZWxpbWluYWRvc1xuICAgICAgICBlbGVtZW50b3NBY3R1YWxlcy5mb3JFYWNoKGVsZW1lbnRvID0+IHtcbiAgICAgICAgICBsZXQgZGVzcGxhemFtaWVudG8gPSAwO1xuXG4gICAgICAgICAgLy8gQ2FsY3VsYXIgY3XDoW50byBkZWJlIG1vdmVyc2UgYmFzYWRvIGVuIGxvcyBzZWdtZW50b3MgZWxpbWluYWRvcyBhbnRlcmlvcmVzXG4gICAgICAgICAgZm9yIChjb25zdCBzZWdtZW50byBvZiBzZWdtZW50b3NPcmRlbmFkb3MpIHtcbiAgICAgICAgICAgIGlmIChlbGVtZW50by5mcm9tID4gc2VnbWVudG8uc3RhcnQpIHtcbiAgICAgICAgICAgICAgZGVzcGxhemFtaWVudG8gKz0gc2VnbWVudG8uc2l6ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBTaSBoYXkgZGVzcGxhemFtaWVudG8sIGHDsWFkaXIgYSBsYXMgYWN0dWFsaXphY2lvbmVzXG4gICAgICAgICAgaWYgKGRlc3BsYXphbWllbnRvID4gMCkge1xuICAgICAgICAgICAgY29uc3QgbnVldm9Gcm9tID0gZWxlbWVudG8uZnJvbSAtIGRlc3BsYXphbWllbnRvO1xuICAgICAgICAgICAgY29uc3QgbnVldm9UbyA9IGVsZW1lbnRvLnRvIC0gZGVzcGxhemFtaWVudG87XG5cbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGBFbGVtZW50byAke2VsZW1lbnRvLmlkLnN1YnN0cmluZygwLDgpfS4uLiBzZSBtb3ZlcsOhOiAke2VsZW1lbnRvLmZyb219bXMgLT4gJHtudWV2b0Zyb219bXMgKGRlc3BsYXphbWllbnRvOiAke2Rlc3BsYXphbWllbnRvfW1zKWApO1xuXG4gICAgICAgICAgICBhY3R1YWxpemFjaW9uZXNbZWxlbWVudG8uaWRdID0ge1xuICAgICAgICAgICAgICBkaXNwbGF5OiB7XG4gICAgICAgICAgICAgICAgZnJvbTogbnVldm9Gcm9tLFxuICAgICAgICAgICAgICAgIHRvOiBudWV2b1RvXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBlbGVtZW50b3NBTW92ZXIrKztcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNvbnNvbGUubG9nKGBFbGVtZW50b3MgYSBtb3ZlcjogJHtlbGVtZW50b3NBTW92ZXJ9IGRlICR7ZWxlbWVudG9zQWN0dWFsZXMubGVuZ3RofSB0b3RhbGApO1xuXG4gICAgICAgIC8vIEFwbGljYXIgbGFzIGFjdHVhbGl6YWNpb25lc1xuICAgICAgICBpZiAoZWxlbWVudG9zQU1vdmVyID4gMCkge1xuICAgICAgICAgIGNvbnNvbGUubG9nKFwiQXBsaWNhbmRvIGFjdHVhbGl6YWNpb25lcyBwYXJhIGNvbXBhY3RhciB0aW1lbGluZS4uLlwiKTtcblxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBkaXNwYXRjaChFRElUX09CSkVDVCwge1xuICAgICAgICAgICAgICBwYXlsb2FkOiBhY3R1YWxpemFjaW9uZXNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc29sZS5sb2coXCJBY3R1YWxpemFjaW9uZXMgYXBsaWNhZGFzIGNvbiDDqXhpdG9cIik7XG5cbiAgICAgICAgICAgIC8vIFJlZnJlc2NhciBsYSB2aXN0YVxuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBzY2FsZSB9ID0gc3RhdGVNYW5hZ2VyLmdldFN0YXRlKCk7XG4gICAgICAgICAgICAgICAgaWYgKHNjYWxlKSB7XG4gICAgICAgICAgICAgICAgICBjb25zdCB1cGRhdGVkU2NhbGUgPSB7IC4uLnNjYWxlIH07XG4gICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHVwZGF0ZWRTY2FsZS51bml0ID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgICAgICB1cGRhdGVkU2NhbGUudW5pdCA9ICh1cGRhdGVkU2NhbGUudW5pdCB8fCAwKSArIDE7XG5cbiAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2goVElNRUxJTkVfU0NBTEVfQ0hBTkdFRCwge1xuICAgICAgICAgICAgICAgICAgICAgIHBheWxvYWQ6IHsgc2NhbGU6IHVwZGF0ZWRTY2FsZSB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIFZvbHZlciBhIGxhIGVzY2FsYSBvcmlnaW5hbFxuICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjdXJyZW50U2NhbGUgPSB7IC4uLnN0YXRlTWFuYWdlci5nZXRTdGF0ZSgpLnNjYWxlIH07XG4gICAgICAgICAgICAgICAgICAgICAgY3VycmVudFNjYWxlLnVuaXQgPSAoY3VycmVudFNjYWxlLnVuaXQgfHwgMSkgLSAxO1xuICAgICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoKFRJTUVMSU5FX1NDQUxFX0NIQU5HRUQsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBheWxvYWQ6IHsgc2NhbGU6IGN1cnJlbnRTY2FsZSB9XG4gICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0sIDMwMCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBhbCByZWZyZXNjYXIgbGEgdmlzdGE6XCIsIGVycm9yKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgNTAwKTtcblxuICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgYWwgYXBsaWNhciBhY3R1YWxpemFjaW9uZXM6XCIsIGVycm9yKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc29sZS5sb2coXCJObyBzZSBlbmNvbnRyYXJvbiBlbGVtZW50b3MgcXVlIG5lY2VzaXRlbiBtb3ZlcnNlXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc29sZS5sb2coXCJUaW1lbGluZSBjb21wYWN0YWRvIGNvcnJlY3RhbWVudGVcIik7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIGFsIHJlYWxpemFyIGVsIHJlY29ydGUgaW50ZWxpZ2VudGU6XCIsIGVycm9yKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBhZGRNdXNpYzogKG11c2ljUGF0aDogc3RyaW5nLCBvcHRpb25zPzogTXVzaWNPcHRpb25zKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICAvLyBWYWxvcmVzIHByZWRldGVybWluYWRvc1xuICAgICAgICBjb25zdCBzdGFydFRpbWUgPSBvcHRpb25zPy5zdGFydFRpbWUgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuc3RhcnRUaW1lIDogMDtcbiAgICAgICAgY29uc3QgZW5kVGltZSA9IG9wdGlvbnM/LmVuZFRpbWUgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuZW5kVGltZSA6IChzdGFydFRpbWUgKyAzMCk7IC8vIER1cmFjacOzbiBwcmVkZXRlcm1pbmFkYSBtw6FzIGxhcmdhIHBhcmEgbcO6c2ljYVxuICAgICAgICBjb25zdCB2b2x1bWUgPSBvcHRpb25zPy52b2x1bWUgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMudm9sdW1lIDogODA7IC8vIFZvbHVtZW4gcHJlZGV0ZXJtaW5hZG8gYWwgODAlXG4gICAgICAgIGNvbnN0IHJlc3BlY3ROYXRpdmVEdXJhdGlvbiA9IG9wdGlvbnM/LnJlc3BlY3ROYXRpdmVEdXJhdGlvbiAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5yZXNwZWN0TmF0aXZlRHVyYXRpb24gOiB0cnVlOyAvLyBQb3IgZGVmZWN0bywgcmVzcGV0YXIgZHVyYWNpw7NuIG5hdGl2YVxuXG4gICAgICAgIGNvbnNvbGUubG9nKGBBw7FhZGllbmRvIG3DunNpY2EgZGVzZGUgJHttdXNpY1BhdGh9YCk7XG4gICAgICAgIGNvbnNvbGUubG9nKGBUaWVtcG9zOiAke3N0YXJ0VGltZX1zIGEgJHtlbmRUaW1lfXMsIHZvbHVtZW46ICR7dm9sdW1lfSwgcmVzcGVjdE5hdGl2ZUR1cmF0aW9uOiAke3Jlc3BlY3ROYXRpdmVEdXJhdGlvbn1gKTtcblxuICAgICAgICAvLyBDcmVhciBwYXlsb2FkIHBhcmEgbGEgbcO6c2ljYVxuICAgICAgICBjb25zdCBhdWRpb1BheWxvYWQgPSB7XG4gICAgICAgICAgaWQ6IGdlbmVyYXRlSWQoKSxcbiAgICAgICAgICBkaXNwbGF5OiB7XG4gICAgICAgICAgICBmcm9tOiBzdGFydFRpbWUgKiAxMDAwLCAvLyBDb252ZXJ0aXIgYSBtaWxpc2VndW5kb3NcbiAgICAgICAgICAgIHRvOiBlbmRUaW1lICogMTAwMCAgICAgLy8gQ29udmVydGlyIGEgbWlsaXNlZ3VuZG9zXG4gICAgICAgICAgfSxcbiAgICAgICAgICB0eXBlOiAnYXVkaW8nLFxuICAgICAgICAgIGRldGFpbHM6IHtcbiAgICAgICAgICAgIHNyYzogbXVzaWNQYXRoLFxuICAgICAgICAgICAgdm9sdW1lOiB2b2x1bWUsXG4gICAgICAgICAgICBmYWRlSW46IG9wdGlvbnM/LmZhZGVJbiA9PT0gdHJ1ZSxcbiAgICAgICAgICAgIGZhZGVPdXQ6IG9wdGlvbnM/LmZhZGVPdXQgPT09IHRydWVcbiAgICAgICAgICB9LFxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIEFncmVnYXIgYXVkaW8gYWwgdGltZWxpbmUgdXNhbmRvIEFERF9BVURJT1xuICAgICAgICBkaXNwYXRjaChBRERfQVVESU8sIHtcbiAgICAgICAgICBwYXlsb2FkOiBhdWRpb1BheWxvYWQsXG4gICAgICAgICAgb3B0aW9uczoge1xuICAgICAgICAgICAgcmVzcGVjdE5hdGl2ZUR1cmF0aW9uOiByZXNwZWN0TmF0aXZlRHVyYXRpb25cbiAgICAgICAgICB9LFxuICAgICAgICB9KTtcblxuICAgICAgICBjb25zb2xlLmxvZyhgTcO6c2ljYSBhZ3JlZ2FkYSBleGl0b3NhbWVudGUgY29uIElEOiAke2F1ZGlvUGF5bG9hZC5pZH1gKTtcbiAgICAgICAgcmV0dXJuIGF1ZGlvUGF5bG9hZC5pZDtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBhbCBhZ3JlZ2FyIG3DunNpY2E6XCIsIGVycm9yKTtcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBleGVjdXRvcjtcbn1cbiJdLCJuYW1lcyI6WyJkaXNwYXRjaCIsIkFERF9URVhUIiwiQUREX1ZJREVPIiwiQUREX0lNQUdFIiwiQUREX0FVRElPIiwiQUNUSVZFX1NQTElUIiwiTEFZRVJfU0VMRUNUIiwiTEFZRVJfREVMRVRFIiwiVElNRUxJTkVfU0NBTEVfQ0hBTkdFRCIsIkVESVRfT0JKRUNUIiwiZ2VuZXJhdGVJZCIsImNyZWF0ZVZpZGVvQ29tbWFuZEV4ZWN1dG9yIiwic3RhdGVNYW5hZ2VyIiwiZXhlY3V0b3IiLCJhZGRUZXh0IiwidGV4dCIsIm9wdGlvbnMiLCJwb3NpdGlvbiIsIngiLCJ5IiwiZm9udFNpemUiLCJmb250RmFtaWx5IiwiY29sb3IiLCJzdGFydFRpbWUiLCJlbmRUaW1lIiwidGV4dFBheWxvYWQiLCJpZCIsImRpc3BsYXkiLCJmcm9tIiwidG8iLCJ0eXBlIiwiZGV0YWlscyIsIndpZHRoIiwid29yZFdyYXAiLCJ0ZXh0QWxpZ24iLCJib3JkZXJXaWR0aCIsImJvcmRlckNvbG9yIiwiYm94U2hhZG93IiwiYmx1ciIsInBheWxvYWQiLCJjaGFuZ2VDb2xvciIsImVsZW1lbnRJZCIsImNvbnNvbGUiLCJsb2ciLCJhZGRJbWFnZSIsInVybCIsImVycm9yIiwiRXJyb3IiLCJKU09OIiwic3RyaW5naWZ5IiwiaW5jbHVkZXMiLCJoZWlnaHQiLCJ1bmRlZmluZWQiLCJpc0V4cGxpY2l0bHlBbmltYXRlZCIsImlzQW5pbWF0ZWQiLCJpc0V4cGxpY2l0bHlTdGF0aWMiLCJpc1N0YXRpYyIsImlzQVBORyIsInRvTG93ZXJDYXNlIiwiZW5kc1dpdGgiLCJpc0dJRiIsInNob3VsZFRyZWF0QXNBbmltYXRlZCIsImxvZ1VybCIsInN0YXJ0c1dpdGgiLCJzdWJzdHJpbmciLCJzY2FsZU1vZGUiLCJ1c2VGdWxsU2NyZWVuIiwiY29tbW9uUGF5bG9hZFByb3BzIiwiY29tbW9uRGV0YWlsc1Byb3BzIiwic3JjIiwib3BhY2l0eSIsImxlZnQiLCJ0b3AiLCJvcmlnaW5YIiwib3JpZ2luWSIsImltYWdlSWQiLCJpbWFnZVBheWxvYWQiLCJsZW5ndGgiLCJkaXNwYXRjaE9wdGlvbnMiLCJtZXNzYWdlIiwic3RhY2siLCJhZGRWaWRlbyIsImlzQVZJIiwiaXNFeHBsaWNpdEFQTkciLCJ0cmVhdEFzQVBORyIsInJlc3BlY3ROYXRpdmVEdXJhdGlvbiIsImZpbmFsRW5kVGltZSIsInN5bmNXaXRoVGltZWxpbmUiLCJhcG5nVmlkZW9QYXlsb2FkIiwiYXBuZ0Vycm9yIiwidmlkZW9QYXlsb2FkIiwiYXV0b1BsYXkiLCJsb29wIiwicmVzb3VyY2VJZCIsInBsYXliYWNrQmVoYXZpb3IiLCJjaGFuZ2VEdXJhdGlvbiIsImR1cmF0aW9uIiwiY2hhbmdlVHJhbnNpdGlvbiIsInRyYW5zaXRpb24iLCJhZGRTdWJ0aXRsZXMiLCJwYXJzZVRpbWVUb01zIiwidGltZVN0cmluZyIsImhvdXJzIiwibWludXRlcyIsInNlY29uZHNBbmRNcyIsInNwbGl0Iiwic2Vjb25kcyIsIm1zIiwicGFyc2VJbnQiLCJwYXJzZVNSVCIsInNydENvbnRlbnQiLCJzZWdtZW50cyIsImJsb2NrcyIsInRyaW0iLCJmb3JFYWNoIiwiYmxvY2siLCJsaW5lcyIsInRpbWVSYW5nZSIsInNsaWNlIiwiam9pbiIsInB1c2giLCJzcGxpdFRleHRJbnRvR3JvdXBzIiwid29yZHNQZXJHcm91cCIsIndvcmRzIiwiZ3JvdXBzIiwiaSIsImdyb3VwIiwicHJvY2Vzc1NlZ21lbnQiLCJzZWdtZW50IiwidGV4dEdyb3VwcyIsInRvdGFsRHVyYXRpb24iLCJncm91cER1cmF0aW9uIiwibWFwIiwiZ3JvdXBUZXh0IiwiaW5kZXgiLCJjcmVhdGVTdWJ0aXRsZVBheWxvYWQiLCJ0b1VwcGVyQ2FzZSIsImZvbnRVcmwiLCJiYWNrZ3JvdW5kQ29sb3IiLCJwYWRkaW5nIiwiYm9yZGVyUmFkaXVzIiwiZ2V0U3VidGl0bGVUcmFja0lkIiwic3RhdGUiLCJnZXRTdGF0ZSIsIk9iamVjdCIsImtleXMiLCJ0cmFja3MiLCJBcnJheSIsImlzQXJyYXkiLCJ0ZXh0VHJhY2siLCJmaW5kIiwidHJhY2siLCJhY2NlcHRzIiwidGltZWxpbmUiLCJjYW52YXMiLCJjYW52YXNUcmFja3MiLCJ0cmFja0lkIiwidGltZWxpbmVUcmFja3MiLCJhY3RpdmVJZHMiLCJ0cmFja0l0ZW1zTWFwIiwiYWN0aXZlRWxlbWVudCIsInRleHRJdGVtcyIsInZhbHVlcyIsImZpbHRlciIsIml0ZW0iLCJmaXJzdEl0ZW0iLCJrZXkiLCJyZXNwb25zZSIsImZldGNoIiwib2siLCJzdGF0dXMiLCJmbGF0TWFwIiwib3JpZ2luYWxMZW5ndGgiLCJwYXNzZXNTdGFydEZpbHRlciIsInBhc3Nlc0VuZEZpbHRlciIsIlByb21pc2UiLCJyZXNvbHZlIiwiZmlyc3RTZWdtZW50IiwicmVtYWluaW5nU2VnbWVudHMiLCJzZXRUaW1lb3V0IiwidXBkYXRlZFN0YXRlIiwibmV3VHJhY2tJZCIsImFsbEl0ZW1zIiwibW9zdFJlY2VudEl0ZW0iLCJzb3J0IiwiYSIsImIiLCJhVGltZSIsInRpbWVzdGFtcCIsImJUaW1lIiwidXNlZFRyYWNrcyIsIlNldCIsImFkZCIsInRyYWNrVGltZU1hcCIsImNoZWNrT3ZlcmxhcCIsInNvbWUiLCJ0aW1lU2xvdCIsImFkZFRpbWVTbG90IiwiY2hlY2tGb3JOZXdUcmFja3MiLCJwcmV2U3RhdGUiLCJjdXJyZW50U3RhdGUiLCJwcmV2SXRlbXMiLCJjdXJyZW50SXRlbXMiLCJuZXdJdGVtSWRzIiwibmV3SXRlbXMiLCJoYXMiLCJyZWNlbnRUcmFja0lkIiwicHJvY2Vzc1NlZ21lbnRXaXRoVHJhY2tpbmciLCJzZWxlY3RlZFRyYWNrSWQiLCJoYXNPdmVybGFwIiwiZm91bmROb25PdmVybGFwcGluZ1RyYWNrIiwibmV3VHJhY2siLCJjb21wbGV0ZWRDb3VudCIsImdldEFjdGl2ZUVsZW1lbnRzIiwiYWN0aXZlRWxlbWVudHMiLCJnZXRBbGxUaW1lbGluZUVsZW1lbnRzIiwib2JqVmFsdWUiLCJzYW1wbGUiLCJlbnRyaWVzIiwiXyIsImFsbEVsZW1lbnRzIiwicmVtb3ZlU2VnbWVudHMiLCJ0cmFja0l0ZW1zIiwiZmlyc3RJdGVtSWQiLCJpZHMiLCJvcmlnaW5hbEl0ZW1JZCIsIm9yaWdpbmFsSXRlbSIsInRyYWNrVHlwZSIsImVuZE1zIiwidGltZSIsInN0YXRlQWZ0ZXJGaXJzdEN1dCIsImVsZW1lbnRzQWZ0ZXJGaXJzdEN1dCIsImlzTmFOIiwiZHVyYWNpw7NuIiwic3RhcnRNcyIsImxlZnRFbGVtZW50IiwiZWxlbSIsInN0YXRlQWZ0ZXJTZWNvbmRDdXQiLCJlbGVtZW50c0FmdGVyU2Vjb25kQ3V0IiwibWlkZGxlRWxlbWVudHMiLCJNYXRoIiwiYWJzIiwibWlkZGxlRWxlbWVudCIsInZpc2libGUiLCJzY2FsZSIsIm9yaWdpbmFsVW5pdCIsInVuaXQiLCJjb21wYWN0VGltZWxpbmUiLCJlc3RhZG8iLCJ0b2Rvc0VsZW1lbnRvcyIsImVsZW1lbnRvc1BvclRyYWNrIiwiaWR4IiwiZXNwYWNpb3NWYWNpb3MiLCJlbGVtZW50b3MiLCJlbGVtZW50b0FjdHVhbCIsImVsZW1lbnRvU2lndWllbnRlIiwiZXNwYWNpbyIsInN0YXJ0IiwiZW5kIiwic2l6ZSIsImVsZW1lbnRvQW50ZXMiLCJlbGVtZW50b0Rlc3B1ZXMiLCJlc3BhY2lvVG90YWwiLCJhY3R1YWxpemFjaW9uZXMiLCJlbGVtZW50b3NBTW92ZXIiLCJlbGVtZW50byIsImRlc3BsYXphbWllbnRvIiwibnVldm9Gcm9tIiwibnVldm9UbyIsInVwZGF0ZWRTY2FsZSIsImN1cnJlbnRTY2FsZSIsInNtYXJ0VHJpbSIsImRhdGEiLCJqc29uIiwicyIsImVzdGFkb1ByZXZpbyIsImVsZW1lbnRvc1ByZXZpb3MiLCJjb250YWRvclRyYWNrcyIsInRyYWNrSWRQcmluY2lwYWwiLCJ0cmFja3NQb3JVc28iLCJyZXN1bHQiLCJzZWdtZW50b3NFbGltaW5hZG9zIiwiZWxlbWVudG9zQWN0dWFsZXMiLCJzZWdtZW50byIsInNlZ21lbnRvc09yZGVuYWRvcyIsImFkZE11c2ljIiwibXVzaWNQYXRoIiwidm9sdW1lIiwiYXVkaW9QYXlsb2FkIiwiZmFkZUluIiwiZmFkZU91dCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./components/ai-chat/ai-video-commands.ts\n"));

/***/ })

});
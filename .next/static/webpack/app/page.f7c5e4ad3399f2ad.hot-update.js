"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./features/editor/timeline/ruler.tsx":
/*!********************************************!*\
  !*** ./features/editor/timeline/ruler.tsx ***!
  \********************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _constants_constants__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../constants/constants */ \"(app-pages-browser)/./features/editor/constants/constants.ts\");\n/* harmony import */ var _utils_format__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/format */ \"(app-pages-browser)/./features/editor/utils/format.ts\");\n/* harmony import */ var _store_use_store__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../store/use-store */ \"(app-pages-browser)/./features/editor/store/use-store.ts\");\n/* harmony import */ var lodash_debounce__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! lodash/debounce */ \"(app-pages-browser)/./node_modules/lodash/debounce.js\");\n/* harmony import */ var lodash_debounce__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(lodash_debounce__WEBPACK_IMPORTED_MODULE_5__);\n\nvar _s = $RefreshSig$();\n\n\n\n\n\nconst Ruler = (props)=>{\n    _s();\n    const { height = 42, longLineSize = 10, shortLineSize = 6, offsetX = _constants_constants__WEBPACK_IMPORTED_MODULE_2__.TIMELINE_OFFSET_X + _constants_constants__WEBPACK_IMPORTED_MODULE_2__.TIMELINE_OFFSET_CANVAS_LEFT, textOffsetY = 17, textFormat = _utils_format__WEBPACK_IMPORTED_MODULE_3__.formatTimelineUnit, scrollLeft: scrollPos = 0, onClick } = props;\n    const { scale } = (0,_store_use_store__WEBPACK_IMPORTED_MODULE_4__[\"default\"])();\n    const canvasRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const [canvasContext, setCanvasContext] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [canvasSize, setCanvasSize] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)({\n        width: 0,\n        height: height\n    });\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        const canvas = canvasRef.current;\n        if (canvas) {\n            const context = canvas.getContext(\"2d\");\n            setCanvasContext(context);\n            resize(canvas, context, scrollPos);\n        }\n    }, []);\n    const handleResize = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(()=>{\n        resize(canvasRef.current, canvasContext, scrollPos);\n    }, [\n        canvasContext,\n        scrollPos\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        const resizeHandler = lodash_debounce__WEBPACK_IMPORTED_MODULE_5___default()(handleResize, 200);\n        window.addEventListener(\"resize\", resizeHandler);\n        return ()=>{\n            window.removeEventListener(\"resize\", resizeHandler);\n        };\n    }, [\n        handleResize\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (canvasContext) {\n            resize(canvasRef.current, canvasContext, scrollPos);\n        }\n    }, [\n        canvasContext,\n        scrollPos,\n        scale\n    ]);\n    const resize = (canvas, context, scrollPos)=>{\n        if (!canvas || !context) return;\n        const offsetParent = canvas.offsetParent;\n        var _offsetParent_offsetWidth;\n        const width = (_offsetParent_offsetWidth = offsetParent === null || offsetParent === void 0 ? void 0 : offsetParent.offsetWidth) !== null && _offsetParent_offsetWidth !== void 0 ? _offsetParent_offsetWidth : canvas.offsetWidth;\n        const height = canvasSize.height;\n        canvas.width = width;\n        canvas.height = height;\n        draw(context, scrollPos, width, height);\n        setCanvasSize({\n            width,\n            height\n        });\n    };\n    const draw = (context, scrollPos, width, height)=>{\n        const zoom = scale.zoom;\n        const unit = scale.unit;\n        const segments = scale.segments;\n        context.clearRect(0, 0, width, height);\n        context.save();\n        // Dibujar un fondo con gradiente para la regla\n        const gradient = context.createLinearGradient(0, 0, 0, height);\n        gradient.addColorStop(0, \"rgba(45, 25, 75, 0.9)\"); // Púrpura oscuro en la parte superior\n        gradient.addColorStop(1, \"rgba(30, 15, 50, 0.9)\"); // Más oscuro en la parte inferior\n        context.fillStyle = gradient;\n        context.fillRect(0, 0, width, height);\n        // Dibujar una línea de borde brillante en la parte inferior\n        context.beginPath();\n        context.moveTo(0, height - 0.5);\n        context.lineTo(width, height - 0.5);\n        context.strokeStyle = \"rgba(156, 90, 250, 0.6)\"; // Púrpura brillante\n        context.lineWidth = 1;\n        context.stroke();\n        // Configurar estilos de texto\n        context.fillStyle = \"#b388ff\"; // Púrpura claro para el texto\n        context.font = \"\".concat(_constants_constants__WEBPACK_IMPORTED_MODULE_2__.SMALL_FONT_SIZE, \"px \").concat(_constants_constants__WEBPACK_IMPORTED_MODULE_2__.SECONDARY_FONT);\n        context.textBaseline = \"top\";\n        context.textAlign = \"center\"; // Centrar el texto\n        context.translate(0.5, 0);\n        context.beginPath();\n        const zoomUnit = unit * zoom * _constants_constants__WEBPACK_IMPORTED_MODULE_2__.PREVIEW_FRAME_WIDTH;\n        const minRange = Math.floor(scrollPos / zoomUnit);\n        const maxRange = Math.ceil((scrollPos + width) / zoomUnit);\n        const length = maxRange - minRange;\n        // Crear un brillo de fondo para las marcas principales\n        const createHighlight = function(x) {\n            let radius = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 10, alpha = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0.1;\n            const glow = context.createRadialGradient(x, height, 0, x, height, radius);\n            glow.addColorStop(0, \"rgba(156, 90, 250, \".concat(alpha, \")\"));\n            glow.addColorStop(1, \"rgba(156, 90, 250, 0)\");\n            return glow;\n        };\n        // Dibujar texto antes de dibujar las líneas\n        for(let i = 0; i <= length; ++i){\n            const value = i + minRange;\n            if (value < 0) continue;\n            const startValue = value * zoomUnit / zoom;\n            const startPos = (startValue - scrollPos / zoom) * zoom;\n            if (startPos < -zoomUnit || startPos >= width + zoomUnit) continue;\n            const text = textFormat(startValue);\n            const posX = startPos + offsetX;\n            // Dibujar texto sin efecto de sombra/brillo\n            context.fillText(text, posX, textOffsetY);\n        }\n        // Dibujar líneas largas y cortas después del texto\n        for(let i = 0; i <= length; ++i){\n            const value = i + minRange;\n            if (value < 0) continue;\n            const startValue = value * zoomUnit;\n            const startPos = startValue - scrollPos + offsetX;\n            // Dibujar un brillo de fondo para cada marca principal\n            if (value % 2 === 0) {\n                context.fillStyle = createHighlight(startPos, 12, 0.15);\n                context.fillRect(startPos - 12, height - 18, 24, 18);\n            }\n            for(let j = 0; j < segments; ++j){\n                const pos = startPos + j / segments * zoomUnit;\n                if (pos < 0 || pos >= width) continue;\n                const lineSize = j % segments ? shortLineSize : longLineSize;\n                // Establecer color basado en el tamaño de la línea\n                if (lineSize === shortLineSize) {\n                    context.strokeStyle = \"rgba(156, 90, 250, 0.3)\"; // Púrpura claro para líneas cortas\n                } else {\n                    context.strokeStyle = \"rgba(156, 90, 250, 0.7)\"; // Púrpura más brillante para líneas largas\n                }\n                const origin = 24; // Aumentar el origen para empezar las líneas más abajo, debajo del texto\n                const [x1, y1] = [\n                    pos,\n                    origin\n                ];\n                const [x2, y2] = [\n                    x1,\n                    y1 + lineSize\n                ];\n                context.beginPath(); // Comenzar un nuevo camino para cada línea\n                context.lineWidth = lineSize === shortLineSize ? 1 : 1.5; // Líneas más gruesas para marcas principales\n                context.moveTo(x1, y1);\n                context.lineTo(x2, y2);\n                context.stroke(); // Dibujar la línea\n            }\n        }\n        context.restore();\n    };\n    const handleClick = (event)=>{\n        const canvas = canvasRef.current;\n        if (!canvas) return;\n        // Obtener el cuadro delimitador del canvas para calcular la posición relativa del clic\n        const rect = canvas.getBoundingClientRect();\n        const clickX = event.clientX - rect.left;\n        // Calcular la posición x total, incluido scrollPos\n        const totalX = clickX + scrollPos - _constants_constants__WEBPACK_IMPORTED_MODULE_2__.TIMELINE_OFFSET_X - _constants_constants__WEBPACK_IMPORTED_MODULE_2__.TIMELINE_OFFSET_CANVAS_LEFT;\n        onClick === null || onClick === void 0 ? void 0 : onClick(totalX);\n    };\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: \"border-t border-purple-800/30\",\n        style: {\n            position: \"relative\",\n            width: \"100%\",\n            height: \"\".concat(canvasSize.height, \"px\"),\n            boxShadow: \"0 2px 6px rgba(0,0,0,0.2)\"\n        },\n        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"canvas\", {\n            onMouseUp: handleClick,\n            ref: canvasRef,\n            height: canvasSize.height,\n            className: \"cursor-pointer\"\n        }, void 0, false, {\n            fileName: \"C:\\\\Users\\\\david\\\\Desktop\\\\ai-video-agent\\\\react-video-editor\\\\features\\\\editor\\\\timeline\\\\ruler.tsx\",\n            lineNumber: 229,\n            columnNumber: 7\n        }, undefined)\n    }, void 0, false, {\n        fileName: \"C:\\\\Users\\\\david\\\\Desktop\\\\ai-video-agent\\\\react-video-editor\\\\features\\\\editor\\\\timeline\\\\ruler.tsx\",\n        lineNumber: 220,\n        columnNumber: 5\n    }, undefined);\n};\n_s(Ruler, \"aN+WB/8Xd7Skq6vEzJ6ZUc408xA=\", false, function() {\n    return [\n        _store_use_store__WEBPACK_IMPORTED_MODULE_4__[\"default\"]\n    ];\n});\n_c = Ruler;\n/* harmony default export */ __webpack_exports__[\"default\"] = (Ruler);\nvar _c;\n$RefreshReg$(_c, \"Ruler\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2ZlYXR1cmVzL2VkaXRvci90aW1lbGluZS9ydWxlci50c3giLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBaUU7QUFRakM7QUFDcUI7QUFDWDtBQUNSO0FBY2xDLE1BQU1ZLFFBQVEsQ0FBQ0M7O0lBQ2IsTUFBTSxFQUNKQyxTQUFTLEVBQUUsRUFDWEMsZUFBZSxFQUFFLEVBQ2pCQyxnQkFBZ0IsQ0FBQyxFQUNqQkMsVUFBVVQsbUVBQWlCQSxHQUFHRCw2RUFBMkIsRUFDekRXLGNBQWMsRUFBRSxFQUNoQkMsYUFBYVYsNkRBQWtCLEVBQy9CVyxZQUFZQyxZQUFZLENBQUMsRUFDekJDLE9BQU8sRUFDUixHQUFHVDtJQUNKLE1BQU0sRUFBRVUsS0FBSyxFQUFFLEdBQUdiLDREQUFRQTtJQUMxQixNQUFNYyxZQUFZdEIsNkNBQU1BLENBQTJCO0lBQ25ELE1BQU0sQ0FBQ3VCLGVBQWVDLGlCQUFpQixHQUNyQ3ZCLCtDQUFRQSxDQUFrQztJQUM1QyxNQUFNLENBQUN3QixZQUFZQyxjQUFjLEdBQUd6QiwrQ0FBUUEsQ0FBQztRQUMzQzBCLE9BQU87UUFDUGYsUUFBUUE7SUFDVjtJQUVBYixnREFBU0EsQ0FBQztRQUNSLE1BQU02QixTQUFTTixVQUFVTyxPQUFPO1FBQ2hDLElBQUlELFFBQVE7WUFDVixNQUFNRSxVQUFVRixPQUFPRyxVQUFVLENBQUM7WUFDbENQLGlCQUFpQk07WUFDakJFLE9BQU9KLFFBQVFFLFNBQVNYO1FBQzFCO0lBQ0YsR0FBRyxFQUFFO0lBRUwsTUFBTWMsZUFBZW5DLGtEQUFXQSxDQUFDO1FBQy9Ca0MsT0FBT1YsVUFBVU8sT0FBTyxFQUFFTixlQUFlSjtJQUMzQyxHQUFHO1FBQUNJO1FBQWVKO0tBQVU7SUFFN0JwQixnREFBU0EsQ0FBQztRQUNSLE1BQU1tQyxnQkFBZ0J6QixzREFBUUEsQ0FBQ3dCLGNBQWM7UUFDN0NFLE9BQU9DLGdCQUFnQixDQUFDLFVBQVVGO1FBRWxDLE9BQU87WUFDTEMsT0FBT0Us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QUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vZmVhdHVyZXMvZWRpdG9yL3RpbWVsaW5lL3J1bGVyLnRzeD8wNjk0Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHVzZUNhbGxiYWNrLCB1c2VFZmZlY3QsIHVzZVJlZiwgdXNlU3RhdGUgfSBmcm9tIFwicmVhY3RcIjtcblxuaW1wb3J0IHtcbiAgUFJFVklFV19GUkFNRV9XSURUSCxcbiAgU0VDT05EQVJZX0ZPTlQsXG4gIFNNQUxMX0ZPTlRfU0laRSxcbiAgVElNRUxJTkVfT0ZGU0VUX0NBTlZBU19MRUZULFxuICBUSU1FTElORV9PRkZTRVRfWCxcbn0gZnJvbSBcIi4uL2NvbnN0YW50cy9jb25zdGFudHNcIjtcbmltcG9ydCB7IGZvcm1hdFRpbWVsaW5lVW5pdCB9IGZyb20gXCIuLi91dGlscy9mb3JtYXRcIjtcbmltcG9ydCB1c2VTdG9yZSBmcm9tIFwiLi4vc3RvcmUvdXNlLXN0b3JlXCI7XG5pbXBvcnQgeyBkZWJvdW5jZSB9IGZyb20gXCJsb2Rhc2hcIjtcblxuaW50ZXJmYWNlIFJ1bGVyUHJvcHMge1xuICBoZWlnaHQ/OiBudW1iZXI7XG4gIGxvbmdMaW5lU2l6ZT86IG51bWJlcjtcbiAgc2hvcnRMaW5lU2l6ZT86IG51bWJlcjtcbiAgb2Zmc2V0WD86IG51bWJlcjtcbiAgdGV4dE9mZnNldFk/OiBudW1iZXI7XG4gIHNjcm9sbFBvcz86IG51bWJlcjtcbiAgdGV4dEZvcm1hdD86IChzY2FsZTogbnVtYmVyKSA9PiBzdHJpbmc7XG4gIHNjcm9sbExlZnQ/OiBudW1iZXI7XG4gIG9uQ2xpY2s/OiAodW5pdHM6IG51bWJlcikgPT4gdm9pZDtcbn1cblxuY29uc3QgUnVsZXIgPSAocHJvcHM6IFJ1bGVyUHJvcHMpID0+IHtcbiAgY29uc3Qge1xuICAgIGhlaWdodCA9IDQyLCAvLyBJbmNyZW1lbnRhZG8gbGlnZXJhbWVudGUgcGFyYSBtw6FzIGVzcGFjaW9cbiAgICBsb25nTGluZVNpemUgPSAxMCxcbiAgICBzaG9ydExpbmVTaXplID0gNixcbiAgICBvZmZzZXRYID0gVElNRUxJTkVfT0ZGU0VUX1ggKyBUSU1FTElORV9PRkZTRVRfQ0FOVkFTX0xFRlQsXG4gICAgdGV4dE9mZnNldFkgPSAxNywgLy8gUG9zaWNpw7NuIGRlbCB0ZXh0byBzb2JyZSBsYXMgbMOtbmVhc1xuICAgIHRleHRGb3JtYXQgPSBmb3JtYXRUaW1lbGluZVVuaXQsXG4gICAgc2Nyb2xsTGVmdDogc2Nyb2xsUG9zID0gMCxcbiAgICBvbkNsaWNrLFxuICB9ID0gcHJvcHM7XG4gIGNvbnN0IHsgc2NhbGUgfSA9IHVzZVN0b3JlKCk7XG4gIGNvbnN0IGNhbnZhc1JlZiA9IHVzZVJlZjxIVE1MQ2FudmFzRWxlbWVudCB8IG51bGw+KG51bGwpO1xuICBjb25zdCBbY2FudmFzQ29udGV4dCwgc2V0Q2FudmFzQ29udGV4dF0gPVxuICAgIHVzZVN0YXRlPENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCB8IG51bGw+KG51bGwpO1xuICBjb25zdCBbY2FudmFzU2l6ZSwgc2V0Q2FudmFzU2l6ZV0gPSB1c2VTdGF0ZSh7XG4gICAgd2lkdGg6IDAsXG4gICAgaGVpZ2h0OiBoZWlnaHQsXG4gIH0pO1xuXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgY29uc3QgY2FudmFzID0gY2FudmFzUmVmLmN1cnJlbnQ7XG4gICAgaWYgKGNhbnZhcykge1xuICAgICAgY29uc3QgY29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XG4gICAgICBzZXRDYW52YXNDb250ZXh0KGNvbnRleHQpO1xuICAgICAgcmVzaXplKGNhbnZhcywgY29udGV4dCwgc2Nyb2xsUG9zKTtcbiAgICB9XG4gIH0sIFtdKTtcblxuICBjb25zdCBoYW5kbGVSZXNpemUgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgcmVzaXplKGNhbnZhc1JlZi5jdXJyZW50LCBjYW52YXNDb250ZXh0LCBzY3JvbGxQb3MpO1xuICB9LCBbY2FudmFzQ29udGV4dCwgc2Nyb2xsUG9zXSk7XG5cbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCByZXNpemVIYW5kbGVyID0gZGVib3VuY2UoaGFuZGxlUmVzaXplLCAyMDApO1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwicmVzaXplXCIsIHJlc2l6ZUhhbmRsZXIpO1xuXG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwicmVzaXplXCIsIHJlc2l6ZUhhbmRsZXIpO1xuICAgIH07XG4gIH0sIFtoYW5kbGVSZXNpemVdKTtcblxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChjYW52YXNDb250ZXh0KSB7XG4gICAgICByZXNpemUoY2FudmFzUmVmLmN1cnJlbnQsIGNhbnZhc0NvbnRleHQsIHNjcm9sbFBvcyk7XG4gICAgfVxuICB9LCBbY2FudmFzQ29udGV4dCwgc2Nyb2xsUG9zLCBzY2FsZV0pO1xuXG4gIGNvbnN0IHJlc2l6ZSA9IChcbiAgICBjYW52YXM6IEhUTUxDYW52YXNFbGVtZW50IHwgbnVsbCxcbiAgICBjb250ZXh0OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQgfCBudWxsLFxuICAgIHNjcm9sbFBvczogbnVtYmVyLFxuICApID0+IHtcbiAgICBpZiAoIWNhbnZhcyB8fCAhY29udGV4dCkgcmV0dXJuO1xuXG4gICAgY29uc3Qgb2Zmc2V0UGFyZW50ID0gY2FudmFzLm9mZnNldFBhcmVudCBhcyBIVE1MRGl2RWxlbWVudDtcbiAgICBjb25zdCB3aWR0aCA9IG9mZnNldFBhcmVudD8ub2Zmc2V0V2lkdGggPz8gY2FudmFzLm9mZnNldFdpZHRoO1xuICAgIGNvbnN0IGhlaWdodCA9IGNhbnZhc1NpemUuaGVpZ2h0O1xuXG4gICAgY2FudmFzLndpZHRoID0gd2lkdGg7XG4gICAgY2FudmFzLmhlaWdodCA9IGhlaWdodDtcblxuICAgIGRyYXcoY29udGV4dCwgc2Nyb2xsUG9zLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICBzZXRDYW52YXNTaXplKHsgd2lkdGgsIGhlaWdodCB9KTtcbiAgfTtcblxuICBjb25zdCBkcmF3ID0gKFxuICAgIGNvbnRleHQ6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCxcbiAgICBzY3JvbGxQb3M6IG51bWJlcixcbiAgICB3aWR0aDogbnVtYmVyLFxuICAgIGhlaWdodDogbnVtYmVyLFxuICApID0+IHtcbiAgICBjb25zdCB6b29tID0gc2NhbGUuem9vbTtcbiAgICBjb25zdCB1bml0ID0gc2NhbGUudW5pdDtcbiAgICBjb25zdCBzZWdtZW50cyA9IHNjYWxlLnNlZ21lbnRzO1xuICAgIGNvbnRleHQuY2xlYXJSZWN0KDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xuICAgIGNvbnRleHQuc2F2ZSgpO1xuXG4gICAgLy8gRGlidWphciB1biBmb25kbyBjb24gZ3JhZGllbnRlIHBhcmEgbGEgcmVnbGFcbiAgICBjb25zdCBncmFkaWVudCA9IGNvbnRleHQuY3JlYXRlTGluZWFyR3JhZGllbnQoMCwgMCwgMCwgaGVpZ2h0KTtcbiAgICBncmFkaWVudC5hZGRDb2xvclN0b3AoMCwgXCJyZ2JhKDQ1LCAyNSwgNzUsIDAuOSlcIik7IC8vIFDDunJwdXJhIG9zY3VybyBlbiBsYSBwYXJ0ZSBzdXBlcmlvclxuICAgIGdyYWRpZW50LmFkZENvbG9yU3RvcCgxLCBcInJnYmEoMzAsIDE1LCA1MCwgMC45KVwiKTsgLy8gTcOhcyBvc2N1cm8gZW4gbGEgcGFydGUgaW5mZXJpb3JcbiAgICBjb250ZXh0LmZpbGxTdHlsZSA9IGdyYWRpZW50O1xuICAgIGNvbnRleHQuZmlsbFJlY3QoMCwgMCwgd2lkdGgsIGhlaWdodCk7XG5cbiAgICAvLyBEaWJ1amFyIHVuYSBsw61uZWEgZGUgYm9yZGUgYnJpbGxhbnRlIGVuIGxhIHBhcnRlIGluZmVyaW9yXG4gICAgY29udGV4dC5iZWdpblBhdGgoKTtcbiAgICBjb250ZXh0Lm1vdmVUbygwLCBoZWlnaHQgLSAwLjUpO1xuICAgIGNvbnRleHQubGluZVRvKHdpZHRoLCBoZWlnaHQgLSAwLjUpO1xuICAgIGNvbnRleHQuc3Ryb2tlU3R5bGUgPSBcInJnYmEoMTU2LCA5MCwgMjUwLCAwLjYpXCI7IC8vIFDDunJwdXJhIGJyaWxsYW50ZVxuICAgIGNvbnRleHQubGluZVdpZHRoID0gMTtcbiAgICBjb250ZXh0LnN0cm9rZSgpO1xuXG4gICAgLy8gQ29uZmlndXJhciBlc3RpbG9zIGRlIHRleHRvXG4gICAgY29udGV4dC5maWxsU3R5bGUgPSBcIiNiMzg4ZmZcIjsgLy8gUMO6cnB1cmEgY2xhcm8gcGFyYSBlbCB0ZXh0b1xuICAgIGNvbnRleHQuZm9udCA9IGAke1NNQUxMX0ZPTlRfU0laRX1weCAke1NFQ09OREFSWV9GT05UfWA7XG4gICAgY29udGV4dC50ZXh0QmFzZWxpbmUgPSBcInRvcFwiO1xuICAgIGNvbnRleHQudGV4dEFsaWduID0gXCJjZW50ZXJcIjsgLy8gQ2VudHJhciBlbCB0ZXh0b1xuXG4gICAgY29udGV4dC50cmFuc2xhdGUoMC41LCAwKTtcbiAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xuXG4gICAgY29uc3Qgem9vbVVuaXQgPSB1bml0ICogem9vbSAqIFBSRVZJRVdfRlJBTUVfV0lEVEg7XG4gICAgY29uc3QgbWluUmFuZ2UgPSBNYXRoLmZsb29yKHNjcm9sbFBvcyAvIHpvb21Vbml0KTtcbiAgICBjb25zdCBtYXhSYW5nZSA9IE1hdGguY2VpbCgoc2Nyb2xsUG9zICsgd2lkdGgpIC8gem9vbVVuaXQpO1xuICAgIGNvbnN0IGxlbmd0aCA9IG1heFJhbmdlIC0gbWluUmFuZ2U7XG5cbiAgICAvLyBDcmVhciB1biBicmlsbG8gZGUgZm9uZG8gcGFyYSBsYXMgbWFyY2FzIHByaW5jaXBhbGVzXG4gICAgY29uc3QgY3JlYXRlSGlnaGxpZ2h0ID0gKHg6IG51bWJlciwgcmFkaXVzOiBudW1iZXIgPSAxMCwgYWxwaGE6IG51bWJlciA9IDAuMSkgPT4ge1xuICAgICAgY29uc3QgZ2xvdyA9IGNvbnRleHQuY3JlYXRlUmFkaWFsR3JhZGllbnQoeCwgaGVpZ2h0LCAwLCB4LCBoZWlnaHQsIHJhZGl1cyk7XG4gICAgICBnbG93LmFkZENvbG9yU3RvcCgwLCBgcmdiYSgxNTYsIDkwLCAyNTAsICR7YWxwaGF9KWApO1xuICAgICAgZ2xvdy5hZGRDb2xvclN0b3AoMSwgXCJyZ2JhKDE1NiwgOTAsIDI1MCwgMClcIik7XG4gICAgICByZXR1cm4gZ2xvdztcbiAgICB9O1xuXG4gICAgLy8gRGlidWphciB0ZXh0byBhbnRlcyBkZSBkaWJ1amFyIGxhcyBsw61uZWFzXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPD0gbGVuZ3RoOyArK2kpIHtcbiAgICAgIGNvbnN0IHZhbHVlID0gaSArIG1pblJhbmdlO1xuXG4gICAgICBpZiAodmFsdWUgPCAwKSBjb250aW51ZTtcblxuICAgICAgY29uc3Qgc3RhcnRWYWx1ZSA9ICh2YWx1ZSAqIHpvb21Vbml0KSAvIHpvb207XG4gICAgICBjb25zdCBzdGFydFBvcyA9IChzdGFydFZhbHVlIC0gc2Nyb2xsUG9zIC8gem9vbSkgKiB6b29tO1xuXG4gICAgICBpZiAoc3RhcnRQb3MgPCAtem9vbVVuaXQgfHwgc3RhcnRQb3MgPj0gd2lkdGggKyB6b29tVW5pdCkgY29udGludWU7XG5cbiAgICAgIGNvbnN0IHRleHQgPSB0ZXh0Rm9ybWF0KHN0YXJ0VmFsdWUpO1xuICAgICAgY29uc3QgcG9zWCA9IHN0YXJ0UG9zICsgb2Zmc2V0WDtcblxuICAgICAgLy8gRGlidWphciB0ZXh0byBzaW4gZWZlY3RvIGRlIHNvbWJyYS9icmlsbG9cbiAgICAgIGNvbnRleHQuZmlsbFRleHQodGV4dCwgcG9zWCwgdGV4dE9mZnNldFkpO1xuICAgIH1cblxuICAgIC8vIERpYnVqYXIgbMOtbmVhcyBsYXJnYXMgeSBjb3J0YXMgZGVzcHXDqXMgZGVsIHRleHRvXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPD0gbGVuZ3RoOyArK2kpIHtcbiAgICAgIGNvbnN0IHZhbHVlID0gaSArIG1pblJhbmdlO1xuXG4gICAgICBpZiAodmFsdWUgPCAwKSBjb250aW51ZTtcblxuICAgICAgY29uc3Qgc3RhcnRWYWx1ZSA9IHZhbHVlICogem9vbVVuaXQ7XG4gICAgICBjb25zdCBzdGFydFBvcyA9IHN0YXJ0VmFsdWUgLSBzY3JvbGxQb3MgKyBvZmZzZXRYO1xuXG4gICAgICAvLyBEaWJ1amFyIHVuIGJyaWxsbyBkZSBmb25kbyBwYXJhIGNhZGEgbWFyY2EgcHJpbmNpcGFsXG4gICAgICBpZiAodmFsdWUgJSAyID09PSAwKSB7XG4gICAgICAgIGNvbnRleHQuZmlsbFN0eWxlID0gY3JlYXRlSGlnaGxpZ2h0KHN0YXJ0UG9zLCAxMiwgMC4xNSk7XG4gICAgICAgIGNvbnRleHQuZmlsbFJlY3Qoc3RhcnRQb3MgLSAxMiwgaGVpZ2h0IC0gMTgsIDI0LCAxOCk7XG4gICAgICB9XG5cbiAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgc2VnbWVudHM7ICsraikge1xuICAgICAgICBjb25zdCBwb3MgPSBzdGFydFBvcyArIChqIC8gc2VnbWVudHMpICogem9vbVVuaXQ7XG5cbiAgICAgICAgaWYgKHBvcyA8IDAgfHwgcG9zID49IHdpZHRoKSBjb250aW51ZTtcblxuICAgICAgICBjb25zdCBsaW5lU2l6ZSA9IGogJSBzZWdtZW50cyA/IHNob3J0TGluZVNpemUgOiBsb25nTGluZVNpemU7XG5cbiAgICAgICAgLy8gRXN0YWJsZWNlciBjb2xvciBiYXNhZG8gZW4gZWwgdGFtYcOxbyBkZSBsYSBsw61uZWFcbiAgICAgICAgaWYgKGxpbmVTaXplID09PSBzaG9ydExpbmVTaXplKSB7XG4gICAgICAgICAgY29udGV4dC5zdHJva2VTdHlsZSA9IFwicmdiYSgxNTYsIDkwLCAyNTAsIDAuMylcIjsgLy8gUMO6cnB1cmEgY2xhcm8gcGFyYSBsw61uZWFzIGNvcnRhc1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnRleHQuc3Ryb2tlU3R5bGUgPSBcInJnYmEoMTU2LCA5MCwgMjUwLCAwLjcpXCI7IC8vIFDDunJwdXJhIG3DoXMgYnJpbGxhbnRlIHBhcmEgbMOtbmVhcyBsYXJnYXNcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IG9yaWdpbiA9IDI0OyAvLyBBdW1lbnRhciBlbCBvcmlnZW4gcGFyYSBlbXBlemFyIGxhcyBsw61uZWFzIG3DoXMgYWJham8sIGRlYmFqbyBkZWwgdGV4dG9cblxuICAgICAgICBjb25zdCBbeDEsIHkxXSA9IFtwb3MsIG9yaWdpbl07XG4gICAgICAgIGNvbnN0IFt4MiwgeTJdID0gW3gxLCB5MSArIGxpbmVTaXplXTtcblxuICAgICAgICBjb250ZXh0LmJlZ2luUGF0aCgpOyAvLyBDb21lbnphciB1biBudWV2byBjYW1pbm8gcGFyYSBjYWRhIGzDrW5lYVxuICAgICAgICBjb250ZXh0LmxpbmVXaWR0aCA9IGxpbmVTaXplID09PSBzaG9ydExpbmVTaXplID8gMSA6IDEuNTsgLy8gTMOtbmVhcyBtw6FzIGdydWVzYXMgcGFyYSBtYXJjYXMgcHJpbmNpcGFsZXNcbiAgICAgICAgY29udGV4dC5tb3ZlVG8oeDEsIHkxKTtcbiAgICAgICAgY29udGV4dC5saW5lVG8oeDIsIHkyKTtcbiAgICAgICAgY29udGV4dC5zdHJva2UoKTsgLy8gRGlidWphciBsYSBsw61uZWFcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb250ZXh0LnJlc3RvcmUoKTtcbiAgfTtcblxuICBjb25zdCBoYW5kbGVDbGljayA9IChldmVudDogUmVhY3QuTW91c2VFdmVudDxIVE1MQ2FudmFzRWxlbWVudD4pID0+IHtcbiAgICBjb25zdCBjYW52YXMgPSBjYW52YXNSZWYuY3VycmVudDtcbiAgICBpZiAoIWNhbnZhcykgcmV0dXJuO1xuXG4gICAgLy8gT2J0ZW5lciBlbCBjdWFkcm8gZGVsaW1pdGFkb3IgZGVsIGNhbnZhcyBwYXJhIGNhbGN1bGFyIGxhIHBvc2ljacOzbiByZWxhdGl2YSBkZWwgY2xpY1xuICAgIGNvbnN0IHJlY3QgPSBjYW52YXMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgY29uc3QgY2xpY2tYID0gZXZlbnQuY2xpZW50WCAtIHJlY3QubGVmdDtcblxuICAgIC8vIENhbGN1bGFyIGxhIHBvc2ljacOzbiB4IHRvdGFsLCBpbmNsdWlkbyBzY3JvbGxQb3NcbiAgICBjb25zdCB0b3RhbFggPVxuICAgICAgY2xpY2tYICsgc2Nyb2xsUG9zIC0gVElNRUxJTkVfT0ZGU0VUX1ggLSBUSU1FTElORV9PRkZTRVRfQ0FOVkFTX0xFRlQ7XG5cbiAgICBvbkNsaWNrPy4odG90YWxYKTtcbiAgfTtcblxuICByZXR1cm4gKFxuICAgIDxkaXZcbiAgICAgIGNsYXNzTmFtZT1cImJvcmRlci10IGJvcmRlci1wdXJwbGUtODAwLzMwXCJcbiAgICAgIHN0eWxlPXt7XG4gICAgICAgIHBvc2l0aW9uOiBcInJlbGF0aXZlXCIsXG4gICAgICAgIHdpZHRoOiBcIjEwMCVcIixcbiAgICAgICAgaGVpZ2h0OiBgJHtjYW52YXNTaXplLmhlaWdodH1weGAsXG4gICAgICAgIGJveFNoYWRvdzogXCIwIDJweCA2cHggcmdiYSgwLDAsMCwwLjIpXCIsXG4gICAgICB9fVxuICAgID5cbiAgICAgIDxjYW52YXNcbiAgICAgICAgb25Nb3VzZVVwPXtoYW5kbGVDbGlja31cbiAgICAgICAgcmVmPXtjYW52YXNSZWZ9XG4gICAgICAgIGhlaWdodD17Y2FudmFzU2l6ZS5oZWlnaHR9XG4gICAgICAgIGNsYXNzTmFtZT1cImN1cnNvci1wb2ludGVyXCJcbiAgICAgIC8+XG4gICAgPC9kaXY+XG4gICk7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBSdWxlcjtcbiJdLCJuYW1lcyI6WyJ1c2VDYWxsYmFjayIsInVzZUVmZmVjdCIsInVzZVJlZiIsInVzZVN0YXRlIiwiUFJFVklFV19GUkFNRV9XSURUSCIsIlNFQ09OREFSWV9GT05UIiwiU01BTExfRk9OVF9TSVpFIiwiVElNRUxJTkVfT0ZGU0VUX0NBTlZBU19MRUZUIiwiVElNRUxJTkVfT0ZGU0VUX1giLCJmb3JtYXRUaW1lbGluZVVuaXQiLCJ1c2VTdG9yZSIsImRlYm91bmNlIiwiUnVsZXIiLCJwcm9wcyIsImhlaWdodCIsImxvbmdMaW5lU2l6ZSIsInNob3J0TGluZVNpemUiLCJvZmZzZXRYIiwidGV4dE9mZnNldFkiLCJ0ZXh0Rm9ybWF0Iiwic2Nyb2xsTGVmdCIsInNjcm9sbFBvcyIsIm9uQ2xpY2siLCJzY2FsZSIsImNhbnZhc1JlZiIsImNhbnZhc0NvbnRleHQiLCJzZXRDYW52YXNDb250ZXh0IiwiY2FudmFzU2l6ZSIsInNldENhbnZhc1NpemUiLCJ3aWR0aCIsImNhbnZhcyIsImN1cnJlbnQiLCJjb250ZXh0IiwiZ2V0Q29udGV4dCIsInJlc2l6ZSIsImhhbmRsZVJlc2l6ZSIsInJlc2l6ZUhhbmRsZXIiLCJ3aW5kb3ciLCJhZGRFdmVudExpc3RlbmVyIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsIm9mZnNldFBhcmVudCIsIm9mZnNldFdpZHRoIiwiZHJhdyIsInpvb20iLCJ1bml0Iiwic2VnbWVudHMiLCJjbGVhclJlY3QiLCJzYXZlIiwiZ3JhZGllbnQiLCJjcmVhdGVMaW5lYXJHcmFkaWVudCIsImFkZENvbG9yU3RvcCIsImZpbGxTdHlsZSIsImZpbGxSZWN0IiwiYmVnaW5QYXRoIiwibW92ZVRvIiwibGluZVRvIiwic3Ryb2tlU3R5bGUiLCJsaW5lV2lkdGgiLCJzdHJva2UiLCJmb250IiwidGV4dEJhc2VsaW5lIiwidGV4dEFsaWduIiwidHJhbnNsYXRlIiwiem9vbVVuaXQiLCJtaW5SYW5nZSIsIk1hdGgiLCJmbG9vciIsIm1heFJhbmdlIiwiY2VpbCIsImxlbmd0aCIsImNyZWF0ZUhpZ2hsaWdodCIsIngiLCJyYWRpdXMiLCJhbHBoYSIsImdsb3ciLCJjcmVhdGVSYWRpYWxHcmFkaWVudCIsImkiLCJ2YWx1ZSIsInN0YXJ0VmFsdWUiLCJzdGFydFBvcyIsInRleHQiLCJwb3NYIiwiZmlsbFRleHQiLCJqIiwicG9zIiwibGluZVNpemUiLCJvcmlnaW4iLCJ4MSIsInkxIiwieDIiLCJ5MiIsInJlc3RvcmUiLCJoYW5kbGVDbGljayIsImV2ZW50IiwicmVjdCIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsImNsaWNrWCIsImNsaWVudFgiLCJsZWZ0IiwidG90YWxYIiwiZGl2IiwiY2xhc3NOYW1lIiwic3R5bGUiLCJwb3NpdGlvbiIsImJveFNoYWRvdyIsIm9uTW91c2VVcCIsInJlZiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./features/editor/timeline/ruler.tsx\n"));

/***/ })

});
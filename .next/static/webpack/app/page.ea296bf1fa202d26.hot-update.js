"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./features/editor/services/ai-service.ts":
/*!************************************************!*\
  !*** ./features/editor/services/ai-service.ts ***!
  \************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AIService: function() { return /* binding */ AIService; }\n/* harmony export */ });\n/**\r\n * Servicio para manejar la comunicación con la IA.\r\n * Esta es una implementación base que simula respuestas.\r\n * En el futuro, se conectará con una API real.\r\n */ class AIService {\n    /**\r\n   * Analiza los elementos seleccionados para buscar URLs\r\n   */ static async analyzeItems(request) {\n        try {\n            // Simulamos un tiempo de respuesta de la API\n            await new Promise((resolve)=>setTimeout(resolve, 1000));\n            console.log(\"AI Service - Request:\", request);\n            // Extraer el texto relevante de los elementos seleccionados\n            const elementsText = this.extractTextFromElements(request.items);\n            // Mensaje explícito o texto extraído de los elementos\n            const textToAnalyze = request.message || elementsText;\n            // Analizar si el texto contiene URLs\n            const urlAnalysis = this.detectURLs(textToAnalyze);\n            // Si hay URLs, obtener capturas de pantalla\n            if (urlAnalysis.containsURLs && urlAnalysis.urls.length > 0) {\n                urlAnalysis.screenshots = await this.fetchScreenshotsForUrls(urlAnalysis.urls);\n            }\n            // Simulación de respuesta de la IA\n            // En un entorno real, esto enviaría la solicitud a un endpoint de API\n            return {\n                success: true,\n                message: \"An\\xe1lisis completado con \\xe9xito\",\n                analysis: {\n                    summary: this.generateURLAnalysisSummary(urlAnalysis, request.items.length),\n                    urlAnalysis: urlAnalysis,\n                    itemsAnalyzed: request.items.length,\n                    analyzedText: textToAnalyze,\n                    recommendations: this.generateRecommendations(urlAnalysis),\n                    confidence: 0.95\n                }\n            };\n        } catch (error) {\n            console.error(\"Error in AI service:\", error);\n            return {\n                success: false,\n                message: \"Error al procesar la solicitud\",\n                error: error instanceof Error ? error.message : String(error)\n            };\n        }\n    }\n    /**\r\n   * Extrae texto de los elementos seleccionados\r\n   */ static extractTextFromElements(items) {\n        // Aquí extraemos el texto de los elementos seleccionados\n        // En un caso real, esto dependería de la estructura de tus elementos\n        let extractedText = \"\";\n        for (const item of items){\n            var _item_details, _item_details1, _item_details2;\n            // Intentar extraer texto de diferentes propiedades comunes\n            // Esto es un ejemplo y debería adaptarse a tu estructura de datos real\n            if (item.text) {\n                extractedText += \" \" + item.text;\n            } else if ((_item_details = item.details) === null || _item_details === void 0 ? void 0 : _item_details.text) {\n                extractedText += \" \" + item.details.text;\n            } else if (item.name) {\n                extractedText += \" \" + item.name;\n            } else if (item.title) {\n                extractedText += \" \" + item.title;\n            } else if (item.description) {\n                extractedText += \" \" + item.description;\n            } else if ((_item_details1 = item.details) === null || _item_details1 === void 0 ? void 0 : _item_details1.description) {\n                extractedText += \" \" + item.details.description;\n            } else if ((_item_details2 = item.details) === null || _item_details2 === void 0 ? void 0 : _item_details2.src) {\n                extractedText += \" \" + item.details.src;\n            } else if (item.src) {\n                extractedText += \" \" + item.src;\n            } else if (item.content) {\n                extractedText += \" \" + item.content;\n            } else if (item.label) {\n                extractedText += \" \" + item.label;\n            } else if (item.value) {\n                extractedText += \" \" + item.value;\n            } else if (typeof item === \"string\") {\n                extractedText += \" \" + item;\n            }\n            // También podemos buscar en atributos anidados\n            if (item.props && typeof item.props === \"object\") {\n                for(const key in item.props){\n                    if (typeof item.props[key] === \"string\") {\n                        extractedText += \" \" + item.props[key];\n                    }\n                }\n            }\n            // Si todavía no hemos encontrado texto, intentamos convertir el objeto a string\n            if (extractedText.trim() === \"\" && item.toString) {\n                const str = item.toString();\n                if (str !== \"[object Object]\") {\n                    extractedText += \" \" + str;\n                }\n            }\n        }\n        return extractedText.trim();\n    }\n    /**\r\n   * Detecta URLs en un texto\r\n   */ static detectURLs(text) {\n        // Expresión regular mejorada para capturar una variedad más amplia de URLs\n        // Esta regex busca URLs con diversos dominios de nivel superior (.com, .org, .ai, etc.)\n        const urlRegex = /(?:https?:\\/\\/)?(?:www\\.)?[-a-zA-Z0-9@:%._\\+~#=]{1,256}\\.[a-zA-Z0-9()]{1,6}\\b(?:[-a-zA-Z0-9()@:%_\\+.~#?&//=]*)/gi;\n        const matches = text.match(urlRegex) || [];\n        // Filtrar posibles falsos positivos (como números de versión: 1.0, etc.)\n        const validUrls = matches.filter((url)=>{\n            // Verificar que el dominio tenga al menos un punto y caracteres alfanuméricos\n            const domainParts = url.split(\".\");\n            // Debe tener al menos un punto y el TLD debe tener al menos 2 caracteres\n            return domainParts.length >= 2 && domainParts[domainParts.length - 1].length >= 2;\n        });\n        return {\n            containsURLs: validUrls.length > 0,\n            urls: validUrls\n        };\n    }\n    /**\r\n   * Obtiene capturas de pantalla para las URLs proporcionadas\r\n   * Utiliza servicios de captura de pantalla de terceros\r\n   */ static async fetchScreenshotsForUrls(urls) {\n        const screenshots = [];\n        // Procesar cada URL en paralelo\n        const screenshotPromises = urls.map(async (url)=>{\n            try {\n                // Usar nuestro propio endpoint de API para obtener la captura\n                const response = await fetch(\"/api/screenshot\", {\n                    method: \"POST\",\n                    headers: {\n                        \"Content-Type\": \"application/json\"\n                    },\n                    body: JSON.stringify({\n                        url\n                    }),\n                    // Timeout para evitar esperas demasiado largas\n                    signal: AbortSignal.timeout(10000) // 10 segundos máximo\n                });\n                if (!response.ok) {\n                    throw new Error(\"Error en la solicitud de captura: \".concat(response.status, \" \").concat(response.statusText));\n                }\n                const data = await response.json();\n                if (data.success) {\n                    return {\n                        url: url,\n                        screenshotUrl: data.screenshotUrl\n                    };\n                } else {\n                    throw new Error(data.error || \"Error desconocido al obtener la captura\");\n                }\n            } catch (error) {\n                console.error(\"Error al obtener captura para \".concat(url, \":\"), error);\n                return {\n                    url: url,\n                    error: error instanceof Error ? error.message : \"Error al generar la captura\"\n                };\n            }\n        });\n        // Esperar a que todas las capturas se completen\n        const results = await Promise.all(screenshotPromises);\n        return results;\n    }\n    /**\r\n   * Genera un resumen basado en el análisis de URLs\r\n   */ static generateURLAnalysisSummary(analysis, itemCount) {\n        if (analysis.containsURLs) {\n            const urlCount = analysis.urls.length;\n            return \"He analizado el contenido de \".concat(itemCount, \" elemento\").concat(itemCount !== 1 ? \"s\" : \"\", \" y encontrado \").concat(urlCount, \" URL\").concat(urlCount !== 1 ? \"s\" : \"\", \".\");\n        } else {\n            return \"He analizado el contenido de \".concat(itemCount, \" elemento\").concat(itemCount !== 1 ? \"s\" : \"\", \" y no he encontrado ninguna URL.\");\n        }\n    }\n    /**\r\n   * Genera recomendaciones basadas en el análisis de URLs\r\n   */ static generateRecommendations(analysis) {\n        if (analysis.containsURLs) {\n            return [\n                \"Considere verificar si las URLs son seguras antes de utilizarlas.\",\n                \"Aseg\\xfarese de que las URLs est\\xe9n activas y funcionen correctamente.\",\n                \"Considere revisar si los enlaces apuntan a los recursos deseados.\"\n            ];\n        } else {\n            return [\n                \"El contenido no contiene URLs. Si necesita incluir referencias web, considere a\\xf1adirlas.\",\n                \"Puede a\\xf1adir enlaces a recursos adicionales para enriquecer el contenido.\"\n            ];\n        }\n    }\n}\n/* harmony default export */ __webpack_exports__[\"default\"] = (AIService);\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2ZlYXR1cmVzL2VkaXRvci9zZXJ2aWNlcy9haS1zZXJ2aWNlLnRzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTs7OztDQUlDLEdBMkJNLE1BQU1BO0lBQ1g7O0dBRUMsR0FDRCxhQUFvQkMsYUFBYUMsT0FBMEIsRUFBK0I7UUFDeEYsSUFBSTtZQUNGLDZDQUE2QztZQUM3QyxNQUFNLElBQUlDLFFBQVFDLENBQUFBLFVBQVdDLFdBQVdELFNBQVM7WUFFakRFLFFBQVFDLEdBQUcsQ0FBQyx5QkFBeUJMO1lBRXJDLDREQUE0RDtZQUM1RCxNQUFNTSxlQUFlLElBQUksQ0FBQ0MsdUJBQXVCLENBQUNQLFFBQVFRLEtBQUs7WUFFL0Qsc0RBQXNEO1lBQ3RELE1BQU1DLGdCQUFnQlQsUUFBUVUsT0FBTyxJQUFJSjtZQUV6QyxxQ0FBcUM7WUFDckMsTUFBTUssY0FBYyxJQUFJLENBQUNDLFVBQVUsQ0FBQ0g7WUFFcEMsNENBQTRDO1lBQzVDLElBQUlFLFlBQVlFLFlBQVksSUFBSUYsWUFBWUcsSUFBSSxDQUFDQyxNQUFNLEdBQUcsR0FBRztnQkFDM0RKLFlBQVlLLFdBQVcsR0FBRyxNQUFNLElBQUksQ0FBQ0MsdUJBQXVCLENBQUNOLFlBQVlHLElBQUk7WUFDL0U7WUFFQSxtQ0FBbUM7WUFDbkMsc0VBQXNFO1lBQ3RFLE9BQU87Z0JBQ0xJLFNBQVM7Z0JBQ1RSLFNBQVM7Z0JBQ1RTLFVBQVU7b0JBQ1JDLFNBQVMsSUFBSSxDQUFDQywwQkFBMEIsQ0FBQ1YsYUFBYVgsUUFBUVEsS0FBSyxDQUFDTyxNQUFNO29CQUMxRUosYUFBYUE7b0JBQ2JXLGVBQWV0QixRQUFRUSxLQUFLLENBQUNPLE1BQU07b0JBQ25DUSxjQUFjZDtvQkFDZGUsaUJBQWlCLElBQUksQ0FBQ0MsdUJBQXVCLENBQUNkO29CQUM5Q2UsWUFBWTtnQkFDZDtZQUNGO1FBQ0YsRUFBRSxPQUFPQyxPQUFPO1lBQ2R2QixRQUFRdUIsS0FBSyxDQUFDLHdCQUF3QkE7WUFDdEMsT0FBTztnQkFDTFQsU0FBUztnQkFDVFIsU0FBUztnQkFDVGlCLE9BQU9BLGlCQUFpQkMsUUFBUUQsTUFBTWpCLE9BQU8sR0FBR21CLE9BQU9GO1lBQ3pEO1FBQ0Y7SUFDRjtJQUVBOztHQUVDLEdBQ0QsT0FBZXBCLHdCQUF3QkMsS0FBWSxFQUFVO1FBQzNELHlEQUF5RDtRQUN6RCxxRUFBcUU7UUFDckUsSUFBSXNCLGdCQUFnQjtRQUVwQixLQUFLLE1BQU1DLFFBQVF2QixNQUFPO2dCQUtidUIsZUFRQUEsZ0JBRUFBO1lBZFgsMkRBQTJEO1lBQzNELHVFQUF1RTtZQUN2RSxJQUFJQSxLQUFLQyxJQUFJLEVBQUU7Z0JBQ2JGLGlCQUFpQixNQUFNQyxLQUFLQyxJQUFJO1lBQ2xDLE9BQU8sS0FBSUQsZ0JBQUFBLEtBQUtFLE9BQU8sY0FBWkYsb0NBQUFBLGNBQWNDLElBQUksRUFBRTtnQkFDN0JGLGlCQUFpQixNQUFNQyxLQUFLRSxPQUFPLENBQUNELElBQUk7WUFDMUMsT0FBTyxJQUFJRCxLQUFLRyxJQUFJLEVBQUU7Z0JBQ3BCSixpQkFBaUIsTUFBTUMsS0FBS0csSUFBSTtZQUNsQyxPQUFPLElBQUlILEtBQUtJLEtBQUssRUFBRTtnQkFDckJMLGlCQUFpQixNQUFNQyxLQUFLSSxLQUFLO1lBQ25DLE9BQU8sSUFBSUosS0FBS0ssV0FBVyxFQUFFO2dCQUMzQk4saUJBQWlCLE1BQU1DLEtBQUtLLFdBQVc7WUFDekMsT0FBTyxLQUFJTCxpQkFBQUEsS0FBS0UsT0FBTyxjQUFaRixxQ0FBQUEsZUFBY0ssV0FBVyxFQUFFO2dCQUNwQ04saUJBQWlCLE1BQU1DLEtBQUtFLE9BQU8sQ0FBQ0csV0FBVztZQUNqRCxPQUFPLEtBQUlMLGlCQUFBQSxLQUFLRSxPQUFPLGNBQVpGLHFDQUFBQSxlQUFjTSxHQUFHLEVBQUU7Z0JBQzVCUCxpQkFBaUIsTUFBTUMsS0FBS0UsT0FBTyxDQUFDSSxHQUFHO1lBQ3pDLE9BQU8sSUFBSU4sS0FBS00sR0FBRyxFQUFFO2dCQUNuQlAsaUJBQWlCLE1BQU1DLEtBQUtNLEdBQUc7WUFDakMsT0FBTyxJQUFJTixLQUFLTyxPQUFPLEVBQUU7Z0JBQ3ZCUixpQkFBaUIsTUFBTUMsS0FBS08sT0FBTztZQUNyQyxPQUFPLElBQUlQLEtBQUtRLEtBQUssRUFBRTtnQkFDckJULGlCQUFpQixNQUFNQyxLQUFLUSxLQUFLO1lBQ25DLE9BQU8sSUFBSVIsS0FBS1MsS0FBSyxFQUFFO2dCQUNyQlYsaUJBQWlCLE1BQU1DLEtBQUtTLEtBQUs7WUFDbkMsT0FBTyxJQUFJLE9BQU9ULFNBQVMsVUFBVTtnQkFDbkNELGlCQUFpQixNQUFNQztZQUN6QjtZQUVBLCtDQUErQztZQUMvQyxJQUFJQSxLQUFLVSxLQUFLLElBQUksT0FBT1YsS0FBS1UsS0FBSyxLQUFLLFVBQVU7Z0JBQ2hELElBQUssTUFBTUMsT0FBT1gsS0FBS1UsS0FBSyxDQUFFO29CQUM1QixJQUFJLE9BQU9WLEtBQUtVLEtBQUssQ0FBQ0MsSUFBSSxLQUFLLFVBQVU7d0JBQ3ZDWixpQkFBaUIsTUFBTUMsS0FBS1UsS0FBSyxDQUFDQyxJQUFJO29CQUN4QztnQkFDRjtZQUNGO1lBRUEsZ0ZBQWdGO1lBQ2hGLElBQUlaLGNBQWNhLElBQUksT0FBTyxNQUFNWixLQUFLYSxRQUFRLEVBQUU7Z0JBQ2hELE1BQU1DLE1BQU1kLEtBQUthLFFBQVE7Z0JBQ3pCLElBQUlDLFFBQVEsbUJBQW1CO29CQUM3QmYsaUJBQWlCLE1BQU1lO2dCQUN6QjtZQUNGO1FBQ0Y7UUFFQSxPQUFPZixjQUFjYSxJQUFJO0lBQzNCO0lBRUE7O0dBRUMsR0FDRCxPQUFlL0IsV0FBV29CLElBQVksRUFBcUI7UUFDekQsMkVBQTJFO1FBQzNFLHdGQUF3RjtRQUN4RixNQUFNYyxXQUFXO1FBRWpCLE1BQU1DLFVBQVVmLEtBQUtnQixLQUFLLENBQUNGLGFBQWEsRUFBRTtRQUUxQyx5RUFBeUU7UUFDekUsTUFBTUcsWUFBWUYsUUFBUUcsTUFBTSxDQUFDQyxDQUFBQTtZQUMvQiw4RUFBOEU7WUFDOUUsTUFBTUMsY0FBY0QsSUFBSUUsS0FBSyxDQUFDO1lBQzlCLHlFQUF5RTtZQUN6RSxPQUFPRCxZQUFZckMsTUFBTSxJQUFJLEtBQUtxQyxXQUFXLENBQUNBLFlBQVlyQyxNQUFNLEdBQUcsRUFBRSxDQUFDQSxNQUFNLElBQUk7UUFDbEY7UUFFQSxPQUFPO1lBQ0xGLGNBQWNvQyxVQUFVbEMsTUFBTSxHQUFHO1lBQ2pDRCxNQUFNbUM7UUFDUjtJQUNGO0lBRUE7OztHQUdDLEdBQ0QsYUFBcUJoQyx3QkFBd0JILElBQWMsRUFBZ0M7UUFDekYsTUFBTUUsY0FBbUMsRUFBRTtRQUUzQyxnQ0FBZ0M7UUFDaEMsTUFBTXNDLHFCQUFxQnhDLEtBQUt5QyxHQUFHLENBQUMsT0FBT0o7WUFDekMsSUFBSTtnQkFDRiw4REFBOEQ7Z0JBQzlELE1BQU1LLFdBQVcsTUFBTUMsTUFBTSxtQkFBbUI7b0JBQzlDQyxRQUFRO29CQUNSQyxTQUFTO3dCQUNQLGdCQUFnQjtvQkFDbEI7b0JBQ0FDLE1BQU1DLEtBQUtDLFNBQVMsQ0FBQzt3QkFBRVg7b0JBQUk7b0JBQzNCLCtDQUErQztvQkFDL0NZLFFBQVFDLFlBQVlDLE9BQU8sQ0FBQyxPQUFPLHFCQUFxQjtnQkFDMUQ7Z0JBRUEsSUFBSSxDQUFDVCxTQUFTVSxFQUFFLEVBQUU7b0JBQ2hCLE1BQU0sSUFBSXRDLE1BQU0scUNBQXdENEIsT0FBbkJBLFNBQVNXLE1BQU0sRUFBQyxLQUF1QixPQUFwQlgsU0FBU1ksVUFBVTtnQkFDN0Y7Z0JBRUEsTUFBTUMsT0FBTyxNQUFNYixTQUFTYyxJQUFJO2dCQUVoQyxJQUFJRCxLQUFLbkQsT0FBTyxFQUFFO29CQUNoQixPQUFPO3dCQUNMaUMsS0FBS0E7d0JBQ0xvQixlQUFlRixLQUFLRSxhQUFhO29CQUNuQztnQkFDRixPQUFPO29CQUNMLE1BQU0sSUFBSTNDLE1BQU15QyxLQUFLMUMsS0FBSyxJQUFJO2dCQUNoQztZQUNGLEVBQUUsT0FBT0EsT0FBTztnQkFDZHZCLFFBQVF1QixLQUFLLENBQUMsaUNBQXFDLE9BQUp3QixLQUFJLE1BQUl4QjtnQkFDdkQsT0FBTztvQkFDTHdCLEtBQUtBO29CQUNMeEIsT0FBT0EsaUJBQWlCQyxRQUFRRCxNQUFNakIsT0FBTyxHQUFHO2dCQUNsRDtZQUNGO1FBQ0Y7UUFFQSxnREFBZ0Q7UUFDaEQsTUFBTThELFVBQVUsTUFBTXZFLFFBQVF3RSxHQUFHLENBQUNuQjtRQUNsQyxPQUFPa0I7SUFDVDtJQUVBOztHQUVDLEdBQ0QsT0FBZW5ELDJCQUEyQkYsUUFBMkIsRUFBRXVELFNBQWlCLEVBQVU7UUFDaEcsSUFBSXZELFNBQVNOLFlBQVksRUFBRTtZQUN6QixNQUFNOEQsV0FBV3hELFNBQVNMLElBQUksQ0FBQ0MsTUFBTTtZQUNyQyxPQUFPLGdDQUFxRDJELE9BQXJCQSxXQUFVLGFBQXNEQyxPQUEzQ0QsY0FBYyxJQUFJLE1BQU0sSUFBRyxrQkFBK0JDLE9BQWZBLFVBQVMsUUFBZ0MsT0FBMUJBLGFBQWEsSUFBSSxNQUFNLElBQUc7UUFDbEosT0FBTztZQUNMLE9BQU8sZ0NBQXFERCxPQUFyQkEsV0FBVSxhQUFzQyxPQUEzQkEsY0FBYyxJQUFJLE1BQU0sSUFBRztRQUN6RjtJQUNGO0lBRUE7O0dBRUMsR0FDRCxPQUFlakQsd0JBQXdCTixRQUEyQixFQUFZO1FBQzVFLElBQUlBLFNBQVNOLFlBQVksRUFBRTtZQUN6QixPQUFPO2dCQUNMO2dCQUNBO2dCQUNBO2FBQ0Q7UUFDSCxPQUFPO1lBQ0wsT0FBTztnQkFDTDtnQkFDQTthQUNEO1FBQ0g7SUFDRjtBQUNGO0FBRUEsK0RBQWVmLFNBQVNBLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vZmVhdHVyZXMvZWRpdG9yL3NlcnZpY2VzL2FpLXNlcnZpY2UudHM/MGFlMiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcclxuICogU2VydmljaW8gcGFyYSBtYW5lamFyIGxhIGNvbXVuaWNhY2nDs24gY29uIGxhIElBLlxyXG4gKiBFc3RhIGVzIHVuYSBpbXBsZW1lbnRhY2nDs24gYmFzZSBxdWUgc2ltdWxhIHJlc3B1ZXN0YXMuXHJcbiAqIEVuIGVsIGZ1dHVybywgc2UgY29uZWN0YXLDoSBjb24gdW5hIEFQSSByZWFsLlxyXG4gKi9cclxuXHJcbmludGVyZmFjZSBBSUFuYWx5c2lzUmVxdWVzdCB7XHJcbiAgbWVzc2FnZT86IHN0cmluZztcclxuICBpdGVtczogYW55W107IC8vIExvcyBlbGVtZW50b3Mgc2VsZWNjaW9uYWRvcyBlbiBsYSB0aW1lbGluZVxyXG4gIGNvbnRleHQ/OiBhbnk7IC8vIEluZm9ybWFjacOzbiBkZSBjb250ZXh0byBhZGljaW9uYWxcclxufVxyXG5cclxuaW50ZXJmYWNlIEFJQW5hbHlzaXNSZXNwb25zZSB7XHJcbiAgc3VjY2VzczogYm9vbGVhbjtcclxuICBtZXNzYWdlOiBzdHJpbmc7XHJcbiAgYW5hbHlzaXM/OiBhbnk7IC8vIEFuw6FsaXNpcyBkZXRhbGxhZG8gZGUgbGEgSUFcclxuICBlcnJvcj86IHN0cmluZztcclxufVxyXG5cclxuaW50ZXJmYWNlIFVSTFNjcmVlbnNob3RJbmZvIHtcclxuICB1cmw6IHN0cmluZztcclxuICBzY3JlZW5zaG90VXJsOiBzdHJpbmc7IC8vIFVSTCBkZSBsYSBjYXB0dXJhIGRlIHBhbnRhbGxhXHJcbiAgZXJyb3I/OiBzdHJpbmc7IC8vIEVycm9yIGVuIGNhc28gZGUgcXVlIGZhbGxlIGxhIGNhcHR1cmFcclxufVxyXG5cclxuaW50ZXJmYWNlIFVSTEFuYWx5c2lzUmVzdWx0IHtcclxuICBjb250YWluc1VSTHM6IGJvb2xlYW47XHJcbiAgdXJsczogc3RyaW5nW107XHJcbiAgc2NyZWVuc2hvdHM/OiBVUkxTY3JlZW5zaG90SW5mb1tdOyAvLyBDYXB0dXJhcyBkZSBwYW50YWxsYSBkZSBsYXMgVVJMc1xyXG59XHJcblxyXG5leHBvcnQgY2xhc3MgQUlTZXJ2aWNlIHtcclxuICAvKipcclxuICAgKiBBbmFsaXphIGxvcyBlbGVtZW50b3Mgc2VsZWNjaW9uYWRvcyBwYXJhIGJ1c2NhciBVUkxzXHJcbiAgICovXHJcbiAgcHVibGljIHN0YXRpYyBhc3luYyBhbmFseXplSXRlbXMocmVxdWVzdDogQUlBbmFseXNpc1JlcXVlc3QpOiBQcm9taXNlPEFJQW5hbHlzaXNSZXNwb25zZT4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgLy8gU2ltdWxhbW9zIHVuIHRpZW1wbyBkZSByZXNwdWVzdGEgZGUgbGEgQVBJXHJcbiAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCAxMDAwKSk7XHJcblxyXG4gICAgICBjb25zb2xlLmxvZygnQUkgU2VydmljZSAtIFJlcXVlc3Q6JywgcmVxdWVzdCk7XHJcblxyXG4gICAgICAvLyBFeHRyYWVyIGVsIHRleHRvIHJlbGV2YW50ZSBkZSBsb3MgZWxlbWVudG9zIHNlbGVjY2lvbmFkb3NcclxuICAgICAgY29uc3QgZWxlbWVudHNUZXh0ID0gdGhpcy5leHRyYWN0VGV4dEZyb21FbGVtZW50cyhyZXF1ZXN0Lml0ZW1zKTtcclxuXHJcbiAgICAgIC8vIE1lbnNhamUgZXhwbMOtY2l0byBvIHRleHRvIGV4dHJhw61kbyBkZSBsb3MgZWxlbWVudG9zXHJcbiAgICAgIGNvbnN0IHRleHRUb0FuYWx5emUgPSByZXF1ZXN0Lm1lc3NhZ2UgfHwgZWxlbWVudHNUZXh0O1xyXG5cclxuICAgICAgLy8gQW5hbGl6YXIgc2kgZWwgdGV4dG8gY29udGllbmUgVVJMc1xyXG4gICAgICBjb25zdCB1cmxBbmFseXNpcyA9IHRoaXMuZGV0ZWN0VVJMcyh0ZXh0VG9BbmFseXplKTtcclxuXHJcbiAgICAgIC8vIFNpIGhheSBVUkxzLCBvYnRlbmVyIGNhcHR1cmFzIGRlIHBhbnRhbGxhXHJcbiAgICAgIGlmICh1cmxBbmFseXNpcy5jb250YWluc1VSTHMgJiYgdXJsQW5hbHlzaXMudXJscy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgdXJsQW5hbHlzaXMuc2NyZWVuc2hvdHMgPSBhd2FpdCB0aGlzLmZldGNoU2NyZWVuc2hvdHNGb3JVcmxzKHVybEFuYWx5c2lzLnVybHMpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBTaW11bGFjacOzbiBkZSByZXNwdWVzdGEgZGUgbGEgSUFcclxuICAgICAgLy8gRW4gdW4gZW50b3JubyByZWFsLCBlc3RvIGVudmlhcsOtYSBsYSBzb2xpY2l0dWQgYSB1biBlbmRwb2ludCBkZSBBUElcclxuICAgICAgcmV0dXJuIHtcclxuICAgICAgICBzdWNjZXNzOiB0cnVlLFxyXG4gICAgICAgIG1lc3NhZ2U6IFwiQW7DoWxpc2lzIGNvbXBsZXRhZG8gY29uIMOpeGl0b1wiLFxyXG4gICAgICAgIGFuYWx5c2lzOiB7XHJcbiAgICAgICAgICBzdW1tYXJ5OiB0aGlzLmdlbmVyYXRlVVJMQW5hbHlzaXNTdW1tYXJ5KHVybEFuYWx5c2lzLCByZXF1ZXN0Lml0ZW1zLmxlbmd0aCksXHJcbiAgICAgICAgICB1cmxBbmFseXNpczogdXJsQW5hbHlzaXMsXHJcbiAgICAgICAgICBpdGVtc0FuYWx5emVkOiByZXF1ZXN0Lml0ZW1zLmxlbmd0aCxcclxuICAgICAgICAgIGFuYWx5emVkVGV4dDogdGV4dFRvQW5hbHl6ZSxcclxuICAgICAgICAgIHJlY29tbWVuZGF0aW9uczogdGhpcy5nZW5lcmF0ZVJlY29tbWVuZGF0aW9ucyh1cmxBbmFseXNpcyksXHJcbiAgICAgICAgICBjb25maWRlbmNlOiAwLjk1XHJcbiAgICAgICAgfVxyXG4gICAgICB9O1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgaW4gQUkgc2VydmljZTonLCBlcnJvcik7XHJcbiAgICAgIHJldHVybiB7XHJcbiAgICAgICAgc3VjY2VzczogZmFsc2UsXHJcbiAgICAgICAgbWVzc2FnZTogXCJFcnJvciBhbCBwcm9jZXNhciBsYSBzb2xpY2l0dWRcIixcclxuICAgICAgICBlcnJvcjogZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiBTdHJpbmcoZXJyb3IpXHJcbiAgICAgIH07XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBFeHRyYWUgdGV4dG8gZGUgbG9zIGVsZW1lbnRvcyBzZWxlY2Npb25hZG9zXHJcbiAgICovXHJcbiAgcHJpdmF0ZSBzdGF0aWMgZXh0cmFjdFRleHRGcm9tRWxlbWVudHMoaXRlbXM6IGFueVtdKTogc3RyaW5nIHtcclxuICAgIC8vIEFxdcOtIGV4dHJhZW1vcyBlbCB0ZXh0byBkZSBsb3MgZWxlbWVudG9zIHNlbGVjY2lvbmFkb3NcclxuICAgIC8vIEVuIHVuIGNhc28gcmVhbCwgZXN0byBkZXBlbmRlcsOtYSBkZSBsYSBlc3RydWN0dXJhIGRlIHR1cyBlbGVtZW50b3NcclxuICAgIGxldCBleHRyYWN0ZWRUZXh0ID0gXCJcIjtcclxuXHJcbiAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgaXRlbXMpIHtcclxuICAgICAgLy8gSW50ZW50YXIgZXh0cmFlciB0ZXh0byBkZSBkaWZlcmVudGVzIHByb3BpZWRhZGVzIGNvbXVuZXNcclxuICAgICAgLy8gRXN0byBlcyB1biBlamVtcGxvIHkgZGViZXLDrWEgYWRhcHRhcnNlIGEgdHUgZXN0cnVjdHVyYSBkZSBkYXRvcyByZWFsXHJcbiAgICAgIGlmIChpdGVtLnRleHQpIHtcclxuICAgICAgICBleHRyYWN0ZWRUZXh0ICs9IFwiIFwiICsgaXRlbS50ZXh0O1xyXG4gICAgICB9IGVsc2UgaWYgKGl0ZW0uZGV0YWlscz8udGV4dCkge1xyXG4gICAgICAgIGV4dHJhY3RlZFRleHQgKz0gXCIgXCIgKyBpdGVtLmRldGFpbHMudGV4dDtcclxuICAgICAgfSBlbHNlIGlmIChpdGVtLm5hbWUpIHtcclxuICAgICAgICBleHRyYWN0ZWRUZXh0ICs9IFwiIFwiICsgaXRlbS5uYW1lO1xyXG4gICAgICB9IGVsc2UgaWYgKGl0ZW0udGl0bGUpIHtcclxuICAgICAgICBleHRyYWN0ZWRUZXh0ICs9IFwiIFwiICsgaXRlbS50aXRsZTtcclxuICAgICAgfSBlbHNlIGlmIChpdGVtLmRlc2NyaXB0aW9uKSB7XHJcbiAgICAgICAgZXh0cmFjdGVkVGV4dCArPSBcIiBcIiArIGl0ZW0uZGVzY3JpcHRpb247XHJcbiAgICAgIH0gZWxzZSBpZiAoaXRlbS5kZXRhaWxzPy5kZXNjcmlwdGlvbikge1xyXG4gICAgICAgIGV4dHJhY3RlZFRleHQgKz0gXCIgXCIgKyBpdGVtLmRldGFpbHMuZGVzY3JpcHRpb247XHJcbiAgICAgIH0gZWxzZSBpZiAoaXRlbS5kZXRhaWxzPy5zcmMpIHtcclxuICAgICAgICBleHRyYWN0ZWRUZXh0ICs9IFwiIFwiICsgaXRlbS5kZXRhaWxzLnNyYztcclxuICAgICAgfSBlbHNlIGlmIChpdGVtLnNyYykge1xyXG4gICAgICAgIGV4dHJhY3RlZFRleHQgKz0gXCIgXCIgKyBpdGVtLnNyYztcclxuICAgICAgfSBlbHNlIGlmIChpdGVtLmNvbnRlbnQpIHtcclxuICAgICAgICBleHRyYWN0ZWRUZXh0ICs9IFwiIFwiICsgaXRlbS5jb250ZW50O1xyXG4gICAgICB9IGVsc2UgaWYgKGl0ZW0ubGFiZWwpIHtcclxuICAgICAgICBleHRyYWN0ZWRUZXh0ICs9IFwiIFwiICsgaXRlbS5sYWJlbDtcclxuICAgICAgfSBlbHNlIGlmIChpdGVtLnZhbHVlKSB7XHJcbiAgICAgICAgZXh0cmFjdGVkVGV4dCArPSBcIiBcIiArIGl0ZW0udmFsdWU7XHJcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGl0ZW0gPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgZXh0cmFjdGVkVGV4dCArPSBcIiBcIiArIGl0ZW07XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIFRhbWJpw6luIHBvZGVtb3MgYnVzY2FyIGVuIGF0cmlidXRvcyBhbmlkYWRvc1xyXG4gICAgICBpZiAoaXRlbS5wcm9wcyAmJiB0eXBlb2YgaXRlbS5wcm9wcyA9PT0gJ29iamVjdCcpIHtcclxuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBpdGVtLnByb3BzKSB7XHJcbiAgICAgICAgICBpZiAodHlwZW9mIGl0ZW0ucHJvcHNba2V5XSA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgZXh0cmFjdGVkVGV4dCArPSBcIiBcIiArIGl0ZW0ucHJvcHNba2V5XTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIFNpIHRvZGF2w61hIG5vIGhlbW9zIGVuY29udHJhZG8gdGV4dG8sIGludGVudGFtb3MgY29udmVydGlyIGVsIG9iamV0byBhIHN0cmluZ1xyXG4gICAgICBpZiAoZXh0cmFjdGVkVGV4dC50cmltKCkgPT09IFwiXCIgJiYgaXRlbS50b1N0cmluZykge1xyXG4gICAgICAgIGNvbnN0IHN0ciA9IGl0ZW0udG9TdHJpbmcoKTtcclxuICAgICAgICBpZiAoc3RyICE9PSBcIltvYmplY3QgT2JqZWN0XVwiKSB7XHJcbiAgICAgICAgICBleHRyYWN0ZWRUZXh0ICs9IFwiIFwiICsgc3RyO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBleHRyYWN0ZWRUZXh0LnRyaW0oKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIERldGVjdGEgVVJMcyBlbiB1biB0ZXh0b1xyXG4gICAqL1xyXG4gIHByaXZhdGUgc3RhdGljIGRldGVjdFVSTHModGV4dDogc3RyaW5nKTogVVJMQW5hbHlzaXNSZXN1bHQge1xyXG4gICAgLy8gRXhwcmVzacOzbiByZWd1bGFyIG1lam9yYWRhIHBhcmEgY2FwdHVyYXIgdW5hIHZhcmllZGFkIG3DoXMgYW1wbGlhIGRlIFVSTHNcclxuICAgIC8vIEVzdGEgcmVnZXggYnVzY2EgVVJMcyBjb24gZGl2ZXJzb3MgZG9taW5pb3MgZGUgbml2ZWwgc3VwZXJpb3IgKC5jb20sIC5vcmcsIC5haSwgZXRjLilcclxuICAgIGNvbnN0IHVybFJlZ2V4ID0gLyg/Omh0dHBzPzpcXC9cXC8pPyg/Ond3d1xcLik/Wy1hLXpBLVowLTlAOiUuX1xcK34jPV17MSwyNTZ9XFwuW2EtekEtWjAtOSgpXXsxLDZ9XFxiKD86Wy1hLXpBLVowLTkoKUA6JV9cXCsufiM/Ji8vPV0qKS9naTtcclxuXHJcbiAgICBjb25zdCBtYXRjaGVzID0gdGV4dC5tYXRjaCh1cmxSZWdleCkgfHwgW107XHJcblxyXG4gICAgLy8gRmlsdHJhciBwb3NpYmxlcyBmYWxzb3MgcG9zaXRpdm9zIChjb21vIG7Dum1lcm9zIGRlIHZlcnNpw7NuOiAxLjAsIGV0Yy4pXHJcbiAgICBjb25zdCB2YWxpZFVybHMgPSBtYXRjaGVzLmZpbHRlcih1cmwgPT4ge1xyXG4gICAgICAvLyBWZXJpZmljYXIgcXVlIGVsIGRvbWluaW8gdGVuZ2EgYWwgbWVub3MgdW4gcHVudG8geSBjYXJhY3RlcmVzIGFsZmFudW3DqXJpY29zXHJcbiAgICAgIGNvbnN0IGRvbWFpblBhcnRzID0gdXJsLnNwbGl0KCcuJyk7XHJcbiAgICAgIC8vIERlYmUgdGVuZXIgYWwgbWVub3MgdW4gcHVudG8geSBlbCBUTEQgZGViZSB0ZW5lciBhbCBtZW5vcyAyIGNhcmFjdGVyZXNcclxuICAgICAgcmV0dXJuIGRvbWFpblBhcnRzLmxlbmd0aCA+PSAyICYmIGRvbWFpblBhcnRzW2RvbWFpblBhcnRzLmxlbmd0aCAtIDFdLmxlbmd0aCA+PSAyO1xyXG4gICAgfSk7XHJcblxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgY29udGFpbnNVUkxzOiB2YWxpZFVybHMubGVuZ3RoID4gMCxcclxuICAgICAgdXJsczogdmFsaWRVcmxzXHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogT2J0aWVuZSBjYXB0dXJhcyBkZSBwYW50YWxsYSBwYXJhIGxhcyBVUkxzIHByb3BvcmNpb25hZGFzXHJcbiAgICogVXRpbGl6YSBzZXJ2aWNpb3MgZGUgY2FwdHVyYSBkZSBwYW50YWxsYSBkZSB0ZXJjZXJvc1xyXG4gICAqL1xyXG4gIHByaXZhdGUgc3RhdGljIGFzeW5jIGZldGNoU2NyZWVuc2hvdHNGb3JVcmxzKHVybHM6IHN0cmluZ1tdKTogUHJvbWlzZTxVUkxTY3JlZW5zaG90SW5mb1tdPiB7XHJcbiAgICBjb25zdCBzY3JlZW5zaG90czogVVJMU2NyZWVuc2hvdEluZm9bXSA9IFtdO1xyXG5cclxuICAgIC8vIFByb2Nlc2FyIGNhZGEgVVJMIGVuIHBhcmFsZWxvXHJcbiAgICBjb25zdCBzY3JlZW5zaG90UHJvbWlzZXMgPSB1cmxzLm1hcChhc3luYyAodXJsKSA9PiB7XHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgLy8gVXNhciBudWVzdHJvIHByb3BpbyBlbmRwb2ludCBkZSBBUEkgcGFyYSBvYnRlbmVyIGxhIGNhcHR1cmFcclxuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKCcvYXBpL3NjcmVlbnNob3QnLCB7XHJcbiAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcclxuICAgICAgICAgIGhlYWRlcnM6IHtcclxuICAgICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7IHVybCB9KSxcclxuICAgICAgICAgIC8vIFRpbWVvdXQgcGFyYSBldml0YXIgZXNwZXJhcyBkZW1hc2lhZG8gbGFyZ2FzXHJcbiAgICAgICAgICBzaWduYWw6IEFib3J0U2lnbmFsLnRpbWVvdXQoMTAwMDApIC8vIDEwIHNlZ3VuZG9zIG3DoXhpbW9cclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xyXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBFcnJvciBlbiBsYSBzb2xpY2l0dWQgZGUgY2FwdHVyYTogJHtyZXNwb25zZS5zdGF0dXN9ICR7cmVzcG9uc2Uuc3RhdHVzVGV4dH1gKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XHJcblxyXG4gICAgICAgIGlmIChkYXRhLnN1Y2Nlc3MpIHtcclxuICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHVybDogdXJsLFxyXG4gICAgICAgICAgICBzY3JlZW5zaG90VXJsOiBkYXRhLnNjcmVlbnNob3RVcmxcclxuICAgICAgICAgIH07XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihkYXRhLmVycm9yIHx8ICdFcnJvciBkZXNjb25vY2lkbyBhbCBvYnRlbmVyIGxhIGNhcHR1cmEnKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgY29uc29sZS5lcnJvcihgRXJyb3IgYWwgb2J0ZW5lciBjYXB0dXJhIHBhcmEgJHt1cmx9OmAsIGVycm9yKTtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgdXJsOiB1cmwsXHJcbiAgICAgICAgICBlcnJvcjogZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiAnRXJyb3IgYWwgZ2VuZXJhciBsYSBjYXB0dXJhJ1xyXG4gICAgICAgIH07XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIC8vIEVzcGVyYXIgYSBxdWUgdG9kYXMgbGFzIGNhcHR1cmFzIHNlIGNvbXBsZXRlblxyXG4gICAgY29uc3QgcmVzdWx0cyA9IGF3YWl0IFByb21pc2UuYWxsKHNjcmVlbnNob3RQcm9taXNlcyk7XHJcbiAgICByZXR1cm4gcmVzdWx0cztcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdlbmVyYSB1biByZXN1bWVuIGJhc2FkbyBlbiBlbCBhbsOhbGlzaXMgZGUgVVJMc1xyXG4gICAqL1xyXG4gIHByaXZhdGUgc3RhdGljIGdlbmVyYXRlVVJMQW5hbHlzaXNTdW1tYXJ5KGFuYWx5c2lzOiBVUkxBbmFseXNpc1Jlc3VsdCwgaXRlbUNvdW50OiBudW1iZXIpOiBzdHJpbmcge1xyXG4gICAgaWYgKGFuYWx5c2lzLmNvbnRhaW5zVVJMcykge1xyXG4gICAgICBjb25zdCB1cmxDb3VudCA9IGFuYWx5c2lzLnVybHMubGVuZ3RoO1xyXG4gICAgICByZXR1cm4gYEhlIGFuYWxpemFkbyBlbCBjb250ZW5pZG8gZGUgJHtpdGVtQ291bnR9IGVsZW1lbnRvJHtpdGVtQ291bnQgIT09IDEgPyAncycgOiAnJ30geSBlbmNvbnRyYWRvICR7dXJsQ291bnR9IFVSTCR7dXJsQ291bnQgIT09IDEgPyAncycgOiAnJ30uYDtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHJldHVybiBgSGUgYW5hbGl6YWRvIGVsIGNvbnRlbmlkbyBkZSAke2l0ZW1Db3VudH0gZWxlbWVudG8ke2l0ZW1Db3VudCAhPT0gMSA/ICdzJyA6ICcnfSB5IG5vIGhlIGVuY29udHJhZG8gbmluZ3VuYSBVUkwuYDtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdlbmVyYSByZWNvbWVuZGFjaW9uZXMgYmFzYWRhcyBlbiBlbCBhbsOhbGlzaXMgZGUgVVJMc1xyXG4gICAqL1xyXG4gIHByaXZhdGUgc3RhdGljIGdlbmVyYXRlUmVjb21tZW5kYXRpb25zKGFuYWx5c2lzOiBVUkxBbmFseXNpc1Jlc3VsdCk6IHN0cmluZ1tdIHtcclxuICAgIGlmIChhbmFseXNpcy5jb250YWluc1VSTHMpIHtcclxuICAgICAgcmV0dXJuIFtcclxuICAgICAgICBcIkNvbnNpZGVyZSB2ZXJpZmljYXIgc2kgbGFzIFVSTHMgc29uIHNlZ3VyYXMgYW50ZXMgZGUgdXRpbGl6YXJsYXMuXCIsXHJcbiAgICAgICAgXCJBc2Vnw7pyZXNlIGRlIHF1ZSBsYXMgVVJMcyBlc3TDqW4gYWN0aXZhcyB5IGZ1bmNpb25lbiBjb3JyZWN0YW1lbnRlLlwiLFxyXG4gICAgICAgIFwiQ29uc2lkZXJlIHJldmlzYXIgc2kgbG9zIGVubGFjZXMgYXB1bnRhbiBhIGxvcyByZWN1cnNvcyBkZXNlYWRvcy5cIlxyXG4gICAgICBdO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgcmV0dXJuIFtcclxuICAgICAgICBcIkVsIGNvbnRlbmlkbyBubyBjb250aWVuZSBVUkxzLiBTaSBuZWNlc2l0YSBpbmNsdWlyIHJlZmVyZW5jaWFzIHdlYiwgY29uc2lkZXJlIGHDsWFkaXJsYXMuXCIsXHJcbiAgICAgICAgXCJQdWVkZSBhw7FhZGlyIGVubGFjZXMgYSByZWN1cnNvcyBhZGljaW9uYWxlcyBwYXJhIGVucmlxdWVjZXIgZWwgY29udGVuaWRvLlwiXHJcbiAgICAgIF07XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBBSVNlcnZpY2U7XHJcbiJdLCJuYW1lcyI6WyJBSVNlcnZpY2UiLCJhbmFseXplSXRlbXMiLCJyZXF1ZXN0IiwiUHJvbWlzZSIsInJlc29sdmUiLCJzZXRUaW1lb3V0IiwiY29uc29sZSIsImxvZyIsImVsZW1lbnRzVGV4dCIsImV4dHJhY3RUZXh0RnJvbUVsZW1lbnRzIiwiaXRlbXMiLCJ0ZXh0VG9BbmFseXplIiwibWVzc2FnZSIsInVybEFuYWx5c2lzIiwiZGV0ZWN0VVJMcyIsImNvbnRhaW5zVVJMcyIsInVybHMiLCJsZW5ndGgiLCJzY3JlZW5zaG90cyIsImZldGNoU2NyZWVuc2hvdHNGb3JVcmxzIiwic3VjY2VzcyIsImFuYWx5c2lzIiwic3VtbWFyeSIsImdlbmVyYXRlVVJMQW5hbHlzaXNTdW1tYXJ5IiwiaXRlbXNBbmFseXplZCIsImFuYWx5emVkVGV4dCIsInJlY29tbWVuZGF0aW9ucyIsImdlbmVyYXRlUmVjb21tZW5kYXRpb25zIiwiY29uZmlkZW5jZSIsImVycm9yIiwiRXJyb3IiLCJTdHJpbmciLCJleHRyYWN0ZWRUZXh0IiwiaXRlbSIsInRleHQiLCJkZXRhaWxzIiwibmFtZSIsInRpdGxlIiwiZGVzY3JpcHRpb24iLCJzcmMiLCJjb250ZW50IiwibGFiZWwiLCJ2YWx1ZSIsInByb3BzIiwia2V5IiwidHJpbSIsInRvU3RyaW5nIiwic3RyIiwidXJsUmVnZXgiLCJtYXRjaGVzIiwibWF0Y2giLCJ2YWxpZFVybHMiLCJmaWx0ZXIiLCJ1cmwiLCJkb21haW5QYXJ0cyIsInNwbGl0Iiwic2NyZWVuc2hvdFByb21pc2VzIiwibWFwIiwicmVzcG9uc2UiLCJmZXRjaCIsIm1ldGhvZCIsImhlYWRlcnMiLCJib2R5IiwiSlNPTiIsInN0cmluZ2lmeSIsInNpZ25hbCIsIkFib3J0U2lnbmFsIiwidGltZW91dCIsIm9rIiwic3RhdHVzIiwic3RhdHVzVGV4dCIsImRhdGEiLCJqc29uIiwic2NyZWVuc2hvdFVybCIsInJlc3VsdHMiLCJhbGwiLCJpdGVtQ291bnQiLCJ1cmxDb3VudCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./features/editor/services/ai-service.ts\n"));

/***/ })

});
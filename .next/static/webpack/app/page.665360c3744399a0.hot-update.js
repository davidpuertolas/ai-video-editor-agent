"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./features/editor/hooks/use-pointer-drag.tsx":
/*!****************************************************!*\
  !*** ./features/editor/hooks/use-pointer-drag.tsx ***!
  \****************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   usePointerDrag: function() { return /* binding */ usePointerDrag; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\nvar _s = $RefreshSig$();\n\nfunction usePointerDrag(options) {\n    _s();\n    const [dragState, setDragState] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(undefined);\n    const [isDragging, setIsDragging] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const [isStarted, setIsStarted] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const infoRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)({\n        x: 0,\n        y: 0,\n        startedAt: 0,\n        dragging: false\n    });\n    const optionsRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(options);\n    const dragStateRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(dragState);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        optionsRef.current = options;\n    }, [\n        options\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        dragStateRef.current = dragState;\n    }, [\n        dragState\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (!isStarted) {\n            return;\n        }\n        const { stopPropagation = true, preventDefault = true, onClick, onStart, onMove, onEnd, dragPredicate } = optionsRef.current;\n        const getData = (e)=>{\n            const { x: startX, y: startY, startedAt, initialEvent } = infoRef.current;\n            const deltaX = e.clientX - startX;\n            const deltaY = e.clientY - startY;\n            console.log(\"usePointerDrag - getData:\", {\n                x: e.clientX,\n                y: e.clientY,\n                deltaX,\n                deltaY,\n                startX,\n                startY\n            });\n            return {\n                x: e.clientX,\n                y: e.clientY,\n                state: dragStateRef.current,\n                setState: setDragState,\n                deltaX,\n                deltaY,\n                startX,\n                startY,\n                startedAt,\n                initialEvent,\n                distance: Math.sqrt(Math.pow(deltaX, 2) + Math.pow(deltaY, 2)),\n                event: e\n            };\n        };\n        const handleEvent = (e)=>{\n            if (preventDefault) e.preventDefault();\n            if (stopPropagation) e.stopPropagation();\n        };\n        const handleMove = (e)=>{\n            const data = getData(e);\n            if (!infoRef.current.dragging) {\n                if (!dragPredicate || dragPredicate(data)) {\n                    console.log(\"usePointerDrag - Drag started:\", data);\n                    handleEvent(e);\n                    infoRef.current.dragging = true;\n                    onStart === null || onStart === void 0 ? void 0 : onStart(data);\n                }\n            } else {\n                console.log(\"usePointerDrag - Dragging:\", {\n                    x: data.x,\n                    y: data.y,\n                    deltaX: data.deltaX,\n                    deltaY: data.deltaY\n                });\n                handleEvent(e);\n                onMove === null || onMove === void 0 ? void 0 : onMove(data);\n            }\n        };\n        const handleUp = (e)=>{\n            const data = getData(e);\n            if (infoRef.current.dragging) {\n                console.log(\"usePointerDrag - Drag ended:\", data);\n                handleEvent(e);\n                onEnd === null || onEnd === void 0 ? void 0 : onEnd(data);\n            } else {\n                console.log(\"usePointerDrag - Click (no drag):\", data);\n                onClick === null || onClick === void 0 ? void 0 : onClick(data);\n            }\n            infoRef.current.dragging = false;\n            setDragState(undefined);\n            setIsDragging(false);\n            setIsStarted(false);\n        };\n        document.addEventListener(\"pointermove\", handleMove);\n        document.addEventListener(\"pointerup\", handleUp);\n        return ()=>{\n            document.removeEventListener(\"pointermove\", handleMove);\n            document.removeEventListener(\"pointerup\", handleUp);\n        };\n    }, [\n        isStarted\n    ]);\n    const startDragging = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((state)=>{\n        setDragState(state);\n        setIsStarted(true);\n        setIsDragging(true);\n        infoRef.current.dragging = true;\n    }, [\n        setDragState,\n        setIsStarted,\n        setIsDragging\n    ]);\n    const dragProps = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((state)=>{\n        return {\n            onPointerDown: (e)=>{\n                var _optionsRef_current_onBeforeStart, _optionsRef_current;\n                setDragState(state);\n                setIsStarted(true);\n                setIsDragging(true);\n                const now = Date.now();\n                infoRef.current = {\n                    x: e.clientX,\n                    y: e.clientY,\n                    startedAt: now,\n                    dragging: false,\n                    initialEvent: e.nativeEvent\n                };\n                if (optionsRef.current.pointerDownPreventDefault) {\n                    e.preventDefault();\n                }\n                if (optionsRef.current.pointerDownStopPropagation) {\n                    e.stopPropagation();\n                }\n                (_optionsRef_current_onBeforeStart = (_optionsRef_current = optionsRef.current).onBeforeStart) === null || _optionsRef_current_onBeforeStart === void 0 ? void 0 : _optionsRef_current_onBeforeStart.call(_optionsRef_current, {\n                    x: e.clientX,\n                    y: e.clientY,\n                    state: state,\n                    setState: setDragState,\n                    deltaX: 0,\n                    deltaY: 0,\n                    startX: e.clientX,\n                    startY: e.clientY,\n                    startedAt: now,\n                    initialEvent: e.nativeEvent,\n                    distance: 0,\n                    event: e.nativeEvent\n                });\n            }\n        };\n    }, [\n        setDragState,\n        setIsStarted\n    ]);\n    return {\n        startDragging,\n        dragState,\n        isDragging,\n        dragProps\n    };\n}\n_s(usePointerDrag, \"VCy0KyrP1/+FTiojBSvYXs9Uxts=\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2ZlYXR1cmVzL2VkaXRvci9ob29rcy91c2UtcG9pbnRlci1kcmFnLnRzeCIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQXdFO0FBNktqRSxTQUFTSyxlQUNkQyxPQUErQjs7SUFFL0IsTUFBTSxDQUFDQyxXQUFXQyxhQUFhLEdBQUdQLCtDQUFRQSxDQUFnQlE7SUFDMUQsTUFBTSxDQUFDQyxZQUFZQyxjQUFjLEdBQUdWLCtDQUFRQSxDQUFDO0lBQzdDLE1BQU0sQ0FBQ1csV0FBV0MsYUFBYSxHQUFHWiwrQ0FBUUEsQ0FBQztJQUUzQyxNQUFNYSxVQUFVViw2Q0FBTUEsQ0FNbkI7UUFBRVcsR0FBRztRQUFHQyxHQUFHO1FBQUdDLFdBQVc7UUFBR0MsVUFBVTtJQUFNO0lBQy9DLE1BQU1DLGFBQWFmLDZDQUFNQSxDQUFDRTtJQUMxQixNQUFNYyxlQUFlaEIsNkNBQU1BLENBQUNHO0lBRTVCTCxnREFBU0EsQ0FBQztRQUNSaUIsV0FBV0UsT0FBTyxHQUFHZjtJQUN2QixHQUFHO1FBQUNBO0tBQVE7SUFFWkosZ0RBQVNBLENBQUM7UUFDUmtCLGFBQWFDLE9BQU8sR0FBR2Q7SUFDekIsR0FBRztRQUFDQTtLQUFVO0lBRWRMLGdEQUFTQSxDQUFDO1FBQ1IsSUFBSSxDQUFDVSxXQUFXO1lBQ2Q7UUFDRjtRQUVBLE1BQU0sRUFDSlUsa0JBQWtCLElBQUksRUFDdEJDLGlCQUFpQixJQUFJLEVBQ3JCQyxPQUFPLEVBQ1BDLE9BQU8sRUFDUEMsTUFBTSxFQUNOQyxLQUFLLEVBQ0xDLGFBQWEsRUFDZCxHQUFHVCxXQUFXRSxPQUFPO1FBRXRCLE1BQU1RLFVBQVUsQ0FBQ0M7WUFDZixNQUFNLEVBQUVmLEdBQUdnQixNQUFNLEVBQUVmLEdBQUdnQixNQUFNLEVBQUVmLFNBQVMsRUFBRWdCLFlBQVksRUFBRSxHQUFHbkIsUUFBUU8sT0FBTztZQUV6RSxNQUFNYSxTQUFTSixFQUFFSyxPQUFPLEdBQUdKO1lBQzNCLE1BQU1LLFNBQVNOLEVBQUVPLE9B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ZSxjQUFjSCxFQUFFNkIsV0FBVztnQkFDN0I7Z0JBRUEsSUFBSXhDLFdBQVdFLE9BQU8sQ0FBQ3VDLHlCQUF5QixFQUFFO29CQUNoRDlCLEVBQUVQLGNBQWM7Z0JBQ2xCO2dCQUVBLElBQUlKLFdBQVdFLE9BQU8sQ0FBQ3dDLDBCQUEwQixFQUFFO29CQUNqRC9CLEVBQUVSLGVBQWU7Z0JBQ25CO2lCQUVBSCxvQ0FBQUEsQ0FBQUEsc0JBQUFBLFdBQVdFLE9BQU8sRUFBQ3lDLGFBQWEsY0FBaEMzQyx3REFBQUEsdUNBQUFBLHFCQUFtQztvQkFDakNKLEdBQUdlLEVBQUVLLE9BQU87b0JBQ1puQixHQUFHYyxFQUFFTyxPQUFPO29CQUNaRyxPQUFPQTtvQkFDUEMsVUFBVWpDO29CQUNWMEIsUUFBUTtvQkFDUkUsUUFBUTtvQkFDUkwsUUFBUUQsRUFBRUssT0FBTztvQkFDakJILFFBQVFGLEVBQUVPLE9BQU87b0JBQ2pCcEIsV0FBV3dDO29CQUNYeEIsY0FBY0gsRUFBRTZCLFdBQVc7b0JBQzNCakIsVUFBVTtvQkFDVkksT0FBT2hCLEVBQUU2QixXQUFXO2dCQUN0QjtZQUNGO1FBQ0Y7SUFDRixHQUNBO1FBQUNuRDtRQUFjSztLQUFhO0lBRzlCLE9BQU87UUFDTHlDO1FBQ0EvQztRQUNBRztRQUNBNkM7SUFDRjtBQUNGO0dBbkxnQmxEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL2ZlYXR1cmVzL2VkaXRvci9ob29rcy91c2UtcG9pbnRlci1kcmFnLnRzeD8xM2JkIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBSZWFjdCwgeyB1c2VTdGF0ZSwgdXNlRWZmZWN0LCB1c2VDYWxsYmFjaywgdXNlUmVmIH0gZnJvbSBcInJlYWN0XCI7XHJcblxyXG4vKipcclxuICogRXZlbnQgb2JqZWN0IHRvIGJlIGFwcGxpZWQgb24gdGhlIHRhcmdldCBlbGVtZW50LlxyXG4gKiA8ZGl2IHsuLi5ldmVudHN9IC8+XHJcbiAqL1xyXG5leHBvcnQgaW50ZXJmYWNlIElQb2ludGVyRHJhZ0V2ZW50cyB7XHJcbiAgb25Qb2ludGVyRG93bihlOiBSZWFjdC5Qb2ludGVyRXZlbnQpOiB2b2lkO1xyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIElQb2ludGVyRHJhZ1JldHVybkJhc2Uge1xyXG4gIC8qKlxyXG4gICAqIFRydWUgaWYgY29uc3RyYWludHMgd2VyZSBtZXQgYW5kIHRoZSBkcmFnZ2luZyBpcyBoYXBwZW5pbmcuXHJcbiAgICovXHJcbiAgaXNEcmFnZ2luZzogYm9vbGVhbjtcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBJUG9pbnRlckRyYWdSZXR1cm5XaXRoU3RhdGU8VD4gZXh0ZW5kcyBJUG9pbnRlckRyYWdSZXR1cm5CYXNlIHtcclxuICAvKipcclxuICAgKiBGdW5jdGlvbiB0byBiZSBtYW51YWxseSBjYWxsZWQgd2hlbiBkcmFnZ2luZyBiZWdpbnMuXHJcbiAgICovXHJcbiAgc3RhcnREcmFnZ2luZyhzdGF0ZTogVCk6IHZvaWQ7XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybnMgcHJvcHMgdG8gYXBwbHkgb24gdGhlIHRhcmdldCBSZWFjdCBub2RlLlxyXG4gICAqL1xyXG4gIGRyYWdQcm9wcyhzdGF0ZTogVCk6IElQb2ludGVyRHJhZ0V2ZW50cztcclxuXHJcbiAgLyoqXHJcbiAgICogQ3VycmVudCBkcmFnIHN0YXRlLiBVbmRlZmluZWQgaWYgbm90IG1vdmluZy5cclxuICAgKi9cclxuICBkcmFnU3RhdGU/OiBUO1xyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIElQb2ludGVyRHJhZ1JldHVybldpdGhvdXRTdGF0ZSBleHRlbmRzIElQb2ludGVyRHJhZ1JldHVybkJhc2Uge1xyXG4gIC8qKlxyXG4gICAqIEZ1bmN0aW9uIHRvIGJlIG1hbnVhbGx5IGNhbGxlZCB3aGVuIGRyYWdnaW5nIGJlZ2lucy5cclxuICAgKi9cclxuICBzdGFydERyYWdnaW5nKCk6IHZvaWQ7XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybnMgcHJvcHMgdG8gYXBwbHkgb24gdGhlIHRhcmdldCBSZWFjdCBub2RlLlxyXG4gICAqL1xyXG4gIGRyYWdQcm9wcygpOiBJUG9pbnRlckRyYWdFdmVudHM7XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgSVBvaW50ZXJEcmFnRGF0YTxUPiB7XHJcbiAgLyoqXHJcbiAgICogQ3VycmVudCBwb2ludGVyIGhvcml6b250YWwgcG9zaXRpb24gKGNsaWVudFgpLlxyXG4gICAqL1xyXG4gIHg6IG51bWJlcjtcclxuXHJcbiAgLyoqXHJcbiAgICogQ3VycmVudCBwb2ludGVyIHZlcnRpY2FsIHBvc2l0aW9uIChjbGllbnRZKS5cclxuICAgKi9cclxuICB5OiBudW1iZXI7XHJcblxyXG4gIC8qKlxyXG4gICAqIERpZmZlcmVuY2UgYmV0d2VlbiBjdXJyZW50IGhvcml6b250YWwgcG9zaXRpb24gYW5kIHN0YXJ0IGhvcml6b250YWwgcG9zaXRpb24uIChjbGllbnRYIC0gc3RhcnRYKVxyXG4gICAqL1xyXG4gIGRlbHRhWDogbnVtYmVyO1xyXG5cclxuICAvKipcclxuICAgKiBEaWZmZXJlbmNlIGJldHdlZW4gY3VycmVudCB2ZXJ0aWNhbCBwb3NpdGlvbiBhbmQgc3RhcnQgaG9yaXpvbnRhbCBwb3NpdGlvbi4gKGNsaWVudFkgLSBzdGFydFkpXHJcbiAgICovXHJcbiAgZGVsdGFZOiBudW1iZXI7XHJcblxyXG4gIC8qKlxyXG4gICAqIFN0YXJ0aW5nIHBvaW50ZXIgaG9yaXpvbnRhbCBwb3NpdGlvbiAoY2xpZW50WCkuXHJcbiAgICovXHJcbiAgc3RhcnRYOiBudW1iZXI7XHJcblxyXG4gIC8qKlxyXG4gICAqIFN0YXJ0aW5nIHBvaW50ZXIgdmVydGljYWwgcG9zaXRpb24gKGNsaWVudFkpLlxyXG4gICAqL1xyXG4gIHN0YXJ0WTogbnVtYmVyO1xyXG5cclxuICAvKipcclxuICAgKiBEaXN0YW5jZSBiZXR3ZWVuIHN0YXJ0aW5nIHBvc2l0aW9uIGFuZCBjdXJyZW50IHBvc2l0aW9uLlxyXG4gICAqL1xyXG4gIGRpc3RhbmNlOiBudW1iZXI7XHJcblxyXG4gIC8qKlxyXG4gICAqIFRpbWVzdGFtcCAoVU5JWDsgbWlsbGlzZWNvbmRzKSB3aGVuIHBvaW50ZXJEb3duIG9jY3VyZWQuXHJcbiAgICovXHJcbiAgc3RhcnRlZEF0OiBudW1iZXI7XHJcblxyXG4gIC8qKlxyXG4gICAqIEN1cnJlbnQgZHJhZ1N0YXRlLlxyXG4gICAqL1xyXG4gIHN0YXRlOiBUO1xyXG5cclxuICAvKipcclxuICAgKiBVcGRhdGUgZHJhZ1N0YXRlLlxyXG4gICAqL1xyXG4gIHNldFN0YXRlOiBSZWFjdC5EaXNwYXRjaDxSZWFjdC5TZXRTdGF0ZUFjdGlvbjxUIHwgdW5kZWZpbmVkPj47XHJcblxyXG4gIC8qKlxyXG4gICAqIFBvaW50ZXJFdmVudCBvYmplY3QgZnJvbSBwb2ludGVyRG93bi5cclxuICAgKi9cclxuICBpbml0aWFsRXZlbnQ/OiBQb2ludGVyRXZlbnQ7XHJcblxyXG4gIC8qKlxyXG4gICAqIFBvaW50ZXJFdmVudCBvYmplY3QgZnJvbSBjdXJyZW50IGV2ZW50LlxyXG4gICAqL1xyXG4gIGV2ZW50PzogUG9pbnRlckV2ZW50O1xyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIElQb2ludGVyRHJhZ09wdGlvbnM8VD4ge1xyXG4gIC8qKlxyXG4gICAqIElmIHNldCB0byB0cnVlLCBzdG9wUHJvcGFnYXRpb24gd2lsbCBiZSBjYWxsZWQuXHJcbiAgICogRG9lcyBub3QgYXBwbHkgdG8gcG9pbnRlckRvd24uXHJcbiAgICogRGVmYXVsdDogdHJ1ZS5cclxuICAgKi9cclxuICBzdG9wUHJvcGFnYXRpb24/OiBib29sZWFuO1xyXG5cclxuICAvKipcclxuICAgKiBJZiBzZXQgdG8gdHJ1ZSwgcHJldmVudERlZmF1bHQgd2lsbCBiZSBjYWxsZWQuXHJcbiAgICogRG9lcyBub3QgYXBwbHkgdG8gcG9pbnRlckRvd24uXHJcbiAgICogRGVmYXVsdDogdHJ1ZS5cclxuICAgKi9cclxuICBwcmV2ZW50RGVmYXVsdD86IGJvb2xlYW47XHJcblxyXG4gIC8qKlxyXG4gICAqIElmIHNldCB0byB0cnVlLCBzdG9wUHJvcGFnYXRpb24gd2lsbCBiZSBjYWxsZWQuXHJcbiAgICogQXBwbGllcyBvbmx5IHRvIHBvaW50ZXJEb3duLlxyXG4gICAqIERlZmF1bHQ6IGZhbHNlLlxyXG4gICAqL1xyXG4gIHBvaW50ZXJEb3duU3RvcFByb3BhZ2F0aW9uPzogYm9vbGVhbjtcclxuXHJcbiAgLyoqXHJcbiAgICogSWYgc2V0IHRvIHRydWUsIHByZXZlbnREZWZhdWx0IHdpbGwgYmUgY2FsbGVkLlxyXG4gICAqIEFwcGxpZXMgb25seSB0byBwb2ludGVyRG93bi5cclxuICAgKiBEZWZhdWx0OiBmYWxzZS5cclxuICAgKi9cclxuICBwb2ludGVyRG93blByZXZlbnREZWZhdWx0PzogYm9vbGVhbjtcclxuXHJcbiAgLyoqXHJcbiAgICogQ2FsbGVkIG9uIHBvaW50ZXJEb3duLlxyXG4gICAqL1xyXG4gIG9uQmVmb3JlU3RhcnQ/KHN0YXRlOiBJUG9pbnRlckRyYWdEYXRhPFQ+KTogdm9pZDtcclxuXHJcbiAgLyoqXHJcbiAgICogQ2FsbGVkIGlmIG5vIGRyYWdnaW5nIG9jY3VycyAoZWl0aGVyIGR1ZSB0byBjb25zdHJhaW50cyBvciB0aGUgdXNlciBub3QgbW92aW5nIHRoZSBwb2ludGVyKS5cclxuICAgKi9cclxuICBvbkNsaWNrPyhzdGF0ZTogSVBvaW50ZXJEcmFnRGF0YTxUPik6IHZvaWQ7XHJcblxyXG4gIC8qKlxyXG4gICAqIENhbGxlZCB3aGVuIGRyYWdnaW5nIGJlZ2lucyAoY29uc3RyYWludHMgd2VyZSBtZXQgb3IgdXNlciBtb3ZlZCB0aGUgcG9pbnRlcikuXHJcbiAgICovXHJcbiAgb25TdGFydD8oc3RhdGU6IElQb2ludGVyRHJhZ0RhdGE8VD4pOiB2b2lkO1xyXG5cclxuICAvKipcclxuICAgKiBDYWxsZWQgd2hlbiBkcmFnZ2luZyBjb250aW51ZXMuXHJcbiAgICovXHJcbiAgb25Nb3ZlPyhzdGF0ZTogSVBvaW50ZXJEcmFnRGF0YTxUPik6IHZvaWQ7XHJcblxyXG4gIC8qKlxyXG4gICAqIENhbGxlZCB3aGVuIGRyYWdnaW5nIGVuZHMuXHJcbiAgICovXHJcbiAgb25FbmQ/KHN0YXRlOiBJUG9pbnRlckRyYWdEYXRhPFQ+KTogdm9pZDtcclxuXHJcbiAgLyoqXHJcbiAgICogRHJhZyBwcmVkaWNhdGUgZnVuY3Rpb24gdGhhdCBpcyBjYWxsZWQgZHVyaW5nIHBvaW50ZXJNb3ZlIGFuZCByZXR1cm5zIHRydWUgdG8gYmVnaW4gZHJhZ2dpbmcuXHJcbiAgICovXHJcbiAgZHJhZ1ByZWRpY2F0ZT8oc3RhdGU6IElQb2ludGVyRHJhZ0RhdGE8VD4pOiBib29sZWFuO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gdXNlUG9pbnRlckRyYWc8VD4oXHJcbiAgb3B0aW9uczogSVBvaW50ZXJEcmFnT3B0aW9uczxUPixcclxuKTogdW5rbm93biBleHRlbmRzIFRcclxuICA/IElQb2ludGVyRHJhZ1JldHVybldpdGhvdXRTdGF0ZVxyXG4gIDogSVBvaW50ZXJEcmFnUmV0dXJuV2l0aFN0YXRlPFQ+O1xyXG5leHBvcnQgZnVuY3Rpb24gdXNlUG9pbnRlckRyYWc8VD4oXHJcbiAgb3B0aW9uczogSVBvaW50ZXJEcmFnT3B0aW9uczxUPixcclxuKTogSVBvaW50ZXJEcmFnUmV0dXJuV2l0aG91dFN0YXRlIHwgSVBvaW50ZXJEcmFnUmV0dXJuV2l0aFN0YXRlPFQ+IHtcclxuICBjb25zdCBbZHJhZ1N0YXRlLCBzZXREcmFnU3RhdGVdID0gdXNlU3RhdGU8VCB8IHVuZGVmaW5lZD4odW5kZWZpbmVkKTtcclxuICBjb25zdCBbaXNEcmFnZ2luZywgc2V0SXNEcmFnZ2luZ10gPSB1c2VTdGF0ZShmYWxzZSk7XHJcbiAgY29uc3QgW2lzU3RhcnRlZCwgc2V0SXNTdGFydGVkXSA9IHVzZVN0YXRlKGZhbHNlKTtcclxuXHJcbiAgY29uc3QgaW5mb1JlZiA9IHVzZVJlZjx7XHJcbiAgICB4OiBudW1iZXI7XHJcbiAgICB5OiBudW1iZXI7XHJcbiAgICBzdGFydGVkQXQ6IG51bWJlcjtcclxuICAgIGRyYWdnaW5nOiBib29sZWFuO1xyXG4gICAgaW5pdGlhbEV2ZW50PzogUG9pbnRlckV2ZW50O1xyXG4gIH0+KHsgeDogMCwgeTogMCwgc3RhcnRlZEF0OiAwLCBkcmFnZ2luZzogZmFsc2UgfSk7XHJcbiAgY29uc3Qgb3B0aW9uc1JlZiA9IHVzZVJlZihvcHRpb25zKTtcclxuICBjb25zdCBkcmFnU3RhdGVSZWYgPSB1c2VSZWYoZHJhZ1N0YXRlKTtcclxuXHJcbiAgdXNlRWZmZWN0KCgpID0+IHtcclxuICAgIG9wdGlvbnNSZWYuY3VycmVudCA9IG9wdGlvbnM7XHJcbiAgfSwgW29wdGlvbnNdKTtcclxuXHJcbiAgdXNlRWZmZWN0KCgpID0+IHtcclxuICAgIGRyYWdTdGF0ZVJlZi5jdXJyZW50ID0gZHJhZ1N0YXRlO1xyXG4gIH0sIFtkcmFnU3RhdGVdKTtcclxuXHJcbiAgdXNlRWZmZWN0KCgpID0+IHtcclxuICAgIGlmICghaXNTdGFydGVkKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCB7XHJcbiAgICAgIHN0b3BQcm9wYWdhdGlvbiA9IHRydWUsXHJcbiAgICAgIHByZXZlbnREZWZhdWx0ID0gdHJ1ZSxcclxuICAgICAgb25DbGljayxcclxuICAgICAgb25TdGFydCxcclxuICAgICAgb25Nb3ZlLFxyXG4gICAgICBvbkVuZCxcclxuICAgICAgZHJhZ1ByZWRpY2F0ZSxcclxuICAgIH0gPSBvcHRpb25zUmVmLmN1cnJlbnQ7XHJcblxyXG4gICAgY29uc3QgZ2V0RGF0YSA9IChlOiBQb2ludGVyRXZlbnQpOiBJUG9pbnRlckRyYWdEYXRhPFQ+ID0+IHtcclxuICAgICAgY29uc3QgeyB4OiBzdGFydFgsIHk6IHN0YXJ0WSwgc3RhcnRlZEF0LCBpbml0aWFsRXZlbnQgfSA9IGluZm9SZWYuY3VycmVudDtcclxuXHJcbiAgICAgIGNvbnN0IGRlbHRhWCA9IGUuY2xpZW50WCAtIHN0YXJ0WDtcclxuICAgICAgY29uc3QgZGVsdGFZID0gZS5jbGllbnRZIC0gc3RhcnRZO1xyXG5cclxuICAgICAgY29uc29sZS5sb2coXCJ1c2VQb2ludGVyRHJhZyAtIGdldERhdGE6XCIsIHtcclxuICAgICAgICB4OiBlLmNsaWVudFgsXHJcbiAgICAgICAgeTogZS5jbGllbnRZLFxyXG4gICAgICAgIGRlbHRhWCxcclxuICAgICAgICBkZWx0YVksXHJcbiAgICAgICAgc3RhcnRYLFxyXG4gICAgICAgIHN0YXJ0WVxyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIHJldHVybiB7XHJcbiAgICAgICAgeDogZS5jbGllbnRYLFxyXG4gICAgICAgIHk6IGUuY2xpZW50WSxcclxuICAgICAgICBzdGF0ZTogZHJhZ1N0YXRlUmVmLmN1cnJlbnQhLFxyXG4gICAgICAgIHNldFN0YXRlOiBzZXREcmFnU3RhdGUsXHJcbiAgICAgICAgZGVsdGFYLFxyXG4gICAgICAgIGRlbHRhWSxcclxuICAgICAgICBzdGFydFgsXHJcbiAgICAgICAgc3RhcnRZLFxyXG4gICAgICAgIHN0YXJ0ZWRBdCxcclxuICAgICAgICBpbml0aWFsRXZlbnQsXHJcbiAgICAgICAgZGlzdGFuY2U6IE1hdGguc3FydChNYXRoLnBvdyhkZWx0YVgsIDIpICsgTWF0aC5wb3coZGVsdGFZLCAyKSksXHJcbiAgICAgICAgZXZlbnQ6IGUsXHJcbiAgICAgIH07XHJcbiAgICB9O1xyXG5cclxuICAgIGNvbnN0IGhhbmRsZUV2ZW50ID0gKGU6IFBvaW50ZXJFdmVudCkgPT4ge1xyXG4gICAgICBpZiAocHJldmVudERlZmF1bHQpIGUucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgaWYgKHN0b3BQcm9wYWdhdGlvbikgZS5zdG9wUHJvcGFnYXRpb24oKTtcclxuICAgIH07XHJcblxyXG4gICAgY29uc3QgaGFuZGxlTW92ZSA9IChlOiBQb2ludGVyRXZlbnQpID0+IHtcclxuICAgICAgY29uc3QgZGF0YSA9IGdldERhdGEoZSk7XHJcblxyXG4gICAgICBpZiAoIWluZm9SZWYuY3VycmVudC5kcmFnZ2luZykge1xyXG4gICAgICAgIGlmICghZHJhZ1ByZWRpY2F0ZSB8fCBkcmFnUHJlZGljYXRlKGRhdGEpKSB7XHJcbiAgICAgICAgICBjb25zb2xlLmxvZyhcInVzZVBvaW50ZXJEcmFnIC0gRHJhZyBzdGFydGVkOlwiLCBkYXRhKTtcclxuICAgICAgICAgIGhhbmRsZUV2ZW50KGUpO1xyXG4gICAgICAgICAgaW5mb1JlZi5jdXJyZW50LmRyYWdnaW5nID0gdHJ1ZTtcclxuICAgICAgICAgIG9uU3RhcnQ/LihkYXRhKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgY29uc29sZS5sb2coXCJ1c2VQb2ludGVyRHJhZyAtIERyYWdnaW5nOlwiLCB7IHg6IGRhdGEueCwgeTogZGF0YS55LCBkZWx0YVg6IGRhdGEuZGVsdGFYLCBkZWx0YVk6IGRhdGEuZGVsdGFZIH0pO1xyXG4gICAgICAgIGhhbmRsZUV2ZW50KGUpO1xyXG4gICAgICAgIG9uTW92ZT8uKGRhdGEpO1xyXG4gICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIGNvbnN0IGhhbmRsZVVwID0gKGU6IFBvaW50ZXJFdmVudCkgPT4ge1xyXG4gICAgICBjb25zdCBkYXRhID0gZ2V0RGF0YShlKTtcclxuICAgICAgaWYgKGluZm9SZWYuY3VycmVudC5kcmFnZ2luZykge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKFwidXNlUG9pbnRlckRyYWcgLSBEcmFnIGVuZGVkOlwiLCBkYXRhKTtcclxuICAgICAgICBoYW5kbGVFdmVudChlKTtcclxuICAgICAgICBvbkVuZD8uKGRhdGEpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKFwidXNlUG9pbnRlckRyYWcgLSBDbGljayAobm8gZHJhZyk6XCIsIGRhdGEpO1xyXG4gICAgICAgIG9uQ2xpY2s/LihkYXRhKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaW5mb1JlZi5jdXJyZW50LmRyYWdnaW5nID0gZmFsc2U7XHJcbiAgICAgIHNldERyYWdTdGF0ZSh1bmRlZmluZWQpO1xyXG4gICAgICBzZXRJc0RyYWdnaW5nKGZhbHNlKTtcclxuICAgICAgc2V0SXNTdGFydGVkKGZhbHNlKTtcclxuICAgIH07XHJcblxyXG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJtb3ZlXCIsIGhhbmRsZU1vdmUpO1xyXG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJ1cFwiLCBoYW5kbGVVcCk7XHJcblxyXG4gICAgcmV0dXJuICgpID0+IHtcclxuICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJtb3ZlXCIsIGhhbmRsZU1vdmUpO1xyXG4gICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwicG9pbnRlcnVwXCIsIGhhbmRsZVVwKTtcclxuICAgIH07XHJcbiAgfSwgW2lzU3RhcnRlZF0pO1xyXG5cclxuICBjb25zdCBzdGFydERyYWdnaW5nID0gdXNlQ2FsbGJhY2soXHJcbiAgICAoc3RhdGU/OiBUKSA9PiB7XHJcbiAgICAgIHNldERyYWdTdGF0ZShzdGF0ZSk7XHJcbiAgICAgIHNldElzU3RhcnRlZCh0cnVlKTtcclxuICAgICAgc2V0SXNEcmFnZ2luZyh0cnVlKTtcclxuICAgICAgaW5mb1JlZi5jdXJyZW50LmRyYWdnaW5nID0gdHJ1ZTtcclxuICAgIH0sXHJcbiAgICBbc2V0RHJhZ1N0YXRlLCBzZXRJc1N0YXJ0ZWQsIHNldElzRHJhZ2dpbmddLFxyXG4gICk7XHJcblxyXG4gIGNvbnN0IGRyYWdQcm9wcyA9IHVzZUNhbGxiYWNrKFxyXG4gICAgKHN0YXRlPzogVCkgPT4ge1xyXG4gICAgICByZXR1cm4ge1xyXG4gICAgICAgIG9uUG9pbnRlckRvd246IChlOiBSZWFjdC5Qb2ludGVyRXZlbnQpID0+IHtcclxuICAgICAgICAgIHNldERyYWdTdGF0ZShzdGF0ZSk7XHJcbiAgICAgICAgICBzZXRJc1N0YXJ0ZWQodHJ1ZSk7XHJcbiAgICAgICAgICBzZXRJc0RyYWdnaW5nKHRydWUpO1xyXG4gICAgICAgICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcclxuICAgICAgICAgIGluZm9SZWYuY3VycmVudCA9IHtcclxuICAgICAgICAgICAgeDogZS5jbGllbnRYLFxyXG4gICAgICAgICAgICB5OiBlLmNsaWVudFksXHJcbiAgICAgICAgICAgIHN0YXJ0ZWRBdDogbm93LFxyXG4gICAgICAgICAgICBkcmFnZ2luZzogZmFsc2UsXHJcbiAgICAgICAgICAgIGluaXRpYWxFdmVudDogZS5uYXRpdmVFdmVudCxcclxuICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgaWYgKG9wdGlvbnNSZWYuY3VycmVudC5wb2ludGVyRG93blByZXZlbnREZWZhdWx0KSB7XHJcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICBpZiAob3B0aW9uc1JlZi5jdXJyZW50LnBvaW50ZXJEb3duU3RvcFByb3BhZ2F0aW9uKSB7XHJcbiAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgb3B0aW9uc1JlZi5jdXJyZW50Lm9uQmVmb3JlU3RhcnQ/Lih7XHJcbiAgICAgICAgICAgIHg6IGUuY2xpZW50WCxcclxuICAgICAgICAgICAgeTogZS5jbGllbnRZLFxyXG4gICAgICAgICAgICBzdGF0ZTogc3RhdGUhLFxyXG4gICAgICAgICAgICBzZXRTdGF0ZTogc2V0RHJhZ1N0YXRlLFxyXG4gICAgICAgICAgICBkZWx0YVg6IDAsXHJcbiAgICAgICAgICAgIGRlbHRhWTogMCxcclxuICAgICAgICAgICAgc3RhcnRYOiBlLmNsaWVudFgsXHJcbiAgICAgICAgICAgIHN0YXJ0WTogZS5jbGllbnRZLFxyXG4gICAgICAgICAgICBzdGFydGVkQXQ6IG5vdyxcclxuICAgICAgICAgICAgaW5pdGlhbEV2ZW50OiBlLm5hdGl2ZUV2ZW50LFxyXG4gICAgICAgICAgICBkaXN0YW5jZTogMCxcclxuICAgICAgICAgICAgZXZlbnQ6IGUubmF0aXZlRXZlbnQsXHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICB9LFxyXG4gICAgICB9O1xyXG4gICAgfSxcclxuICAgIFtzZXREcmFnU3RhdGUsIHNldElzU3RhcnRlZF0sXHJcbiAgKTtcclxuXHJcbiAgcmV0dXJuIHtcclxuICAgIHN0YXJ0RHJhZ2dpbmcsXHJcbiAgICBkcmFnU3RhdGUsXHJcbiAgICBpc0RyYWdnaW5nLFxyXG4gICAgZHJhZ1Byb3BzLFxyXG4gIH0gYXMgSVBvaW50ZXJEcmFnUmV0dXJuV2l0aFN0YXRlPFQ+IHwgSVBvaW50ZXJEcmFnUmV0dXJuV2l0aG91dFN0YXRlO1xyXG59XHJcbiJdLCJuYW1lcyI6WyJSZWFjdCIsInVzZVN0YXRlIiwidXNlRWZmZWN0IiwidXNlQ2FsbGJhY2siLCJ1c2VSZWYiLCJ1c2VQb2ludGVyRHJhZyIsIm9wdGlvbnMiLCJkcmFnU3RhdGUiLCJzZXREcmFnU3RhdGUiLCJ1bmRlZmluZWQiLCJpc0RyYWdnaW5nIiwic2V0SXNEcmFnZ2luZyIsImlzU3RhcnRlZCIsInNldElzU3RhcnRlZCIsImluZm9SZWYiLCJ4IiwieSIsInN0YXJ0ZWRBdCIsImRyYWdnaW5nIiwib3B0aW9uc1JlZiIsImRyYWdTdGF0ZVJlZiIsImN1cnJlbnQiLCJzdG9wUHJvcGFnYXRpb24iLCJwcmV2ZW50RGVmYXVsdCIsIm9uQ2xpY2siLCJvblN0YXJ0Iiwib25Nb3ZlIiwib25FbmQiLCJkcmFnUHJlZGljYXRlIiwiZ2V0RGF0YSIsImUiLCJzdGFydFgiLCJzdGFydFkiLCJpbml0aWFsRXZlbnQiLCJkZWx0YVgiLCJjbGllbnRYIiwiZGVsdGFZIiwiY2xpZW50WSIsImNvbnNvbGUiLCJsb2ciLCJzdGF0ZSIsInNldFN0YXRlIiwiZGlzdGFuY2UiLCJNYXRoIiwic3FydCIsInBvdyIsImV2ZW50IiwiaGFuZGxlRXZlbnQiLCJoYW5kbGVNb3ZlIiwiZGF0YSIsImhhbmRsZVVwIiwiZG9jdW1lbnQiLCJhZGRFdmVudExpc3RlbmVyIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsInN0YXJ0RHJhZ2dpbmciLCJkcmFnUHJvcHMiLCJvblBvaW50ZXJEb3duIiwibm93IiwiRGF0ZSIsIm5hdGl2ZUV2ZW50IiwicG9pbnRlckRvd25QcmV2ZW50RGVmYXVsdCIsInBvaW50ZXJEb3duU3RvcFByb3BhZ2F0aW9uIiwib25CZWZvcmVTdGFydCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./features/editor/hooks/use-pointer-drag.tsx\n"));

/***/ })

});
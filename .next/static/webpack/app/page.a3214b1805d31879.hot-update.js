"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./features/editor/services/ai-service.ts":
/*!************************************************!*\
  !*** ./features/editor/services/ai-service.ts ***!
  \************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AIService: function() { return /* binding */ AIService; }\n/* harmony export */ });\n/**\n * Servicio para manejar la comunicación con la IA.\n * Esta es una implementación base que simula respuestas.\n * En el futuro, se conectará con una API real.\n */ class AIService {\n    /**\n   * Analiza los elementos seleccionados para buscar URLs\n   */ static async analyzeItems(request) {\n        try {\n            // Simulamos un tiempo de respuesta de la API\n            await new Promise((resolve)=>setTimeout(resolve, 800));\n            console.log(\"AI Service - Request:\", request);\n            // Extraer el texto relevante de los elementos seleccionados\n            const elementsText = this.extractTextFromElements(request.items);\n            // Mensaje explícito o texto extraído de los elementos\n            const textToAnalyze = request.message || elementsText;\n            // Analizar si el texto contiene URLs\n            const urlAnalysis = this.detectURLs(textToAnalyze);\n            // Análisis de intención (solo si hay un mensaje explícito)\n            let intentAnalysis = null;\n            let screenshotInfo = null;\n            if (request.message && urlAnalysis.containsURLs) {\n                // Realizar la petición a la API para analizar la intención\n                try {\n                    const intentResponse = await this.callScreenshotIntentAPI(request.message, urlAnalysis.urls);\n                    // Guardar el análisis de intención\n                    intentAnalysis = intentResponse.intentAnalysis;\n                    // Si se detectó la intención y hay screenshot disponible, guardar la info\n                    if (intentResponse.screenshot) {\n                        screenshotInfo = intentResponse.screenshot;\n                        // Guardar la información de screenshot en el análisis de URL\n                        // pero SOLO si realmente se detectó la intención de ver un screenshot\n                        if (!urlAnalysis.screenshots) {\n                            urlAnalysis.screenshots = [];\n                        }\n                        // Añadir solo el screenshot específico que se solicitó\n                        if (!urlAnalysis.screenshots.some((s)=>s.url === screenshotInfo.url)) {\n                            urlAnalysis.screenshots.push(screenshotInfo);\n                        }\n                    }\n                } catch (error) {\n                    console.error(\"Error al llamar a la API de intenci\\xf3n:\", error);\n                // Si falla, continuar sin análisis de intención\n                }\n            }\n            // Simulación de respuesta de la IA\n            // En un entorno real, esto enviaría la solicitud a un endpoint de API\n            return {\n                success: true,\n                message: \"An\\xe1lisis completado con \\xe9xito\",\n                analysis: {\n                    summary: this.generateURLAnalysisSummary(urlAnalysis, request.items.length),\n                    urlAnalysis: urlAnalysis,\n                    itemsAnalyzed: request.items.length,\n                    analyzedText: textToAnalyze,\n                    recommendations: this.generateRecommendations(urlAnalysis),\n                    intentAnalysis: intentAnalysis,\n                    confidence: 0.95\n                }\n            };\n        } catch (error) {\n            console.error(\"Error in AI service:\", error);\n            return {\n                success: false,\n                message: \"Error al procesar la solicitud\",\n                error: error instanceof Error ? error.message : String(error)\n            };\n        }\n    }\n    /**\n   * Llama a la API para analizar la intención de ver screenshots\n   */ static async callScreenshotIntentAPI(message, urls) {\n        const response = await fetch(\"/api/screenshot\", {\n            method: \"POST\",\n            headers: {\n                \"Content-Type\": \"application/json\"\n            },\n            body: JSON.stringify({\n                message,\n                urls\n            })\n        });\n        if (!response.ok) {\n            throw new Error(\"Error en la API: \".concat(response.status));\n        }\n        return await response.json();\n    }\n    /**\n   * Detecta URLs en un texto\n   */ static detectURLs(text) {\n        // Expresión regular mejorada para capturar una variedad más amplia de URLs\n        // Esta regex busca URLs con diversos dominios de nivel superior (.com, .org, .ai, etc.)\n        const urlRegex = /(?:https?:\\/\\/)?(?:www\\.)?[-a-zA-Z0-9@:%._\\+~#=]{1,256}\\.[a-zA-Z0-9()]{1,6}\\b(?:[-a-zA-Z0-9()@:%_\\+.~#?&//=]*)/gi;\n        const matches = text.match(urlRegex) || [];\n        // Filtrar posibles falsos positivos (como números de versión: 1.0, etc.)\n        const validUrls = matches.filter((url)=>{\n            // Verificar que el dominio tenga al menos un punto y caracteres alfanuméricos\n            const domainParts = url.split(\".\");\n            // Debe tener al menos un punto y el TLD debe tener al menos 2 caracteres\n            return domainParts.length >= 2 && domainParts[domainParts.length - 1].length >= 2;\n        });\n        return {\n            containsURLs: validUrls.length > 0,\n            urls: validUrls\n        };\n    }\n    /**\n   * Extrae texto de los elementos seleccionados\n   */ static extractTextFromElements(items) {\n        // Aquí extraemos el texto de los elementos seleccionados\n        // En un caso real, esto dependería de la estructura de tus elementos\n        let extractedText = \"\";\n        for (const item of items){\n            var _item_details, _item_details1, _item_details2;\n            // Intentar extraer texto de diferentes propiedades comunes\n            // Esto es un ejemplo y debería adaptarse a tu estructura de datos real\n            if (item.text) {\n                extractedText += \" \" + item.text;\n            } else if ((_item_details = item.details) === null || _item_details === void 0 ? void 0 : _item_details.text) {\n                extractedText += \" \" + item.details.text;\n            } else if (item.name) {\n                extractedText += \" \" + item.name;\n            } else if (item.title) {\n                extractedText += \" \" + item.title;\n            } else if (item.description) {\n                extractedText += \" \" + item.description;\n            } else if ((_item_details1 = item.details) === null || _item_details1 === void 0 ? void 0 : _item_details1.description) {\n                extractedText += \" \" + item.details.description;\n            } else if ((_item_details2 = item.details) === null || _item_details2 === void 0 ? void 0 : _item_details2.src) {\n                extractedText += \" \" + item.details.src;\n            } else if (item.src) {\n                extractedText += \" \" + item.src;\n            } else if (item.content) {\n                extractedText += \" \" + item.content;\n            } else if (item.label) {\n                extractedText += \" \" + item.label;\n            } else if (item.value) {\n                extractedText += \" \" + item.value;\n            } else if (typeof item === \"string\") {\n                extractedText += \" \" + item;\n            }\n            // También podemos buscar en atributos anidados\n            if (item.props && typeof item.props === \"object\") {\n                for(const key in item.props){\n                    if (typeof item.props[key] === \"string\") {\n                        extractedText += \" \" + item.props[key];\n                    }\n                }\n            }\n            // Si todavía no hemos encontrado texto, intentamos convertir el objeto a string\n            if (extractedText.trim() === \"\" && item.toString) {\n                const str = item.toString();\n                if (str !== \"[object Object]\") {\n                    extractedText += \" \" + str;\n                }\n            }\n        }\n        return extractedText.trim();\n    }\n    /**\n   * Genera un resumen basado en el análisis de URLs\n   */ static generateURLAnalysisSummary(analysis, itemCount) {\n        if (analysis.containsURLs) {\n            const urlCount = analysis.urls.length;\n            return \"He analizado el contenido de \".concat(itemCount, \" elemento\").concat(itemCount !== 1 ? \"s\" : \"\", \" y encontrado \").concat(urlCount, \" URL\").concat(urlCount !== 1 ? \"s\" : \"\", \".\");\n        } else {\n            return \"He analizado el contenido de \".concat(itemCount, \" elemento\").concat(itemCount !== 1 ? \"s\" : \"\", \" y no he encontrado ninguna URL.\");\n        }\n    }\n    /**\n   * Genera recomendaciones basadas en el análisis de URLs\n   */ static generateRecommendations(analysis) {\n        if (analysis.containsURLs) {\n            return [\n                \"Considere verificar si las URLs son seguras antes de utilizarlas.\",\n                \"Aseg\\xfarese de que las URLs est\\xe9n activas y funcionen correctamente.\",\n                \"Considere revisar si los enlaces apuntan a los recursos deseados.\",\n                \"Para ver capturas de pantalla de las URLs, preg\\xfantame 'muestra el screenshot de <url>'\"\n            ];\n        } else {\n            return [\n                \"El contenido no contiene URLs. Si necesita incluir referencias web, considere a\\xf1adirlas.\",\n                \"Puede a\\xf1adir enlaces a recursos adicionales para enriquecer el contenido.\"\n            ];\n        }\n    }\n}\n/* harmony default export */ __webpack_exports__[\"default\"] = (AIService);\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2ZlYXR1cmVzL2VkaXRvci9zZXJ2aWNlcy9haS1zZXJ2aWNlLnRzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTs7OztDQUlDLEdBa0NNLE1BQU1BO0lBQ1g7O0dBRUMsR0FDRCxhQUFvQkMsYUFBYUMsT0FBMEIsRUFBK0I7UUFDeEYsSUFBSTtZQUNGLDZDQUE2QztZQUM3QyxNQUFNLElBQUlDLFFBQVFDLENBQUFBLFVBQVdDLFdBQVdELFNBQVM7WUFFakRFLFFBQVFDLEdBQUcsQ0FBQyx5QkFBeUJMO1lBRXJDLDREQUE0RDtZQUM1RCxNQUFNTSxlQUFlLElBQUksQ0FBQ0MsdUJBQXVCLENBQUNQLFFBQVFRLEtBQUs7WUFFL0Qsc0RBQXNEO1lBQ3RELE1BQU1DLGdCQUFnQlQsUUFBUVUsT0FBTyxJQUFJSjtZQUV6QyxxQ0FBcUM7WUFDckMsTUFBTUssY0FBYyxJQUFJLENBQUNDLFVBQVUsQ0FBQ0g7WUFFcEMsMkRBQTJEO1lBQzNELElBQUlJLGlCQUFpQjtZQUNyQixJQUFJQyxpQkFBaUI7WUFFckIsSUFBSWQsUUFBUVUsT0FBTyxJQUFJQyxZQUFZSSxZQUFZLEVBQUU7Z0JBQy9DLDJEQUEyRDtnQkFDM0QsSUFBSTtvQkFDRixNQUFNQyxpQkFBaUIsTUFBTSxJQUFJLENBQUNDLHVCQUF1QixDQUFDakIsUUFBUVUsT0FBTyxFQUFFQyxZQUFZTyxJQUFJO29CQUUzRixtQ0FBbUM7b0JBQ25DTCxpQkFBaUJHLGVBQWVILGNBQWM7b0JBRTlDLDBFQUEwRTtvQkFDMUUsSUFBSUcsZUFBZUcsVUFBVSxFQUFFO3dCQUM3QkwsaUJBQWlCRSxlQUFlRyxVQUFVO3dCQUUxQyw2REFBNkQ7d0JBQzdELHNFQUFzRTt3QkFDdEUsSUFBSSxDQUFDUixZQUFZUyxXQUFXLEVBQUU7NEJBQzVCVCxZQUFZUyxXQUFXLEdBQUcsRUFBRTt3QkFDOUI7d0JBRUEsdURBQXVEO3dCQUN2RCxJQUFJLENBQUNULFlBQVlTLFdBQVcsQ0FBQ0MsSUFBSSxDQUFDQyxD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SUMsUUFBUSxtQkFBbUI7b0JBQzdCZCxpQkFBaUIsTUFBTWM7Z0JBQ3pCO1lBQ0Y7UUFDRjtRQUVBLE9BQU9kLGNBQWNZLElBQUk7SUFDM0I7SUFFQTs7R0FFQyxHQUNELE9BQWV2QywyQkFBMkJGLFFBQTJCLEVBQUU0QyxTQUFpQixFQUFVO1FBQ2hHLElBQUk1QyxTQUFTWixZQUFZLEVBQUU7WUFDekIsTUFBTXlELFdBQVc3QyxTQUFTVCxJQUFJLENBQUNZLE1BQU07WUFDckMsT0FBTyxnQ0FBcUR5QyxPQUFyQkEsV0FBVSxhQUFzREMsT0FBM0NELGNBQWMsSUFBSSxNQUFNLElBQUcsa0JBQStCQyxPQUFmQSxVQUFTLFFBQWdDLE9BQTFCQSxhQUFhLElBQUksTUFBTSxJQUFHO1FBQ2xKLE9BQU87WUFDTCxPQUFPLGdDQUFxREQsT0FBckJBLFdBQVUsYUFBc0MsT0FBM0JBLGNBQWMsSUFBSSxNQUFNLElBQUc7UUFDekY7SUFDRjtJQUVBOztHQUVDLEdBQ0QsT0FBZXJDLHdCQUF3QlAsUUFBMkIsRUFBWTtRQUM1RSxJQUFJQSxTQUFTWixZQUFZLEVBQUU7WUFDekIsT0FBTztnQkFDTDtnQkFDQTtnQkFDQTtnQkFDQTthQUNEO1FBQ0gsT0FBTztZQUNMLE9BQU87Z0JBQ0w7Z0JBQ0E7YUFDRDtRQUNIO0lBQ0Y7QUFDRjtBQUVBLCtEQUFlakIsU0FBU0EsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9mZWF0dXJlcy9lZGl0b3Ivc2VydmljZXMvYWktc2VydmljZS50cz8wYWUyIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogU2VydmljaW8gcGFyYSBtYW5lamFyIGxhIGNvbXVuaWNhY2nDs24gY29uIGxhIElBLlxuICogRXN0YSBlcyB1bmEgaW1wbGVtZW50YWNpw7NuIGJhc2UgcXVlIHNpbXVsYSByZXNwdWVzdGFzLlxuICogRW4gZWwgZnV0dXJvLCBzZSBjb25lY3RhcsOhIGNvbiB1bmEgQVBJIHJlYWwuXG4gKi9cblxuaW50ZXJmYWNlIEFJQW5hbHlzaXNSZXF1ZXN0IHtcbiAgbWVzc2FnZT86IHN0cmluZztcbiAgaXRlbXM6IGFueVtdOyAvLyBMb3MgZWxlbWVudG9zIHNlbGVjY2lvbmFkb3MgZW4gbGEgdGltZWxpbmVcbiAgY29udGV4dD86IGFueTsgLy8gSW5mb3JtYWNpw7NuIGRlIGNvbnRleHRvIGFkaWNpb25hbFxufVxuXG5pbnRlcmZhY2UgQUlBbmFseXNpc1Jlc3BvbnNlIHtcbiAgc3VjY2VzczogYm9vbGVhbjtcbiAgbWVzc2FnZTogc3RyaW5nO1xuICBhbmFseXNpcz86IGFueTsgLy8gQW7DoWxpc2lzIGRldGFsbGFkbyBkZSBsYSBJQVxuICBlcnJvcj86IHN0cmluZztcbn1cblxuaW50ZXJmYWNlIFVSTEFuYWx5c2lzUmVzdWx0IHtcbiAgY29udGFpbnNVUkxzOiBib29sZWFuO1xuICB1cmxzOiBzdHJpbmdbXTtcbiAgc2NyZWVuc2hvdHM/OiBVUkxTY3JlZW5zaG90SW5mb1tdOyAvLyBJbmZvcm1hY2nDs24gZGUgc2NyZWVuc2hvdHMgcGFyYSBsYXMgVVJMcyAoc29sbyBzZSBsbGVuYW4gc2kgbGEgSUEgZGV0ZWN0YSBpbnRlbmNpw7NuKVxufVxuXG5pbnRlcmZhY2UgVVJMU2NyZWVuc2hvdEluZm8ge1xuICB1cmw6IHN0cmluZztcbiAgc2NyZWVuc2hvdFBhdGg6IHN0cmluZztcbn1cblxuaW50ZXJmYWNlIEludGVudEFuYWx5c2lzUmVzdWx0IHtcbiAgaGFzSW50ZW50OiBib29sZWFuO1xuICBpbnRlbnQ6IHN0cmluZztcbiAgY29uZmlkZW5jZTogbnVtYmVyO1xuICB0YXJnZXQ/OiBzdHJpbmc7IC8vIFBvciBlamVtcGxvLCB1bmEgVVJMIGVzcGVjw61maWNhXG4gIGFjdGlvbj86IHN0cmluZzsgLy8gQWNjacOzbiBhIHJlYWxpemFyXG59XG5cbmV4cG9ydCBjbGFzcyBBSVNlcnZpY2Uge1xuICAvKipcbiAgICogQW5hbGl6YSBsb3MgZWxlbWVudG9zIHNlbGVjY2lvbmFkb3MgcGFyYSBidXNjYXIgVVJMc1xuICAgKi9cbiAgcHVibGljIHN0YXRpYyBhc3luYyBhbmFseXplSXRlbXMocmVxdWVzdDogQUlBbmFseXNpc1JlcXVlc3QpOiBQcm9taXNlPEFJQW5hbHlzaXNSZXNwb25zZT4ge1xuICAgIHRyeSB7XG4gICAgICAvLyBTaW11bGFtb3MgdW4gdGllbXBvIGRlIHJlc3B1ZXN0YSBkZSBsYSBBUElcbiAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCA4MDApKTtcblxuICAgICAgY29uc29sZS5sb2coJ0FJIFNlcnZpY2UgLSBSZXF1ZXN0OicsIHJlcXVlc3QpO1xuXG4gICAgICAvLyBFeHRyYWVyIGVsIHRleHRvIHJlbGV2YW50ZSBkZSBsb3MgZWxlbWVudG9zIHNlbGVjY2lvbmFkb3NcbiAgICAgIGNvbnN0IGVsZW1lbnRzVGV4dCA9IHRoaXMuZXh0cmFjdFRleHRGcm9tRWxlbWVudHMocmVxdWVzdC5pdGVtcyk7XG5cbiAgICAgIC8vIE1lbnNhamUgZXhwbMOtY2l0byBvIHRleHRvIGV4dHJhw61kbyBkZSBsb3MgZWxlbWVudG9zXG4gICAgICBjb25zdCB0ZXh0VG9BbmFseXplID0gcmVxdWVzdC5tZXNzYWdlIHx8IGVsZW1lbnRzVGV4dDtcblxuICAgICAgLy8gQW5hbGl6YXIgc2kgZWwgdGV4dG8gY29udGllbmUgVVJMc1xuICAgICAgY29uc3QgdXJsQW5hbHlzaXMgPSB0aGlzLmRldGVjdFVSTHModGV4dFRvQW5hbHl6ZSk7XG5cbiAgICAgIC8vIEFuw6FsaXNpcyBkZSBpbnRlbmNpw7NuIChzb2xvIHNpIGhheSB1biBtZW5zYWplIGV4cGzDrWNpdG8pXG4gICAgICBsZXQgaW50ZW50QW5hbHlzaXMgPSBudWxsO1xuICAgICAgbGV0IHNjcmVlbnNob3RJbmZvID0gbnVsbDtcblxuICAgICAgaWYgKHJlcXVlc3QubWVzc2FnZSAmJiB1cmxBbmFseXNpcy5jb250YWluc1VSTHMpIHtcbiAgICAgICAgLy8gUmVhbGl6YXIgbGEgcGV0aWNpw7NuIGEgbGEgQVBJIHBhcmEgYW5hbGl6YXIgbGEgaW50ZW5jacOzblxuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnN0IGludGVudFJlc3BvbnNlID0gYXdhaXQgdGhpcy5jYWxsU2NyZWVuc2hvdEludGVudEFQSShyZXF1ZXN0Lm1lc3NhZ2UsIHVybEFuYWx5c2lzLnVybHMpO1xuXG4gICAgICAgICAgLy8gR3VhcmRhciBlbCBhbsOhbGlzaXMgZGUgaW50ZW5jacOzblxuICAgICAgICAgIGludGVudEFuYWx5c2lzID0gaW50ZW50UmVzcG9uc2UuaW50ZW50QW5hbHlzaXM7XG5cbiAgICAgICAgICAvLyBTaSBzZSBkZXRlY3TDsyBsYSBpbnRlbmNpw7NuIHkgaGF5IHNjcmVlbnNob3QgZGlzcG9uaWJsZSwgZ3VhcmRhciBsYSBpbmZvXG4gICAgICAgICAgaWYgKGludGVudFJlc3BvbnNlLnNjcmVlbnNob3QpIHtcbiAgICAgICAgICAgIHNjcmVlbnNob3RJbmZvID0gaW50ZW50UmVzcG9uc2Uuc2NyZWVuc2hvdDtcblxuICAgICAgICAgICAgLy8gR3VhcmRhciBsYSBpbmZvcm1hY2nDs24gZGUgc2NyZWVuc2hvdCBlbiBlbCBhbsOhbGlzaXMgZGUgVVJMXG4gICAgICAgICAgICAvLyBwZXJvIFNPTE8gc2kgcmVhbG1lbnRlIHNlIGRldGVjdMOzIGxhIGludGVuY2nDs24gZGUgdmVyIHVuIHNjcmVlbnNob3RcbiAgICAgICAgICAgIGlmICghdXJsQW5hbHlzaXMuc2NyZWVuc2hvdHMpIHtcbiAgICAgICAgICAgICAgdXJsQW5hbHlzaXMuc2NyZWVuc2hvdHMgPSBbXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gQcOxYWRpciBzb2xvIGVsIHNjcmVlbnNob3QgZXNwZWPDrWZpY28gcXVlIHNlIHNvbGljaXTDs1xuICAgICAgICAgICAgaWYgKCF1cmxBbmFseXNpcy5zY3JlZW5zaG90cy5zb21lKHMgPT4gcy51cmwgPT09IHNjcmVlbnNob3RJbmZvLnVybCkpIHtcbiAgICAgICAgICAgICAgdXJsQW5hbHlzaXMuc2NyZWVuc2hvdHMucHVzaChzY3JlZW5zaG90SW5mbyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGFsIGxsYW1hciBhIGxhIEFQSSBkZSBpbnRlbmNpw7NuOicsIGVycm9yKTtcbiAgICAgICAgICAvLyBTaSBmYWxsYSwgY29udGludWFyIHNpbiBhbsOhbGlzaXMgZGUgaW50ZW5jacOzblxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFNpbXVsYWNpw7NuIGRlIHJlc3B1ZXN0YSBkZSBsYSBJQVxuICAgICAgLy8gRW4gdW4gZW50b3JubyByZWFsLCBlc3RvIGVudmlhcsOtYSBsYSBzb2xpY2l0dWQgYSB1biBlbmRwb2ludCBkZSBBUElcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgICAgIG1lc3NhZ2U6IFwiQW7DoWxpc2lzIGNvbXBsZXRhZG8gY29uIMOpeGl0b1wiLFxuICAgICAgICBhbmFseXNpczoge1xuICAgICAgICAgIHN1bW1hcnk6IHRoaXMuZ2VuZXJhdGVVUkxBbmFseXNpc1N1bW1hcnkodXJsQW5hbHlzaXMsIHJlcXVlc3QuaXRlbXMubGVuZ3RoKSxcbiAgICAgICAgICB1cmxBbmFseXNpczogdXJsQW5hbHlzaXMsXG4gICAgICAgICAgaXRlbXNBbmFseXplZDogcmVxdWVzdC5pdGVtcy5sZW5ndGgsXG4gICAgICAgICAgYW5hbHl6ZWRUZXh0OiB0ZXh0VG9BbmFseXplLFxuICAgICAgICAgIHJlY29tbWVuZGF0aW9uczogdGhpcy5nZW5lcmF0ZVJlY29tbWVuZGF0aW9ucyh1cmxBbmFseXNpcyksXG4gICAgICAgICAgaW50ZW50QW5hbHlzaXM6IGludGVudEFuYWx5c2lzLFxuICAgICAgICAgIGNvbmZpZGVuY2U6IDAuOTVcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgaW4gQUkgc2VydmljZTonLCBlcnJvcik7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgbWVzc2FnZTogXCJFcnJvciBhbCBwcm9jZXNhciBsYSBzb2xpY2l0dWRcIixcbiAgICAgICAgZXJyb3I6IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogU3RyaW5nKGVycm9yKVxuICAgICAgfTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogTGxhbWEgYSBsYSBBUEkgcGFyYSBhbmFsaXphciBsYSBpbnRlbmNpw7NuIGRlIHZlciBzY3JlZW5zaG90c1xuICAgKi9cbiAgcHJpdmF0ZSBzdGF0aWMgYXN5bmMgY2FsbFNjcmVlbnNob3RJbnRlbnRBUEkobWVzc2FnZTogc3RyaW5nLCB1cmxzOiBzdHJpbmdbXSkge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goJy9hcGkvc2NyZWVuc2hvdCcsIHtcbiAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgaGVhZGVyczoge1xuICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgfSxcbiAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgbWVzc2FnZSxcbiAgICAgICAgdXJsc1xuICAgICAgfSksXG4gICAgfSk7XG5cbiAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEVycm9yIGVuIGxhIEFQSTogJHtyZXNwb25zZS5zdGF0dXN9YCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXRlY3RhIFVSTHMgZW4gdW4gdGV4dG9cbiAgICovXG4gIHByaXZhdGUgc3RhdGljIGRldGVjdFVSTHModGV4dDogc3RyaW5nKTogVVJMQW5hbHlzaXNSZXN1bHQge1xuICAgIC8vIEV4cHJlc2nDs24gcmVndWxhciBtZWpvcmFkYSBwYXJhIGNhcHR1cmFyIHVuYSB2YXJpZWRhZCBtw6FzIGFtcGxpYSBkZSBVUkxzXG4gICAgLy8gRXN0YSByZWdleCBidXNjYSBVUkxzIGNvbiBkaXZlcnNvcyBkb21pbmlvcyBkZSBuaXZlbCBzdXBlcmlvciAoLmNvbSwgLm9yZywgLmFpLCBldGMuKVxuICAgIGNvbnN0IHVybFJlZ2V4ID0gLyg/Omh0dHBzPzpcXC9cXC8pPyg/Ond3d1xcLik/Wy1hLXpBLVowLTlAOiUuX1xcK34jPV17MSwyNTZ9XFwuW2EtekEtWjAtOSgpXXsxLDZ9XFxiKD86Wy1hLXpBLVowLTkoKUA6JV9cXCsufiM/Ji8vPV0qKS9naTtcblxuICAgIGNvbnN0IG1hdGNoZXMgPSB0ZXh0Lm1hdGNoKHVybFJlZ2V4KSB8fCBbXTtcblxuICAgIC8vIEZpbHRyYXIgcG9zaWJsZXMgZmFsc29zIHBvc2l0aXZvcyAoY29tbyBuw7ptZXJvcyBkZSB2ZXJzacOzbjogMS4wLCBldGMuKVxuICAgIGNvbnN0IHZhbGlkVXJscyA9IG1hdGNoZXMuZmlsdGVyKHVybCA9PiB7XG4gICAgICAvLyBWZXJpZmljYXIgcXVlIGVsIGRvbWluaW8gdGVuZ2EgYWwgbWVub3MgdW4gcHVudG8geSBjYXJhY3RlcmVzIGFsZmFudW3DqXJpY29zXG4gICAgICBjb25zdCBkb21haW5QYXJ0cyA9IHVybC5zcGxpdCgnLicpO1xuICAgICAgLy8gRGViZSB0ZW5lciBhbCBtZW5vcyB1biBwdW50byB5IGVsIFRMRCBkZWJlIHRlbmVyIGFsIG1lbm9zIDIgY2FyYWN0ZXJlc1xuICAgICAgcmV0dXJuIGRvbWFpblBhcnRzLmxlbmd0aCA+PSAyICYmIGRvbWFpblBhcnRzW2RvbWFpblBhcnRzLmxlbmd0aCAtIDFdLmxlbmd0aCA+PSAyO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIGNvbnRhaW5zVVJMczogdmFsaWRVcmxzLmxlbmd0aCA+IDAsXG4gICAgICB1cmxzOiB2YWxpZFVybHNcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIEV4dHJhZSB0ZXh0byBkZSBsb3MgZWxlbWVudG9zIHNlbGVjY2lvbmFkb3NcbiAgICovXG4gIHByaXZhdGUgc3RhdGljIGV4dHJhY3RUZXh0RnJvbUVsZW1lbnRzKGl0ZW1zOiBhbnlbXSk6IHN0cmluZyB7XG4gICAgLy8gQXF1w60gZXh0cmFlbW9zIGVsIHRleHRvIGRlIGxvcyBlbGVtZW50b3Mgc2VsZWNjaW9uYWRvc1xuICAgIC8vIEVuIHVuIGNhc28gcmVhbCwgZXN0byBkZXBlbmRlcsOtYSBkZSBsYSBlc3RydWN0dXJhIGRlIHR1cyBlbGVtZW50b3NcbiAgICBsZXQgZXh0cmFjdGVkVGV4dCA9IFwiXCI7XG5cbiAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgaXRlbXMpIHtcbiAgICAgIC8vIEludGVudGFyIGV4dHJhZXIgdGV4dG8gZGUgZGlmZXJlbnRlcyBwcm9waWVkYWRlcyBjb211bmVzXG4gICAgICAvLyBFc3RvIGVzIHVuIGVqZW1wbG8geSBkZWJlcsOtYSBhZGFwdGFyc2UgYSB0dSBlc3RydWN0dXJhIGRlIGRhdG9zIHJlYWxcbiAgICAgIGlmIChpdGVtLnRleHQpIHtcbiAgICAgICAgZXh0cmFjdGVkVGV4dCArPSBcIiBcIiArIGl0ZW0udGV4dDtcbiAgICAgIH0gZWxzZSBpZiAoaXRlbS5kZXRhaWxzPy50ZXh0KSB7XG4gICAgICAgIGV4dHJhY3RlZFRleHQgKz0gXCIgXCIgKyBpdGVtLmRldGFpbHMudGV4dDtcbiAgICAgIH0gZWxzZSBpZiAoaXRlbS5uYW1lKSB7XG4gICAgICAgIGV4dHJhY3RlZFRleHQgKz0gXCIgXCIgKyBpdGVtLm5hbWU7XG4gICAgICB9IGVsc2UgaWYgKGl0ZW0udGl0bGUpIHtcbiAgICAgICAgZXh0cmFjdGVkVGV4dCArPSBcIiBcIiArIGl0ZW0udGl0bGU7XG4gICAgICB9IGVsc2UgaWYgKGl0ZW0uZGVzY3JpcHRpb24pIHtcbiAgICAgICAgZXh0cmFjdGVkVGV4dCArPSBcIiBcIiArIGl0ZW0uZGVzY3JpcHRpb247XG4gICAgICB9IGVsc2UgaWYgKGl0ZW0uZGV0YWlscz8uZGVzY3JpcHRpb24pIHtcbiAgICAgICAgZXh0cmFjdGVkVGV4dCArPSBcIiBcIiArIGl0ZW0uZGV0YWlscy5kZXNjcmlwdGlvbjtcbiAgICAgIH0gZWxzZSBpZiAoaXRlbS5kZXRhaWxzPy5zcmMpIHtcbiAgICAgICAgZXh0cmFjdGVkVGV4dCArPSBcIiBcIiArIGl0ZW0uZGV0YWlscy5zcmM7XG4gICAgICB9IGVsc2UgaWYgKGl0ZW0uc3JjKSB7XG4gICAgICAgIGV4dHJhY3RlZFRleHQgKz0gXCIgXCIgKyBpdGVtLnNyYztcbiAgICAgIH0gZWxzZSBpZiAoaXRlbS5jb250ZW50KSB7XG4gICAgICAgIGV4dHJhY3RlZFRleHQgKz0gXCIgXCIgKyBpdGVtLmNvbnRlbnQ7XG4gICAgICB9IGVsc2UgaWYgKGl0ZW0ubGFiZWwpIHtcbiAgICAgICAgZXh0cmFjdGVkVGV4dCArPSBcIiBcIiArIGl0ZW0ubGFiZWw7XG4gICAgICB9IGVsc2UgaWYgKGl0ZW0udmFsdWUpIHtcbiAgICAgICAgZXh0cmFjdGVkVGV4dCArPSBcIiBcIiArIGl0ZW0udmFsdWU7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBpdGVtID09PSAnc3RyaW5nJykge1xuICAgICAgICBleHRyYWN0ZWRUZXh0ICs9IFwiIFwiICsgaXRlbTtcbiAgICAgIH1cblxuICAgICAgLy8gVGFtYmnDqW4gcG9kZW1vcyBidXNjYXIgZW4gYXRyaWJ1dG9zIGFuaWRhZG9zXG4gICAgICBpZiAoaXRlbS5wcm9wcyAmJiB0eXBlb2YgaXRlbS5wcm9wcyA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gaXRlbS5wcm9wcykge1xuICAgICAgICAgIGlmICh0eXBlb2YgaXRlbS5wcm9wc1trZXldID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgZXh0cmFjdGVkVGV4dCArPSBcIiBcIiArIGl0ZW0ucHJvcHNba2V5XTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gU2kgdG9kYXbDrWEgbm8gaGVtb3MgZW5jb250cmFkbyB0ZXh0bywgaW50ZW50YW1vcyBjb252ZXJ0aXIgZWwgb2JqZXRvIGEgc3RyaW5nXG4gICAgICBpZiAoZXh0cmFjdGVkVGV4dC50cmltKCkgPT09IFwiXCIgJiYgaXRlbS50b1N0cmluZykge1xuICAgICAgICBjb25zdCBzdHIgPSBpdGVtLnRvU3RyaW5nKCk7XG4gICAgICAgIGlmIChzdHIgIT09IFwiW29iamVjdCBPYmplY3RdXCIpIHtcbiAgICAgICAgICBleHRyYWN0ZWRUZXh0ICs9IFwiIFwiICsgc3RyO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGV4dHJhY3RlZFRleHQudHJpbSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYSB1biByZXN1bWVuIGJhc2FkbyBlbiBlbCBhbsOhbGlzaXMgZGUgVVJMc1xuICAgKi9cbiAgcHJpdmF0ZSBzdGF0aWMgZ2VuZXJhdGVVUkxBbmFseXNpc1N1bW1hcnkoYW5hbHlzaXM6IFVSTEFuYWx5c2lzUmVzdWx0LCBpdGVtQ291bnQ6IG51bWJlcik6IHN0cmluZyB7XG4gICAgaWYgKGFuYWx5c2lzLmNvbnRhaW5zVVJMcykge1xuICAgICAgY29uc3QgdXJsQ291bnQgPSBhbmFseXNpcy51cmxzLmxlbmd0aDtcbiAgICAgIHJldHVybiBgSGUgYW5hbGl6YWRvIGVsIGNvbnRlbmlkbyBkZSAke2l0ZW1Db3VudH0gZWxlbWVudG8ke2l0ZW1Db3VudCAhPT0gMSA/ICdzJyA6ICcnfSB5IGVuY29udHJhZG8gJHt1cmxDb3VudH0gVVJMJHt1cmxDb3VudCAhPT0gMSA/ICdzJyA6ICcnfS5gO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gYEhlIGFuYWxpemFkbyBlbCBjb250ZW5pZG8gZGUgJHtpdGVtQ291bnR9IGVsZW1lbnRvJHtpdGVtQ291bnQgIT09IDEgPyAncycgOiAnJ30geSBubyBoZSBlbmNvbnRyYWRvIG5pbmd1bmEgVVJMLmA7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYSByZWNvbWVuZGFjaW9uZXMgYmFzYWRhcyBlbiBlbCBhbsOhbGlzaXMgZGUgVVJMc1xuICAgKi9cbiAgcHJpdmF0ZSBzdGF0aWMgZ2VuZXJhdGVSZWNvbW1lbmRhdGlvbnMoYW5hbHlzaXM6IFVSTEFuYWx5c2lzUmVzdWx0KTogc3RyaW5nW10ge1xuICAgIGlmIChhbmFseXNpcy5jb250YWluc1VSTHMpIHtcbiAgICAgIHJldHVybiBbXG4gICAgICAgIFwiQ29uc2lkZXJlIHZlcmlmaWNhciBzaSBsYXMgVVJMcyBzb24gc2VndXJhcyBhbnRlcyBkZSB1dGlsaXphcmxhcy5cIixcbiAgICAgICAgXCJBc2Vnw7pyZXNlIGRlIHF1ZSBsYXMgVVJMcyBlc3TDqW4gYWN0aXZhcyB5IGZ1bmNpb25lbiBjb3JyZWN0YW1lbnRlLlwiLFxuICAgICAgICBcIkNvbnNpZGVyZSByZXZpc2FyIHNpIGxvcyBlbmxhY2VzIGFwdW50YW4gYSBsb3MgcmVjdXJzb3MgZGVzZWFkb3MuXCIsXG4gICAgICAgIFwiUGFyYSB2ZXIgY2FwdHVyYXMgZGUgcGFudGFsbGEgZGUgbGFzIFVSTHMsIHByZWfDum50YW1lICdtdWVzdHJhIGVsIHNjcmVlbnNob3QgZGUgPHVybD4nXCJcbiAgICAgIF07XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBbXG4gICAgICAgIFwiRWwgY29udGVuaWRvIG5vIGNvbnRpZW5lIFVSTHMuIFNpIG5lY2VzaXRhIGluY2x1aXIgcmVmZXJlbmNpYXMgd2ViLCBjb25zaWRlcmUgYcOxYWRpcmxhcy5cIixcbiAgICAgICAgXCJQdWVkZSBhw7FhZGlyIGVubGFjZXMgYSByZWN1cnNvcyBhZGljaW9uYWxlcyBwYXJhIGVucmlxdWVjZXIgZWwgY29udGVuaWRvLlwiXG4gICAgICBdO1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBBSVNlcnZpY2U7XG4iXSwibmFtZXMiOlsiQUlTZXJ2aWNlIiwiYW5hbHl6ZUl0ZW1zIiwicmVxdWVzdCIsIlByb21pc2UiLCJyZXNvbHZlIiwic2V0VGltZW91dCIsImNvbnNvbGUiLCJsb2ciLCJlbGVtZW50c1RleHQiLCJleHRyYWN0VGV4dEZyb21FbGVtZW50cyIsIml0ZW1zIiwidGV4dFRvQW5hbHl6ZSIsIm1lc3NhZ2UiLCJ1cmxBbmFseXNpcyIsImRldGVjdFVSTHMiLCJpbnRlbnRBbmFseXNpcyIsInNjcmVlbnNob3RJbmZvIiwiY29udGFpbnNVUkxzIiwiaW50ZW50UmVzcG9uc2UiLCJjYWxsU2NyZWVuc2hvdEludGVudEFQSSIsInVybHMiLCJzY3JlZW5zaG90Iiwic2NyZWVuc2hvdHMiLCJzb21lIiwicyIsInVybCIsInB1c2giLCJlcnJvciIsInN1Y2Nlc3MiLCJhbmFseXNpcyIsInN1bW1hcnkiLCJnZW5lcmF0ZVVSTEFuYWx5c2lzU3VtbWFyeSIsImxlbmd0aCIsIml0ZW1zQW5hbHl6ZWQiLCJhbmFseXplZFRleHQiLCJyZWNvbW1lbmRhdGlvbnMiLCJnZW5lcmF0ZVJlY29tbWVuZGF0aW9ucyIsImNvbmZpZGVuY2UiLCJFcnJvciIsIlN0cmluZyIsInJlc3BvbnNlIiwiZmV0Y2giLCJtZXRob2QiLCJoZWFkZXJzIiwiYm9keSIsIkpTT04iLCJzdHJpbmdpZnkiLCJvayIsInN0YXR1cyIsImpzb24iLCJ0ZXh0IiwidXJsUmVnZXgiLCJtYXRjaGVzIiwibWF0Y2giLCJ2YWxpZFVybHMiLCJmaWx0ZXIiLCJkb21haW5QYXJ0cyIsInNwbGl0IiwiZXh0cmFjdGVkVGV4dCIsIml0ZW0iLCJkZXRhaWxzIiwibmFtZSIsInRpdGxlIiwiZGVzY3JpcHRpb24iLCJzcmMiLCJjb250ZW50IiwibGFiZWwiLCJ2YWx1ZSIsInByb3BzIiwia2V5IiwidHJpbSIsInRvU3RyaW5nIiwic3RyIiwiaXRlbUNvdW50IiwidXJsQ291bnQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./features/editor/services/ai-service.ts\n"));

/***/ })

});
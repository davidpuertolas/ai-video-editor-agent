"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./features/editor/scene/interactions.tsx":
/*!************************************************!*\
  !*** ./features/editor/scene/interactions.tsx ***!
  \************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SceneInteractions: function() { return /* binding */ SceneInteractions; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _interactify_selection__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @interactify/selection */ \"(app-pages-browser)/./node_modules/@interactify/selection/dist/selecto.esm.js\");\n/* harmony import */ var _interactify_moveable__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @interactify/moveable */ \"(app-pages-browser)/./node_modules/@interactify/moveable/dist/index.es.js\");\n/* harmony import */ var _utils_scene__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/scene */ \"(app-pages-browser)/./features/editor/utils/scene.ts\");\n/* harmony import */ var _designcombo_events__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @designcombo/events */ \"(app-pages-browser)/./node_modules/@designcombo/events/dist/index.es.js\");\n/* harmony import */ var _designcombo_state__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @designcombo/state */ \"(app-pages-browser)/./node_modules/@designcombo/state/dist/index.es.js\");\n/* harmony import */ var _utils_target__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../utils/target */ \"(app-pages-browser)/./features/editor/utils/target.ts\");\n/* harmony import */ var _store_use_store__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../store/use-store */ \"(app-pages-browser)/./features/editor/store/use-store.ts\");\n/* harmony import */ var _utils_time__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../utils/time */ \"(app-pages-browser)/./features/editor/utils/time.ts\");\n/* harmony import */ var _store_use_layout_store__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../store/use-layout-store */ \"(app-pages-browser)/./features/editor/store/use-layout-store.ts\");\n/* __next_internal_client_entry_do_not_use__ SceneInteractions auto */ \nvar _s = $RefreshSig$();\n\n\n\n\n\n\n\n\n\n\nlet holdGroupPosition = null;\nlet dragStartEnd = false;\nfunction SceneInteractions(param) {\n    let { stateManager, viewerRef, zoom, size, containerRef } = param;\n    _s();\n    const [targets, setTargets] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]);\n    const [selection, setSelection] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)();\n    const { activeIds, setState, trackItemDetailsMap, trackItemsMap, playerRef, setSceneMoveableRef } = (0,_store_use_store__WEBPACK_IMPORTED_MODULE_7__[\"default\"])();\n    const { setActiveMenuItem, setShowMenuItem } = (0,_store_use_layout_store__WEBPACK_IMPORTED_MODULE_9__[\"default\"])();\n    const moveableRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const [selectionInfo, setSelectionInfo] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(_utils_target__WEBPACK_IMPORTED_MODULE_6__.emptySelection);\n    // Estado para las líneas guía\n    const [showGuides, setShowGuides] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)({\n        left: false,\n        center: false,\n        right: false,\n        top: false,\n        middle: false,\n        bottom: false\n    });\n    // Constantes para el snap\n    const SNAP_THRESHOLD = 15; // Distancia en píxeles para activar el snap\n    const SNAP_EDGE_THRESHOLD = 5; // Umbral para considerar que un elemento está en el borde\n    // Función para aplicar snap a coordenadas\n    const applySnap = function(value, snapPoints) {\n        let threshold = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : SNAP_THRESHOLD;\n        for (const point of snapPoints){\n            if (Math.abs(value - point) <= threshold) {\n                return point;\n            }\n        }\n        return value;\n    };\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        var _playerRef_current;\n        const updateTargets = (time)=>{\n            const currentTime = time || (0,_utils_time__WEBPACK_IMPORTED_MODULE_8__.getCurrentTime)();\n            const { trackItemsMap } = _store_use_store__WEBPACK_IMPORTED_MODULE_7__[\"default\"].getState();\n            const targetIds = activeIds.filter((id)=>{\n                var _trackItemsMap_id, _trackItemsMap_id1;\n                return ((_trackItemsMap_id = trackItemsMap[id]) === null || _trackItemsMap_id === void 0 ? void 0 : _trackItemsMap_id.display.from) <= currentTime && ((_trackItemsMap_id1 = trackItemsMap[id]) === null || _trackItemsMap_id1 === void 0 ? void 0 : _trackItemsMap_id1.display.to) >= currentTime;\n            });\n            const targets = targetIds.map((id)=>(0,_utils_target__WEBPACK_IMPORTED_MODULE_6__.getTargetById)(id));\n            selection === null || selection === void 0 ? void 0 : selection.setSelectedTargets(targets);\n            const selInfo = (0,_utils_target__WEBPACK_IMPORTED_MODULE_6__.getSelectionByIds)(targetIds);\n            setSelectionInfo(selInfo);\n            setTargets(selInfo.targets);\n        };\n        const timer = setTimeout(()=>{\n            updateTargets();\n        });\n        const onSeeked = (v)=>{\n            setTimeout(()=>{\n                const { fps } = _store_use_store__WEBPACK_IMPORTED_MODULE_7__[\"default\"].getState();\n                const seekedTime = v.detail.frame / fps * 1000;\n                updateTargets(seekedTime);\n            });\n        };\n        playerRef === null || playerRef === void 0 ? void 0 : (_playerRef_current = playerRef.current) === null || _playerRef_current === void 0 ? void 0 : _playerRef_current.addEventListener(\"seeked\", onSeeked);\n        return ()=>{\n            var _playerRef_current;\n            playerRef === null || playerRef === void 0 ? void 0 : (_playerRef_current = playerRef.current) === null || _playerRef_current === void 0 ? void 0 : _playerRef_current.removeEventListener(\"seeked\", onSeeked);\n            clearTimeout(timer);\n        };\n    }, [\n        activeIds,\n        playerRef,\n        trackItemsMap\n    ]);\n    // Función para manejar la selección de elementos\n    const handleSelection = (ids)=>{\n        console.log(\"[DEBUG Interactions] Selecci\\xf3n de elementos:\", ids);\n        // Actualizar el estado de activeIds\n        stateManager.updateState({\n            activeIds: ids\n        }, {\n            updateHistory: false,\n            kind: \"layer:selection\"\n        });\n        // Si se ha seleccionado un solo elemento, cambiar inmediatamente al panel de atributos\n        if (ids && ids.length === 1) {\n            console.log(\"[DEBUG Interactions] Cambiando a panel de atributos directamente desde interactions\");\n            // FORZAR cambio directo al panel de atributos\n            setActiveMenuItem(\"attributes\");\n            setShowMenuItem(true);\n            // Forzar el evento de selección para asegurar que todos los componentes se actualicen\n            (0,_designcombo_events__WEBPACK_IMPORTED_MODULE_4__.dispatch)(_designcombo_state__WEBPACK_IMPORTED_MODULE_5__.LAYER_SELECTION, {\n                payload: {\n                    activeIds: ids\n                }\n            });\n            // Verificar el cambio\n            setTimeout(()=>{\n                const currentMenuItem = _store_use_layout_store__WEBPACK_IMPORTED_MODULE_9__[\"default\"].getState().activeMenuItem;\n                console.log(\"[DEBUG Interactions] Panel despu\\xe9s del cambio:\", currentMenuItem);\n            }, 100);\n        }\n    };\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        var _viewerRef_current;\n        const selection = new _interactify_selection__WEBPACK_IMPORTED_MODULE_10__[\"default\"]({\n            container: (_viewerRef_current = viewerRef.current) === null || _viewerRef_current === void 0 ? void 0 : _viewerRef_current.infiniteViewer.getContainer(),\n            boundContainer: true,\n            hitRate: 0,\n            selectableTargets: [\n                \".designcombo-scene-item\"\n            ],\n            selectFromInside: false,\n            selectByClick: true,\n            toggleContinueSelect: \"shift\"\n        }).on(\"select\", (e)=>{\n            const ids = e.selected.map((el)=>(0,_utils_scene__WEBPACK_IMPORTED_MODULE_3__.getIdFromClassName)(el.className));\n            setTargets(e.selected);\n            // Usar la función handleSelection\n            handleSelection(ids);\n        }).on(\"dragStart\", (e)=>{\n            var _moveableRef_current;\n            const target = e.inputEvent.target;\n            dragStartEnd = false;\n            if (targets.includes(target)) {\n                e.stop();\n            }\n            if (target && (moveableRef === null || moveableRef === void 0 ? void 0 : (_moveableRef_current = moveableRef.current) === null || _moveableRef_current === void 0 ? void 0 : _moveableRef_current.moveable.isMoveableElement(target))) {\n                e.stop();\n            }\n        }).on(\"dragEnd\", ()=>{\n            dragStartEnd = true;\n        }).on(\"selectEnd\", (e)=>{\n            const moveable = moveableRef.current;\n            if (e.isDragStart) {\n                e.inputEvent.preventDefault();\n                setTimeout(()=>{\n                    if (!dragStartEnd) {\n                        moveable === null || moveable === void 0 ? void 0 : moveable.moveable.dragStart(e.inputEvent);\n                    }\n                });\n            } else {\n                const targets = e.selected;\n                const ids = targets.map((el)=>(0,_utils_scene__WEBPACK_IMPORTED_MODULE_3__.getIdFromClassName)(el.className));\n                // Usar la función handleSelection\n                handleSelection(ids);\n                setTargets(targets);\n            }\n        });\n        setSelection(selection);\n        return ()=>{\n            selection.destroy();\n        };\n    }, []);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        const activeSelectionSubscription = stateManager.subscribeToActiveIds((newState)=>{\n            setState(newState);\n            // Si hay un solo elemento seleccionado, asegurarse de que se muestre el panel de atributos\n            if (newState.activeIds && newState.activeIds.length === 1) {\n                setActiveMenuItem(\"attributes\");\n                setShowMenuItem(true);\n            }\n        });\n        return ()=>{\n            activeSelectionSubscription.unsubscribe();\n        };\n    }, []);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        moveableRef.current.moveable.updateRect();\n    }, [\n        trackItemsMap\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        setSceneMoveableRef(moveableRef);\n    }, [\n        moveableRef\n    ]);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_interactify_moveable__WEBPACK_IMPORTED_MODULE_2__[\"default\"], {\n        ref: moveableRef,\n        rotationPosition: \"bottom\",\n        renderDirections: selectionInfo.controls,\n        ...selectionInfo.ables,\n        origin: false,\n        target: targets,\n        zoom: 1 / zoom,\n        className: \"designcombo-scene-moveable\",\n        onDrag: (param)=>{\n            let { target, beforeTranslate, inputEvent } = param;\n            const targetId = (0,_utils_scene__WEBPACK_IMPORTED_MODULE_3__.getIdFromClassName)(target.className);\n            const trackItem = trackItemDetailsMap[targetId];\n            // Obtener dimensiones del elemento\n            const targetWidth = target.offsetWidth;\n            const targetHeight = target.offsetHeight;\n            // Calcular la posición propuesta\n            let left = parseFloat(trackItem === null || trackItem === void 0 ? void 0 : trackItem.details.left) + beforeTranslate[0];\n            let top = parseFloat(trackItem === null || trackItem === void 0 ? void 0 : trackItem.details.top) + beforeTranslate[1];\n            // Puntos de snap para el eje X (izquierda, centro, derecha)\n            const snapPointsX = [\n                0,\n                size.width / 2 - targetWidth / 2,\n                size.width - targetWidth // Borde derecho\n            ];\n            // Puntos de snap para el eje Y (arriba, centro, abajo)\n            const snapPointsY = [\n                0,\n                size.height / 2 - targetHeight / 2,\n                size.height - targetHeight // Borde inferior\n            ];\n            // Aplicar snap con umbral normal\n            left = applySnap(left, snapPointsX);\n            top = applySnap(top, snapPointsY);\n            // Feedback visual para indicar el snap (opcional)\n            if (snapPointsX.some((point)=>Math.abs(left - point) <= SNAP_EDGE_THRESHOLD) || snapPointsY.some((point)=>Math.abs(top - point) <= SNAP_EDGE_THRESHOLD)) {\n                // Se podría añadir una clase CSS para indicar visualmente el snap\n                target.classList.add(\"snapped-element\");\n                // Añadir pequeña vibración como feedback táctil (opcional)\n                if (inputEvent instanceof MouseEvent && \"vibrate\" in navigator) {\n                    navigator.vibrate(10); // Vibración sutil de 10ms\n                }\n            } else {\n                target.classList.remove(\"snapped-element\");\n            }\n            // Actualizar posición\n            target.style.top = top + \"px\";\n            target.style.left = left + \"px\";\n        },\n        onDragEnd: (param)=>{\n            let { target, isDrag } = param;\n            if (!isDrag) return;\n            const targetId = (0,_utils_scene__WEBPACK_IMPORTED_MODULE_3__.getIdFromClassName)(target.className);\n            // Eliminar la clase de snap al finalizar\n            target.classList.remove(\"snapped-element\");\n            (0,_designcombo_events__WEBPACK_IMPORTED_MODULE_4__.dispatch)(_designcombo_state__WEBPACK_IMPORTED_MODULE_5__.EDIT_OBJECT, {\n                payload: {\n                    [targetId]: {\n                        details: {\n                            left: target.style.left,\n                            top: target.style.top\n                        }\n                    }\n                }\n            });\n        },\n        onScale: (param)=>{\n            let { target, transform, direction } = param;\n            const [xControl, yControl] = direction;\n            const scaleRegex = /scale\\(([^)]+)\\)/;\n            const match = target.style.transform.match(scaleRegex);\n            //get current scale\n            const [scaleX, scaleY] = match[1].split(\",\").map((value)=>parseFloat(value.trim()));\n            //get new Scale\n            const match2 = transform.match(scaleRegex);\n            const [newScaleX, newScaleY] = match2[1].split(\",\").map((value)=>parseFloat(value.trim()));\n            const currentWidth = target.clientWidth * scaleX;\n            const currentHeight = target.clientHeight * scaleY;\n            const newWidth = target.clientWidth * newScaleX;\n            const newHeight = target.clientHeight * newScaleY;\n            target.style.transform = transform;\n            //Move element to initial Left position\n            const diffX = currentWidth - newWidth;\n            let newLeft = parseFloat(target.style.left) - diffX / 2;\n            const diffY = currentHeight - newHeight;\n            let newTop = parseFloat(target.style.top) - diffY / 2;\n            if (xControl === -1) {\n                newLeft += diffX;\n            }\n            if (yControl === -1) {\n                newTop += diffY;\n            }\n            target.style.left = newLeft + \"px\";\n            target.style.top = newTop + \"px\";\n        },\n        onScaleEnd: (param)=>{\n            let { target } = param;\n            if (!target.style.transform) return;\n            const targetId = (0,_utils_scene__WEBPACK_IMPORTED_MODULE_3__.getIdFromClassName)(target.className);\n            (0,_designcombo_events__WEBPACK_IMPORTED_MODULE_4__.dispatch)(_designcombo_state__WEBPACK_IMPORTED_MODULE_5__.EDIT_OBJECT, {\n                payload: {\n                    [targetId]: {\n                        details: {\n                            transform: target.style.transform,\n                            left: parseFloat(target.style.left),\n                            top: parseFloat(target.style.top)\n                        }\n                    }\n                }\n            });\n        },\n        onRotate: (param)=>{\n            let { target, transform } = param;\n            target.style.transform = transform;\n        },\n        onRotateEnd: (param)=>{\n            let { target } = param;\n            if (!target.style.transform) return;\n            const targetId = (0,_utils_scene__WEBPACK_IMPORTED_MODULE_3__.getIdFromClassName)(target.className);\n            (0,_designcombo_events__WEBPACK_IMPORTED_MODULE_4__.dispatch)(_designcombo_state__WEBPACK_IMPORTED_MODULE_5__.EDIT_OBJECT, {\n                payload: {\n                    [targetId]: {\n                        details: {\n                            transform: target.style.transform\n                        }\n                    }\n                }\n            });\n        },\n        onDragGroup: (param)=>{\n            let { events } = param;\n            holdGroupPosition = {};\n            // Obtener el rectángulo que contiene todo el grupo\n            let groupLeft = Infinity;\n            let groupTop = Infinity;\n            let groupRight = -Infinity;\n            let groupBottom = -Infinity;\n            // Primer paso: calcular dimensiones del grupo\n            for(let i = 0; i < events.length; i++){\n                const event = events[i];\n                const id = (0,_utils_scene__WEBPACK_IMPORTED_MODULE_3__.getIdFromClassName)(event.target.className);\n                const trackItem = trackItemDetailsMap[id];\n                const left = parseFloat(trackItem === null || trackItem === void 0 ? void 0 : trackItem.details.left);\n                const top = parseFloat(trackItem === null || trackItem === void 0 ? void 0 : trackItem.details.top);\n                const width = event.target.offsetWidth;\n                const height = event.target.offsetHeight;\n                groupLeft = Math.min(groupLeft, left);\n                groupTop = Math.min(groupTop, top);\n                groupRight = Math.max(groupRight, left + width);\n                groupBottom = Math.max(groupBottom, top + height);\n            }\n            const groupWidth = groupRight - groupLeft;\n            const groupHeight = groupBottom - groupTop;\n            // Calcular el desplazamiento base del grupo (desde el primer elemento)\n            const baseTranslate = events[0].beforeTranslate;\n            // Calcular nueva posición del grupo con posible snap\n            let newGroupLeft = groupLeft + baseTranslate[0];\n            let newGroupTop = groupTop + baseTranslate[1];\n            // Puntos de snap para el grupo\n            const snapPointsX = [\n                0,\n                size.width / 2 - groupWidth / 2,\n                size.width - groupWidth // Borde derecho\n            ];\n            const snapPointsY = [\n                0,\n                size.height / 2 - groupHeight / 2,\n                size.height - groupHeight // Borde inferior\n            ];\n            // Aplicar snap al grupo\n            const snappedGroupLeft = applySnap(newGroupLeft, snapPointsX);\n            const snappedGroupTop = applySnap(newGroupTop, snapPointsY);\n            // Calcular el ajuste necesario después del snap\n            const adjustX = snappedGroupLeft - newGroupLeft;\n            const adjustY = snappedGroupTop - newGroupTop;\n            // Feedback visual para el snap de grupo\n            const isGroupSnapped = Math.abs(adjustX) <= SNAP_EDGE_THRESHOLD || Math.abs(adjustY) <= SNAP_EDGE_THRESHOLD;\n            // Aplicar el movimiento ajustado a cada elemento del grupo\n            for(let i = 0; i < events.length; i++){\n                const event = events[i];\n                const id = (0,_utils_scene__WEBPACK_IMPORTED_MODULE_3__.getIdFromClassName)(event.target.className);\n                const trackItem = trackItemDetailsMap[id];\n                const left = parseFloat(trackItem === null || trackItem === void 0 ? void 0 : trackItem.details.left) + event.beforeTranslate[0] + adjustX;\n                const top = parseFloat(trackItem === null || trackItem === void 0 ? void 0 : trackItem.details.top) + event.beforeTranslate[1] + adjustY;\n                event.target.style.left = \"\".concat(left, \"px\");\n                event.target.style.top = \"\".concat(top, \"px\");\n                // Aplicar clase visual si hay snap\n                if (isGroupSnapped) {\n                    event.target.classList.add(\"snapped-element\");\n                } else {\n                    event.target.classList.remove(\"snapped-element\");\n                }\n                holdGroupPosition[id] = {\n                    left: left,\n                    top: top\n                };\n            }\n            // Feedback táctil si hay snap\n            if (isGroupSnapped && \"vibrate\" in navigator) {\n                navigator.vibrate(10);\n            }\n        },\n        onResize: (param)=>{\n            let { target, width: nextWidth, height: nextHeight, direction } = param;\n            if (direction[1] === 1) {\n                var _target_firstElementChild;\n                const currentWidth = target.clientWidth;\n                const currentHeight = target.clientHeight;\n                // Get new width and height\n                const scaleY = nextHeight / currentHeight;\n                const scale = scaleY;\n                // Update target dimensions\n                target.style.width = \"\".concat(currentWidth * scale, \"px\");\n                target.style.height = \"\".concat(currentHeight * scale, \"px\");\n                // Safely access nested elements\n                const animationDiv = (_target_firstElementChild = target.firstElementChild) === null || _target_firstElementChild === void 0 ? void 0 : _target_firstElementChild.firstElementChild;\n                if (animationDiv) {\n                    animationDiv.style.width = \"\".concat(currentWidth * scale, \"px\");\n                    animationDiv.style.height = \"\".concat(currentHeight * scale, \"px\");\n                    const textDiv = animationDiv.firstElementChild;\n                    if (textDiv) {\n                        const fontSize = parseFloat(getComputedStyle(textDiv).fontSize);\n                        textDiv.style.fontSize = \"\".concat(fontSize * scale, \"px\");\n                        textDiv.style.width = \"\".concat(currentWidth * scale, \"px\");\n                        textDiv.style.height = \"\".concat(currentHeight * scale, \"px\");\n                    }\n                }\n            } else {\n                var _target_firstElementChild1;\n                target.style.width = nextWidth + \"px\";\n                target.style.height = nextHeight + \"px\";\n                // Safely access nested elements\n                const animationDiv = (_target_firstElementChild1 = target.firstElementChild) === null || _target_firstElementChild1 === void 0 ? void 0 : _target_firstElementChild1.firstElementChild;\n                if (animationDiv) {\n                    animationDiv.style.width = \"\".concat(nextWidth, \"px\");\n                    animationDiv.style.height = \"\".concat(nextHeight, \"px\");\n                    const textDiv = animationDiv.firstElementChild;\n                    if (textDiv) {\n                        textDiv.style.width = \"\".concat(nextWidth, \"px\");\n                        textDiv.style.height = \"\".concat(nextHeight, \"px\");\n                    }\n                }\n            }\n        },\n        onResizeEnd: (param)=>{\n            let { target } = param;\n            var _target_firstElementChild_firstElementChild, _target_firstElementChild;\n            const targetId = (0,_utils_scene__WEBPACK_IMPORTED_MODULE_3__.getIdFromClassName)(target.className);\n            const textDiv = (_target_firstElementChild = target.firstElementChild) === null || _target_firstElementChild === void 0 ? void 0 : (_target_firstElementChild_firstElementChild = _target_firstElementChild.firstElementChild) === null || _target_firstElementChild_firstElementChild === void 0 ? void 0 : _target_firstElementChild_firstElementChild.firstElementChild;\n            (0,_designcombo_events__WEBPACK_IMPORTED_MODULE_4__.dispatch)(_designcombo_state__WEBPACK_IMPORTED_MODULE_5__.EDIT_OBJECT, {\n                payload: {\n                    [targetId]: {\n                        details: {\n                            width: parseFloat(target.style.width),\n                            height: parseFloat(target.style.height),\n                            fontSize: parseFloat(textDiv.style.fontSize)\n                        }\n                    }\n                }\n            });\n        },\n        onDragGroupEnd: ()=>{\n            if (holdGroupPosition) {\n                const payload = {};\n                Object.keys(holdGroupPosition).forEach((id)=>{\n                    const left = holdGroupPosition[id].left;\n                    const top = holdGroupPosition[id].top;\n                    // Eliminar la clase de snap\n                    const element = document.querySelector(\".id-\".concat(id));\n                    if (element) {\n                        element.classList.remove(\"snapped-element\");\n                    }\n                    payload[id] = {\n                        details: {\n                            top: \"\".concat(top, \"px\"),\n                            left: \"\".concat(left, \"px\")\n                        }\n                    };\n                });\n                (0,_designcombo_events__WEBPACK_IMPORTED_MODULE_4__.dispatch)(_designcombo_state__WEBPACK_IMPORTED_MODULE_5__.EDIT_OBJECT, {\n                    payload: payload\n                });\n                holdGroupPosition = null;\n            }\n        }\n    }, void 0, false, {\n        fileName: \"C:\\\\Users\\\\david\\\\Desktop\\\\ai-video-agent\\\\react-video-editor\\\\features\\\\editor\\\\scene\\\\interactions.tsx\",\n        lineNumber: 236,\n        columnNumber: 5\n    }, this);\n}\n_s(SceneInteractions, \"7L1iPDzOFAwp/g9gD0xehxgRGkw=\", false, function() {\n    return [\n        _store_use_store__WEBPACK_IMPORTED_MODULE_7__[\"default\"],\n        _store_use_layout_store__WEBPACK_IMPORTED_MODULE_9__[\"default\"]\n    ];\n});\n_c = SceneInteractions;\nvar _c;\n$RefreshReg$(_c, \"SceneInteractions\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2ZlYXR1cmVzL2VkaXRvci9zY2VuZS9pbnRlcmFjdGlvbnMudHN4IiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUVvRDtBQUNMO0FBQ0Y7QUFDTztBQUNMO0FBQ21CO0FBTXpDO0FBQ2lCO0FBRUs7QUFDUTtBQUV2RCxJQUFJZSxvQkFBZ0Q7QUFDcEQsSUFBSUMsZUFBZTtBQVNaLFNBQVNDLGtCQUFrQixLQU1UO1FBTlMsRUFDaENDLFlBQVksRUFDWkMsU0FBUyxFQUNUQyxJQUFJLEVBQ0pDLElBQUksRUFDSkMsWUFBWSxFQUNXLEdBTlM7O0lBT2hDLE1BQU0sQ0FBQ0MsU0FBU0MsV0FBVyxHQUFHdEIsK0NBQVFBLENBQW1CLEVBQUU7SUFDM0QsTUFBTSxDQUFDdUIsV0FBV0MsYUFBYSxHQUFHeEIsK0NBQVFBO0lBQzFDLE1BQU0sRUFDSnlCLFNBQVMsRUFDVEMsUUFBUSxFQUNSQyxtQkFBbUIsRUFDbkJDLGFBQWEsRUFDYkMsU0FBUyxFQUNUQyxtQkFBbUIsRUFDcEIsR0FBR3BCLDREQUFRQTtJQUNaLE1BQU0sRUFBRXFCLGlCQUFpQixFQUFFQyxlQUFlLEVBQUUsR0FBR3BCLG1FQUFjQTtJQUM3RCxNQUFNcUIsY0FBY2xDLDZDQUFNQSxDQUFXO0lBQ3JDLE1BQU0sQ0FBQ21DLGVBQWVDLGlCQUFpQixHQUNyQ25DLCtDQUFRQSxDQUFnQk8seURBQWNBO0lBRXhDLDhCQUE4QjtJQUM5QixNQUFNLENBQUM2QixZQUFZQyxjQUFjLEdBQUdyQywrQ0FBUUEsQ0FBQztRQUMzQ3NDLE1BQU07UUFDTkMsUUFBUTtRQUNSQyxPQUFPO1FBQ1BDLEtBQUs7UUFDTEMsUUFBUTtRQUNSQyxRQUFRO0lBQ1Y7SUFFQSwwQkFBMEI7SUFDMUIsTUFBTUMsaUJBQWlCLElBQUksNENBQTRDO0lBQ3ZFLE1BQU1DLHNCQUFzQixHQUFHLDBEQUEwRDtJQUV6RiwwQ0FBMEM7SUFDMUMsTUFBTUMsWUFBWSxTQUFDQyxPQUFlQztZQUFzQkMsNkVBQW9CTDtRQUMxRSxLQUFLLE1BQU1NLFNBQVNGLFdBQVk7WUFDOUIsSUFBSUcsS0FBS0MsR0FBRyxDQUFDTCxRQUFRRyxVQUFVRCxXQUFXO2dCQUN4QyxPQUFPQztZQUNUO1FBQ0Y7UUFDQSxPQUFPSDtJQUNUO0lBRUFqRCxnREFBU0EsQ0FBQztZQThCUitCO1FBN0JBLE1BQU13QixnQkFBZ0IsQ0FBQ0M7WUFDckIsTUFBTUMsY0FBY0QsUUFBUTNDLDJEQUFjQTtZQUMxQyxNQUFNLEVBQUVpQixhQUFhLEVBQUUsR0FBR2xCLHdEQUFRQSxDQUFDOEMsUUFBUTtZQUMzQyxNQUFNQyxZQUFZaEMsVUFBVWlDLE1BQU0sQ0FBQyxDQUFDQztvQkFFaEMvQixtQkFDQUE7Z0JBRkYsT0FDRUEsRUFBQUEsb0JBQUFBLGFBQWEsQ0FBQytCLEdBQUcsY0FBakIvQix3Q0FBQUEsa0JBQW1CZ0MsT0FBTyxDQUFDQyxJQUFJLEtBQUlOLGVBQ25DM0IsRUFBQUEscUJBQUFBLGFBQWEsQ0FBQytCLEdBQUcsY0FBakIvQix5Q0FBQUEsbUJBQW1CZ0MsT0FBTyxDQUFDRSxFQUFFLEtBQUlQO1lBRXJDO1lBQ0EsTUFBTWxDLFVBQVVvQyxVQUFVTSxHQUFHLENBQzNCLENBQUNKLEtBQU9sRCw0REFBYUEsQ0FBQ2tEO1lBRXhCcEMsc0JBQUFBLGdDQUFBQSxVQUFXeUMsa0JBQWtCLENBQUMzQztZQUM5QixNQUFNNEMsVUFBVXpELGdFQUFpQkEsQ0FBQ2lEO1lBRWxDdEIsaUJBQWlCOEI7WUFDakIzQyxXQUFXMkMsUUFBUTVDLE9BQU87UUFDNUI7UUFDQSxNQUFNNkMsUUFBUUMsV0FBVztZQUN2QmQ7UUFDRjtRQUVBLE1BQU1lLFdBQVcsQ0FBQ0M7WUFDaEJGLFdBQVc7Z0JBQ1QsTUFBTSxFQUFFRyxHQUFHLEVBQUUsR0FBRzVELHdEQUFRQSxDQUFDOEMsUUFBUTtnQkFDakMsTUFBTWUsYUFBYSxFQUFHQyxNQUFNLENBQUNDLEtBQUssR0FBR0gsTUFBTztnQkFDNUNqQixjQUFja0I7WUFDaEI7UUFDRjtRQUNBMUMsc0JBQUFBLGlDQUFBQSxxQkFBQUEsVUFBVzZDLE9BQU8sY0FBbEI3Qyx5Q0FBQUEsbUJBQW9COEMsZ0JBQWdCLENBQUMsVUFBVVA7UUFFL0MsT0FBTztnQkFDTHZDO1lBQUFBLHNCQUFBQSxpQ0FBQUEscUJBQUFBLFVBQVc2QyxPQUFPLGNBQWxCN0MseUNBQUFBLG1CQUFvQitDLG1CQUFtQixDQUFDLFVBQVVSO1lBQ2xEUyxhQUFhWDtRQUNmO0lBQ0YsR0FBRztRQUFDekM7UUFBV0k7UUFBV0Q7S0FBYztJQUV4QyxpREFBaUQ7SUFDakQsTUFBTWtELGtCQUFrQixDQUFDQztRQUN2QkMsUUFBUUMsR0FBRyxDQUFDLG1EQUFnREY7UUFFNUQsb0NBQW9DO1FBQ3BDL0QsYUFBYWtFLFdBQVcsQ0FDdEI7WUFDRXpELFdBQVdzRDtRQUNiLEdBQ0E7WUFDRUksZUFBZTtZQUNmQyxNQUFNO1FBQ1I7UUFHRix1RkFBdUY7UUFDdkYsSUFBSUwsT0FBT0EsSUFBSU0sTUFBTSxLQUFLLEdBQUc7WUFDM0JMLFFBQVFDLEdBQUcsQ0FBQztZQUVaLDhDQUE4QztZQUM5Q2xELGtCQUFrQjtZQUNsQkMsZ0JBQWdCO1lBRWhCLHNGQUFzRjtZQUN0RjVCLDZEQUFRQSxDQUFDRSwrREFBZUEsRUFBRTtnQkFDeEJnRixTQUFTO29CQUNQN0QsV0FBV3NEO2dCQUNiO1lBQ0Y7WUFFQSxzQkFBc0I7WUFDdEJaLFdBQVc7Z0JBQ1QsTUFBTW9CLGtCQUFrQjNFLCtEQUFjQSxDQUFDNEMsUUFBUSxHQUFHZ0MsY0FBYztnQkFDaEVSLFFBQVFDLEdBQUcsQ0FBQyxxREFBa0RNO1lBQ2hFLEdBQUc7UUFDTDtJQUNGO0lBRUF6RixnREFBU0EsQ0FBQztZQUVLbUI7UUFEYixNQUFNTSxZQUFZLElBQUl0QiwrREFBU0EsQ0FBQztZQUM5QndGLFNBQVMsR0FBRXhFLHFCQUFBQSxVQUFVeUQsT0FBTyxjQUFqQnpELHlDQUFBQSxtQkFBbUJ5RSxjQUFjLENBQUNDLFlBQVk7WUFDekRDLGdCQUFnQjtZQUNoQkMsU0FBUztZQUNUQyxtQkFBbUI7Z0JBQUM7YUFBMEI7WUFDOUNDLGtCQUFrQjtZQUNsQkMsZUFBZTtZQUNmQyxzQkFBc0I7UUFDeEIsR0FDR0MsRUFBRSxDQUFDLFVBQVUsQ0FBQ0M7WUFDYixNQUFNcEIsTUFBTW9CLEVBQUVDLFFBQVEsQ0FBQ3JDLEdBQUcsQ0FBQyxDQUFDc0MsS0FBT2xHLGdFQUFrQkEsQ0FBQ2tHLEdBQUdDLFNBQVM7WUFDbEVoRixXQUFXNkUsRUFBRUMsUUFBUTtZQUVyQixrQ0FBa0M7WUFDbEN0QixnQkFBZ0JDO1FBQ2xCLEdBQ0NtQixFQUFFLENBQUMsYUFBYSxDQUFDQztnQkFTZGxFO1lBUkYsTUFBTXNFLFNBQVNKLEVBQUVLLFVBQVUsQ0FBQ0QsTUFBTTtZQUNsQ3pGLGVBQWU7WUFFZixJQUFJTyxRQUFRb0YsUUFBUSxDQUFDRixTQUFTO2dCQUM1QkosRUFBRU8sSUFBSTtZQUNSO1lBQ0EsSUFDRUgsV0FDQXRFLHdCQUFBQSxtQ0FBQUEsdUJBQUFBLFlBQWF5QyxPQUFPLGNBQXBCekMsMkNBQUFBLHFCQUFzQjBFLFFBQVEsQ0FBQ0MsaUJBQWlCLENBQUNMLFVBQ2pEO2dCQUNBSixFQUFFTyxJQUFJO1lBQ1I7UUFDRixHQUNDUixFQUFFLENBQUMsV0FBVztZQUNicEYsZUFBZTtRQUNqQixHQUNDb0YsRUFBRSxDQUFDLGFBQWEsQ0FBQ0M7WUFDaEIsTUFBTVEsV0FBVzFFLFlBQVl5QyxPQUFPO1lBQ3BDLElBQUl5QixFQUFFVSxXQUFXLEVBQUU7Z0JBQ2pCVixFQUFFSyxVQUFVLENBQUNNLGNBQWM7Z0JBQzNCM0MsV0FBVztvQkFDVCxJQUFJLENBQUNyRCxjQUFjO3dCQUNqQjZGLHFCQUFBQSwrQkFBQUEsU0FBVUEsUUFBUSxDQUFDSSxTQUFTLENBQUNaLEVBQUVLLFVBQVU7b0JBQzNDO2dCQUNGO1lBQ0YsT0FBTztnQkFDTCxNQUFNbkYsVUFBVThFLEVBQUVDLFFBQVE7Z0JBQzFCLE1BQU1yQixNQUFNMUQsUUFBUTBDLEdBQUcsQ0FBQyxDQUFDc0MsS0FBT2xHLGdFQUFrQkEsQ0FBQ2tHLEdBQUdDLFNBQVM7Z0JBRS9ELGtDQUFrQztnQkFDbEN4QixnQkFBZ0JDO2dCQUNoQnpELFdBQVdEO1lBQ2I7UUFDRjtRQUNGRyxhQUFhRDtRQUNiLE9BQU87WUFDTEEsVUFBVXlGLE9BQU87UUFDbkI7SUFDRixHQUFHLEVBQUU7SUFFTGxILGdEQUFTQSxDQUFDO1FBQ1IsTUFBTW1ILDhCQUE4QmpHLGFBQWFrRyxvQkFBb0IsQ0FDbkUsQ0FBQ0M7WUFDQ3pGLFNBQVN5RjtZQUVULDJGQUEyRjtZQUMzRixJQUFJQSxTQUFTMUYsU0FBUyxJQUFJMEYsU0FBUzFGLFNBQVMsQ0FBQzRELE1BQU0sS0FBSyxHQUFHO2dCQUN6RHRELGtCQUFrQjtnQkFDbEJDLGdCQUFnQjtZQUNsQjtRQUNGO1FBR0YsT0FBTztZQUNMaUYsNEJBQTRCRyxXQUFXO1FBQ3pDO0lBQ0YsR0FBRyxFQUFFO0lBRUx0SCxnREFBU0EsQ0FBQztRQUNSbUMsWUFBWXlDLE9BQU8sQ0FBRWlDLFFBQVEsQ0FBQ1UsVUFBVTtJQUMxQyxHQUFHO1FBQUN6RjtLQUFjO0lBRWxCOUIsZ0RBQVNBLENBQUM7UUFDUmdDLG9CQUFvQkc7SUFDdEIsR0FBRztRQUFDQTtLQUFZO0lBQ2hCLHFCQUNFLDhEQUFDL0IsNkRBQVFBO1FBQ1BvSCxLQUFLckY7UUFDTHNGLGtCQUFrQjtRQUNsQkMsa0JBQWtCdEYsY0FBY3VGLFFBQVE7UUFDdkMsR0FBR3ZGLGNBQWN3RixLQUFLO1FBQ3ZCQyxRQUFRO1FBQ1JwQixRQUFRbEY7UUFDUkgsTUFBTSxJQUFJQTtRQUNWb0YsV0FBVTtRQUNWc0IsUUFBUTtnQkFBQyxFQUFFckIsTUFBTSxFQUFFc0IsZUFBZSxFQUFFckIsVUFBVSxFQUFFO1lBQzlDLE1BQU1zQixXQUFXM0gsZ0VBQWtCQSxDQUFDb0csT0FBT0QsU0FBUztZQUNwRCxNQUFNeUIsWUFBWXBHLG1CQUFtQixDQUFDbUcsU0FBUztZQUUvQyxtQ0FBbUM7WUFDbkMsTUFBTUUsY0FBY3pCLE9BQU8wQixXQUFXO1lBQ3RDLE1BQU1DLGVBQWUzQixPQUFPNEIsWUFBWTtZQUV4QyxpQ0FBaUM7WUFDakMsSUFBSTdGLE9BQU84RixXQUFXTCxzQkFBQUEsZ0NBQUFBLFVBQVdNLE9BQU8sQ0FBQy9GLElBQUksSUFBY3VGLGVBQWUsQ0FBQyxFQUFFO1lBQzdFLElBQUlwRixNQUFNMkYsV0FBV0wsc0JBQUFBLGdDQUFBQSxVQUFXTSxPQUFPLENBQUM1RixHQUFHLElBQWNvRixlQUFlLENBQUMsRUFBRTtZQUUzRSw0REFBNEQ7WUFDNUQsTUFBTVMsY0FBYztnQkFDbEI7Z0JBQ0FuSCxLQUFLb0gsS0FBSyxHQUFHLElBQUlQLGNBQWM7Z0JBQy9CN0csS0FBS29ILEtBQUssR0FBR1AsWUFBWSxnQkFBZ0I7YUFDMUM7WUFFRCx1REFBdUQ7WUFDdkQsTUFBTVEsY0FBYztnQkFDbEI7Z0JBQ0FySCxLQUFLc0gsTUFBTSxHQUFHLElBQUlQLGVBQWU7Z0JBQ2pDL0csS0FBS3NILE1BQU0sR0FBR1AsYUFBYSxpQkFBaUI7YUFDN0M7WUFFRCxpQ0FBaUM7WUFDakM1RixPQUFPUSxVQUFVUixNQUFNZ0c7WUFDdkI3RixNQUFNSyxVQUFVTCxLQUFLK0Y7WUFFckIsa0RBQWtEO1lBQ2xELElBQUlGLFlBQVlJLElBQUksQ0FBQ3hGLENBQUFBLFFBQVNDLEtBQUtDLEdBQUcsQ0FBQ2QsT0FBT1ksVUFBVUwsd0JBQ3BEMkYsWUFBWUUsSUFBSSxDQUFDeEYsQ0FBQUEsUUFBU0MsS0FBS0MsR0FBRyxDQUFDWCxNQUFNUyxVQUFVTCxzQkFBc0I7Z0JBQzNFLGtFQUFrRTtnQkFDbEUwRCxPQUFPb0MsU0FBUyxDQUFDQyxHQUFHLENBQUM7Z0JBRXJCLDJEQUEyRDtnQkFDM0QsSUFBSXBDLHNCQUFzQnFDLGNBQWMsYUFBYUMsV0FBVztvQkFDOURBLFVBQVVDLE9BQU8sQ0FBQyxLQUFLLDBCQUEwQjtnQkFDbkQ7WUFDRixPQUFPO2dCQUNMeEMsT0FBT29DLFNBQVMsQ0FBQ0ssTUFBTSxDQUFDO1lBQzFCO1lBRUEsc0JBQXNCO1lBQ3RCekMsT0FBTzBDLEtBQUssQ0FBQ3hHLEdBQUcsR0FBR0EsTUFBTTtZQUN6QjhELE9BQU8wQyxLQUFLLENBQUMzRyxJQUFJLEdBQUdBLE9BQU87UUFDN0I7UUFDQTRHLFdBQVc7Z0JBQUMsRUFBRTNDLE1BQU0sRUFBRTRDLE1BQU0sRUFBRTtZQUM1QixJQUFJLENBQUNBLFFBQVE7WUFDYixNQUFNckIsV0FBVzNILGdFQUFrQkEsQ0FBQ29HLE9BQU9ELFNBQVM7WUFFcEQseUNBQXlDO1lBQ3pDQyxPQUFPb0MsU0FBUyxDQUFDSyxNQUFNLENBQUM7WUFFeEI1SSw2REFBUUEsQ0FBQ0MsMkRBQVdBLEVBQUU7Z0JBQ3BCaUYsU0FBUztvQkFDUCxDQUFDd0MsU0FBUyxFQUFFO3dCQUNWTyxTQUFTOzRCQUNQL0YsTUFBTWlFLE9BQU8wQyxLQUFLLENBQUMzRyxJQUFJOzRCQUN2QkcsS0FBSzhELE9BQU8wQyxLQUFLLENBQUN4RyxHQUFHO3dCQUN2QjtvQkFDRjtnQkFDRjtZQUNGO1FBQ0Y7UUFDQTJHLFNBQVM7Z0JBQUMsRUFBRTdDLE1BQU0sRUFBRThDLFNBQVMsRUFBRUMsU0FBUyxFQUFFO1lBQ3hDLE1BQU0sQ0FBQ0MsVUFBVUMsU0FBUyxHQUFHRjtZQUU3QixNQUFNRyxhQUFhO1lBQ25CLE1BQU1DLFFBQVFuRCxPQUFPMEMsS0FBSyxDQUFDSSxTQUFTLENBQUNLLEtBQUssQ0FBQ0Q7WUFFM0MsbUJBQW1CO1lBQ25CLE1BQU0sQ0FBQ0UsUUFBUUMsT0FBTyxHQUFHRixLQUFLLENBQUMsRUFBRSxDQUM5QkcsS0FBSyxDQUFDLEtBQ045RixHQUFHLENBQUMsQ0FBQ2hCLFFBQVVxRixXQUFXckYsTUFBTStHLElBQUk7WUFFdkMsZUFBZTtZQUNmLE1BQU1DLFNBQVNWLFVBQVVLLEtBQUssQ0FBQ0Q7WUFDL0IsTUFBTSxDQUFDTyxXQUFXQyxVQUFVLEdBQUdGLE1BQU0sQ0FBQyxFQUFFLENBQ3JDRixLQUFLLENBQUMsS0FDTjlGLEdBQUcsQ0FBQyxDQUFDaEIsUUFBVXFGLFdBQVdyRixNQUFNK0csSUFBSTtZQUV2QyxNQUFNSSxlQUFlM0QsT0FBTzRELFdBQVcsR0FBR1I7WUFDMUMsTUFBTVMsZ0JBQWdCN0QsT0FBTzhELFlBQVksR0FBR1Q7WUFFNUMsTUFBTVUsV0FBVy9ELE9BQU80RCxXQUFXLEdBQUdIO1lBQ3RDLE1BQU1PLFlBQVloRSxPQUFPOEQsWUFBWSxHQUFHSjtZQUV4QzFELE9BQU8wQyxLQUFLLENBQUNJLFNBQVMsR0FBR0E7WUFFekIsdUNBQXVDO1lBQ3ZDLE1BQU1tQixRQUFRTixlQUFlSTtZQUM3QixJQUFJRyxVQUFVckMsV0FBVzdCLE9BQU8wQyxLQUFLLENBQUMzRyxJQUFJLElBQUlrSSxRQUFRO1lBRXRELE1BQU1FLFFBQVFOLGdCQUFnQkc7WUFDOUIsSUFBSUksU0FBU3ZDLFdBQVc3QixPQUFPMEMsS0FBSyxDQUFDeEcsR0FBRyxJQUFJaUksUUFBUTtZQUVwRCxJQUFJbkIsYUFBYSxDQUFDLEdBQUc7Z0JBQ25Ca0IsV0FBV0Q7WUFDYjtZQUNBLElBQUloQixhQUFhLENBQUMsR0FBRztnQkFDbkJtQixVQUFVRDtZQUNaO1lBQ0FuRSxPQUFPMEMsS0FBSyxDQUFDM0csSUFBSSxHQUFHbUksVUFBVTtZQUM5QmxFLE9BQU8wQyxLQUFLLENBQUN4RyxHQUFHLEdBQUdrSSxTQUFTO1FBQzlCO1FBQ0FDLFlBQVk7Z0JBQUMsRUFBRXJFLE1BQU0sRUFBRTtZQUNyQixJQUFJLENBQUNBLE9BQU8wQyxLQUFLLENBQUNJLFNBQVMsRUFBRTtZQUM3QixNQUFNdkIsV0FBVzNILGdFQUFrQkEsQ0FBQ29HLE9BQU9ELFNBQVM7WUFFcERsRyw2REFBUUEsQ0FBQ0MsMkRBQVdBLEVBQUU7Z0JBQ3BCaUYsU0FBUztvQkFDUCxDQUFDd0MsU0FBUyxFQUFFO3dCQUNWTyxTQUFTOzRCQUNQZ0IsV0FBVzlDLE9BQU8wQyxLQUFLLENBQUNJLFNBQVM7NEJBQ2pDL0csTUFBTThGLFdBQVc3QixPQUFPMEMsS0FBSyxDQUFDM0csSUFBSTs0QkFDbENHLEtBQUsyRixXQUFXN0IsT0FBTzBDLEtBQUssQ0FBQ3hHLEdBQUc7d0JBQ2xDO29CQUNGO2dCQUNGO1lBQ0Y7UUFDRjtRQUNBb0ksVUFBVTtnQkFBQyxFQUFFdEUsTUFBTSxFQUFFOEMsU0FBUyxFQUFFO1lBQzlCOUMsT0FBTzBDLEtBQUssQ0FBQ0ksU0FBUyxHQUFHQTtRQUMzQjtRQUNBeUIsYUFBYTtnQkFBQyxFQUFFdkUsTUFBTSxFQUFFO1lBQ3RCLElBQUksQ0FBQ0EsT0FBTzBDLEtBQUssQ0FBQ0ksU0FBUyxFQUFFO1lBQzdCLE1BQU12QixXQUFXM0gsZ0VBQWtCQSxDQUFDb0csT0FBT0QsU0FBUztZQUNwRGxHLDZEQUFRQSxDQUFDQywyREFBV0EsRUFBRTtnQkFDcEJpRixTQUFTO29CQUNQLENBQUN3QyxTQUFTLEVBQUU7d0JBQ1ZPLFNBQVM7NEJBQ1BnQixXQUFXOUMsT0FBTzBDLEtBQUssQ0FBQ0ksU0FBUzt3QkFDbkM7b0JBQ0Y7Z0JBQ0Y7WUFDRjtRQUNGO1FBQ0EwQixhQUFhO2dCQUFDLEVBQUVDLE1BQU0sRUFBRTtZQUN0Qm5LLG9CQUFvQixDQUFDO1lBRXJCLG1EQUFtRDtZQUNuRCxJQUFJb0ssWUFBWUM7WUFDaEIsSUFBSUMsV0FBV0Q7WUFDZixJQUFJRSxhQUFhLENBQUNGO1lBQ2xCLElBQUlHLGNBQWMsQ0FBQ0g7WUFFbkIsOENBQThDO1lBQzlDLElBQUssSUFBSUksSUFBSSxHQUFHQSxJQUFJTixPQUFPM0YsTUFBTSxFQUFFaUcsSUFBSztnQkFDdEMsTUFBTUMsUUFBUVAsTUFBTSxDQUFDTSxFQUFFO2dCQUN2QixNQUFNM0gsS0FBS3hELGdFQUFrQkEsQ0FBQ29MLE1BQU1oRixNQUFNLENBQUNELFNBQVM7Z0JBQ3BELE1BQU15QixZQUFZcEcsbUJBQW1CLENBQUNnQyxHQUFHO2dCQUV6QyxNQUFNckIsT0FBTzhGLFdBQVdMLHNCQUFBQSxnQ0FBQUEsVUFBV00sT0FBTyxDQUFDL0YsSUFBSTtnQkFDL0MsTUFBTUcsTUFBTTJGLFdBQVdMLHNCQUFBQSxnQ0FBQUEsVUFBV00sT0FBTyxDQUFDNUYsR0FBRztnQkFDN0MsTUFBTThGLFFBQVFnRCxNQUFNaEYsTUFBTSxDQUFDMEIsV0FBVztnQkFDdEMsTUFBTVEsU0FBUzhDLE1BQU1oRixNQUFNLENBQUM0QixZQUFZO2dCQUV4QzhDLFlBQVk5SCxLQUFLcUksR0FBRyxDQUFDUCxXQUFXM0k7Z0JBQ2hDNkksV0FBV2hJLEtBQUtxSSxHQUFHLENBQUNMLFVBQVUxSTtnQkFDOUIySSxhQUFhakksS0FBS3NJLEdBQUcsQ0FBQ0wsWUFBWTlJLE9BQU9pRztnQkFDekM4QyxjQUFjbEksS0FBS3NJLEdBQUcsQ0FBQ0osYUFBYTVJLE1BQU1nRztZQUM1QztZQUVBLE1BQU1pRCxhQUFhTixhQUFhSDtZQUNoQyxNQUFNVSxjQUFjTixjQUFjRjtZQUVsQyx1RUFBdUU7WUFDdkUsTUFBTVMsZ0JBQWdCWixNQUFNLENBQUMsRUFBRSxDQUFDbkQsZUFBZTtZQUUvQyxxREFBcUQ7WUFDckQsSUFBSWdFLGVBQWVaLFlBQVlXLGFBQWEsQ0FBQyxFQUFFO1lBQy9DLElBQUlFLGNBQWNYLFdBQVdTLGFBQWEsQ0FBQyxFQUFFO1lBRTdDLCtCQUErQjtZQUMvQixNQUFNdEQsY0FBYztnQkFDbEI7Z0JBQ0FuSCxLQUFLb0gsS0FBSyxHQUFHLElBQUltRCxhQUFhO2dCQUM5QnZLLEtBQUtvSCxLQUFLLEdBQUdtRCxXQUFXLGdCQUFnQjthQUN6QztZQUVELE1BQU1sRCxjQUFjO2dCQUNsQjtnQkFDQXJILEtBQUtzSCxNQUFNLEdBQUcsSUFBSWtELGNBQWM7Z0JBQ2hDeEssS0FBS3NILE1BQU0sR0FBR2tELFlBQVksaUJBQWlCO2FBQzVDO1lBRUQsd0JBQXdCO1lBQ3hCLE1BQU1JLG1CQUFtQmpKLFVBQVUrSSxjQUFjdkQ7WUFDakQsTUFBTTBELGtCQUFrQmxKLFVBQVVnSixhQUFhdEQ7WUFFL0MsZ0RBQWdEO1lBQ2hELE1BQU15RCxVQUFVRixtQkFBbUJGO1lBQ25DLE1BQU1LLFVBQVVGLGtCQUFrQkY7WUFFbEMsd0NBQXdDO1lBQ3hDLE1BQU1LLGlCQUNKaEosS0FBS0MsR0FBRyxDQUFDNkksWUFBWXBKLHVCQUNyQk0sS0FBS0MsR0FBRyxDQUFDOEksWUFBWXJKO1lBRXZCLDJEQUEyRDtZQUMzRCxJQUFLLElBQUl5SSxJQUFJLEdBQUdBLElBQUlOLE9BQU8zRixNQUFNLEVBQUVpRyxJQUFLO2dCQUN0QyxNQUFNQyxRQUFRUCxNQUFNLENBQUNNLEVBQUU7Z0JBQ3ZCLE1BQU0zSCxLQUFLeEQsZ0VBQWtCQSxDQUFDb0wsTUFBTWhGLE1BQU0sQ0FBQ0QsU0FBUztnQkFDcEQsTUFBTXlCLFlBQVlwRyxtQkFBbUIsQ0FBQ2dDLEdBQUc7Z0JBRXpDLE1BQU1yQixPQUFPOEYsV0FBV0wsc0JBQUFBLGdDQUFBQSxVQUFXTSxPQUFPLENBQUMvRixJQUFJLElBQzdDaUosTUFBTTFELGVBQWUsQ0FBQyxFQUFFLEdBQUdvRTtnQkFDN0IsTUFBTXhKLE1BQU0yRixXQUFXTCxzQkFBQUEsZ0NBQUFBLFVBQVdNLE9BQU8sQ0FBQzVGLEdBQUcsSUFDM0M4SSxNQUFNMUQsZUFBZSxDQUFDLEVBQUUsR0FBR3FFO2dCQUU3QlgsTUFBTWhGLE1BQU0sQ0FBQzBDLEtBQUssQ0FBQzNHLElBQUksR0FBRyxHQUFRLE9BQUxBLE1BQUs7Z0JBQ2xDaUosTUFBTWhGLE1BQU0sQ0FBQzBDLEtBQUssQ0FBQ3hHLEdBQUcsR0FBRyxHQUFPLE9BQUpBLEtBQUk7Z0JBRWhDLG1DQUFtQztnQkFDbkMsSUFBSTBKLGdCQUFnQjtvQkFDbEJaLE1BQU1oRixNQUFNLENBQUNvQyxTQUFTLENBQUNDLEdBQUcsQ0FBQztnQkFDN0IsT0FBTztvQkFDTDJDLE1BQU1oRixNQUFNLENBQUNvQyxTQUFTLENBQUNLLE1BQU0sQ0FBQztnQkFDaEM7Z0JBRUFuSSxpQkFBaUIsQ0FBQzhDLEdBQUcsR0FBRztvQkFDdEJyQixNQUFNQTtvQkFDTkcsS0FBS0E7Z0JBQ1A7WUFDRjtZQUVBLDhCQUE4QjtZQUM5QixJQUFJMEosa0JBQWtCLGFBQWFyRCxXQUFXO2dCQUM1Q0EsVUFBVUMsT0FBTyxDQUFDO1lBQ3BCO1FBQ0Y7UUFDQXFELFVBQVU7Z0JBQUMsRUFDVDdGLE1BQU0sRUFDTmdDLE9BQU84RCxTQUFTLEVBQ2hCNUQsUUFBUTZELFVBQVUsRUFDbEJoRCxTQUFTLEVBQ1Y7WUFDQyxJQUFJQSxTQUFTLENBQUMsRUFBRSxLQUFLLEdBQUc7b0JBYUQvQztnQkFackIsTUFBTTJELGVBQWUzRCxPQUFPNEQsV0FBVztnQkFDdkMsTUFBTUMsZ0JBQWdCN0QsT0FBTzhELFlBQVk7Z0JBRXpDLDJCQUEyQjtnQkFDM0IsTUFBTVQsU0FBUzBDLGFBQWFsQztnQkFDNUIsTUFBTW1DLFFBQVEzQztnQkFFZCwyQkFBMkI7Z0JBQzNCckQsT0FBTzBDLEtBQUssQ0FBQ1YsS0FBSyxHQUFHLEdBQXdCLE9BQXJCMkIsZUFBZXFDLE9BQU07Z0JBQzdDaEcsT0FBTzBDLEtBQUssQ0FBQ1IsTUFBTSxHQUFHLEdBQXlCLE9BQXRCMkIsZ0JBQWdCbUMsT0FBTTtnQkFFL0MsZ0NBQWdDO2dCQUNoQyxNQUFNQyxnQkFBZWpHLDRCQUFBQSxPQUFPa0csaUJBQWlCLGNBQXhCbEcsZ0RBQUFBLDBCQUNqQmtHLGlCQUFpQjtnQkFDckIsSUFBSUQsY0FBYztvQkFDaEJBLGFBQWF2RCxLQUFLLENBQUNWLEtBQUssR0FBRyxHQUF3QixPQUFyQjJCLGVBQWVxQyxPQUFNO29CQUNuREMsYUFBYXZELEtBQUssQ0FBQ1IsTUFBTSxHQUFHLEdBQXlCLE9BQXRCMkIsZ0JBQWdCbUMsT0FBTTtvQkFFckQsTUFBTUcsVUFDSkYsYUFBYUMsaUJBQWlCO29CQUNoQyxJQUFJQyxTQUFTO3dCQUNYLE1BQU1DLFdBQVd2RSxXQUFXd0UsaUJBQWlCRixTQUFTQyxRQUFRO3dCQUM5REQsUUFBUXpELEtBQUssQ0FBQzBELFFBQVEsR0FBRyxHQUFvQixPQUFqQkEsV0FBV0osT0FBTTt3QkFDN0NHLFFBQVF6RCxLQUFLLENBQUNWLEtBQUssR0FBRyxHQUF3QixPQUFyQjJCLGVBQWVxQyxPQUFNO3dCQUM5Q0csUUFBUXpELEtBQUssQ0FBQ1IsTUFBTSxHQUFHLEdBQXlCLE9BQXRCMkIsZ0JBQWdCbUMsT0FBTTtvQkFDbEQ7Z0JBQ0Y7WUFDRixPQUFPO29CQUtnQmhHO2dCQUpyQkEsT0FBTzBDLEtBQUssQ0FBQ1YsS0FBSyxHQUFHOEQsWUFBWTtnQkFDakM5RixPQUFPMEMsS0FBSyxDQUFDUixNQUFNLEdBQUc2RCxhQUFhO2dCQUVuQyxnQ0FBZ0M7Z0JBQ2hDLE1BQU1FLGdCQUFlakcsNkJBQUFBLE9BQU9rRyxpQkFBaUIsY0FBeEJsRyxpREFBQUEsMkJBQ2pCa0csaUJBQWlCO2dCQUNyQixJQUFJRCxjQUFjO29CQUNoQkEsYUFBYXZELEtBQUssQ0FBQ1YsS0FBSyxHQUFHLEdBQWEsT0FBVjhELFdBQVU7b0JBQ3hDRyxhQUFhdkQsS0FBSyxDQUFDUixNQUFNLEdBQUcsR0FBYyxPQUFYNkQsWUFBVztvQkFFMUMsTUFBTUksVUFDSkYsYUFBYUMsaUJBQWlCO29CQUNoQyxJQUFJQyxTQUFTO3dCQUNYQSxRQUFRekQsS0FBSyxDQUFDVixLQUFLLEdBQUcsR0FBYSxPQUFWOEQsV0FBVTt3QkFDbkNLLFFBQVF6RCxLQUFLLENBQUNSLE1BQU0sR0FBRyxHQUFjLE9BQVg2RCxZQUFXO29CQUN2QztnQkFDRjtZQUNGO1FBQ0Y7UUFDQU8sYUFBYTtnQkFBQyxFQUFFdEcsTUFBTSxFQUFFO2dCQUVOQSw2Q0FBQUE7WUFEaEIsTUFBTXVCLFdBQVczSCxnRUFBa0JBLENBQUNvRyxPQUFPRCxTQUFTO1lBQ3BELE1BQU1vRyxXQUFVbkcsNEJBQUFBLE9BQU9rRyxpQkFBaUIsY0FBeEJsRyxpREFBQUEsOENBQUFBLDBCQUEwQmtHLGlCQUFpQixjQUEzQ2xHLGtFQUFBQSw0Q0FDWmtHLGlCQUFpQjtZQUNyQnJNLDZEQUFRQSxDQUFDQywyREFBV0EsRUFBRTtnQkFDcEJpRixTQUFTO29CQUNQLENBQUN3QyxTQUFTLEVBQUU7d0JBQ1ZPLFNBQVM7NEJBQ1BFLE9BQU9ILFdBQVc3QixPQUFPMEMsS0FBSyxDQUFDVixLQUFLOzRCQUNwQ0UsUUFBUUwsV0FBVzdCLE9BQU8wQyxLQUFLLENBQUNSLE1BQU07NEJBQ3RDa0UsVUFBVXZFLFdBQVdzRSxRQUFRekQsS0FBSyxDQUFDMEQsUUFBUTt3QkFDN0M7b0JBQ0Y7Z0JBQ0Y7WUFDRjtRQUNGO1FBQ0FHLGdCQUFnQjtZQUNkLElBQUlqTSxtQkFBbUI7Z0JBQ3JCLE1BQU15RSxVQUF3QyxDQUFDO2dCQUMvQ3lILE9BQU9DLElBQUksQ0FBQ25NLG1CQUFtQm9NLE9BQU8sQ0FBQyxDQUFDdEo7b0JBQ3RDLE1BQU1yQixPQUFPekIsaUJBQWtCLENBQUM4QyxHQUFHLENBQUNyQixJQUFJO29CQUN4QyxNQUFNRyxNQUFNNUIsaUJBQWtCLENBQUM4QyxHQUFHLENBQUNsQixHQUFHO29CQUV0Qyw0QkFBNEI7b0JBQzVCLE1BQU15SyxVQUFVQyxTQUFTQyxhQUFhLENBQUMsT0FBVSxPQUFIeko7b0JBQzlDLElBQUl1SixTQUFTO3dCQUNYQSxRQUFRdkUsU0FBUyxDQUFDSyxNQUFNLENBQUM7b0JBQzNCO29CQUVBMUQsT0FBTyxDQUFDM0IsR0FBRyxHQUFHO3dCQUNaMEUsU0FBUzs0QkFDUDVGLEtBQUssR0FBTyxPQUFKQSxLQUFJOzRCQUNaSCxNQUFNLEdBQVEsT0FBTEEsTUFBSzt3QkFDaEI7b0JBQ0Y7Z0JBQ0Y7Z0JBQ0FsQyw2REFBUUEsQ0FBQ0MsMkRBQVdBLEVBQUU7b0JBQ3BCaUYsU0FBU0E7Z0JBQ1g7Z0JBQ0F6RSxvQkFBb0I7WUFDdEI7UUFDRjs7Ozs7O0FBR047R0FsaUJnQkU7O1FBZ0JWTCx3REFBUUE7UUFDbUNFLCtEQUFjQTs7O0tBakIvQ0ciLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vZmVhdHVyZXMvZWRpdG9yL3NjZW5lL2ludGVyYWN0aW9ucy50c3g/MmFlYyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBjbGllbnRcIjtcblxuaW1wb3J0IHsgdXNlRWZmZWN0LCB1c2VSZWYsIHVzZVN0YXRlIH0gZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgU2VsZWN0aW9uIGZyb20gXCJAaW50ZXJhY3RpZnkvc2VsZWN0aW9uXCI7XG5pbXBvcnQgTW92ZWFibGUgZnJvbSBcIkBpbnRlcmFjdGlmeS9tb3ZlYWJsZVwiO1xuaW1wb3J0IHsgZ2V0SWRGcm9tQ2xhc3NOYW1lIH0gZnJvbSBcIi4uL3V0aWxzL3NjZW5lXCI7XG5pbXBvcnQgeyBkaXNwYXRjaCB9IGZyb20gXCJAZGVzaWduY29tYm8vZXZlbnRzXCI7XG5pbXBvcnQgeyBFRElUX09CSkVDVCwgTEFZRVJfU0VMRUNUSU9OIH0gZnJvbSBcIkBkZXNpZ25jb21iby9zdGF0ZVwiO1xuaW1wb3J0IHtcbiAgU2VsZWN0aW9uSW5mbyxcbiAgZW1wdHlTZWxlY3Rpb24sXG4gIGdldFNlbGVjdGlvbkJ5SWRzLFxuICBnZXRUYXJnZXRCeUlkLFxufSBmcm9tIFwiLi4vdXRpbHMvdGFyZ2V0XCI7XG5pbXBvcnQgdXNlU3RvcmUgZnJvbSBcIi4uL3N0b3JlL3VzZS1zdG9yZVwiO1xuaW1wb3J0IFN0YXRlTWFuYWdlciBmcm9tIFwiQGRlc2lnbmNvbWJvL3N0YXRlXCI7XG5pbXBvcnQgeyBnZXRDdXJyZW50VGltZSB9IGZyb20gXCIuLi91dGlscy90aW1lXCI7XG5pbXBvcnQgdXNlTGF5b3V0U3RvcmUgZnJvbSBcIi4uL3N0b3JlL3VzZS1sYXlvdXQtc3RvcmVcIjtcblxubGV0IGhvbGRHcm91cFBvc2l0aW9uOiBSZWNvcmQ8c3RyaW5nLCBhbnk+IHwgbnVsbCA9IG51bGw7XG5sZXQgZHJhZ1N0YXJ0RW5kID0gZmFsc2U7XG5cbmludGVyZmFjZSBTY2VuZUludGVyYWN0aW9uc1Byb3BzIHtcbiAgc3RhdGVNYW5hZ2VyOiBTdGF0ZU1hbmFnZXI7XG4gIHZpZXdlclJlZjogUmVhY3QuUmVmT2JqZWN0PGFueT47XG4gIGNvbnRhaW5lclJlZjogUmVhY3QuUmVmT2JqZWN0PEhUTUxEaXZFbGVtZW50PjtcbiAgem9vbTogbnVtYmVyO1xuICBzaXplOiB7IHdpZHRoOiBudW1iZXI7IGhlaWdodDogbnVtYmVyIH07XG59XG5leHBvcnQgZnVuY3Rpb24gU2NlbmVJbnRlcmFjdGlvbnMoe1xuICBzdGF0ZU1hbmFnZXIsXG4gIHZpZXdlclJlZixcbiAgem9vbSxcbiAgc2l6ZSxcbiAgY29udGFpbmVyUmVmLFxufTogU2NlbmVJbnRlcmFjdGlvbnNQcm9wcykge1xuICBjb25zdCBbdGFyZ2V0cywgc2V0VGFyZ2V0c10gPSB1c2VTdGF0ZTxIVE1MRGl2RWxlbWVudFtdPihbXSk7XG4gIGNvbnN0IFtzZWxlY3Rpb24sIHNldFNlbGVjdGlvbl0gPSB1c2VTdGF0ZTxTZWxlY3Rpb24+KCk7XG4gIGNvbnN0IHtcbiAgICBhY3RpdmVJZHMsXG4gICAgc2V0U3RhdGUsXG4gICAgdHJhY2tJdGVtRGV0YWlsc01hcCxcbiAgICB0cmFja0l0ZW1zTWFwLFxuICAgIHBsYXllclJlZixcbiAgICBzZXRTY2VuZU1vdmVhYmxlUmVmLFxuICB9ID0gdXNlU3RvcmUoKTtcbiAgY29uc3QgeyBzZXRBY3RpdmVNZW51SXRlbSwgc2V0U2hvd01lbnVJdGVtIH0gPSB1c2VMYXlvdXRTdG9yZSgpO1xuICBjb25zdCBtb3ZlYWJsZVJlZiA9IHVzZVJlZjxNb3ZlYWJsZT4obnVsbCk7XG4gIGNvbnN0IFtzZWxlY3Rpb25JbmZvLCBzZXRTZWxlY3Rpb25JbmZvXSA9XG4gICAgdXNlU3RhdGU8U2VsZWN0aW9uSW5mbz4oZW1wdHlTZWxlY3Rpb24pO1xuXG4gIC8vIEVzdGFkbyBwYXJhIGxhcyBsw61uZWFzIGd1w61hXG4gIGNvbnN0IFtzaG93R3VpZGVzLCBzZXRTaG93R3VpZGVzXSA9IHVzZVN0YXRlKHtcbiAgICBsZWZ0OiBmYWxzZSxcbiAgICBjZW50ZXI6IGZhbHNlLFxuICAgIHJpZ2h0OiBmYWxzZSxcbiAgICB0b3A6IGZhbHNlLFxuICAgIG1pZGRsZTogZmFsc2UsXG4gICAgYm90dG9tOiBmYWxzZVxuICB9KTtcblxuICAvLyBDb25zdGFudGVzIHBhcmEgZWwgc25hcFxuICBjb25zdCBTTkFQX1RIUkVTSE9MRCA9IDE1OyAvLyBEaXN0YW5jaWEgZW4gcMOteGVsZXMgcGFyYSBhY3RpdmFyIGVsIHNuYXBcbiAgY29uc3QgU05BUF9FREdFX1RIUkVTSE9MRCA9IDU7IC8vIFVtYnJhbCBwYXJhIGNvbnNpZGVyYXIgcXVlIHVuIGVsZW1lbnRvIGVzdMOhIGVuIGVsIGJvcmRlXG5cbiAgLy8gRnVuY2nDs24gcGFyYSBhcGxpY2FyIHNuYXAgYSBjb29yZGVuYWRhc1xuICBjb25zdCBhcHBseVNuYXAgPSAodmFsdWU6IG51bWJlciwgc25hcFBvaW50czogbnVtYmVyW10sIHRocmVzaG9sZDogbnVtYmVyID0gU05BUF9USFJFU0hPTEQpOiBudW1iZXIgPT4ge1xuICAgIGZvciAoY29uc3QgcG9pbnQgb2Ygc25hcFBvaW50cykge1xuICAgICAgaWYgKE1hdGguYWJzKHZhbHVlIC0gcG9pbnQpIDw9IHRocmVzaG9sZCkge1xuICAgICAgICByZXR1cm4gcG9pbnQ7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbiAgfTtcblxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGNvbnN0IHVwZGF0ZVRhcmdldHMgPSAodGltZT86IG51bWJlcikgPT4ge1xuICAgICAgY29uc3QgY3VycmVudFRpbWUgPSB0aW1lIHx8IGdldEN1cnJlbnRUaW1lKCk7XG4gICAgICBjb25zdCB7IHRyYWNrSXRlbXNNYXAgfSA9IHVzZVN0b3JlLmdldFN0YXRlKCk7XG4gICAgICBjb25zdCB0YXJnZXRJZHMgPSBhY3RpdmVJZHMuZmlsdGVyKChpZCkgPT4ge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgIHRyYWNrSXRlbXNNYXBbaWRdPy5kaXNwbGF5LmZyb20gPD0gY3VycmVudFRpbWUgJiZcbiAgICAgICAgICB0cmFja0l0ZW1zTWFwW2lkXT8uZGlzcGxheS50byA+PSBjdXJyZW50VGltZVxuICAgICAgICApO1xuICAgICAgfSk7XG4gICAgICBjb25zdCB0YXJnZXRzID0gdGFyZ2V0SWRzLm1hcChcbiAgICAgICAgKGlkKSA9PiBnZXRUYXJnZXRCeUlkKGlkKSBhcyBIVE1MRGl2RWxlbWVudCxcbiAgICAgICk7XG4gICAgICBzZWxlY3Rpb24/LnNldFNlbGVjdGVkVGFyZ2V0cyh0YXJnZXRzKTtcbiAgICAgIGNvbnN0IHNlbEluZm8gPSBnZXRTZWxlY3Rpb25CeUlkcyh0YXJnZXRJZHMpO1xuXG4gICAgICBzZXRTZWxlY3Rpb25JbmZvKHNlbEluZm8pO1xuICAgICAgc2V0VGFyZ2V0cyhzZWxJbmZvLnRhcmdldHMgYXMgSFRNTERpdkVsZW1lbnRbXSk7XG4gICAgfTtcbiAgICBjb25zdCB0aW1lciA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgdXBkYXRlVGFyZ2V0cygpO1xuICAgIH0pO1xuXG4gICAgY29uc3Qgb25TZWVrZWQgPSAodjogYW55KSA9PiB7XG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgY29uc3QgeyBmcHMgfSA9IHVzZVN0b3JlLmdldFN0YXRlKCk7XG4gICAgICAgIGNvbnN0IHNlZWtlZFRpbWUgPSAodi5kZXRhaWwuZnJhbWUgLyBmcHMpICogMTAwMDtcbiAgICAgICAgdXBkYXRlVGFyZ2V0cyhzZWVrZWRUaW1lKTtcbiAgICAgIH0pO1xuICAgIH07XG4gICAgcGxheWVyUmVmPy5jdXJyZW50Py5hZGRFdmVudExpc3RlbmVyKFwic2Vla2VkXCIsIG9uU2Vla2VkKTtcblxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBwbGF5ZXJSZWY/LmN1cnJlbnQ/LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJzZWVrZWRcIiwgb25TZWVrZWQpO1xuICAgICAgY2xlYXJUaW1lb3V0KHRpbWVyKTtcbiAgICB9O1xuICB9LCBbYWN0aXZlSWRzLCBwbGF5ZXJSZWYsIHRyYWNrSXRlbXNNYXBdKTtcblxuICAvLyBGdW5jacOzbiBwYXJhIG1hbmVqYXIgbGEgc2VsZWNjacOzbiBkZSBlbGVtZW50b3NcbiAgY29uc3QgaGFuZGxlU2VsZWN0aW9uID0gKGlkczogc3RyaW5nW10pID0+IHtcbiAgICBjb25zb2xlLmxvZyhcIltERUJVRyBJbnRlcmFjdGlvbnNdIFNlbGVjY2nDs24gZGUgZWxlbWVudG9zOlwiLCBpZHMpO1xuXG4gICAgLy8gQWN0dWFsaXphciBlbCBlc3RhZG8gZGUgYWN0aXZlSWRzXG4gICAgc3RhdGVNYW5hZ2VyLnVwZGF0ZVN0YXRlKFxuICAgICAge1xuICAgICAgICBhY3RpdmVJZHM6IGlkcyxcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIHVwZGF0ZUhpc3Rvcnk6IGZhbHNlLFxuICAgICAgICBraW5kOiBcImxheWVyOnNlbGVjdGlvblwiLFxuICAgICAgfSxcbiAgICApO1xuXG4gICAgLy8gU2kgc2UgaGEgc2VsZWNjaW9uYWRvIHVuIHNvbG8gZWxlbWVudG8sIGNhbWJpYXIgaW5tZWRpYXRhbWVudGUgYWwgcGFuZWwgZGUgYXRyaWJ1dG9zXG4gICAgaWYgKGlkcyAmJiBpZHMubGVuZ3RoID09PSAxKSB7XG4gICAgICBjb25zb2xlLmxvZyhcIltERUJVRyBJbnRlcmFjdGlvbnNdIENhbWJpYW5kbyBhIHBhbmVsIGRlIGF0cmlidXRvcyBkaXJlY3RhbWVudGUgZGVzZGUgaW50ZXJhY3Rpb25zXCIpO1xuXG4gICAgICAvLyBGT1JaQVIgY2FtYmlvIGRpcmVjdG8gYWwgcGFuZWwgZGUgYXRyaWJ1dG9zXG4gICAgICBzZXRBY3RpdmVNZW51SXRlbShcImF0dHJpYnV0ZXNcIik7XG4gICAgICBzZXRTaG93TWVudUl0ZW0odHJ1ZSk7XG5cbiAgICAgIC8vIEZvcnphciBlbCBldmVudG8gZGUgc2VsZWNjacOzbiBwYXJhIGFzZWd1cmFyIHF1ZSB0b2RvcyBsb3MgY29tcG9uZW50ZXMgc2UgYWN0dWFsaWNlblxuICAgICAgZGlzcGF0Y2goTEFZRVJfU0VMRUNUSU9OLCB7XG4gICAgICAgIHBheWxvYWQ6IHtcbiAgICAgICAgICBhY3RpdmVJZHM6IGlkc1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgLy8gVmVyaWZpY2FyIGVsIGNhbWJpb1xuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRNZW51SXRlbSA9IHVzZUxheW91dFN0b3JlLmdldFN0YXRlKCkuYWN0aXZlTWVudUl0ZW07XG4gICAgICAgIGNvbnNvbGUubG9nKFwiW0RFQlVHIEludGVyYWN0aW9uc10gUGFuZWwgZGVzcHXDqXMgZGVsIGNhbWJpbzpcIiwgY3VycmVudE1lbnVJdGVtKTtcbiAgICAgIH0sIDEwMCk7XG4gICAgfVxuICB9O1xuXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgY29uc3Qgc2VsZWN0aW9uID0gbmV3IFNlbGVjdGlvbih7XG4gICAgICBjb250YWluZXI6IHZpZXdlclJlZi5jdXJyZW50Py5pbmZpbml0ZVZpZXdlci5nZXRDb250YWluZXIoKSxcbiAgICAgIGJvdW5kQ29udGFpbmVyOiB0cnVlLFxuICAgICAgaGl0UmF0ZTogMCxcbiAgICAgIHNlbGVjdGFibGVUYXJnZXRzOiBbXCIuZGVzaWduY29tYm8tc2NlbmUtaXRlbVwiXSxcbiAgICAgIHNlbGVjdEZyb21JbnNpZGU6IGZhbHNlLFxuICAgICAgc2VsZWN0QnlDbGljazogdHJ1ZSxcbiAgICAgIHRvZ2dsZUNvbnRpbnVlU2VsZWN0OiBcInNoaWZ0XCIsXG4gICAgfSlcbiAgICAgIC5vbihcInNlbGVjdFwiLCAoZSkgPT4ge1xuICAgICAgICBjb25zdCBpZHMgPSBlLnNlbGVjdGVkLm1hcCgoZWwpID0+IGdldElkRnJvbUNsYXNzTmFtZShlbC5jbGFzc05hbWUpKTtcbiAgICAgICAgc2V0VGFyZ2V0cyhlLnNlbGVjdGVkIGFzIEhUTUxEaXZFbGVtZW50W10pO1xuXG4gICAgICAgIC8vIFVzYXIgbGEgZnVuY2nDs24gaGFuZGxlU2VsZWN0aW9uXG4gICAgICAgIGhhbmRsZVNlbGVjdGlvbihpZHMpO1xuICAgICAgfSlcbiAgICAgIC5vbihcImRyYWdTdGFydFwiLCAoZSkgPT4ge1xuICAgICAgICBjb25zdCB0YXJnZXQgPSBlLmlucHV0RXZlbnQudGFyZ2V0IGFzIEhUTUxEaXZFbGVtZW50O1xuICAgICAgICBkcmFnU3RhcnRFbmQgPSBmYWxzZTtcblxuICAgICAgICBpZiAodGFyZ2V0cy5pbmNsdWRlcyh0YXJnZXQpKSB7XG4gICAgICAgICAgZS5zdG9wKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKFxuICAgICAgICAgIHRhcmdldCAmJlxuICAgICAgICAgIG1vdmVhYmxlUmVmPy5jdXJyZW50Py5tb3ZlYWJsZS5pc01vdmVhYmxlRWxlbWVudCh0YXJnZXQpXG4gICAgICAgICkge1xuICAgICAgICAgIGUuc3RvcCgpO1xuICAgICAgICB9XG4gICAgICB9KVxuICAgICAgLm9uKFwiZHJhZ0VuZFwiLCAoKSA9PiB7XG4gICAgICAgIGRyYWdTdGFydEVuZCA9IHRydWU7XG4gICAgICB9KVxuICAgICAgLm9uKFwic2VsZWN0RW5kXCIsIChlKSA9PiB7XG4gICAgICAgIGNvbnN0IG1vdmVhYmxlID0gbW92ZWFibGVSZWYuY3VycmVudDtcbiAgICAgICAgaWYgKGUuaXNEcmFnU3RhcnQpIHtcbiAgICAgICAgICBlLmlucHV0RXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIGlmICghZHJhZ1N0YXJ0RW5kKSB7XG4gICAgICAgICAgICAgIG1vdmVhYmxlPy5tb3ZlYWJsZS5kcmFnU3RhcnQoZS5pbnB1dEV2ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zdCB0YXJnZXRzID0gZS5zZWxlY3RlZCBhcyBIVE1MRGl2RWxlbWVudFtdO1xuICAgICAgICAgIGNvbnN0IGlkcyA9IHRhcmdldHMubWFwKChlbCkgPT4gZ2V0SWRGcm9tQ2xhc3NOYW1lKGVsLmNsYXNzTmFtZSkpO1xuXG4gICAgICAgICAgLy8gVXNhciBsYSBmdW5jacOzbiBoYW5kbGVTZWxlY3Rpb25cbiAgICAgICAgICBoYW5kbGVTZWxlY3Rpb24oaWRzKTtcbiAgICAgICAgICBzZXRUYXJnZXRzKHRhcmdldHMpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICBzZXRTZWxlY3Rpb24oc2VsZWN0aW9uKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgc2VsZWN0aW9uLmRlc3Ryb3koKTtcbiAgICB9O1xuICB9LCBbXSk7XG5cbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCBhY3RpdmVTZWxlY3Rpb25TdWJzY3JpcHRpb24gPSBzdGF0ZU1hbmFnZXIuc3Vic2NyaWJlVG9BY3RpdmVJZHMoXG4gICAgICAobmV3U3RhdGUpID0+IHtcbiAgICAgICAgc2V0U3RhdGUobmV3U3RhdGUpO1xuXG4gICAgICAgIC8vIFNpIGhheSB1biBzb2xvIGVsZW1lbnRvIHNlbGVjY2lvbmFkbywgYXNlZ3VyYXJzZSBkZSBxdWUgc2UgbXVlc3RyZSBlbCBwYW5lbCBkZSBhdHJpYnV0b3NcbiAgICAgICAgaWYgKG5ld1N0YXRlLmFjdGl2ZUlkcyAmJiBuZXdTdGF0ZS5hY3RpdmVJZHMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgc2V0QWN0aXZlTWVudUl0ZW0oXCJhdHRyaWJ1dGVzXCIpO1xuICAgICAgICAgIHNldFNob3dNZW51SXRlbSh0cnVlKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICApO1xuXG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGFjdGl2ZVNlbGVjdGlvblN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgIH07XG4gIH0sIFtdKTtcblxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIG1vdmVhYmxlUmVmLmN1cnJlbnQhLm1vdmVhYmxlLnVwZGF0ZVJlY3QoKTtcbiAgfSwgW3RyYWNrSXRlbXNNYXBdKTtcblxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIHNldFNjZW5lTW92ZWFibGVSZWYobW92ZWFibGVSZWYpO1xuICB9LCBbbW92ZWFibGVSZWZdKTtcbiAgcmV0dXJuIChcbiAgICA8TW92ZWFibGVcbiAgICAgIHJlZj17bW92ZWFibGVSZWZ9XG4gICAgICByb3RhdGlvblBvc2l0aW9uPXtcImJvdHRvbVwifVxuICAgICAgcmVuZGVyRGlyZWN0aW9ucz17c2VsZWN0aW9uSW5mby5jb250cm9sc31cbiAgICAgIHsuLi5zZWxlY3Rpb25JbmZvLmFibGVzfVxuICAgICAgb3JpZ2luPXtmYWxzZX1cbiAgICAgIHRhcmdldD17dGFyZ2V0c31cbiAgICAgIHpvb209ezEgLyB6b29tfVxuICAgICAgY2xhc3NOYW1lPVwiZGVzaWduY29tYm8tc2NlbmUtbW92ZWFibGVcIlxuICAgICAgb25EcmFnPXsoeyB0YXJnZXQsIGJlZm9yZVRyYW5zbGF0ZSwgaW5wdXRFdmVudCB9KSA9PiB7XG4gICAgICAgIGNvbnN0IHRhcmdldElkID0gZ2V0SWRGcm9tQ2xhc3NOYW1lKHRhcmdldC5jbGFzc05hbWUpIGFzIHN0cmluZztcbiAgICAgICAgY29uc3QgdHJhY2tJdGVtID0gdHJhY2tJdGVtRGV0YWlsc01hcFt0YXJnZXRJZF07XG5cbiAgICAgICAgLy8gT2J0ZW5lciBkaW1lbnNpb25lcyBkZWwgZWxlbWVudG9cbiAgICAgICAgY29uc3QgdGFyZ2V0V2lkdGggPSB0YXJnZXQub2Zmc2V0V2lkdGg7XG4gICAgICAgIGNvbnN0IHRhcmdldEhlaWdodCA9IHRhcmdldC5vZmZzZXRIZWlnaHQ7XG5cbiAgICAgICAgLy8gQ2FsY3VsYXIgbGEgcG9zaWNpw7NuIHByb3B1ZXN0YVxuICAgICAgICBsZXQgbGVmdCA9IHBhcnNlRmxvYXQodHJhY2tJdGVtPy5kZXRhaWxzLmxlZnQgYXMgc3RyaW5nKSArIGJlZm9yZVRyYW5zbGF0ZVswXTtcbiAgICAgICAgbGV0IHRvcCA9IHBhcnNlRmxvYXQodHJhY2tJdGVtPy5kZXRhaWxzLnRvcCBhcyBzdHJpbmcpICsgYmVmb3JlVHJhbnNsYXRlWzFdO1xuXG4gICAgICAgIC8vIFB1bnRvcyBkZSBzbmFwIHBhcmEgZWwgZWplIFggKGl6cXVpZXJkYSwgY2VudHJvLCBkZXJlY2hhKVxuICAgICAgICBjb25zdCBzbmFwUG9pbnRzWCA9IFtcbiAgICAgICAgICAwLCAvLyBCb3JkZSBpenF1aWVyZG9cbiAgICAgICAgICBzaXplLndpZHRoIC8gMiAtIHRhcmdldFdpZHRoIC8gMiwgLy8gQ2VudHJvIGhvcml6b250YWxcbiAgICAgICAgICBzaXplLndpZHRoIC0gdGFyZ2V0V2lkdGggLy8gQm9yZGUgZGVyZWNob1xuICAgICAgICBdO1xuXG4gICAgICAgIC8vIFB1bnRvcyBkZSBzbmFwIHBhcmEgZWwgZWplIFkgKGFycmliYSwgY2VudHJvLCBhYmFqbylcbiAgICAgICAgY29uc3Qgc25hcFBvaW50c1kgPSBbXG4gICAgICAgICAgMCwgLy8gQm9yZGUgc3VwZXJpb3JcbiAgICAgICAgICBzaXplLmhlaWdodCAvIDIgLSB0YXJnZXRIZWlnaHQgLyAyLCAvLyBDZW50cm8gdmVydGljYWxcbiAgICAgICAgICBzaXplLmhlaWdodCAtIHRhcmdldEhlaWdodCAvLyBCb3JkZSBpbmZlcmlvclxuICAgICAgICBdO1xuXG4gICAgICAgIC8vIEFwbGljYXIgc25hcCBjb24gdW1icmFsIG5vcm1hbFxuICAgICAgICBsZWZ0ID0gYXBwbHlTbmFwKGxlZnQsIHNuYXBQb2ludHNYKTtcbiAgICAgICAgdG9wID0gYXBwbHlTbmFwKHRvcCwgc25hcFBvaW50c1kpO1xuXG4gICAgICAgIC8vIEZlZWRiYWNrIHZpc3VhbCBwYXJhIGluZGljYXIgZWwgc25hcCAob3BjaW9uYWwpXG4gICAgICAgIGlmIChzbmFwUG9pbnRzWC5zb21lKHBvaW50ID0+IE1hdGguYWJzKGxlZnQgLSBwb2ludCkgPD0gU05BUF9FREdFX1RIUkVTSE9MRCkgfHxcbiAgICAgICAgICAgIHNuYXBQb2ludHNZLnNvbWUocG9pbnQgPT4gTWF0aC5hYnModG9wIC0gcG9pbnQpIDw9IFNOQVBfRURHRV9USFJFU0hPTEQpKSB7XG4gICAgICAgICAgLy8gU2UgcG9kcsOtYSBhw7FhZGlyIHVuYSBjbGFzZSBDU1MgcGFyYSBpbmRpY2FyIHZpc3VhbG1lbnRlIGVsIHNuYXBcbiAgICAgICAgICB0YXJnZXQuY2xhc3NMaXN0LmFkZCgnc25hcHBlZC1lbGVtZW50Jyk7XG5cbiAgICAgICAgICAvLyBBw7FhZGlyIHBlcXVlw7FhIHZpYnJhY2nDs24gY29tbyBmZWVkYmFjayB0w6FjdGlsIChvcGNpb25hbClcbiAgICAgICAgICBpZiAoaW5wdXRFdmVudCBpbnN0YW5jZW9mIE1vdXNlRXZlbnQgJiYgJ3ZpYnJhdGUnIGluIG5hdmlnYXRvcikge1xuICAgICAgICAgICAgbmF2aWdhdG9yLnZpYnJhdGUoMTApOyAvLyBWaWJyYWNpw7NuIHN1dGlsIGRlIDEwbXNcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGFyZ2V0LmNsYXNzTGlzdC5yZW1vdmUoJ3NuYXBwZWQtZWxlbWVudCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQWN0dWFsaXphciBwb3NpY2nDs25cbiAgICAgICAgdGFyZ2V0LnN0eWxlLnRvcCA9IHRvcCArIFwicHhcIjtcbiAgICAgICAgdGFyZ2V0LnN0eWxlLmxlZnQgPSBsZWZ0ICsgXCJweFwiO1xuICAgICAgfX1cbiAgICAgIG9uRHJhZ0VuZD17KHsgdGFyZ2V0LCBpc0RyYWcgfSkgPT4ge1xuICAgICAgICBpZiAoIWlzRHJhZykgcmV0dXJuO1xuICAgICAgICBjb25zdCB0YXJnZXRJZCA9IGdldElkRnJvbUNsYXNzTmFtZSh0YXJnZXQuY2xhc3NOYW1lKSBhcyBzdHJpbmc7XG5cbiAgICAgICAgLy8gRWxpbWluYXIgbGEgY2xhc2UgZGUgc25hcCBhbCBmaW5hbGl6YXJcbiAgICAgICAgdGFyZ2V0LmNsYXNzTGlzdC5yZW1vdmUoJ3NuYXBwZWQtZWxlbWVudCcpO1xuXG4gICAgICAgIGRpc3BhdGNoKEVESVRfT0JKRUNULCB7XG4gICAgICAgICAgcGF5bG9hZDoge1xuICAgICAgICAgICAgW3RhcmdldElkXToge1xuICAgICAgICAgICAgICBkZXRhaWxzOiB7XG4gICAgICAgICAgICAgICAgbGVmdDogdGFyZ2V0LnN0eWxlLmxlZnQsXG4gICAgICAgICAgICAgICAgdG9wOiB0YXJnZXQuc3R5bGUudG9wLFxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICAgIH19XG4gICAgICBvblNjYWxlPXsoeyB0YXJnZXQsIHRyYW5zZm9ybSwgZGlyZWN0aW9uIH0pID0+IHtcbiAgICAgICAgY29uc3QgW3hDb250cm9sLCB5Q29udHJvbF0gPSBkaXJlY3Rpb247XG5cbiAgICAgICAgY29uc3Qgc2NhbGVSZWdleCA9IC9zY2FsZVxcKChbXildKylcXCkvO1xuICAgICAgICBjb25zdCBtYXRjaCA9IHRhcmdldC5zdHlsZS50cmFuc2Zvcm0ubWF0Y2goc2NhbGVSZWdleCkhO1xuXG4gICAgICAgIC8vZ2V0IGN1cnJlbnQgc2NhbGVcbiAgICAgICAgY29uc3QgW3NjYWxlWCwgc2NhbGVZXSA9IG1hdGNoWzFdXG4gICAgICAgICAgLnNwbGl0KFwiLFwiKVxuICAgICAgICAgIC5tYXAoKHZhbHVlKSA9PiBwYXJzZUZsb2F0KHZhbHVlLnRyaW0oKSkpO1xuXG4gICAgICAgIC8vZ2V0IG5ldyBTY2FsZVxuICAgICAgICBjb25zdCBtYXRjaDIgPSB0cmFuc2Zvcm0ubWF0Y2goc2NhbGVSZWdleCkhO1xuICAgICAgICBjb25zdCBbbmV3U2NhbGVYLCBuZXdTY2FsZVldID0gbWF0Y2gyWzFdXG4gICAgICAgICAgLnNwbGl0KFwiLFwiKVxuICAgICAgICAgIC5tYXAoKHZhbHVlKSA9PiBwYXJzZUZsb2F0KHZhbHVlLnRyaW0oKSkpO1xuXG4gICAgICAgIGNvbnN0IGN1cnJlbnRXaWR0aCA9IHRhcmdldC5jbGllbnRXaWR0aCAqIHNjYWxlWDtcbiAgICAgICAgY29uc3QgY3VycmVudEhlaWdodCA9IHRhcmdldC5jbGllbnRIZWlnaHQgKiBzY2FsZVk7XG5cbiAgICAgICAgY29uc3QgbmV3V2lkdGggPSB0YXJnZXQuY2xpZW50V2lkdGggKiBuZXdTY2FsZVg7XG4gICAgICAgIGNvbnN0IG5ld0hlaWdodCA9IHRhcmdldC5jbGllbnRIZWlnaHQgKiBuZXdTY2FsZVk7XG5cbiAgICAgICAgdGFyZ2V0LnN0eWxlLnRyYW5zZm9ybSA9IHRyYW5zZm9ybTtcblxuICAgICAgICAvL01vdmUgZWxlbWVudCB0byBpbml0aWFsIExlZnQgcG9zaXRpb25cbiAgICAgICAgY29uc3QgZGlmZlggPSBjdXJyZW50V2lkdGggLSBuZXdXaWR0aDtcbiAgICAgICAgbGV0IG5ld0xlZnQgPSBwYXJzZUZsb2F0KHRhcmdldC5zdHlsZS5sZWZ0KSAtIGRpZmZYIC8gMjtcblxuICAgICAgICBjb25zdCBkaWZmWSA9IGN1cnJlbnRIZWlnaHQgLSBuZXdIZWlnaHQ7XG4gICAgICAgIGxldCBuZXdUb3AgPSBwYXJzZUZsb2F0KHRhcmdldC5zdHlsZS50b3ApIC0gZGlmZlkgLyAyO1xuXG4gICAgICAgIGlmICh4Q29udHJvbCA9PT0gLTEpIHtcbiAgICAgICAgICBuZXdMZWZ0ICs9IGRpZmZYO1xuICAgICAgICB9XG4gICAgICAgIGlmICh5Q29udHJvbCA9PT0gLTEpIHtcbiAgICAgICAgICBuZXdUb3AgKz0gZGlmZlk7XG4gICAgICAgIH1cbiAgICAgICAgdGFyZ2V0LnN0eWxlLmxlZnQgPSBuZXdMZWZ0ICsgXCJweFwiO1xuICAgICAgICB0YXJnZXQuc3R5bGUudG9wID0gbmV3VG9wICsgXCJweFwiO1xuICAgICAgfX1cbiAgICAgIG9uU2NhbGVFbmQ9eyh7IHRhcmdldCB9KSA9PiB7XG4gICAgICAgIGlmICghdGFyZ2V0LnN0eWxlLnRyYW5zZm9ybSkgcmV0dXJuO1xuICAgICAgICBjb25zdCB0YXJnZXRJZCA9IGdldElkRnJvbUNsYXNzTmFtZSh0YXJnZXQuY2xhc3NOYW1lKSBhcyBzdHJpbmc7XG5cbiAgICAgICAgZGlzcGF0Y2goRURJVF9PQkpFQ1QsIHtcbiAgICAgICAgICBwYXlsb2FkOiB7XG4gICAgICAgICAgICBbdGFyZ2V0SWRdOiB7XG4gICAgICAgICAgICAgIGRldGFpbHM6IHtcbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm06IHRhcmdldC5zdHlsZS50cmFuc2Zvcm0sXG4gICAgICAgICAgICAgICAgbGVmdDogcGFyc2VGbG9hdCh0YXJnZXQuc3R5bGUubGVmdCksXG4gICAgICAgICAgICAgICAgdG9wOiBwYXJzZUZsb2F0KHRhcmdldC5zdHlsZS50b3ApLFxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICAgIH19XG4gICAgICBvblJvdGF0ZT17KHsgdGFyZ2V0LCB0cmFuc2Zvcm0gfSkgPT4ge1xuICAgICAgICB0YXJnZXQuc3R5bGUudHJhbnNmb3JtID0gdHJhbnNmb3JtO1xuICAgICAgfX1cbiAgICAgIG9uUm90YXRlRW5kPXsoeyB0YXJnZXQgfSkgPT4ge1xuICAgICAgICBpZiAoIXRhcmdldC5zdHlsZS50cmFuc2Zvcm0pIHJldHVybjtcbiAgICAgICAgY29uc3QgdGFyZ2V0SWQgPSBnZXRJZEZyb21DbGFzc05hbWUodGFyZ2V0LmNsYXNzTmFtZSkgYXMgc3RyaW5nO1xuICAgICAgICBkaXNwYXRjaChFRElUX09CSkVDVCwge1xuICAgICAgICAgIHBheWxvYWQ6IHtcbiAgICAgICAgICAgIFt0YXJnZXRJZF06IHtcbiAgICAgICAgICAgICAgZGV0YWlsczoge1xuICAgICAgICAgICAgICAgIHRyYW5zZm9ybTogdGFyZ2V0LnN0eWxlLnRyYW5zZm9ybSxcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgICB9fVxuICAgICAgb25EcmFnR3JvdXA9eyh7IGV2ZW50cyB9KSA9PiB7XG4gICAgICAgIGhvbGRHcm91cFBvc2l0aW9uID0ge307XG5cbiAgICAgICAgLy8gT2J0ZW5lciBlbCByZWN0w6FuZ3VsbyBxdWUgY29udGllbmUgdG9kbyBlbCBncnVwb1xuICAgICAgICBsZXQgZ3JvdXBMZWZ0ID0gSW5maW5pdHk7XG4gICAgICAgIGxldCBncm91cFRvcCA9IEluZmluaXR5O1xuICAgICAgICBsZXQgZ3JvdXBSaWdodCA9IC1JbmZpbml0eTtcbiAgICAgICAgbGV0IGdyb3VwQm90dG9tID0gLUluZmluaXR5O1xuXG4gICAgICAgIC8vIFByaW1lciBwYXNvOiBjYWxjdWxhciBkaW1lbnNpb25lcyBkZWwgZ3J1cG9cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBldmVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBjb25zdCBldmVudCA9IGV2ZW50c1tpXTtcbiAgICAgICAgICBjb25zdCBpZCA9IGdldElkRnJvbUNsYXNzTmFtZShldmVudC50YXJnZXQuY2xhc3NOYW1lKTtcbiAgICAgICAgICBjb25zdCB0cmFja0l0ZW0gPSB0cmFja0l0ZW1EZXRhaWxzTWFwW2lkXTtcblxuICAgICAgICAgIGNvbnN0IGxlZnQgPSBwYXJzZUZsb2F0KHRyYWNrSXRlbT8uZGV0YWlscy5sZWZ0IGFzIHN0cmluZyk7XG4gICAgICAgICAgY29uc3QgdG9wID0gcGFyc2VGbG9hdCh0cmFja0l0ZW0/LmRldGFpbHMudG9wIGFzIHN0cmluZyk7XG4gICAgICAgICAgY29uc3Qgd2lkdGggPSBldmVudC50YXJnZXQub2Zmc2V0V2lkdGg7XG4gICAgICAgICAgY29uc3QgaGVpZ2h0ID0gZXZlbnQudGFyZ2V0Lm9mZnNldEhlaWdodDtcblxuICAgICAgICAgIGdyb3VwTGVmdCA9IE1hdGgubWluKGdyb3VwTGVmdCwgbGVmdCk7XG4gICAgICAgICAgZ3JvdXBUb3AgPSBNYXRoLm1pbihncm91cFRvcCwgdG9wKTtcbiAgICAgICAgICBncm91cFJpZ2h0ID0gTWF0aC5tYXgoZ3JvdXBSaWdodCwgbGVmdCArIHdpZHRoKTtcbiAgICAgICAgICBncm91cEJvdHRvbSA9IE1hdGgubWF4KGdyb3VwQm90dG9tLCB0b3AgKyBoZWlnaHQpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgZ3JvdXBXaWR0aCA9IGdyb3VwUmlnaHQgLSBncm91cExlZnQ7XG4gICAgICAgIGNvbnN0IGdyb3VwSGVpZ2h0ID0gZ3JvdXBCb3R0b20gLSBncm91cFRvcDtcblxuICAgICAgICAvLyBDYWxjdWxhciBlbCBkZXNwbGF6YW1pZW50byBiYXNlIGRlbCBncnVwbyAoZGVzZGUgZWwgcHJpbWVyIGVsZW1lbnRvKVxuICAgICAgICBjb25zdCBiYXNlVHJhbnNsYXRlID0gZXZlbnRzWzBdLmJlZm9yZVRyYW5zbGF0ZTtcblxuICAgICAgICAvLyBDYWxjdWxhciBudWV2YSBwb3NpY2nDs24gZGVsIGdydXBvIGNvbiBwb3NpYmxlIHNuYXBcbiAgICAgICAgbGV0IG5ld0dyb3VwTGVmdCA9IGdyb3VwTGVmdCArIGJhc2VUcmFuc2xhdGVbMF07XG4gICAgICAgIGxldCBuZXdHcm91cFRvcCA9IGdyb3VwVG9wICsgYmFzZVRyYW5zbGF0ZVsxXTtcblxuICAgICAgICAvLyBQdW50b3MgZGUgc25hcCBwYXJhIGVsIGdydXBvXG4gICAgICAgIGNvbnN0IHNuYXBQb2ludHNYID0gW1xuICAgICAgICAgIDAsIC8vIEJvcmRlIGl6cXVpZXJkb1xuICAgICAgICAgIHNpemUud2lkdGggLyAyIC0gZ3JvdXBXaWR0aCAvIDIsIC8vIENlbnRybyBob3Jpem9udGFsXG4gICAgICAgICAgc2l6ZS53aWR0aCAtIGdyb3VwV2lkdGggLy8gQm9yZGUgZGVyZWNob1xuICAgICAgICBdO1xuXG4gICAgICAgIGNvbnN0IHNuYXBQb2ludHNZID0gW1xuICAgICAgICAgIDAsIC8vIEJvcmRlIHN1cGVyaW9yXG4gICAgICAgICAgc2l6ZS5oZWlnaHQgLyAyIC0gZ3JvdXBIZWlnaHQgLyAyLCAvLyBDZW50cm8gdmVydGljYWxcbiAgICAgICAgICBzaXplLmhlaWdodCAtIGdyb3VwSGVpZ2h0IC8vIEJvcmRlIGluZmVyaW9yXG4gICAgICAgIF07XG5cbiAgICAgICAgLy8gQXBsaWNhciBzbmFwIGFsIGdydXBvXG4gICAgICAgIGNvbnN0IHNuYXBwZWRHcm91cExlZnQgPSBhcHBseVNuYXAobmV3R3JvdXBMZWZ0LCBzbmFwUG9pbnRzWCk7XG4gICAgICAgIGNvbnN0IHNuYXBwZWRHcm91cFRvcCA9IGFwcGx5U25hcChuZXdHcm91cFRvcCwgc25hcFBvaW50c1kpO1xuXG4gICAgICAgIC8vIENhbGN1bGFyIGVsIGFqdXN0ZSBuZWNlc2FyaW8gZGVzcHXDqXMgZGVsIHNuYXBcbiAgICAgICAgY29uc3QgYWRqdXN0WCA9IHNuYXBwZWRHcm91cExlZnQgLSBuZXdHcm91cExlZnQ7XG4gICAgICAgIGNvbnN0IGFkanVzdFkgPSBzbmFwcGVkR3JvdXBUb3AgLSBuZXdHcm91cFRvcDtcblxuICAgICAgICAvLyBGZWVkYmFjayB2aXN1YWwgcGFyYSBlbCBzbmFwIGRlIGdydXBvXG4gICAgICAgIGNvbnN0IGlzR3JvdXBTbmFwcGVkID1cbiAgICAgICAgICBNYXRoLmFicyhhZGp1c3RYKSA8PSBTTkFQX0VER0VfVEhSRVNIT0xEIHx8XG4gICAgICAgICAgTWF0aC5hYnMoYWRqdXN0WSkgPD0gU05BUF9FREdFX1RIUkVTSE9MRDtcblxuICAgICAgICAvLyBBcGxpY2FyIGVsIG1vdmltaWVudG8gYWp1c3RhZG8gYSBjYWRhIGVsZW1lbnRvIGRlbCBncnVwb1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGV2ZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGNvbnN0IGV2ZW50ID0gZXZlbnRzW2ldO1xuICAgICAgICAgIGNvbnN0IGlkID0gZ2V0SWRGcm9tQ2xhc3NOYW1lKGV2ZW50LnRhcmdldC5jbGFzc05hbWUpO1xuICAgICAgICAgIGNvbnN0IHRyYWNrSXRlbSA9IHRyYWNrSXRlbURldGFpbHNNYXBbaWRdO1xuXG4gICAgICAgICAgY29uc3QgbGVmdCA9IHBhcnNlRmxvYXQodHJhY2tJdGVtPy5kZXRhaWxzLmxlZnQgYXMgc3RyaW5nKSArXG4gICAgICAgICAgICBldmVudC5iZWZvcmVUcmFuc2xhdGVbMF0gKyBhZGp1c3RYO1xuICAgICAgICAgIGNvbnN0IHRvcCA9IHBhcnNlRmxvYXQodHJhY2tJdGVtPy5kZXRhaWxzLnRvcCBhcyBzdHJpbmcpICtcbiAgICAgICAgICAgIGV2ZW50LmJlZm9yZVRyYW5zbGF0ZVsxXSArIGFkanVzdFk7XG5cbiAgICAgICAgICBldmVudC50YXJnZXQuc3R5bGUubGVmdCA9IGAke2xlZnR9cHhgO1xuICAgICAgICAgIGV2ZW50LnRhcmdldC5zdHlsZS50b3AgPSBgJHt0b3B9cHhgO1xuXG4gICAgICAgICAgLy8gQXBsaWNhciBjbGFzZSB2aXN1YWwgc2kgaGF5IHNuYXBcbiAgICAgICAgICBpZiAoaXNHcm91cFNuYXBwZWQpIHtcbiAgICAgICAgICAgIGV2ZW50LnRhcmdldC5jbGFzc0xpc3QuYWRkKCdzbmFwcGVkLWVsZW1lbnQnKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZXZlbnQudGFyZ2V0LmNsYXNzTGlzdC5yZW1vdmUoJ3NuYXBwZWQtZWxlbWVudCcpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGhvbGRHcm91cFBvc2l0aW9uW2lkXSA9IHtcbiAgICAgICAgICAgIGxlZnQ6IGxlZnQsXG4gICAgICAgICAgICB0b3A6IHRvcCxcbiAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRmVlZGJhY2sgdMOhY3RpbCBzaSBoYXkgc25hcFxuICAgICAgICBpZiAoaXNHcm91cFNuYXBwZWQgJiYgJ3ZpYnJhdGUnIGluIG5hdmlnYXRvcikge1xuICAgICAgICAgIG5hdmlnYXRvci52aWJyYXRlKDEwKTtcbiAgICAgICAgfVxuICAgICAgfX1cbiAgICAgIG9uUmVzaXplPXsoe1xuICAgICAgICB0YXJnZXQsXG4gICAgICAgIHdpZHRoOiBuZXh0V2lkdGgsXG4gICAgICAgIGhlaWdodDogbmV4dEhlaWdodCxcbiAgICAgICAgZGlyZWN0aW9uLFxuICAgICAgfSkgPT4ge1xuICAgICAgICBpZiAoZGlyZWN0aW9uWzFdID09PSAxKSB7XG4gICAgICAgICAgY29uc3QgY3VycmVudFdpZHRoID0gdGFyZ2V0LmNsaWVudFdpZHRoO1xuICAgICAgICAgIGNvbnN0IGN1cnJlbnRIZWlnaHQgPSB0YXJnZXQuY2xpZW50SGVpZ2h0O1xuXG4gICAgICAgICAgLy8gR2V0IG5ldyB3aWR0aCBhbmQgaGVpZ2h0XG4gICAgICAgICAgY29uc3Qgc2NhbGVZID0gbmV4dEhlaWdodCAvIGN1cnJlbnRIZWlnaHQ7XG4gICAgICAgICAgY29uc3Qgc2NhbGUgPSBzY2FsZVk7XG5cbiAgICAgICAgICAvLyBVcGRhdGUgdGFyZ2V0IGRpbWVuc2lvbnNcbiAgICAgICAgICB0YXJnZXQuc3R5bGUud2lkdGggPSBgJHtjdXJyZW50V2lkdGggKiBzY2FsZX1weGA7XG4gICAgICAgICAgdGFyZ2V0LnN0eWxlLmhlaWdodCA9IGAke2N1cnJlbnRIZWlnaHQgKiBzY2FsZX1weGA7XG5cbiAgICAgICAgICAvLyBTYWZlbHkgYWNjZXNzIG5lc3RlZCBlbGVtZW50c1xuICAgICAgICAgIGNvbnN0IGFuaW1hdGlvbkRpdiA9IHRhcmdldC5maXJzdEVsZW1lbnRDaGlsZFxuICAgICAgICAgICAgPy5maXJzdEVsZW1lbnRDaGlsZCBhcyBIVE1MRGl2RWxlbWVudCB8IG51bGw7XG4gICAgICAgICAgaWYgKGFuaW1hdGlvbkRpdikge1xuICAgICAgICAgICAgYW5pbWF0aW9uRGl2LnN0eWxlLndpZHRoID0gYCR7Y3VycmVudFdpZHRoICogc2NhbGV9cHhgO1xuICAgICAgICAgICAgYW5pbWF0aW9uRGl2LnN0eWxlLmhlaWdodCA9IGAke2N1cnJlbnRIZWlnaHQgKiBzY2FsZX1weGA7XG5cbiAgICAgICAgICAgIGNvbnN0IHRleHREaXYgPVxuICAgICAgICAgICAgICBhbmltYXRpb25EaXYuZmlyc3RFbGVtZW50Q2hpbGQgYXMgSFRNTERpdkVsZW1lbnQgfCBudWxsO1xuICAgICAgICAgICAgaWYgKHRleHREaXYpIHtcbiAgICAgICAgICAgICAgY29uc3QgZm9udFNpemUgPSBwYXJzZUZsb2F0KGdldENvbXB1dGVkU3R5bGUodGV4dERpdikuZm9udFNpemUpO1xuICAgICAgICAgICAgICB0ZXh0RGl2LnN0eWxlLmZvbnRTaXplID0gYCR7Zm9udFNpemUgKiBzY2FsZX1weGA7XG4gICAgICAgICAgICAgIHRleHREaXYuc3R5bGUud2lkdGggPSBgJHtjdXJyZW50V2lkdGggKiBzY2FsZX1weGA7XG4gICAgICAgICAgICAgIHRleHREaXYuc3R5bGUuaGVpZ2h0ID0gYCR7Y3VycmVudEhlaWdodCAqIHNjYWxlfXB4YDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGFyZ2V0LnN0eWxlLndpZHRoID0gbmV4dFdpZHRoICsgXCJweFwiO1xuICAgICAgICAgIHRhcmdldC5zdHlsZS5oZWlnaHQgPSBuZXh0SGVpZ2h0ICsgXCJweFwiO1xuXG4gICAgICAgICAgLy8gU2FmZWx5IGFjY2VzcyBuZXN0ZWQgZWxlbWVudHNcbiAgICAgICAgICBjb25zdCBhbmltYXRpb25EaXYgPSB0YXJnZXQuZmlyc3RFbGVtZW50Q2hpbGRcbiAgICAgICAgICAgID8uZmlyc3RFbGVtZW50Q2hpbGQgYXMgSFRNTERpdkVsZW1lbnQgfCBudWxsO1xuICAgICAgICAgIGlmIChhbmltYXRpb25EaXYpIHtcbiAgICAgICAgICAgIGFuaW1hdGlvbkRpdi5zdHlsZS53aWR0aCA9IGAke25leHRXaWR0aH1weGA7XG4gICAgICAgICAgICBhbmltYXRpb25EaXYuc3R5bGUuaGVpZ2h0ID0gYCR7bmV4dEhlaWdodH1weGA7XG5cbiAgICAgICAgICAgIGNvbnN0IHRleHREaXYgPVxuICAgICAgICAgICAgICBhbmltYXRpb25EaXYuZmlyc3RFbGVtZW50Q2hpbGQgYXMgSFRNTERpdkVsZW1lbnQgfCBudWxsO1xuICAgICAgICAgICAgaWYgKHRleHREaXYpIHtcbiAgICAgICAgICAgICAgdGV4dERpdi5zdHlsZS53aWR0aCA9IGAke25leHRXaWR0aH1weGA7XG4gICAgICAgICAgICAgIHRleHREaXYuc3R5bGUuaGVpZ2h0ID0gYCR7bmV4dEhlaWdodH1weGA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9fVxuICAgICAgb25SZXNpemVFbmQ9eyh7IHRhcmdldCB9KSA9PiB7XG4gICAgICAgIGNvbnN0IHRhcmdldElkID0gZ2V0SWRGcm9tQ2xhc3NOYW1lKHRhcmdldC5jbGFzc05hbWUpIGFzIHN0cmluZztcbiAgICAgICAgY29uc3QgdGV4dERpdiA9IHRhcmdldC5maXJzdEVsZW1lbnRDaGlsZD8uZmlyc3RFbGVtZW50Q2hpbGRcbiAgICAgICAgICA/LmZpcnN0RWxlbWVudENoaWxkIGFzIEhUTUxEaXZFbGVtZW50O1xuICAgICAgICBkaXNwYXRjaChFRElUX09CSkVDVCwge1xuICAgICAgICAgIHBheWxvYWQ6IHtcbiAgICAgICAgICAgIFt0YXJnZXRJZF06IHtcbiAgICAgICAgICAgICAgZGV0YWlsczoge1xuICAgICAgICAgICAgICAgIHdpZHRoOiBwYXJzZUZsb2F0KHRhcmdldC5zdHlsZS53aWR0aCksXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiBwYXJzZUZsb2F0KHRhcmdldC5zdHlsZS5oZWlnaHQpLFxuICAgICAgICAgICAgICAgIGZvbnRTaXplOiBwYXJzZUZsb2F0KHRleHREaXYuc3R5bGUuZm9udFNpemUpLFxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICAgIH19XG4gICAgICBvbkRyYWdHcm91cEVuZD17KCkgPT4ge1xuICAgICAgICBpZiAoaG9sZEdyb3VwUG9zaXRpb24pIHtcbiAgICAgICAgICBjb25zdCBwYXlsb2FkOiBSZWNvcmQ8c3RyaW5nLCBQYXJ0aWFsPGFueT4+ID0ge307XG4gICAgICAgICAgT2JqZWN0LmtleXMoaG9sZEdyb3VwUG9zaXRpb24pLmZvckVhY2goKGlkKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBsZWZ0ID0gaG9sZEdyb3VwUG9zaXRpb24hW2lkXS5sZWZ0O1xuICAgICAgICAgICAgY29uc3QgdG9wID0gaG9sZEdyb3VwUG9zaXRpb24hW2lkXS50b3A7XG5cbiAgICAgICAgICAgIC8vIEVsaW1pbmFyIGxhIGNsYXNlIGRlIHNuYXBcbiAgICAgICAgICAgIGNvbnN0IGVsZW1lbnQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKGAuaWQtJHtpZH1gKTtcbiAgICAgICAgICAgIGlmIChlbGVtZW50KSB7XG4gICAgICAgICAgICAgIGVsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZSgnc25hcHBlZC1lbGVtZW50Jyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHBheWxvYWRbaWRdID0ge1xuICAgICAgICAgICAgICBkZXRhaWxzOiB7XG4gICAgICAgICAgICAgICAgdG9wOiBgJHt0b3B9cHhgLFxuICAgICAgICAgICAgICAgIGxlZnQ6IGAke2xlZnR9cHhgLFxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBkaXNwYXRjaChFRElUX09CSkVDVCwge1xuICAgICAgICAgICAgcGF5bG9hZDogcGF5bG9hZCxcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBob2xkR3JvdXBQb3NpdGlvbiA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgIH19XG4gICAgLz5cbiAgKTtcbn1cblxuIl0sIm5hbWVzIjpbInVzZUVmZmVjdCIsInVzZVJlZiIsInVzZVN0YXRlIiwiU2VsZWN0aW9uIiwiTW92ZWFibGUiLCJnZXRJZEZyb21DbGFzc05hbWUiLCJkaXNwYXRjaCIsIkVESVRfT0JKRUNUIiwiTEFZRVJfU0VMRUNUSU9OIiwiZW1wdHlTZWxlY3Rpb24iLCJnZXRTZWxlY3Rpb25CeUlkcyIsImdldFRhcmdldEJ5SWQiLCJ1c2VTdG9yZSIsImdldEN1cnJlbnRUaW1lIiwidXNlTGF5b3V0U3RvcmUiLCJob2xkR3JvdXBQb3NpdGlvbiIsImRyYWdTdGFydEVuZCIsIlNjZW5lSW50ZXJhY3Rpb25zIiwic3RhdGVNYW5hZ2VyIiwidmlld2VyUmVmIiwiem9vbSIsInNpemUiLCJjb250YWluZXJSZWYiLCJ0YXJnZXRzIiwic2V0VGFyZ2V0cyIsInNlbGVjdGlvbiIsInNldFNlbGVjdGlvbiIsImFjdGl2ZUlkcyIsInNldFN0YXRlIiwidHJhY2tJdGVtRGV0YWlsc01hcCIsInRyYWNrSXRlbXNNYXAiLCJwbGF5ZXJSZWYiLCJzZXRTY2VuZU1vdmVhYmxlUmVmIiwic2V0QWN0aXZlTWVudUl0ZW0iLCJzZXRTaG93TWVudUl0ZW0iLCJtb3ZlYWJsZVJlZiIsInNlbGVjdGlvbkluZm8iLCJzZXRTZWxlY3Rpb25JbmZvIiwic2hvd0d1aWRlcyIsInNldFNob3dHdWlkZXMiLCJsZWZ0IiwiY2VudGVyIiwicmlnaHQiLCJ0b3AiLCJtaWRkbGUiLCJib3R0b20iLCJTTkFQX1RIUkVTSE9MRCIsIlNOQVBfRURHRV9USFJFU0hPTEQiLCJhcHBseVNuYXAiLCJ2YWx1ZSIsInNuYXBQb2ludHMiLCJ0aHJlc2hvbGQiLCJwb2ludCIsIk1hdGgiLCJhYnMiLCJ1cGRhdGVUYXJnZXRzIiwidGltZSIsImN1cnJlbnRUaW1lIiwiZ2V0U3RhdGUiLCJ0YXJnZXRJZHMiLCJmaWx0ZXIiLCJpZCIsImRpc3BsYXkiLCJmcm9tIiwidG8iLCJtYXAiLCJzZXRTZWxlY3RlZFRhcmdldHMiLCJzZWxJbmZvIiwidGltZXIiLCJzZXRUaW1lb3V0Iiwib25TZWVrZWQiLCJ2IiwiZnBzIiwic2Vla2VkVGltZSIsImRldGFpbCIsImZyYW1lIiwiY3VycmVudCIsImFkZEV2ZW50TGlzdGVuZXIiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiY2xlYXJUaW1lb3V0IiwiaGFuZGxlU2VsZWN0aW9uIiwiaWRzIiwiY29uc29sZSIsImxvZyIsInVwZGF0ZVN0YXRlIiwidXBkYXRlSGlzdG9yeSIsImtpbmQiLCJsZW5ndGgiLCJwYXlsb2FkIiwiY3VycmVudE1lbnVJdGVtIiwiYWN0aXZlTWVudUl0ZW0iLCJjb250YWluZXIiLCJpbmZpbml0ZVZpZXdlciIsImdldENvbnRhaW5lciIsImJvdW5kQ29udGFpbmVyIiwiaGl0UmF0ZSIsInNlbGVjdGFibGVUYXJnZXRzIiwic2VsZWN0RnJvbUluc2lkZSIsInNlbGVjdEJ5Q2xpY2siLCJ0b2dnbGVDb250aW51ZVNlbGVjdCIsIm9uIiwiZSIsInNlbGVjdGVkIiwiZWwiLCJjbGFzc05hbWUiLCJ0YXJnZXQiLCJpbnB1dEV2ZW50IiwiaW5jbHVkZXMiLCJzdG9wIiwibW92ZWFibGUiLCJpc01vdmVhYmxlRWxlbWVudCIsImlzRHJhZ1N0YXJ0IiwicHJldmVudERlZmF1bHQiLCJkcmFnU3RhcnQiLCJkZXN0cm95IiwiYWN0aXZlU2VsZWN0aW9uU3Vic2NyaXB0aW9uIiwic3Vic2NyaWJlVG9BY3RpdmVJZHMiLCJuZXdTdGF0ZSIsInVuc3Vic2NyaWJlIiwidXBkYXRlUmVjdCIsInJlZiIsInJvdGF0aW9uUG9zaXRpb24iLCJyZW5kZXJEaXJlY3Rpb25zIiwiY29udHJvbHMiLCJhYmxlcyIsIm9yaWdpbiIsIm9uRHJhZyIsImJlZm9yZVRyYW5zbGF0ZSIsInRhcmdldElkIiwidHJhY2tJdGVtIiwidGFyZ2V0V2lkdGgiLCJvZmZzZXRXaWR0aCIsInRhcmdldEhlaWdodCIsIm9mZnNldEhlaWdodCIsInBhcnNlRmxvYXQiLCJkZXRhaWxzIiwic25hcFBvaW50c1giLCJ3aWR0aCIsInNuYXBQb2ludHNZIiwiaGVpZ2h0Iiwic29tZSIsImNsYXNzTGlzdCIsImFkZCIsIk1vdXNlRXZlbnQiLCJuYXZpZ2F0b3IiLCJ2aWJyYXRlIiwicmVtb3ZlIiwic3R5bGUiLCJvbkRyYWdFbmQiLCJpc0RyYWciLCJvblNjYWxlIiwidHJhbnNmb3JtIiwiZGlyZWN0aW9uIiwieENvbnRyb2wiLCJ5Q29udHJvbCIsInNjYWxlUmVnZXgiLCJtYXRjaCIsInNjYWxlWCIsInNjYWxlWSIsInNwbGl0IiwidHJpbSIsIm1hdGNoMiIsIm5ld1NjYWxlWCIsIm5ld1NjYWxlWSIsImN1cnJlbnRXaWR0aCIsImNsaWVudFdpZHRoIiwiY3VycmVudEhlaWdodCIsImNsaWVudEhlaWdodCIsIm5ld1dpZHRoIiwibmV3SGVpZ2h0IiwiZGlmZlgiLCJuZXdMZWZ0IiwiZGlmZlkiLCJuZXdUb3AiLCJvblNjYWxlRW5kIiwib25Sb3RhdGUiLCJvblJvdGF0ZUVuZCIsIm9uRHJhZ0dyb3VwIiwiZXZlbnRzIiwiZ3JvdXBMZWZ0IiwiSW5maW5pdHkiLCJncm91cFRvcCIsImdyb3VwUmlnaHQiLCJncm91cEJvdHRvbSIsImkiLCJldmVudCIsIm1pbiIsIm1heCIsImdyb3VwV2lkdGgiLCJncm91cEhlaWdodCIsImJhc2VUcmFuc2xhdGUiLCJuZXdHcm91cExlZnQiLCJuZXdHcm91cFRvcCIsInNuYXBwZWRHcm91cExlZnQiLCJzbmFwcGVkR3JvdXBUb3AiLCJhZGp1c3RYIiwiYWRqdXN0WSIsImlzR3JvdXBTbmFwcGVkIiwib25SZXNpemUiLCJuZXh0V2lkdGgiLCJuZXh0SGVpZ2h0Iiwic2NhbGUiLCJhbmltYXRpb25EaXYiLCJmaXJzdEVsZW1lbnRDaGlsZCIsInRleHREaXYiLCJmb250U2l6ZSIsImdldENvbXB1dGVkU3R5bGUiLCJvblJlc2l6ZUVuZCIsIm9uRHJhZ0dyb3VwRW5kIiwiT2JqZWN0Iiwia2V5cyIsImZvckVhY2giLCJlbGVtZW50IiwiZG9jdW1lbnQiLCJxdWVyeVNlbGVjdG9yIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./features/editor/scene/interactions.tsx\n"));

/***/ })

});
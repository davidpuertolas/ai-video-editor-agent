"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./components/ai-chat/ai-video-commands.ts":
/*!*************************************************!*\
  !*** ./components/ai-chat/ai-video-commands.ts ***!
  \*************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createVideoCommandExecutor: function() { return /* binding */ createVideoCommandExecutor; }\n/* harmony export */ });\n/* harmony import */ var _designcombo_events__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @designcombo/events */ \"(app-pages-browser)/./node_modules/@designcombo/events/dist/index.es.js\");\n/* harmony import */ var _designcombo_state__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @designcombo/state */ \"(app-pages-browser)/./node_modules/@designcombo/state/dist/index.es.js\");\n/* harmony import */ var _designcombo_timeline__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @designcombo/timeline */ \"(app-pages-browser)/./node_modules/@designcombo/timeline/dist/index.es.js\");\n\n\n\nfunction createVideoCommandExecutor(stateManager) {\n    // Crear el objeto executor con todos los métodos\n    const executor = {\n        addText: (text, options)=>{\n            const position = (options === null || options === void 0 ? void 0 : options.position) || {\n                x: 0.5,\n                y: 0.5\n            }; // Centrado por defecto\n            const fontSize = (options === null || options === void 0 ? void 0 : options.fontSize) || 48;\n            const fontFamily = (options === null || options === void 0 ? void 0 : options.fontFamily) || \"Roboto-Bold\";\n            const color = (options === null || options === void 0 ? void 0 : options.color) || \"#FFFFFF\";\n            const startTime = (options === null || options === void 0 ? void 0 : options.startTime) || 0; // Por defecto al inicio\n            const endTime = (options === null || options === void 0 ? void 0 : options.endTime) || 5; // Por defecto 5 segundos de duración\n            // Crear payload para el texto\n            const textPayload = {\n                id: (0,_designcombo_timeline__WEBPACK_IMPORTED_MODULE_2__.generateId)(),\n                display: {\n                    from: startTime * 1000,\n                    to: endTime * 1000 // Convertir a milisegundos\n                },\n                type: \"text\",\n                details: {\n                    text: text,\n                    fontSize: fontSize,\n                    width: 600,\n                    fontFamily: fontFamily,\n                    color: color,\n                    wordWrap: \"break-word\",\n                    textAlign: \"center\",\n                    borderWidth: 0,\n                    borderColor: \"#000000\",\n                    boxShadow: {\n                        color: \"#ffffff\",\n                        x: 0,\n                        y: 0,\n                        blur: 0\n                    }\n                }\n            };\n            // Agregar texto al timeline\n            (0,_designcombo_events__WEBPACK_IMPORTED_MODULE_0__.dispatch)(_designcombo_state__WEBPACK_IMPORTED_MODULE_1__.ADD_TEXT, {\n                payload: textPayload,\n                options: {}\n            });\n        },\n        changeColor: (elementId, color)=>{\n            // Simulación de cambio de color (la implementación real dependerá de la estructura del proyecto)\n            console.log(\"Cambiando color del elemento \".concat(elementId, \" a \").concat(color));\n        // Aquí iría la lógica real para cambiar el color de un elemento\n        },\n        addImage: (url, options)=>{\n            // Asegurar que tenemos una URL válida\n            if (!url) {\n                console.error(\"URL de imagen no v\\xe1lida\");\n                return;\n            }\n            // Verificar si es una URL genérica de referencia, que no debe usarse directamente\n            if (url === \"imagen_adjunta_por_el_usuario.jpg\" || url.includes(\"/url_de_la_imagen\")) {\n                console.error(\"Error: URL de imagen gen\\xe9rica inv\\xe1lida detectada\", url);\n                throw new Error(\"La URL de imagen no es v\\xe1lida. Se intent\\xf3 usar un marcador gen\\xe9rico directamente.\");\n            }\n            const width = (options === null || options === void 0 ? void 0 : options.width) || 480;\n            const height = (options === null || options === void 0 ? void 0 : options.height) || 270;\n            const startTime = (options === null || options === void 0 ? void 0 : options.startTime) !== undefined ? options.startTime : 0;\n            const endTime = (options === null || options === void 0 ? void 0 : options.endTime) !== undefined ? options.endTime : startTime + 5;\n            // Para depuración, mostrar parte de la URL (truncada si es data:URL)\n            const logUrl = url.startsWith(\"data:\") ? \"\".concat(url.substring(0, 30), \"... (data URL)\") : url;\n            console.log(\"A\\xf1adiendo imagen desde \".concat(logUrl, \" desde segundo \").concat(startTime, \" hasta \").concat(endTime));\n            // Pre-cargar la imagen para obtener sus dimensiones reales\n            const preloadImage = (imageUrl)=>{\n                return new Promise((resolve)=>{\n                    if (imageUrl.startsWith(\"data:\")) {\n                        // Para data URLs, creamos una imagen temporal\n                        const img = new Image();\n                        img.onload = ()=>{\n                            resolve({\n                                width: img.width,\n                                height: img.height\n                            });\n                        };\n                        img.onerror = ()=>{\n                            console.warn(\"Error al cargar la imagen para dimensiones, usando valores por defecto\");\n                            resolve({\n                                width: 480,\n                                height: 270\n                            });\n                        };\n                        img.src = imageUrl;\n                    } else {\n                        // Para URLs normales, usamos dimensiones predeterminadas\n                        resolve({\n                            width: 480,\n                            height: 270\n                        });\n                    }\n                });\n            };\n            // Función para crear el payload después de pre-cargar la imagen\n            const createAndDispatchPayload = async ()=>{\n                try {\n                    // Obtener dimensiones reales si es una data URL\n                    let finalWidth = width;\n                    let finalHeight = height;\n                    if (url.startsWith(\"data:\")) {\n                        const dimensions = await preloadImage(url);\n                        // Calcular proporciones para mantener relación de aspecto\n                        const aspectRatio = dimensions.width / dimensions.height;\n                        // Ajustar dimensiones manteniendo proporción\n                        if (aspectRatio > 1) {\n                            finalWidth = Math.min(640, dimensions.width);\n                            finalHeight = finalWidth / aspectRatio;\n                        } else {\n                            finalHeight = Math.min(480, dimensions.height);\n                            finalWidth = finalHeight * aspectRatio;\n                        }\n                        console.log(\"Dimensiones originales: \".concat(dimensions.width, \"x\").concat(dimensions.height, \", Ajustadas: \").concat(finalWidth, \"x\").concat(finalHeight));\n                    }\n                    // Obtener posición (centrada por defecto)\n                    const position = (options === null || options === void 0 ? void 0 : options.position) || {\n                        x: 0.5,\n                        y: 0.5\n                    };\n                    // Crear payload para la imagen con dimensiones ajustadas\n                    const imagePayload = {\n                        id: (0,_designcombo_timeline__WEBPACK_IMPORTED_MODULE_2__.generateId)(),\n                        display: {\n                            from: startTime * 1000,\n                            to: endTime * 1000 // Convertir a milisegundos\n                        },\n                        type: \"image\",\n                        details: {\n                            src: url,\n                            width: finalWidth,\n                            height: finalHeight,\n                            opacity: 100,\n                            scaleMode: \"fit\",\n                            left: position.x,\n                            top: position.y,\n                            originX: \"center\",\n                            originY: \"center\"\n                        }\n                    };\n                    // Agregar imagen al timeline\n                    (0,_designcombo_events__WEBPACK_IMPORTED_MODULE_0__.dispatch)(_designcombo_state__WEBPACK_IMPORTED_MODULE_1__.ADD_IMAGE, {\n                        payload: imagePayload,\n                        options: {\n                            scaleMode: \"fit\",\n                            position: position\n                        }\n                    });\n                    console.log(\"Imagen agregada correctamente al timeline en posici\\xf3n (\".concat(position.x, \", \").concat(position.y, \")\"));\n                } catch (error) {\n                    console.error(\"Error al agregar imagen al timeline:\", error);\n                    throw new Error(\"Error al agregar imagen: \".concat(error instanceof Error ? error.message : \"Error desconocido\"));\n                }\n            };\n            // Iniciar el proceso\n            createAndDispatchPayload();\n        },\n        addVideo: (url, options)=>{\n            console.log(\"[addVideo] Iniciando addVideo para URL: \".concat(url));\n            console.log(\"[addVideo] Opciones recibidas:\", options);\n            try {\n                const { startTime = 0, endTime = 5, width, height, position } = options;\n                console.log(\"[addVideo] Par\\xe1metros procesados: startTime=\".concat(startTime, \", endTime=\").concat(endTime, \", width=\").concat(width, \", height=\").concat(height));\n                console.log(\"[addVideo] Position:\", position);\n                // Verificar si la URL termina con .apng o .mov para tratarlos como transiciones a pantalla completa\n                const isAPNG = url.toLowerCase().endsWith(\".apng\");\n                const isMOV = url.toLowerCase().endsWith(\".mov\");\n                const needsFullscreen = isAPNG || isMOV;\n                console.log(\"[addVideo] Tipo de archivo: APNG=\".concat(isAPNG, \", MOV=\").concat(isMOV, \", needsFullscreen=\").concat(needsFullscreen));\n                // Crear un payload para el video\n                console.log(\"[addVideo] Creando payload para el video...\");\n                const payload = {\n                    id: (0,_designcombo_timeline__WEBPACK_IMPORTED_MODULE_2__.generateId)(),\n                    display: {\n                        from: startTime * 1000,\n                        to: endTime * 1000\n                    },\n                    type: \"video\",\n                    details: {\n                        src: url,\n                        width: width || 640,\n                        height: height || 360,\n                        opacity: 100,\n                        scaleMode: needsFullscreen ? \"cover\" : \"fit\",\n                        left: (position === null || position === void 0 ? void 0 : position.x) || 0.5,\n                        top: (position === null || position === void 0 ? void 0 : position.y) || 0.5,\n                        originX: \"center\",\n                        originY: \"center\"\n                    }\n                };\n                console.log(\"[addVideo] Payload generado:\", payload);\n                // Despachar la acción para añadir el video\n                console.log(\"[addVideo] Despachando acci\\xf3n ADD_VIDEO...\");\n                (0,_designcombo_events__WEBPACK_IMPORTED_MODULE_0__.dispatch)(_designcombo_state__WEBPACK_IMPORTED_MODULE_1__.ADD_VIDEO, {\n                    payload,\n                    options: {\n                        scaleMode: needsFullscreen ? \"cover\" : \"fit\",\n                        position: position || {\n                            x: 0.5,\n                            y: 0.5\n                        },\n                        resourceId: \"main\"\n                    }\n                });\n                console.log(\"[addVideo] \".concat(isAPNG ? \"APNG\" : isMOV ? \"MOV\" : \"Video\", \" a\\xf1adido exitosamente a la l\\xednea de tiempo.\"));\n                console.log(\"[addVideo] Video a\\xf1adido en tiempo: \".concat(startTime, \"s - \").concat(endTime, \"s\"));\n                console.log(\"[addVideo] Dimensiones: \".concat(payload.details.width, \"x\").concat(payload.details.height));\n                return payload.id;\n            } catch (error) {\n                console.error(\"[addVideo] Error al a\\xf1adir video:\", error);\n                throw new Error(\"Error adding video: \".concat(error instanceof Error ? error.message : String(error)));\n            }\n        },\n        changeDuration: (elementId, duration)=>{\n            // Simulación de cambio de duración (la implementación real dependerá de la estructura del proyecto)\n            console.log(\"Cambiando duraci\\xf3n del elemento \".concat(elementId, \" a \").concat(duration, \"s\"));\n        // Aquí iría la lógica real para cambiar la duración de un elemento\n        },\n        changeTransition: (elementId, transition)=>{\n            // Simulación de cambio de transición (la implementación real dependerá de la estructura del proyecto)\n            console.log(\"Cambiando transici\\xf3n del elemento \".concat(elementId, \" a \").concat(transition));\n        // Aquí iría la lógica real para cambiar la transición de un elemento\n        },\n        addSubtitles: async (options)=>{\n            try {\n                console.log(\"A\\xf1adiendo subt\\xedtulos directamente sin depender del bot\\xf3n\");\n                // Función para parsear el tiempo de formato SRT a milisegundos\n                const parseTimeToMs = (timeString)=>{\n                    const [hours, minutes, secondsAndMs] = timeString.split(\":\");\n                    const [seconds, ms] = secondsAndMs.split(\",\");\n                    return parseInt(hours) * 3600000 + parseInt(minutes) * 60000 + parseInt(seconds) * 1000 + parseInt(ms);\n                };\n                // Función para parsear el archivo SRT\n                const parseSRT = (srtContent)=>{\n                    const segments = [];\n                    const blocks = srtContent.trim().split(\"\\n\\n\");\n                    blocks.forEach((block)=>{\n                        const lines = block.split(\"\\n\");\n                        if (lines.length >= 3) {\n                            const id = parseInt(lines[0]);\n                            const timeRange = lines[1].split(\" --> \");\n                            const startTime = parseTimeToMs(timeRange[0]);\n                            const endTime = parseTimeToMs(timeRange[1]);\n                            const text = lines.slice(2).join(\"\\n\"); // Unir todas las líneas de texto\n                            segments.push({\n                                id,\n                                startTime,\n                                endTime,\n                                text\n                            });\n                        }\n                    });\n                    return segments;\n                };\n                // Función para dividir un texto en grupos de aproximadamente 3 palabras\n                const splitTextIntoGroups = function(text) {\n                    let wordsPerGroup = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 3;\n                    const words = text.split(/\\s+/);\n                    const groups = [];\n                    for(let i = 0; i < words.length; i += wordsPerGroup){\n                        const group = words.slice(i, i + wordsPerGroup).join(\" \");\n                        groups.push(group);\n                    }\n                    return groups;\n                };\n                // Función para procesar un segmento y dividirlo en múltiples segmentos si es necesario\n                const processSegment = (segment)=>{\n                    const textGroups = splitTextIntoGroups(segment.text);\n                    // Si solo hay un grupo, devolver el segmento original\n                    if (textGroups.length <= 1) {\n                        return [\n                            segment\n                        ];\n                    }\n                    // Calcular la duración de cada grupo\n                    const totalDuration = segment.endTime - segment.startTime;\n                    const groupDuration = totalDuration / textGroups.length;\n                    // Crear un nuevo segmento para cada grupo\n                    return textGroups.map((groupText, index)=>{\n                        const startTime = segment.startTime + index * groupDuration;\n                        const endTime = startTime + groupDuration;\n                        return {\n                            id: segment.id * 1000 + index,\n                            startTime,\n                            endTime,\n                            text: groupText\n                        };\n                    });\n                };\n                // Función para crear el payload de texto para subtítulos\n                const createSubtitlePayload = (text, startTime, endTime)=>({\n                        id: (0,_designcombo_timeline__WEBPACK_IMPORTED_MODULE_2__.generateId)(),\n                        display: {\n                            from: startTime,\n                            to: endTime\n                        },\n                        type: \"text\",\n                        details: {\n                            text: text.toUpperCase(),\n                            fontSize: 80,\n                            width: 900,\n                            fontUrl: \"/fonts/mrbeast.ttf\",\n                            fontFamily: \"MrBeast\",\n                            color: \"#FFFF00\",\n                            wordWrap: \"break-word\",\n                            textAlign: \"center\",\n                            borderWidth: 20,\n                            borderColor: \"#000000\",\n                            boxShadow: {\n                                color: \"#000000\",\n                                x: 3,\n                                y: 3,\n                                blur: 0\n                            },\n                            backgroundColor: \"transparent\",\n                            padding: 10,\n                            borderRadius: 0\n                        }\n                    });\n                // Cargar el archivo SRT\n                console.log(\"Cargando archivo SRT...\");\n                const response = await fetch(\"/transcriptions/transcription1.srt\");\n                if (!response.ok) {\n                    throw new Error(\"Error al cargar el archivo SRT: \".concat(response.status));\n                }\n                const srtContent = await response.text();\n                console.log(\"Archivo SRT cargado correctamente\");\n                // Parsear el archivo SRT\n                let segments = parseSRT(srtContent);\n                console.log(\"Se encontraron \".concat(segments.length, \" segmentos de subt\\xedtulos\"));\n                // Siempre usar el modo agrupado (dividir en grupos de 3 palabras)\n                segments = segments.flatMap(processSegment);\n                console.log(\"Despu\\xe9s de procesar, hay \".concat(segments.length, \" segmentos de subt\\xedtulos\"));\n                // Filtrar por tiempo si es necesario\n                if ((options === null || options === void 0 ? void 0 : options.startTime) !== undefined || (options === null || options === void 0 ? void 0 : options.endTime) !== undefined) {\n                    const originalLength = segments.length;\n                    segments = segments.filter((segment)=>{\n                        const passesStartFilter = options.startTime === undefined || segment.startTime >= options.startTime * 1000;\n                        const passesEndFilter = options.endTime === undefined || segment.endTime <= options.endTime * 1000;\n                        return passesStartFilter && passesEndFilter;\n                    });\n                    console.log(\"Filtrado por tiempo: de \".concat(originalLength, \" a \").concat(segments.length, \" segmentos\"));\n                }\n                // Añadir los subtítulos con un retraso entre cada uno\n                console.log(\"A\\xf1adiendo \".concat(segments.length, \" segmentos de subt\\xedtulos al timeline...\"));\n                segments.forEach((segment, index)=>{\n                    setTimeout(()=>{\n                        (0,_designcombo_events__WEBPACK_IMPORTED_MODULE_0__.dispatch)(_designcombo_state__WEBPACK_IMPORTED_MODULE_1__.ADD_TEXT, {\n                            payload: createSubtitlePayload(segment.text, segment.startTime, segment.endTime),\n                            options: {}\n                        });\n                        if ((index + 1) % 10 === 0 || index === segments.length - 1) {\n                            console.log(\"Progreso: \".concat(index + 1, \"/\").concat(segments.length, \" subt\\xedtulos a\\xf1adidos\"));\n                        }\n                    }, index * 200); // 200ms de retraso entre cada subtítulo\n                });\n                return true;\n            } catch (error) {\n                console.error(\"Error al a\\xf1adir subt\\xedtulos:\", error);\n                return false;\n            }\n        },\n        getActiveElements: async ()=>{\n            try {\n                // Obtener el estado actual\n                const state = stateManager.getState();\n                // Verificar si hay IDs activos\n                if (!state.activeIds || state.activeIds.length === 0) {\n                    console.log(\"No hay elementos activos seleccionados\");\n                    return [];\n                }\n                // Verificar si hay elementos en el trackItemsMap\n                if (!state.trackItemsMap) {\n                    console.log(\"No hay trackItemsMap disponible\");\n                    return [];\n                }\n                // Obtener información de los elementos activos\n                const activeElements = state.activeIds.filter((id)=>state.trackItemsMap[id]).map((id)=>{\n                    var _item_display, _item_display1;\n                    const item = state.trackItemsMap[id];\n                    return {\n                        id,\n                        trackId: item.trackId,\n                        type: item.type,\n                        from: (_item_display = item.display) === null || _item_display === void 0 ? void 0 : _item_display.from,\n                        to: (_item_display1 = item.display) === null || _item_display1 === void 0 ? void 0 : _item_display1.to,\n                        duration: item.display ? item.display.to - item.display.from : 0,\n                        details: item.details\n                    };\n                });\n                console.log(\"Se encontraron \".concat(activeElements.length, \" elementos activos\"));\n                return activeElements;\n            } catch (error) {\n                console.error(\"Error al obtener elementos activos:\", error);\n                return [];\n            }\n        },\n        getAllTimelineElements: async ()=>{\n            try {\n                // Obtener el estado actual\n                const state = stateManager.getState();\n                // Verificar si hay elementos en el trackItemsMap\n                if (!state.trackItemsMap || Object.keys(state.trackItemsMap).length === 0) {\n                    console.log(\"No hay elementos en el trackItemsMap\");\n                    // Buscar elementos en otras propiedades del estado\n                    for (const key of Object.keys(state)){\n                        if (typeof state[key] === \"object\" && state[key] !== null) {\n                            const objValue = state[key];\n                            console.log(\"Explorando propiedad alternativa: \".concat(key));\n                            // Verificar si parece ser un mapa de elementos\n                            if (Object.keys(objValue).length > 0) {\n                                const sample = objValue[Object.keys(objValue)[0]];\n                                if (sample && sample.display && sample.type) {\n                                    console.log(\"Encontrada posible fuente alternativa de elementos en propiedad \".concat(key));\n                                    // Procesar elementos de esta propiedad alternativa\n                                    return Object.entries(objValue).filter((param)=>{\n                                        let [_, item] = param;\n                                        return item && item.display;\n                                    }).map((param)=>{\n                                        let [id, item] = param;\n                                        var _item_display, _item_display1;\n                                        return {\n                                            id,\n                                            trackId: item.trackId,\n                                            type: item.type,\n                                            from: (_item_display = item.display) === null || _item_display === void 0 ? void 0 : _item_display.from,\n                                            to: (_item_display1 = item.display) === null || _item_display1 === void 0 ? void 0 : _item_display1.to,\n                                            duration: item.display ? item.display.to - item.display.from : 0,\n                                            details: item.details\n                                        };\n                                    });\n                                }\n                            }\n                        }\n                    }\n                    return [];\n                }\n                // Obtener todos los elementos\n                const allElements = Object.entries(state.trackItemsMap).filter((param)=>{\n                    let [_, item] = param;\n                    return item && item.display;\n                }).map((param)=>{\n                    let [id, item] = param;\n                    var _item_display, _item_display1;\n                    return {\n                        id,\n                        trackId: item.trackId,\n                        type: item.type,\n                        from: (_item_display = item.display) === null || _item_display === void 0 ? void 0 : _item_display.from,\n                        to: (_item_display1 = item.display) === null || _item_display1 === void 0 ? void 0 : _item_display1.to,\n                        duration: item.display ? item.display.to - item.display.from : 0,\n                        details: item.details\n                    };\n                }).sort((a, b)=>(a.from || 0) - (b.from || 0));\n                console.log(\"Se encontraron \".concat(allElements.length, \" elementos en el timeline\"));\n                return allElements;\n            } catch (error) {\n                console.error(\"Error al obtener todos los elementos del timeline:\", error);\n                return [];\n            }\n        },\n        removeSegments: async (segments)=>{\n            try {\n                console.log(\"Iniciando eliminaci\\xf3n de segmentos m\\xfaltiples\");\n                // Obtener el estado actual\n                const state = stateManager.getState();\n                // Validar que haya elementos en la timeline\n                if (!state.activeIds || state.activeIds.length === 0) {\n                    console.error(\"No hay elementos seleccionados en la timeline\");\n                    // Buscar el primer elemento disponible en la timeline\n                    const trackItemsMap = state.trackItemsMap || {};\n                    const trackItems = Object.keys(trackItemsMap);\n                    if (trackItems.length === 0) {\n                        console.error(\"No hay elementos en la timeline para eliminar segmentos\");\n                        throw new Error(\"No hay elementos en la timeline\");\n                    }\n                    // Seleccionar el primer elemento disponible\n                    const firstItemId = trackItems[0];\n                    console.log(\"Seleccionando autom\\xe1ticamente el elemento con ID: \".concat(firstItemId));\n                    (0,_designcombo_events__WEBPACK_IMPORTED_MODULE_0__.dispatch)(_designcombo_state__WEBPACK_IMPORTED_MODULE_1__.LAYER_SELECT, {\n                        payload: {\n                            ids: [\n                                firstItemId\n                            ]\n                        }\n                    });\n                    // Esperar a que se aplique la selección\n                    await new Promise((resolve)=>setTimeout(resolve, 300));\n                }\n                // Almacenamos información del elemento seleccionado\n                const currentState = stateManager.getState();\n                if (!currentState.activeIds || currentState.activeIds.length === 0) {\n                    throw new Error(\"No se pudo seleccionar ning\\xfan elemento en la timeline\");\n                }\n                const originalItemId = currentState.activeIds[0];\n                const originalItem = currentState.trackItemsMap[originalItemId];\n                const trackType = originalItem.type;\n                const trackId = originalItem.trackId;\n                console.log(\"Elemento seleccionado: ID=\".concat(originalItemId, \", tipo=\").concat(trackType, \", trackId=\").concat(trackId));\n                // Procesar cada segmento en orden (de final a principio para evitar afectar posiciones)\n                for(let i = segments.length - 1; i >= 0; i--){\n                    const segment = segments[i];\n                    console.log(\"Procesando segmento \".concat(i + 1, \"/\").concat(segments.length, \": \").concat(segment.startTime, \"s - \").concat(segment.endTime, \"s\"));\n                    try {\n                        // PASO 1: Hacer un corte en el tiempo final\n                        const endMs = segment.endTime * 1000;\n                        (0,_designcombo_events__WEBPACK_IMPORTED_MODULE_0__.dispatch)(_designcombo_state__WEBPACK_IMPORTED_MODULE_1__.ACTIVE_SPLIT, {\n                            payload: {},\n                            options: {\n                                time: endMs\n                            }\n                        });\n                        console.log(\"Paso 1: Corte aplicado en tiempo final \".concat(segment.endTime, \"s\"));\n                        // Esperar a que se procese el primer corte\n                        await new Promise((resolve)=>setTimeout(resolve, 500));\n                        // Obtenemos el estado después del primer corte\n                        const stateAfterFirstCut = stateManager.getState();\n                        const elementsAfterFirstCut = Object.entries(stateAfterFirstCut.trackItemsMap).filter((param)=>{\n                            let [_, item] = param;\n                            return item.type === trackType && item.trackId === trackId && item.display && !isNaN(item.display.from) && !isNaN(item.display.to);\n                        }).map((param)=>{\n                            let [id, item] = param;\n                            return {\n                                id,\n                                from: item.display.from,\n                                to: item.display.to,\n                                duración: item.display.to - item.display.from\n                            };\n                        }).sort((a, b)=>a.from - b.from);\n                        console.log(\"Elementos despu\\xe9s del primer corte:\", elementsAfterFirstCut);\n                        // PASO 2: Identificar el elemento izquierdo que contiene el tiempo inicial\n                        const startMs = segment.startTime * 1000;\n                        const leftElement = elementsAfterFirstCut.find((elem)=>elem.from <= startMs && elem.to >= startMs);\n                        if (!leftElement) {\n                            console.error(\"No se pudo identificar el elemento izquierdo para el segmento \".concat(i + 1));\n                            continue;\n                        }\n                        console.log(\"Paso 2: Elemento izquierdo identificado (ID: \".concat(leftElement.id, \")\"));\n                        // PASO 3: Seleccionar el elemento izquierdo y hacer corte en tiempo inicial\n                        (0,_designcombo_events__WEBPACK_IMPORTED_MODULE_0__.dispatch)(_designcombo_state__WEBPACK_IMPORTED_MODULE_1__.LAYER_SELECT, {\n                            payload: {\n                                ids: [\n                                    leftElement.id\n                                ]\n                            }\n                        });\n                        // Esperar a que se aplique la selección\n                        await new Promise((resolve)=>setTimeout(resolve, 300));\n                        // Aplicar el corte en el tiempo inicial\n                        (0,_designcombo_events__WEBPACK_IMPORTED_MODULE_0__.dispatch)(_designcombo_state__WEBPACK_IMPORTED_MODULE_1__.ACTIVE_SPLIT, {\n                            payload: {},\n                            options: {\n                                time: startMs\n                            }\n                        });\n                        console.log(\"Paso 3: Segundo corte aplicado en tiempo inicial \".concat(segment.startTime, \"s\"));\n                        // Esperar a que se procese el segundo corte\n                        await new Promise((resolve)=>setTimeout(resolve, 500));\n                        // Obtenemos el estado después del segundo corte\n                        const stateAfterSecondCut = stateManager.getState();\n                        const elementsAfterSecondCut = Object.entries(stateAfterSecondCut.trackItemsMap).filter((param)=>{\n                            let [_, item] = param;\n                            return item.type === trackType && item.trackId === trackId && item.display && !isNaN(item.display.from) && !isNaN(item.display.to);\n                        }).map((param)=>{\n                            let [id, item] = param;\n                            return {\n                                id,\n                                from: item.display.from,\n                                to: item.display.to,\n                                duración: item.display.to - item.display.from\n                            };\n                        }).sort((a, b)=>a.from - b.from);\n                        console.log(\"Elementos despu\\xe9s del segundo corte:\", elementsAfterSecondCut);\n                        // PASO 4: Identificar el elemento del medio usando criterios más precisos\n                        const middleElements = elementsAfterSecondCut.filter((elem)=>Math.abs(elem.from - startMs) < 50 && Math.abs(elem.to - endMs) < 50);\n                        console.log(\"Elementos que coinciden con los criterios del medio:\", middleElements);\n                        if (middleElements.length === 0) {\n                            console.error(\"No se pudo identificar el elemento del medio para el segmento \".concat(i + 1));\n                            continue;\n                        }\n                        // Si hay más de un elemento que coincide, tomamos el primero\n                        const middleElement = middleElements[0];\n                        console.log(\"Paso 4: Elemento del medio identificado (ID: \".concat(middleElement.id, \")\"));\n                        // PASO 5: Seleccionar y eliminar el elemento del medio\n                        (0,_designcombo_events__WEBPACK_IMPORTED_MODULE_0__.dispatch)(_designcombo_state__WEBPACK_IMPORTED_MODULE_1__.LAYER_SELECT, {\n                            payload: {\n                                ids: [\n                                    middleElement.id\n                                ]\n                            }\n                        });\n                        // Esperar a que se aplique la selección\n                        await new Promise((resolve)=>setTimeout(resolve, 300));\n                        // Verificar que el elemento está seleccionado antes de eliminarlo\n                        const currentState = stateManager.getState();\n                        if (currentState.activeIds && currentState.activeIds.includes(middleElement.id)) {\n                            console.log(\"Elemento del medio correctamente seleccionado, procediendo con eliminaci\\xf3n\");\n                            (0,_designcombo_events__WEBPACK_IMPORTED_MODULE_0__.dispatch)(_designcombo_state__WEBPACK_IMPORTED_MODULE_1__.LAYER_DELETE);\n                            console.log(\"Elemento eliminado correctamente: \".concat(middleElement.id));\n                        } else {\n                            console.log(\"No se pudo seleccionar normalmente, intentando m\\xe9todo alternativo\");\n                            // Enfoque alternativo: Usar el EDIT_OBJECT para \"ocultar\" el segmento\n                            (0,_designcombo_events__WEBPACK_IMPORTED_MODULE_0__.dispatch)(_designcombo_state__WEBPACK_IMPORTED_MODULE_1__.EDIT_OBJECT, {\n                                payload: {\n                                    [middleElement.id]: {\n                                        display: {\n                                            from: -99999,\n                                            to: -99990\n                                        },\n                                        visible: false // Adicionalmente marcarlo como no visible\n                                    }\n                                }\n                            });\n                            console.log(\"Aplicado m\\xe9todo alternativo para ocultar el segmento\");\n                        }\n                        // Esperar a que se procese la eliminación\n                        await new Promise((resolve)=>setTimeout(resolve, 500));\n                    } catch (error) {\n                        console.error(\"Error al procesar el segmento \".concat(i + 1, \":\"), error);\n                    }\n                    // Pausa entre segmentos\n                    await new Promise((resolve)=>setTimeout(resolve, 500));\n                }\n                // Actualizar la escala para refrescar la vista\n                const { scale } = stateManager.getState();\n                if (scale) {\n                    console.log(\"Actualizando escala para refrescar la vista\");\n                    // Guardar el valor actual de scale.unit\n                    const originalUnit = scale.unit;\n                    // Incrementar el valor\n                    scale.unit += 1;\n                    console.log(\"Scale cambiada: \".concat(originalUnit, \" -> \").concat(scale.unit));\n                    // Asegurar que el cambio sea notado por el sistema\n                    (0,_designcombo_events__WEBPACK_IMPORTED_MODULE_0__.dispatch)(_designcombo_state__WEBPACK_IMPORTED_MODULE_1__.TIMELINE_SCALE_CHANGED, {\n                        payload: {\n                            scale: {\n                                ...scale,\n                                unit: scale.unit // Explícitamente establecer el nuevo valor\n                            }\n                        }\n                    });\n                    // Forzar una actualización adicional volviendo al valor original después de un momento\n                    setTimeout(()=>{\n                        const currentState = stateManager.getState();\n                        if (currentState.scale) {\n                            (0,_designcombo_events__WEBPACK_IMPORTED_MODULE_0__.dispatch)(_designcombo_state__WEBPACK_IMPORTED_MODULE_1__.TIMELINE_SCALE_CHANGED, {\n                                payload: {\n                                    scale: {\n                                        ...currentState.scale,\n                                        unit: originalUnit // Volver al valor original\n                                    }\n                                }\n                            });\n                            console.log(\"Restaurado scale a valor original: \".concat(originalUnit));\n                        }\n                    }, 300);\n                }\n                console.log(\"Eliminaci\\xf3n de segmentos completada\");\n                return true;\n            } catch (error) {\n                console.error(\"Error al eliminar segmentos:\", error);\n                return false;\n            }\n        },\n        compactTimeline: async ()=>{\n            try {\n                console.log(\"=== INICIANDO COMPACTACI\\xd3N DE L\\xcdNEA DE TIEMPO DESDE IA ===\");\n                // Obtener el estado actual\n                const estado = stateManager.getState();\n                console.log(\"Estado para compactaci\\xf3n:\", Object.keys(estado));\n                // Añadir un tiempo de espera inicial para asegurar que el estado está actualizado\n                console.log(\"Esperando 1 segundo para asegurar consistencia del estado...\");\n                await new Promise((resolve)=>setTimeout(resolve, 1000));\n                // Verificación adicional para asegurarnos que los cambios en la timeline ya se aplicaron\n                console.log(\"Verificando que los elementos en la timeline reflejen los cambios m\\xe1s recientes...\");\n                // Pequeña pausa adicional para asegurar consistencia del estado\n                await new Promise((resolve)=>setTimeout(resolve, 500));\n                // Buscar los elementos del timeline - usando la referencia al método dentro del mismo objeto\n                const todosElementos = await executor.getAllTimelineElements();\n                console.log(\"Encontrados \".concat(todosElementos.length, \" elementos en la timeline\"));\n                // Logging de elementos para diagnóstico\n                todosElementos.forEach((elem, index)=>{\n                    console.log(\"Elemento \".concat(index + 1, \": ID=\").concat(elem.id, \", Tipo=\").concat(elem.type, \", Track=\").concat(elem.trackId, \", Tiempo=\").concat(elem.from, \"ms-\").concat(elem.to, \"ms (duraci\\xf3n=\").concat(elem.to - elem.from, \"ms)\"));\n                });\n                // Si no hay elementos, no podemos compactar\n                if (todosElementos.length === 0) {\n                    console.log(\"No hay elementos en el timeline para compactar\");\n                    return false;\n                }\n                // Agrupar elementos por track para análisis\n                const elementosPorTrack = {};\n                todosElementos.forEach((elem)=>{\n                    if (elem.trackId) {\n                        if (!elementosPorTrack[elem.trackId]) {\n                            elementosPorTrack[elem.trackId] = [];\n                        }\n                        elementosPorTrack[elem.trackId].push(elem);\n                    }\n                });\n                // Ordenar elementos en cada track por tiempo\n                Object.keys(elementosPorTrack).forEach((trackId)=>{\n                    elementosPorTrack[trackId].sort((a, b)=>a.from - b.from);\n                });\n                console.log(\"Elementos agrupados por track:\", Object.keys(elementosPorTrack).length);\n                // Logging de tracks para diagnóstico\n                Object.keys(elementosPorTrack).forEach((trackId)=>{\n                    console.log(\"Track \".concat(trackId, \": \").concat(elementosPorTrack[trackId].length, \" elementos\"));\n                    // Mostrar los elementos en este track ordenados\n                    elementosPorTrack[trackId].forEach((elem, idx)=>{\n                        console.log(\"  \".concat(idx + 1, \". ID=\").concat(elem.id.substring(0, 8), \"... Tiempo=\").concat(elem.from, \"ms-\").concat(elem.to, \"ms (duraci\\xf3n: \").concat(elem.to - elem.from, \"ms)\"));\n                    });\n                });\n                // Buscar espacios vacíos en cada track\n                const espaciosVacios = [];\n                Object.keys(elementosPorTrack).forEach((trackId)=>{\n                    const elementos = elementosPorTrack[trackId];\n                    // Si hay al menos 2 elementos, podemos buscar espacios\n                    if (elementos.length >= 2) {\n                        for(let i = 0; i < elementos.length - 1; i++){\n                            const elementoActual = elementos[i];\n                            const elementoSiguiente = elementos[i + 1];\n                            // Verificar si hay un espacio entre el fin del elemento actual y el inicio del siguiente\n                            const espacio = elementoSiguiente.from - elementoActual.to;\n                            // Si el espacio es significativo (más de 100ms)\n                            if (espacio > 100) {\n                                espaciosVacios.push({\n                                    trackId,\n                                    start: elementoActual.to,\n                                    end: elementoSiguiente.from,\n                                    size: espacio,\n                                    elementoAntes: elementoActual.id,\n                                    elementoDespues: elementoSiguiente.id\n                                });\n                                console.log(\"Encontrado espacio de \".concat(espacio, \"ms (\").concat(espacio / 1000, \"s) en track \").concat(trackId, \" entre elementos \").concat(elementoActual.id.substring(0, 8), \"... y \").concat(elementoSiguiente.id.substring(0, 8), \"...\"));\n                            }\n                        }\n                    }\n                });\n                console.log(\"Se encontraron \".concat(espaciosVacios.length, \" espacios vac\\xedos\"));\n                // Si no hay espacios, no necesitamos compactar\n                if (espaciosVacios.length === 0) {\n                    console.log(\"No hay espacios significativos para compactar\");\n                    return true; // Devolvemos true porque técnicamente está compactado\n                }\n                // Ordenar espacios por posición (de izquierda a derecha)\n                espaciosVacios.sort((a, b)=>a.start - b.start);\n                // Calcular el espacio total a compactar\n                let espacioTotal = 0;\n                espaciosVacios.forEach((espacio)=>{\n                    espacioTotal += espacio.size;\n                });\n                console.log(\"Espacio total a compactar: \".concat(espacioTotal, \"ms (\").concat(espacioTotal / 1000, \"s)\"));\n                console.log(\"Preparando actualizaciones para \".concat(todosElementos.length, \" elementos...\"));\n                // Preparar actualizaciones para cada elemento\n                const actualizaciones = {};\n                let elementosAMover = 0;\n                // Para cada elemento, calculamos el desplazamiento basado en los espacios anteriores\n                todosElementos.forEach((elemento)=>{\n                    let desplazamiento = 0;\n                    // Calcular cuánto debe moverse basado en los espacios vacíos anteriores\n                    for (const espacio of espaciosVacios){\n                        // Si el elemento está después del espacio vacío, debe moverse\n                        if (elemento.from > espacio.end) {\n                            desplazamiento += espacio.size;\n                        }\n                    }\n                    // Si hay desplazamiento, añadir a las actualizaciones\n                    if (desplazamiento > 0) {\n                        const nuevoFrom = elemento.from - desplazamiento;\n                        const nuevoTo = elemento.to - desplazamiento;\n                        console.log(\"Elemento \".concat(elemento.id.substring(0, 8), \"... se mover\\xe1: \").concat(elemento.from, \"ms -> \").concat(nuevoFrom, \"ms (desplazamiento: \").concat(desplazamiento, \"ms)\"));\n                        actualizaciones[elemento.id] = {\n                            display: {\n                                from: nuevoFrom,\n                                to: nuevoTo\n                            }\n                        };\n                        elementosAMover++;\n                    }\n                });\n                console.log(\"Elementos a mover: \".concat(elementosAMover, \" de \").concat(todosElementos.length, \" total\"));\n                // Aplicar las actualizaciones\n                if (elementosAMover > 0) {\n                    console.log(\"Aplicando actualizaciones para compactar timeline...\");\n                    try {\n                        (0,_designcombo_events__WEBPACK_IMPORTED_MODULE_0__.dispatch)(_designcombo_state__WEBPACK_IMPORTED_MODULE_1__.EDIT_OBJECT, {\n                            payload: actualizaciones\n                        });\n                        console.log(\"Actualizaciones aplicadas con \\xe9xito\");\n                    } catch (error) {\n                        console.error(\"Error al aplicar actualizaciones:\", error);\n                        return false;\n                    }\n                    // Refrescar la vista\n                    setTimeout(()=>{\n                        try {\n                            const { scale } = stateManager.getState();\n                            if (scale) {\n                                // Hacer un pequeño cambio en la escala para forzar la actualización\n                                const updatedScale = {\n                                    ...scale\n                                };\n                                if (typeof updatedScale.unit === \"number\") {\n                                    updatedScale.unit = (updatedScale.unit || 0) + 1;\n                                    (0,_designcombo_events__WEBPACK_IMPORTED_MODULE_0__.dispatch)(_designcombo_state__WEBPACK_IMPORTED_MODULE_1__.TIMELINE_SCALE_CHANGED, {\n                                        payload: {\n                                            scale: updatedScale\n                                        }\n                                    });\n                                    // Volver a la escala original\n                                    setTimeout(()=>{\n                                        const currentScale = {\n                                            ...stateManager.getState().scale\n                                        };\n                                        currentScale.unit = (currentScale.unit || 1) - 1;\n                                        (0,_designcombo_events__WEBPACK_IMPORTED_MODULE_0__.dispatch)(_designcombo_state__WEBPACK_IMPORTED_MODULE_1__.TIMELINE_SCALE_CHANGED, {\n                                            payload: {\n                                                scale: currentScale\n                                            }\n                                        });\n                                    }, 300);\n                                }\n                            }\n                        } catch (error) {\n                            console.error(\"Error al refrescar la vista:\", error);\n                        }\n                    }, 500);\n                    console.log(\"Compactaci\\xf3n completada con \\xe9xito\");\n                    return true;\n                } else {\n                    console.log(\"No hay elementos que necesiten moverse\");\n                    return true;\n                }\n            } catch (error) {\n                console.error(\"Error al compactar la l\\xednea de tiempo:\", error);\n                return false;\n            }\n        },\n        smartTrim: async ()=>{\n            try {\n                console.log(\"=== INICIANDO PROCESO DE RECORTE INTELIGENTE DESDE IA ===\");\n                // 1. Realizar la llamada al API para analizar la transcripción\n                console.log(\"Solicitando an\\xe1lisis de transcripci\\xf3n...\");\n                const response = await fetch(\"/api/smart-trim\");\n                if (!response.ok) {\n                    throw new Error(\"Error al analizar la transcripci\\xf3n: \".concat(response.status));\n                }\n                const data = await response.json();\n                console.log(\"An\\xe1lisis de transcripci\\xf3n completado:\", data);\n                if (!data.removeSegments || !Array.isArray(data.removeSegments) || data.removeSegments.length === 0) {\n                    console.log(\"No se encontraron segmentos para eliminar\");\n                    return false;\n                }\n                // 2. Convertir los segmentos al formato que espera removeSegments\n                const segments = data.removeSegments.map((segment)=>({\n                        startTime: segment.startTime,\n                        endTime: segment.endTime // Ya está en segundos\n                    }));\n                console.log(\"Se eliminar\\xe1n \".concat(segments.length, \" segmentos:\"), segments.map((s)=>\"\".concat(s.startTime, \"s-\").concat(s.endTime, \"s\")).join(\", \"));\n                // Almacenar información del estado previo para identificar tracks y elementos\n                console.log(\"Obteniendo informaci\\xf3n del estado antes de eliminar segmentos...\");\n                const estadoPrevio = stateManager.getState();\n                const elementosPrevios = await executor.getAllTimelineElements();\n                // Determinar el trackId principal basado en los elementos\n                const contadorTracks = {};\n                elementosPrevios.forEach((elem)=>{\n                    if (elem.trackId) {\n                        contadorTracks[elem.trackId] = (contadorTracks[elem.trackId] || 0) + 1;\n                    }\n                });\n                // Encontrar el track con más elementos\n                let trackIdPrincipal = \"\";\n                if (Object.keys(contadorTracks).length > 0) {\n                    const tracksPorUso = Object.entries(contadorTracks).sort((a, b)=>b[1] - a[1]);\n                    if (tracksPorUso.length > 0) {\n                        trackIdPrincipal = tracksPorUso[0][0];\n                        console.log(\"Usando trackId principal: \".concat(trackIdPrincipal));\n                    }\n                }\n                // 3. Eliminar los segmentos\n                console.log(\"Ejecutando eliminaci\\xf3n de segmentos...\");\n                const result = await executor.removeSegments(segments);\n                if (!result) {\n                    console.log(\"Error al eliminar los segmentos\");\n                    return false;\n                }\n                console.log(\"Segmentos eliminados correctamente\");\n                // 4. Crear registro de los segmentos eliminados para compactación\n                const segmentosEliminados = segments.map((segment)=>({\n                        start: segment.startTime * 1000,\n                        end: segment.endTime * 1000,\n                        trackId: trackIdPrincipal,\n                        size: (segment.endTime - segment.startTime) * 1000\n                    }));\n                console.log(\"Segmentos registrados para compactaci\\xf3n:\", segmentosEliminados);\n                // 5. Esperar un momento para que se completen las actualizaciones del DOM y el estado\n                console.log(\"Esperando 5 segundos para asegurar que los cambios en la timeline est\\xe9n completos antes de compactar...\");\n                await new Promise((resolve)=>setTimeout(resolve, 5000));\n                // 6. Compactar el timeline usando el enfoque de segmentos registrados\n                console.log(\"Compactando timeline basado en segmentos eliminados...\");\n                // Obtener elementos actuales después de la eliminación\n                const elementosActuales = await executor.getAllTimelineElements();\n                console.log(\"Se encontraron \".concat(elementosActuales.length, \" elementos en la timeline despu\\xe9s de eliminar segmentos\"));\n                // Calcular el espacio total a compactar\n                let espacioTotal = 0;\n                segmentosEliminados.forEach((segmento)=>{\n                    espacioTotal += segmento.size;\n                });\n                console.log(\"Espacio total a compactar: \".concat(espacioTotal, \"ms (\").concat(espacioTotal / 1000, \"s)\"));\n                // Preparar actualizaciones para cada elemento\n                const actualizaciones = {};\n                let elementosAMover = 0;\n                // Ordenar segmentos por posición de inicio\n                const segmentosOrdenados = [\n                    ...segmentosEliminados\n                ].sort((a, b)=>a.start - b.start);\n                // Para cada elemento, calcular el desplazamiento basado en los segmentos eliminados\n                elementosActuales.forEach((elemento)=>{\n                    let desplazamiento = 0;\n                    // Calcular cuánto debe moverse basado en los segmentos eliminados anteriores\n                    for (const segmento of segmentosOrdenados){\n                        if (elemento.from > segmento.start) {\n                            desplazamiento += segmento.size;\n                        }\n                    }\n                    // Si hay desplazamiento, añadir a las actualizaciones\n                    if (desplazamiento > 0) {\n                        const nuevoFrom = elemento.from - desplazamiento;\n                        const nuevoTo = elemento.to - desplazamiento;\n                        console.log(\"Elemento \".concat(elemento.id.substring(0, 8), \"... se mover\\xe1: \").concat(elemento.from, \"ms -> \").concat(nuevoFrom, \"ms (desplazamiento: \").concat(desplazamiento, \"ms)\"));\n                        actualizaciones[elemento.id] = {\n                            display: {\n                                from: nuevoFrom,\n                                to: nuevoTo\n                            }\n                        };\n                        elementosAMover++;\n                    }\n                });\n                console.log(\"Elementos a mover: \".concat(elementosAMover, \" de \").concat(elementosActuales.length, \" total\"));\n                // Aplicar las actualizaciones\n                if (elementosAMover > 0) {\n                    console.log(\"Aplicando actualizaciones para compactar timeline...\");\n                    try {\n                        (0,_designcombo_events__WEBPACK_IMPORTED_MODULE_0__.dispatch)(_designcombo_state__WEBPACK_IMPORTED_MODULE_1__.EDIT_OBJECT, {\n                            payload: actualizaciones\n                        });\n                        console.log(\"Actualizaciones aplicadas con \\xe9xito\");\n                        // Refrescar la vista\n                        setTimeout(()=>{\n                            try {\n                                const { scale } = stateManager.getState();\n                                if (scale) {\n                                    const updatedScale = {\n                                        ...scale\n                                    };\n                                    if (typeof updatedScale.unit === \"number\") {\n                                        updatedScale.unit = (updatedScale.unit || 0) + 1;\n                                        (0,_designcombo_events__WEBPACK_IMPORTED_MODULE_0__.dispatch)(_designcombo_state__WEBPACK_IMPORTED_MODULE_1__.TIMELINE_SCALE_CHANGED, {\n                                            payload: {\n                                                scale: updatedScale\n                                            }\n                                        });\n                                        // Volver a la escala original\n                                        setTimeout(()=>{\n                                            const currentScale = {\n                                                ...stateManager.getState().scale\n                                            };\n                                            currentScale.unit = (currentScale.unit || 1) - 1;\n                                            (0,_designcombo_events__WEBPACK_IMPORTED_MODULE_0__.dispatch)(_designcombo_state__WEBPACK_IMPORTED_MODULE_1__.TIMELINE_SCALE_CHANGED, {\n                                                payload: {\n                                                    scale: currentScale\n                                                }\n                                            });\n                                        }, 300);\n                                    }\n                                }\n                            } catch (error) {\n                                console.error(\"Error al refrescar la vista:\", error);\n                            }\n                        }, 500);\n                    } catch (error) {\n                        console.error(\"Error al aplicar actualizaciones:\", error);\n                        return false;\n                    }\n                } else {\n                    console.log(\"No se encontraron elementos que necesiten moverse\");\n                }\n                console.log(\"Timeline compactado correctamente\");\n                return true;\n            } catch (error) {\n                console.error(\"Error al realizar el recorte inteligente:\", error);\n                return false;\n            }\n        }\n    };\n    return executor;\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2NvbXBvbmVudHMvYWktY2hhdC9haS12aWRlby1jb21tYW5kcy50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQytDO0FBQ3lKO0FBQ3JKO0FBOEQ1QyxTQUFTVSwyQkFBMkJDLFlBQTBCO0lBQ25FLGlEQUFpRDtJQUNqRCxNQUFNQyxXQUFpQztRQUNyQ0MsU0FBUyxDQUFDQyxNQUFjQztZQUN0QixNQUFNQyxXQUFXRCxDQUFBQSxvQkFBQUEsOEJBQUFBLFFBQVNDLFFBQVEsS0FBSTtnQkFBRUMsR0FBRztnQkFBS0MsR0FBRztZQUFJLEdBQUcsdUJBQXVCO1lBQ2pGLE1BQU1DLFdBQVdKLENBQUFBLG9CQUFBQSw4QkFBQUEsUUFBU0ksUUFBUSxLQUFJO1lBQ3RDLE1BQU1DLGFBQWFMLENBQUFBLG9CQUFBQSw4QkFBQUEsUUFBU0ssVUFBVSxLQUFJO1lBQzFDLE1BQU1DLFFBQVFOLENBQUFBLG9CQUFBQSw4QkFBQUEsUUFBU00sS0FBSyxLQUFJO1lBQ2hDLE1BQU1DLFlBQVlQLENBQUFBLG9CQUFBQSw4QkFBQUEsUUFBU08sU0FBUyxLQUFJLEdBQUcsd0JBQXdCO1lBQ25FLE1BQU1DLFVBQVVSLENBQUFBLG9CQUFBQSw4QkFBQUEsUUFBU1EsT0FBTyxLQUFJLEdBQUcscUNBQXFDO1lBRTVFLDhCQUE4QjtZQUM5QixNQUFNQyxjQUFjO2dCQUNsQkMsSUFBSWhCLGlFQUFVQTtnQkFDZGlCLFNBQVM7b0JBQ1BDLE1BQU1MLFlBQVk7b0JBQ2xCTSxJQUFJTCxVQUFVLEtBQVMsMkJBQTJCO2dCQUNwRDtnQkFDQU0sTUFBTTtnQkFDTkMsU0FBUztvQkFDUGhCLE1BQU1BO29CQUNOSyxVQUFVQTtvQkFDVlksT0FBTztvQkFDUFgsWUFBWUE7b0JBQ1pDLE9BQU9BO29CQUNQVyxVQUFVO29CQUNWQyxXQUFXO29CQUNYQyxhQUFhO29CQUNiQyxhQUFhO29CQUNiQyxXQUFXO3dCQUNUZixPQUFPO3dCQUNQSixHQUFHO3dCQUNIQyxHQUFHO3dC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LFFBQVFJLEtBQUssQ0FBQyw2Q0FBNkNBO2dCQUMzRCxPQUFPO1lBQ1Q7UUFDRjtJQUNGO0lBRUEsT0FBT2pDO0FBQ1QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vY29tcG9uZW50cy9haS1jaGF0L2FpLXZpZGVvLWNvbW1hbmRzLnRzPzI2MjMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFN0YXRlTWFuYWdlciBmcm9tIFwiQGRlc2lnbmNvbWJvL3N0YXRlXCI7XG5pbXBvcnQgeyBkaXNwYXRjaCB9IGZyb20gXCJAZGVzaWduY29tYm8vZXZlbnRzXCI7XG5pbXBvcnQgeyBERVNJR05fQUREX1RFWFQsIERFU0lHTl9BRERfQVVESU8sIERFU0lHTl9BRERfSU1BR0UsIEFERF9URVhULCBBRERfVklERU8sIEFERF9JTUFHRSwgQUNUSVZFX1NQTElULCBMQVlFUl9TRUxFQ1QsIExBWUVSX0RFTEVURSwgVElNRUxJTkVfU0NBTEVfQ0hBTkdFRCwgRURJVF9PQkpFQ1QgfSBmcm9tIFwiQGRlc2lnbmNvbWJvL3N0YXRlXCI7XG5pbXBvcnQgeyBnZW5lcmF0ZUlkIH0gZnJvbSBcIkBkZXNpZ25jb21iby90aW1lbGluZVwiO1xuXG5cbmV4cG9ydCBpbnRlcmZhY2UgVmlkZW9Db21tYW5kRXhlY3V0b3Ige1xuICBhZGRUZXh0OiAodGV4dDogc3RyaW5nLCBvcHRpb25zPzogVGV4dE9wdGlvbnMpID0+IHZvaWQ7XG4gIGNoYW5nZUNvbG9yOiAoZWxlbWVudElkOiBzdHJpbmcsIGNvbG9yOiBzdHJpbmcpID0+IHZvaWQ7XG4gIGFkZEltYWdlOiAodXJsOiBzdHJpbmcsIG9wdGlvbnM/OiBJbWFnZU9wdGlvbnMpID0+IHZvaWQ7XG4gIGFkZFZpZGVvOiAodXJsOiBzdHJpbmcsIG9wdGlvbnM/OiBWaWRlb09wdGlvbnMpID0+IHZvaWQ7XG4gIGNoYW5nZUR1cmF0aW9uOiAoZWxlbWVudElkOiBzdHJpbmcsIGR1cmF0aW9uOiBudW1iZXIpID0+IHZvaWQ7XG4gIGNoYW5nZVRyYW5zaXRpb246IChlbGVtZW50SWQ6IHN0cmluZywgdHJhbnNpdGlvbjogc3RyaW5nKSA9PiB2b2lkO1xuICBhZGRTdWJ0aXRsZXM6IChvcHRpb25zPzogU3VidGl0bGVPcHRpb25zKSA9PiB2b2lkO1xuICByZW1vdmVTZWdtZW50czogKHNlZ21lbnRzOiBUaW1lU2VnbWVudFtdKSA9PiB2b2lkO1xuICBnZXRBY3RpdmVFbGVtZW50czogKCkgPT4gUHJvbWlzZTxhbnlbXT47XG4gIGdldEFsbFRpbWVsaW5lRWxlbWVudHM6ICgpID0+IFByb21pc2U8YW55W10+O1xuICBjb21wYWN0VGltZWxpbmU6ICgpID0+IFByb21pc2U8Ym9vbGVhbj47XG4gIHNtYXJ0VHJpbTogKCkgPT4gUHJvbWlzZTxib29sZWFuPjtcbn1cblxuaW50ZXJmYWNlIFRleHRPcHRpb25zIHtcbiAgZm9udFNpemU/OiBudW1iZXI7XG4gIGZvbnRGYW1pbHk/OiBzdHJpbmc7XG4gIGNvbG9yPzogc3RyaW5nO1xuICBwb3NpdGlvbj86IHsgeDogbnVtYmVyOyB5OiBudW1iZXIgfTtcbiAgc3RhcnRUaW1lPzogbnVtYmVyOyAvLyBlbiBzZWd1bmRvc1xuICBlbmRUaW1lPzogbnVtYmVyOyAvLyBlbiBzZWd1bmRvc1xufVxuXG5pbnRlcmZhY2UgSW1hZ2VPcHRpb25zIHtcbiAgd2lkdGg/OiBudW1iZXI7XG4gIGhlaWdodD86IG51bWJlcjtcbiAgcG9zaXRpb24/OiB7IHg6IG51bWJlcjsgeTogbnVtYmVyIH07XG4gIHN0YXJ0VGltZT86IG51bWJlcjsgLy8gZW4gc2VndW5kb3NcbiAgZW5kVGltZT86IG51bWJlcjsgLy8gZW4gc2VndW5kb3Ncbn1cblxuaW50ZXJmYWNlIFZpZGVvT3B0aW9ucyB7XG4gIHdpZHRoPzogbnVtYmVyO1xuICBoZWlnaHQ/OiBudW1iZXI7XG4gIHBvc2l0aW9uPzogeyB4OiBudW1iZXI7IHk6IG51bWJlciB9O1xuICBzdGFydFRpbWU/OiBudW1iZXI7IC8vIGVuIHNlZ3VuZG9zXG4gIGVuZFRpbWU/OiBudW1iZXI7IC8vIGVuIHNlZ3VuZG9zXG59XG5cbmludGVyZmFjZSBTdWJ0aXRsZU9wdGlvbnMge1xuICBncm91cFdvcmRzPzogYm9vbGVhbjsgLy8gU2kgc2UgZGViZW4gYWdydXBhciBwYWxhYnJhcyAodHJ1ZSkgbyB1c2FyIHN1YnTDrXR1bG9zIGNvbXBsZXRvcyAoZmFsc2UpXG4gIHN0YXJ0VGltZT86IG51bWJlcjsgICAvLyBUaWVtcG8gZGUgaW5pY2lvIHBhcmEgZmlsdHJhciBzdWJ0w610dWxvcyAob3BjaW9uYWwpXG4gIGVuZFRpbWU/OiBudW1iZXI7ICAgICAvLyBUaWVtcG8gZGUgZmluIHBhcmEgZmlsdHJhciBzdWJ0w610dWxvcyAob3BjaW9uYWwpXG59XG5cbi8vIFRpcG8gcGFyYSByZXByZXNlbnRhciB1biBzZWdtZW50byBkZSBzdWJ0w610dWxvXG5pbnRlcmZhY2UgU3VidGl0bGVTZWdtZW50IHtcbiAgaWQ6IG51bWJlcjtcbiAgc3RhcnRUaW1lOiBudW1iZXI7IC8vIGVuIG1pbGlzZWd1bmRvc1xuICBlbmRUaW1lOiBudW1iZXI7ICAgLy8gZW4gbWlsaXNlZ3VuZG9zXG4gIHRleHQ6IHN0cmluZztcbn1cblxuaW50ZXJmYWNlIFRpbWVTZWdtZW50IHtcbiAgc3RhcnRUaW1lOiBudW1iZXI7IC8vIFRpZW1wbyBkZSBpbmljaW8gZW4gc2VndW5kb3NcbiAgZW5kVGltZTogbnVtYmVyOyAgIC8vIFRpZW1wbyBmaW5hbCBlbiBzZWd1bmRvc1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlVmlkZW9Db21tYW5kRXhlY3V0b3Ioc3RhdGVNYW5hZ2VyOiBTdGF0ZU1hbmFnZXIpOiBWaWRlb0NvbW1hbmRFeGVjdXRvciB7XG4gIC8vIENyZWFyIGVsIG9iamV0byBleGVjdXRvciBjb24gdG9kb3MgbG9zIG3DqXRvZG9zXG4gIGNvbnN0IGV4ZWN1dG9yOiBWaWRlb0NvbW1hbmRFeGVjdXRvciA9IHtcbiAgICBhZGRUZXh0OiAodGV4dDogc3RyaW5nLCBvcHRpb25zPzogVGV4dE9wdGlvbnMpID0+IHtcbiAgICAgIGNvbnN0IHBvc2l0aW9uID0gb3B0aW9ucz8ucG9zaXRpb24gfHwgeyB4OiAwLjUsIHk6IDAuNSB9OyAvLyBDZW50cmFkbyBwb3IgZGVmZWN0b1xuICAgICAgY29uc3QgZm9udFNpemUgPSBvcHRpb25zPy5mb250U2l6ZSB8fCA0ODtcbiAgICAgIGNvbnN0IGZvbnRGYW1pbHkgPSBvcHRpb25zPy5mb250RmFtaWx5IHx8IFwiUm9ib3RvLUJvbGRcIjtcbiAgICAgIGNvbnN0IGNvbG9yID0gb3B0aW9ucz8uY29sb3IgfHwgXCIjRkZGRkZGXCI7XG4gICAgICBjb25zdCBzdGFydFRpbWUgPSBvcHRpb25zPy5zdGFydFRpbWUgfHwgMDsgLy8gUG9yIGRlZmVjdG8gYWwgaW5pY2lvXG4gICAgICBjb25zdCBlbmRUaW1lID0gb3B0aW9ucz8uZW5kVGltZSB8fCA1OyAvLyBQb3IgZGVmZWN0byA1IHNlZ3VuZG9zIGRlIGR1cmFjacOzblxuXG4gICAgICAvLyBDcmVhciBwYXlsb2FkIHBhcmEgZWwgdGV4dG9cbiAgICAgIGNvbnN0IHRleHRQYXlsb2FkID0ge1xuICAgICAgICBpZDogZ2VuZXJhdGVJZCgpLFxuICAgICAgICBkaXNwbGF5OiB7XG4gICAgICAgICAgZnJvbTogc3RhcnRUaW1lICogMTAwMCwgLy8gQ29udmVydGlyIGEgbWlsaXNlZ3VuZG9zXG4gICAgICAgICAgdG86IGVuZFRpbWUgKiAxMDAwICAgICAvLyBDb252ZXJ0aXIgYSBtaWxpc2VndW5kb3NcbiAgICAgICAgfSxcbiAgICAgICAgdHlwZTogJ3RleHQnLFxuICAgICAgICBkZXRhaWxzOiB7XG4gICAgICAgICAgdGV4dDogdGV4dCxcbiAgICAgICAgICBmb250U2l6ZTogZm9udFNpemUsXG4gICAgICAgICAgd2lkdGg6IDYwMCxcbiAgICAgICAgICBmb250RmFtaWx5OiBmb250RmFtaWx5LFxuICAgICAgICAgIGNvbG9yOiBjb2xvcixcbiAgICAgICAgICB3b3JkV3JhcDogJ2JyZWFrLXdvcmQnLFxuICAgICAgICAgIHRleHRBbGlnbjogJ2NlbnRlcicsXG4gICAgICAgICAgYm9yZGVyV2lkdGg6IDAsXG4gICAgICAgICAgYm9yZGVyQ29sb3I6ICcjMDAwMDAwJyxcbiAgICAgICAgICBib3hTaGFkb3c6IHtcbiAgICAgICAgICAgIGNvbG9yOiAnI2ZmZmZmZicsXG4gICAgICAgICAgICB4OiAwLFxuICAgICAgICAgICAgeTogMCxcbiAgICAgICAgICAgIGJsdXI6IDAsXG4gICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgIH07XG5cbiAgICAgIC8vIEFncmVnYXIgdGV4dG8gYWwgdGltZWxpbmVcbiAgICAgIGRpc3BhdGNoKEFERF9URVhULCB7XG4gICAgICAgIHBheWxvYWQ6IHRleHRQYXlsb2FkLFxuICAgICAgICBvcHRpb25zOiB7fSxcbiAgICAgIH0pO1xuICAgIH0sXG5cbiAgICBjaGFuZ2VDb2xvcjogKGVsZW1lbnRJZDogc3RyaW5nLCBjb2xvcjogc3RyaW5nKSA9PiB7XG4gICAgICAvLyBTaW11bGFjacOzbiBkZSBjYW1iaW8gZGUgY29sb3IgKGxhIGltcGxlbWVudGFjacOzbiByZWFsIGRlcGVuZGVyw6EgZGUgbGEgZXN0cnVjdHVyYSBkZWwgcHJveWVjdG8pXG4gICAgICBjb25zb2xlLmxvZyhgQ2FtYmlhbmRvIGNvbG9yIGRlbCBlbGVtZW50byAke2VsZW1lbnRJZH0gYSAke2NvbG9yfWApO1xuXG4gICAgICAvLyBBcXXDrSBpcsOtYSBsYSBsw7NnaWNhIHJlYWwgcGFyYSBjYW1iaWFyIGVsIGNvbG9yIGRlIHVuIGVsZW1lbnRvXG4gICAgfSxcblxuICAgIGFkZEltYWdlOiAodXJsOiBzdHJpbmcsIG9wdGlvbnM/OiBJbWFnZU9wdGlvbnMpID0+IHtcbiAgICAgIC8vIEFzZWd1cmFyIHF1ZSB0ZW5lbW9zIHVuYSBVUkwgdsOhbGlkYVxuICAgICAgaWYgKCF1cmwpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcIlVSTCBkZSBpbWFnZW4gbm8gdsOhbGlkYVwiKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBWZXJpZmljYXIgc2kgZXMgdW5hIFVSTCBnZW7DqXJpY2EgZGUgcmVmZXJlbmNpYSwgcXVlIG5vIGRlYmUgdXNhcnNlIGRpcmVjdGFtZW50ZVxuICAgICAgaWYgKHVybCA9PT0gJ2ltYWdlbl9hZGp1bnRhX3Bvcl9lbF91c3VhcmlvLmpwZycgfHwgdXJsLmluY2x1ZGVzKCcvdXJsX2RlX2xhX2ltYWdlbicpKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvcjogVVJMIGRlIGltYWdlbiBnZW7DqXJpY2EgaW52w6FsaWRhIGRldGVjdGFkYVwiLCB1cmwpO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJMYSBVUkwgZGUgaW1hZ2VuIG5vIGVzIHbDoWxpZGEuIFNlIGludGVudMOzIHVzYXIgdW4gbWFyY2Fkb3IgZ2Vuw6lyaWNvIGRpcmVjdGFtZW50ZS5cIik7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHdpZHRoID0gb3B0aW9ucz8ud2lkdGggfHwgNDgwO1xuICAgICAgY29uc3QgaGVpZ2h0ID0gb3B0aW9ucz8uaGVpZ2h0IHx8IDI3MDtcbiAgICAgIGNvbnN0IHN0YXJ0VGltZSA9IG9wdGlvbnM/LnN0YXJ0VGltZSAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5zdGFydFRpbWUgOiAwO1xuICAgICAgY29uc3QgZW5kVGltZSA9IG9wdGlvbnM/LmVuZFRpbWUgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuZW5kVGltZSA6IHN0YXJ0VGltZSArIDU7XG5cbiAgICAgIC8vIFBhcmEgZGVwdXJhY2nDs24sIG1vc3RyYXIgcGFydGUgZGUgbGEgVVJMICh0cnVuY2FkYSBzaSBlcyBkYXRhOlVSTClcbiAgICAgIGNvbnN0IGxvZ1VybCA9IHVybC5zdGFydHNXaXRoKCdkYXRhOicpXG4gICAgICAgID8gYCR7dXJsLnN1YnN0cmluZygwLCAzMCl9Li4uIChkYXRhIFVSTClgXG4gICAgICAgIDogdXJsO1xuICAgICAgY29uc29sZS5sb2coYEHDsWFkaWVuZG8gaW1hZ2VuIGRlc2RlICR7bG9nVXJsfSBkZXNkZSBzZWd1bmRvICR7c3RhcnRUaW1lfSBoYXN0YSAke2VuZFRpbWV9YCk7XG5cbiAgICAgIC8vIFByZS1jYXJnYXIgbGEgaW1hZ2VuIHBhcmEgb2J0ZW5lciBzdXMgZGltZW5zaW9uZXMgcmVhbGVzXG4gICAgICBjb25zdCBwcmVsb2FkSW1hZ2UgPSAoaW1hZ2VVcmw6IHN0cmluZyk6IFByb21pc2U8eyB3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlciB9PiA9PiB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgICAgIGlmIChpbWFnZVVybC5zdGFydHNXaXRoKCdkYXRhOicpKSB7XG4gICAgICAgICAgICAvLyBQYXJhIGRhdGEgVVJMcywgY3JlYW1vcyB1bmEgaW1hZ2VuIHRlbXBvcmFsXG4gICAgICAgICAgICBjb25zdCBpbWcgPSBuZXcgSW1hZ2UoKTtcbiAgICAgICAgICAgIGltZy5vbmxvYWQgPSAoKSA9PiB7XG4gICAgICAgICAgICAgIHJlc29sdmUoeyB3aWR0aDogaW1nLndpZHRoLCBoZWlnaHQ6IGltZy5oZWlnaHQgfSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaW1nLm9uZXJyb3IgPSAoKSA9PiB7XG4gICAgICAgICAgICAgIGNvbnNvbGUud2FybihcIkVycm9yIGFsIGNhcmdhciBsYSBpbWFnZW4gcGFyYSBkaW1lbnNpb25lcywgdXNhbmRvIHZhbG9yZXMgcG9yIGRlZmVjdG9cIik7XG4gICAgICAgICAgICAgIHJlc29sdmUoeyB3aWR0aDogNDgwLCBoZWlnaHQ6IDI3MCB9KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpbWcuc3JjID0gaW1hZ2VVcmw7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIFBhcmEgVVJMcyBub3JtYWxlcywgdXNhbW9zIGRpbWVuc2lvbmVzIHByZWRldGVybWluYWRhc1xuICAgICAgICAgICAgcmVzb2x2ZSh7IHdpZHRoOiA0ODAsIGhlaWdodDogMjcwIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9O1xuXG4gICAgICAvLyBGdW5jacOzbiBwYXJhIGNyZWFyIGVsIHBheWxvYWQgZGVzcHXDqXMgZGUgcHJlLWNhcmdhciBsYSBpbWFnZW5cbiAgICAgIGNvbnN0IGNyZWF0ZUFuZERpc3BhdGNoUGF5bG9hZCA9IGFzeW5jICgpID0+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAvLyBPYnRlbmVyIGRpbWVuc2lvbmVzIHJlYWxlcyBzaSBlcyB1bmEgZGF0YSBVUkxcbiAgICAgICAgICBsZXQgZmluYWxXaWR0aCA9IHdpZHRoO1xuICAgICAgICAgIGxldCBmaW5hbEhlaWdodCA9IGhlaWdodDtcblxuICAgICAgICAgIGlmICh1cmwuc3RhcnRzV2l0aCgnZGF0YTonKSkge1xuICAgICAgICAgICAgY29uc3QgZGltZW5zaW9ucyA9IGF3YWl0IHByZWxvYWRJbWFnZSh1cmwpO1xuXG4gICAgICAgICAgICAvLyBDYWxjdWxhciBwcm9wb3JjaW9uZXMgcGFyYSBtYW50ZW5lciByZWxhY2nDs24gZGUgYXNwZWN0b1xuICAgICAgICAgICAgY29uc3QgYXNwZWN0UmF0aW8gPSBkaW1lbnNpb25zLndpZHRoIC8gZGltZW5zaW9ucy5oZWlnaHQ7XG5cbiAgICAgICAgICAgIC8vIEFqdXN0YXIgZGltZW5zaW9uZXMgbWFudGVuaWVuZG8gcHJvcG9yY2nDs25cbiAgICAgICAgICAgIGlmIChhc3BlY3RSYXRpbyA+IDEpIHsgLy8gSW1hZ2VuIGhvcml6b250YWxcbiAgICAgICAgICAgICAgZmluYWxXaWR0aCA9IE1hdGgubWluKDY0MCwgZGltZW5zaW9ucy53aWR0aCk7XG4gICAgICAgICAgICAgIGZpbmFsSGVpZ2h0ID0gZmluYWxXaWR0aCAvIGFzcGVjdFJhdGlvO1xuICAgICAgICAgICAgfSBlbHNlIHsgLy8gSW1hZ2VuIHZlcnRpY2FsIG8gY3VhZHJhZGFcbiAgICAgICAgICAgICAgZmluYWxIZWlnaHQgPSBNYXRoLm1pbig0ODAsIGRpbWVuc2lvbnMuaGVpZ2h0KTtcbiAgICAgICAgICAgICAgZmluYWxXaWR0aCA9IGZpbmFsSGVpZ2h0ICogYXNwZWN0UmF0aW87XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGBEaW1lbnNpb25lcyBvcmlnaW5hbGVzOiAke2RpbWVuc2lvbnMud2lkdGh9eCR7ZGltZW5zaW9ucy5oZWlnaHR9LCBBanVzdGFkYXM6ICR7ZmluYWxXaWR0aH14JHtmaW5hbEhlaWdodH1gKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBPYnRlbmVyIHBvc2ljacOzbiAoY2VudHJhZGEgcG9yIGRlZmVjdG8pXG4gICAgICAgICAgY29uc3QgcG9zaXRpb24gPSBvcHRpb25zPy5wb3NpdGlvbiB8fCB7IHg6IDAuNSwgeTogMC41IH07XG5cbiAgICAgICAgICAvLyBDcmVhciBwYXlsb2FkIHBhcmEgbGEgaW1hZ2VuIGNvbiBkaW1lbnNpb25lcyBhanVzdGFkYXNcbiAgICAgICAgICBjb25zdCBpbWFnZVBheWxvYWQgPSB7XG4gICAgICAgICAgICBpZDogZ2VuZXJhdGVJZCgpLFxuICAgICAgICAgICAgZGlzcGxheToge1xuICAgICAgICAgICAgICBmcm9tOiBzdGFydFRpbWUgKiAxMDAwLCAvLyBDb252ZXJ0aXIgYSBtaWxpc2VndW5kb3NcbiAgICAgICAgICAgICAgdG86IGVuZFRpbWUgKiAxMDAwICAgICAvLyBDb252ZXJ0aXIgYSBtaWxpc2VndW5kb3NcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB0eXBlOiAnaW1hZ2UnLFxuICAgICAgICAgICAgZGV0YWlsczoge1xuICAgICAgICAgICAgICBzcmM6IHVybCxcbiAgICAgICAgICAgICAgd2lkdGg6IGZpbmFsV2lkdGgsXG4gICAgICAgICAgICAgIGhlaWdodDogZmluYWxIZWlnaHQsXG4gICAgICAgICAgICAgIG9wYWNpdHk6IDEwMCxcbiAgICAgICAgICAgICAgc2NhbGVNb2RlOiBcImZpdFwiLCAvLyBBc2VndXJhciBxdWUgbGEgaW1hZ2VuIHNlIGVzY2FsZSBtYW50ZW5pZW5kbyBwcm9wb3JjaW9uZXNcbiAgICAgICAgICAgICAgbGVmdDogcG9zaXRpb24ueCwgLy8gUG9zaWNpw7NuIGhvcml6b250YWwgKDAtMSlcbiAgICAgICAgICAgICAgdG9wOiBwb3NpdGlvbi55LCAgLy8gUG9zaWNpw7NuIHZlcnRpY2FsICgwLTEpXG4gICAgICAgICAgICAgIG9yaWdpblg6IFwiY2VudGVyXCIsIC8vIFB1bnRvIGRlIG9yaWdlbiBob3Jpem9udGFsXG4gICAgICAgICAgICAgIG9yaWdpblk6IFwiY2VudGVyXCIsIC8vIFB1bnRvIGRlIG9yaWdlbiB2ZXJ0aWNhbFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgLy8gQWdyZWdhciBpbWFnZW4gYWwgdGltZWxpbmVcbiAgICAgICAgICBkaXNwYXRjaChBRERfSU1BR0UsIHtcbiAgICAgICAgICAgIHBheWxvYWQ6IGltYWdlUGF5bG9hZCxcbiAgICAgICAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgICAgICAgc2NhbGVNb2RlOiBcImZpdFwiLCAvLyBUYW1iacOpbiBjb25maWd1cmFtb3MgYXF1w60gcGFyYSBhc2VndXJhclxuICAgICAgICAgICAgICBwb3NpdGlvbjogcG9zaXRpb24sIC8vIEFzZWd1cmFtb3MgcXVlIGxhIHBvc2ljacOzbiBzZSB0cmFuc2ZpZXJlXG4gICAgICAgICAgICB9LFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGNvbnNvbGUubG9nKGBJbWFnZW4gYWdyZWdhZGEgY29ycmVjdGFtZW50ZSBhbCB0aW1lbGluZSBlbiBwb3NpY2nDs24gKCR7cG9zaXRpb24ueH0sICR7cG9zaXRpb24ueX0pYCk7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIGFsIGFncmVnYXIgaW1hZ2VuIGFsIHRpbWVsaW5lOlwiLCBlcnJvcik7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBFcnJvciBhbCBhZ3JlZ2FyIGltYWdlbjogJHtlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6ICdFcnJvciBkZXNjb25vY2lkbyd9YCk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIC8vIEluaWNpYXIgZWwgcHJvY2Vzb1xuICAgICAgY3JlYXRlQW5kRGlzcGF0Y2hQYXlsb2FkKCk7XG4gICAgfSxcblxuICAgIGFkZFZpZGVvOiAodXJsOiBzdHJpbmcsIG9wdGlvbnM/OiBWaWRlb09wdGlvbnMpID0+IHtcbiAgICAgIGNvbnNvbGUubG9nKGBbYWRkVmlkZW9dIEluaWNpYW5kbyBhZGRWaWRlbyBwYXJhIFVSTDogJHt1cmx9YCk7XG4gICAgICBjb25zb2xlLmxvZyhgW2FkZFZpZGVvXSBPcGNpb25lcyByZWNpYmlkYXM6YCwgb3B0aW9ucyk7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICBzdGFydFRpbWUgPSAwLFxuICAgICAgICAgIGVuZFRpbWUgPSA1LFxuICAgICAgICAgIHdpZHRoLFxuICAgICAgICAgIGhlaWdodCxcbiAgICAgICAgICBwb3NpdGlvbixcbiAgICAgICAgfSA9IG9wdGlvbnM7XG5cbiAgICAgICAgY29uc29sZS5sb2coYFthZGRWaWRlb10gUGFyw6FtZXRyb3MgcHJvY2VzYWRvczogc3RhcnRUaW1lPSR7c3RhcnRUaW1lfSwgZW5kVGltZT0ke2VuZFRpbWV9LCB3aWR0aD0ke3dpZHRofSwgaGVpZ2h0PSR7aGVpZ2h0fWApO1xuICAgICAgICBjb25zb2xlLmxvZyhgW2FkZFZpZGVvXSBQb3NpdGlvbjpgLCBwb3NpdGlvbik7XG5cbiAgICAgICAgLy8gVmVyaWZpY2FyIHNpIGxhIFVSTCB0ZXJtaW5hIGNvbiAuYXBuZyBvIC5tb3YgcGFyYSB0cmF0YXJsb3MgY29tbyB0cmFuc2ljaW9uZXMgYSBwYW50YWxsYSBjb21wbGV0YVxuICAgICAgICBjb25zdCBpc0FQTkcgPSB1cmwudG9Mb3dlckNhc2UoKS5lbmRzV2l0aCgnLmFwbmcnKTtcbiAgICAgICAgY29uc3QgaXNNT1YgPSB1cmwudG9Mb3dlckNhc2UoKS5lbmRzV2l0aCgnLm1vdicpO1xuICAgICAgICBjb25zdCBuZWVkc0Z1bGxzY3JlZW4gPSBpc0FQTkcgfHwgaXNNT1Y7XG5cbiAgICAgICAgY29uc29sZS5sb2coYFthZGRWaWRlb10gVGlwbyBkZSBhcmNoaXZvOiBBUE5HPSR7aXNBUE5HfSwgTU9WPSR7aXNNT1Z9LCBuZWVkc0Z1bGxzY3JlZW49JHtuZWVkc0Z1bGxzY3JlZW59YCk7XG5cbiAgICAgICAgLy8gQ3JlYXIgdW4gcGF5bG9hZCBwYXJhIGVsIHZpZGVvXG4gICAgICAgIGNvbnNvbGUubG9nKGBbYWRkVmlkZW9dIENyZWFuZG8gcGF5bG9hZCBwYXJhIGVsIHZpZGVvLi4uYCk7XG4gICAgICAgIGNvbnN0IHBheWxvYWQgPSB7XG4gICAgICAgICAgaWQ6IGdlbmVyYXRlSWQoKSxcbiAgICAgICAgICBkaXNwbGF5OiB7XG4gICAgICAgICAgICBmcm9tOiBzdGFydFRpbWUgKiAxMDAwLCAvLyBDb252ZXJ0aXIgYSBtaWxpc2VndW5kb3NcbiAgICAgICAgICAgIHRvOiBlbmRUaW1lICogMTAwMCwgICAgIC8vIENvbnZlcnRpciBhIG1pbGlzZWd1bmRvc1xuICAgICAgICAgIH0sXG4gICAgICAgICAgdHlwZTogJ3ZpZGVvJyxcbiAgICAgICAgICBkZXRhaWxzOiB7XG4gICAgICAgICAgICBzcmM6IHVybCxcbiAgICAgICAgICAgIHdpZHRoOiB3aWR0aCB8fCA2NDAsICAgICAvLyBBbmNobyBwcmVkZXRlcm1pbmFkbyBvIGVzcGVjaWZpY2Fkb1xuICAgICAgICAgICAgaGVpZ2h0OiBoZWlnaHQgfHwgMzYwLCAgIC8vIEFsdG8gcHJlZGV0ZXJtaW5hZG8gbyBlc3BlY2lmaWNhZG9cbiAgICAgICAgICAgIG9wYWNpdHk6IDEwMCxcbiAgICAgICAgICAgIHNjYWxlTW9kZTogbmVlZHNGdWxsc2NyZWVuID8gXCJjb3ZlclwiIDogXCJmaXRcIiwgLy8gUGFyYSBBUE5HL01PViB1c2FyIFwiY292ZXJcIiwgcGFyYSBvdHJvcyBcImZpdFwiXG4gICAgICAgICAgICBsZWZ0OiBwb3NpdGlvbj8ueCB8fCAwLjUsIC8vIFVzYXIgeCBkZSBwb3NpdGlvbiBvIGNlbnRyYXJcbiAgICAgICAgICAgIHRvcDogcG9zaXRpb24/LnkgfHwgMC41LCAgLy8gVXNhciB5IGRlIHBvc2l0aW9uIG8gY2VudHJhclxuICAgICAgICAgICAgb3JpZ2luWDogXCJjZW50ZXJcIixcbiAgICAgICAgICAgIG9yaWdpblk6IFwiY2VudGVyXCIsXG4gICAgICAgICAgfSxcbiAgICAgICAgfTtcblxuICAgICAgICBjb25zb2xlLmxvZyhgW2FkZFZpZGVvXSBQYXlsb2FkIGdlbmVyYWRvOmAsIHBheWxvYWQpO1xuXG4gICAgICAgIC8vIERlc3BhY2hhciBsYSBhY2Npw7NuIHBhcmEgYcOxYWRpciBlbCB2aWRlb1xuICAgICAgICBjb25zb2xlLmxvZyhgW2FkZFZpZGVvXSBEZXNwYWNoYW5kbyBhY2Npw7NuIEFERF9WSURFTy4uLmApO1xuICAgICAgICBkaXNwYXRjaChBRERfVklERU8sIHtcbiAgICAgICAgICBwYXlsb2FkLFxuICAgICAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgICAgIHNjYWxlTW9kZTogbmVlZHNGdWxsc2NyZWVuID8gXCJjb3ZlclwiIDogXCJmaXRcIiwgLy8gQ29uc2lzdGVudGUgY29uIGVsIHBheWxvYWRcbiAgICAgICAgICAgIHBvc2l0aW9uOiBwb3NpdGlvbiB8fCB7IHg6IDAuNSwgeTogMC41IH0sXG4gICAgICAgICAgICByZXNvdXJjZUlkOiBcIm1haW5cIlxuICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNvbnNvbGUubG9nKGBbYWRkVmlkZW9dICR7aXNBUE5HID8gJ0FQTkcnIDogaXNNT1YgPyAnTU9WJyA6ICdWaWRlbyd9IGHDsWFkaWRvIGV4aXRvc2FtZW50ZSBhIGxhIGzDrW5lYSBkZSB0aWVtcG8uYCk7XG4gICAgICAgIGNvbnNvbGUubG9nKGBbYWRkVmlkZW9dIFZpZGVvIGHDsWFkaWRvIGVuIHRpZW1wbzogJHtzdGFydFRpbWV9cyAtICR7ZW5kVGltZX1zYCk7XG4gICAgICAgIGNvbnNvbGUubG9nKGBbYWRkVmlkZW9dIERpbWVuc2lvbmVzOiAke3BheWxvYWQuZGV0YWlscy53aWR0aH14JHtwYXlsb2FkLmRldGFpbHMuaGVpZ2h0fWApO1xuXG4gICAgICAgIHJldHVybiBwYXlsb2FkLmlkO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihgW2FkZFZpZGVvXSBFcnJvciBhbCBhw7FhZGlyIHZpZGVvOmAsIGVycm9yKTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBFcnJvciBhZGRpbmcgdmlkZW86ICR7ZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiBTdHJpbmcoZXJyb3IpfWApO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBjaGFuZ2VEdXJhdGlvbjogKGVsZW1lbnRJZDogc3RyaW5nLCBkdXJhdGlvbjogbnVtYmVyKSA9PiB7XG4gICAgICAvLyBTaW11bGFjacOzbiBkZSBjYW1iaW8gZGUgZHVyYWNpw7NuIChsYSBpbXBsZW1lbnRhY2nDs24gcmVhbCBkZXBlbmRlcsOhIGRlIGxhIGVzdHJ1Y3R1cmEgZGVsIHByb3llY3RvKVxuICAgICAgY29uc29sZS5sb2coYENhbWJpYW5kbyBkdXJhY2nDs24gZGVsIGVsZW1lbnRvICR7ZWxlbWVudElkfSBhICR7ZHVyYXRpb259c2ApO1xuXG4gICAgICAvLyBBcXXDrSBpcsOtYSBsYSBsw7NnaWNhIHJlYWwgcGFyYSBjYW1iaWFyIGxhIGR1cmFjacOzbiBkZSB1biBlbGVtZW50b1xuICAgIH0sXG5cbiAgICBjaGFuZ2VUcmFuc2l0aW9uOiAoZWxlbWVudElkOiBzdHJpbmcsIHRyYW5zaXRpb246IHN0cmluZykgPT4ge1xuICAgICAgLy8gU2ltdWxhY2nDs24gZGUgY2FtYmlvIGRlIHRyYW5zaWNpw7NuIChsYSBpbXBsZW1lbnRhY2nDs24gcmVhbCBkZXBlbmRlcsOhIGRlIGxhIGVzdHJ1Y3R1cmEgZGVsIHByb3llY3RvKVxuICAgICAgY29uc29sZS5sb2coYENhbWJpYW5kbyB0cmFuc2ljacOzbiBkZWwgZWxlbWVudG8gJHtlbGVtZW50SWR9IGEgJHt0cmFuc2l0aW9ufWApO1xuXG4gICAgICAvLyBBcXXDrSBpcsOtYSBsYSBsw7NnaWNhIHJlYWwgcGFyYSBjYW1iaWFyIGxhIHRyYW5zaWNpw7NuIGRlIHVuIGVsZW1lbnRvXG4gICAgfSxcblxuICAgIGFkZFN1YnRpdGxlczogYXN5bmMgKG9wdGlvbnM/OiBTdWJ0aXRsZU9wdGlvbnMpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiQcOxYWRpZW5kbyBzdWJ0w610dWxvcyBkaXJlY3RhbWVudGUgc2luIGRlcGVuZGVyIGRlbCBib3TDs25cIik7XG5cbiAgICAgICAgLy8gVGlwbyBwYXJhIHJlcHJlc2VudGFyIHVuIHNlZ21lbnRvIGRlIHN1YnTDrXR1bG9cbiAgICAgICAgaW50ZXJmYWNlIFN1YnRpdGxlU2VnbWVudCB7XG4gICAgICAgICAgaWQ6IG51bWJlcjtcbiAgICAgICAgICBzdGFydFRpbWU6IG51bWJlcjsgLy8gZW4gbWlsaXNlZ3VuZG9zXG4gICAgICAgICAgZW5kVGltZTogbnVtYmVyOyAgIC8vIGVuIG1pbGlzZWd1bmRvc1xuICAgICAgICAgIHRleHQ6IHN0cmluZztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEZ1bmNpw7NuIHBhcmEgcGFyc2VhciBlbCB0aWVtcG8gZGUgZm9ybWF0byBTUlQgYSBtaWxpc2VndW5kb3NcbiAgICAgICAgY29uc3QgcGFyc2VUaW1lVG9NcyA9ICh0aW1lU3RyaW5nOiBzdHJpbmcpOiBudW1iZXIgPT4ge1xuICAgICAgICAgIGNvbnN0IFtob3VycywgbWludXRlcywgc2Vjb25kc0FuZE1zXSA9IHRpbWVTdHJpbmcuc3BsaXQoJzonKTtcbiAgICAgICAgICBjb25zdCBbc2Vjb25kcywgbXNdID0gc2Vjb25kc0FuZE1zLnNwbGl0KCcsJyk7XG5cbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgcGFyc2VJbnQoaG91cnMpICogMzYwMDAwMCArXG4gICAgICAgICAgICBwYXJzZUludChtaW51dGVzKSAqIDYwMDAwICtcbiAgICAgICAgICAgIHBhcnNlSW50KHNlY29uZHMpICogMTAwMCArXG4gICAgICAgICAgICBwYXJzZUludChtcylcbiAgICAgICAgICApO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIEZ1bmNpw7NuIHBhcmEgcGFyc2VhciBlbCBhcmNoaXZvIFNSVFxuICAgICAgICBjb25zdCBwYXJzZVNSVCA9IChzcnRDb250ZW50OiBzdHJpbmcpOiBTdWJ0aXRsZVNlZ21lbnRbXSA9PiB7XG4gICAgICAgICAgY29uc3Qgc2VnbWVudHM6IFN1YnRpdGxlU2VnbWVudFtdID0gW107XG4gICAgICAgICAgY29uc3QgYmxvY2tzID0gc3J0Q29udGVudC50cmltKCkuc3BsaXQoJ1xcblxcbicpO1xuXG4gICAgICAgICAgYmxvY2tzLmZvckVhY2goYmxvY2sgPT4ge1xuICAgICAgICAgICAgY29uc3QgbGluZXMgPSBibG9jay5zcGxpdCgnXFxuJyk7XG4gICAgICAgICAgICBpZiAobGluZXMubGVuZ3RoID49IDMpIHtcbiAgICAgICAgICAgICAgY29uc3QgaWQgPSBwYXJzZUludChsaW5lc1swXSk7XG4gICAgICAgICAgICAgIGNvbnN0IHRpbWVSYW5nZSA9IGxpbmVzWzFdLnNwbGl0KCcgLS0+ICcpO1xuICAgICAgICAgICAgICBjb25zdCBzdGFydFRpbWUgPSBwYXJzZVRpbWVUb01zKHRpbWVSYW5nZVswXSk7XG4gICAgICAgICAgICAgIGNvbnN0IGVuZFRpbWUgPSBwYXJzZVRpbWVUb01zKHRpbWVSYW5nZVsxXSk7XG4gICAgICAgICAgICAgIGNvbnN0IHRleHQgPSBsaW5lcy5zbGljZSgyKS5qb2luKCdcXG4nKTsgLy8gVW5pciB0b2RhcyBsYXMgbMOtbmVhcyBkZSB0ZXh0b1xuXG4gICAgICAgICAgICAgIHNlZ21lbnRzLnB1c2goe1xuICAgICAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgICAgIHN0YXJ0VGltZSxcbiAgICAgICAgICAgICAgICBlbmRUaW1lLFxuICAgICAgICAgICAgICAgIHRleHRcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICByZXR1cm4gc2VnbWVudHM7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gRnVuY2nDs24gcGFyYSBkaXZpZGlyIHVuIHRleHRvIGVuIGdydXBvcyBkZSBhcHJveGltYWRhbWVudGUgMyBwYWxhYnJhc1xuICAgICAgICBjb25zdCBzcGxpdFRleHRJbnRvR3JvdXBzID0gKHRleHQ6IHN0cmluZywgd29yZHNQZXJHcm91cCA9IDMpOiBzdHJpbmdbXSA9PiB7XG4gICAgICAgICAgY29uc3Qgd29yZHMgPSB0ZXh0LnNwbGl0KC9cXHMrLyk7XG4gICAgICAgICAgY29uc3QgZ3JvdXBzOiBzdHJpbmdbXSA9IFtdO1xuXG4gICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB3b3Jkcy5sZW5ndGg7IGkgKz0gd29yZHNQZXJHcm91cCkge1xuICAgICAgICAgICAgY29uc3QgZ3JvdXAgPSB3b3Jkcy5zbGljZShpLCBpICsgd29yZHNQZXJHcm91cCkuam9pbignICcpO1xuICAgICAgICAgICAgZ3JvdXBzLnB1c2goZ3JvdXApO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBncm91cHM7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gRnVuY2nDs24gcGFyYSBwcm9jZXNhciB1biBzZWdtZW50byB5IGRpdmlkaXJsbyBlbiBtw7psdGlwbGVzIHNlZ21lbnRvcyBzaSBlcyBuZWNlc2FyaW9cbiAgICAgICAgY29uc3QgcHJvY2Vzc1NlZ21lbnQgPSAoc2VnbWVudDogU3VidGl0bGVTZWdtZW50KTogU3VidGl0bGVTZWdtZW50W10gPT4ge1xuICAgICAgICAgIGNvbnN0IHRleHRHcm91cHMgPSBzcGxpdFRleHRJbnRvR3JvdXBzKHNlZ21lbnQudGV4dCk7XG5cbiAgICAgICAgICAvLyBTaSBzb2xvIGhheSB1biBncnVwbywgZGV2b2x2ZXIgZWwgc2VnbWVudG8gb3JpZ2luYWxcbiAgICAgICAgICBpZiAodGV4dEdyb3Vwcy5sZW5ndGggPD0gMSkge1xuICAgICAgICAgICAgcmV0dXJuIFtzZWdtZW50XTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBDYWxjdWxhciBsYSBkdXJhY2nDs24gZGUgY2FkYSBncnVwb1xuICAgICAgICAgIGNvbnN0IHRvdGFsRHVyYXRpb24gPSBzZWdtZW50LmVuZFRpbWUgLSBzZWdtZW50LnN0YXJ0VGltZTtcbiAgICAgICAgICBjb25zdCBncm91cER1cmF0aW9uID0gdG90YWxEdXJhdGlvbiAvIHRleHRHcm91cHMubGVuZ3RoO1xuXG4gICAgICAgICAgLy8gQ3JlYXIgdW4gbnVldm8gc2VnbWVudG8gcGFyYSBjYWRhIGdydXBvXG4gICAgICAgICAgcmV0dXJuIHRleHRHcm91cHMubWFwKChncm91cFRleHQsIGluZGV4KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBzdGFydFRpbWUgPSBzZWdtZW50LnN0YXJ0VGltZSArIChpbmRleCAqIGdyb3VwRHVyYXRpb24pO1xuICAgICAgICAgICAgY29uc3QgZW5kVGltZSA9IHN0YXJ0VGltZSArIGdyb3VwRHVyYXRpb247XG5cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIGlkOiBzZWdtZW50LmlkICogMTAwMCArIGluZGV4LCAvLyBHZW5lcmFyIHVuIElEIMO6bmljb1xuICAgICAgICAgICAgICBzdGFydFRpbWUsXG4gICAgICAgICAgICAgIGVuZFRpbWUsXG4gICAgICAgICAgICAgIHRleHQ6IGdyb3VwVGV4dFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBGdW5jacOzbiBwYXJhIGNyZWFyIGVsIHBheWxvYWQgZGUgdGV4dG8gcGFyYSBzdWJ0w610dWxvc1xuICAgICAgICBjb25zdCBjcmVhdGVTdWJ0aXRsZVBheWxvYWQgPSAodGV4dDogc3RyaW5nLCBzdGFydFRpbWU6IG51bWJlciwgZW5kVGltZTogbnVtYmVyKSA9PiAoe1xuICAgICAgICAgIGlkOiBnZW5lcmF0ZUlkKCksXG4gICAgICAgICAgZGlzcGxheToge1xuICAgICAgICAgICAgZnJvbTogc3RhcnRUaW1lLFxuICAgICAgICAgICAgdG86IGVuZFRpbWUsXG4gICAgICAgICAgfSxcbiAgICAgICAgICB0eXBlOiAndGV4dCcsXG4gICAgICAgICAgZGV0YWlsczoge1xuICAgICAgICAgICAgdGV4dDogdGV4dC50b1VwcGVyQ2FzZSgpLCAvLyBDb252ZXJ0aXIgYSBtYXnDunNjdWxhcyBjb21vIE1yQmVhc3RcbiAgICAgICAgICAgIGZvbnRTaXplOiA4MCwgLy8gVGFtYcOxbyBtw6FzIGdyYW5kZSBwYXJhIGVzdGlsbyBNckJlYXN0XG4gICAgICAgICAgICB3aWR0aDogOTAwLFxuICAgICAgICAgICAgZm9udFVybDogJy9mb250cy9tcmJlYXN0LnR0ZicsIC8vIFVzYXIgbGEgZnVlbnRlIE1yQmVhc3RcbiAgICAgICAgICAgIGZvbnRGYW1pbHk6ICdNckJlYXN0JywgLy8gTm9tYnJlIGRlIGxhIGZ1ZW50ZSBNckJlYXN0XG4gICAgICAgICAgICBjb2xvcjogJyNGRkZGMDAnLCAvLyBBbWFyaWxsbyBicmlsbGFudGVcbiAgICAgICAgICAgIHdvcmRXcmFwOiAnYnJlYWstd29yZCcsXG4gICAgICAgICAgICB0ZXh0QWxpZ246ICdjZW50ZXInLFxuICAgICAgICAgICAgYm9yZGVyV2lkdGg6IDIwLCAvLyBTdHJva2UgbmVncm8gZ3J1ZXNvXG4gICAgICAgICAgICBib3JkZXJDb2xvcjogJyMwMDAwMDAnLFxuICAgICAgICAgICAgYm94U2hhZG93OiB7XG4gICAgICAgICAgICAgIGNvbG9yOiAnIzAwMDAwMCcsXG4gICAgICAgICAgICAgIHg6IDMsXG4gICAgICAgICAgICAgIHk6IDMsXG4gICAgICAgICAgICAgIGJsdXI6IDAsIC8vIFNpbiBkZXNlbmZvcXVlIHBhcmEgdW4gZXN0aWxvIG3DoXMgaW1wYWN0YW50ZVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogJ3RyYW5zcGFyZW50JywgLy8gU2luIGZvbmRvIHBhcmEgcXVlIGRlc3RhcXVlIG3DoXNcbiAgICAgICAgICAgIHBhZGRpbmc6IDEwLFxuICAgICAgICAgICAgYm9yZGVyUmFkaXVzOiAwLCAvLyBTaW4gYm9yZGVzIHJlZG9uZGVhZG9zIHBhcmEgdW4gZXN0aWxvIG3DoXMgaW1wYWN0YW50ZVxuICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIENhcmdhciBlbCBhcmNoaXZvIFNSVFxuICAgICAgICBjb25zb2xlLmxvZyhcIkNhcmdhbmRvIGFyY2hpdm8gU1JULi4uXCIpO1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKCcvdHJhbnNjcmlwdGlvbnMvdHJhbnNjcmlwdGlvbjEuc3J0Jyk7XG4gICAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEVycm9yIGFsIGNhcmdhciBlbCBhcmNoaXZvIFNSVDogJHtyZXNwb25zZS5zdGF0dXN9YCk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBzcnRDb250ZW50ID0gYXdhaXQgcmVzcG9uc2UudGV4dCgpO1xuICAgICAgICBjb25zb2xlLmxvZyhcIkFyY2hpdm8gU1JUIGNhcmdhZG8gY29ycmVjdGFtZW50ZVwiKTtcblxuICAgICAgICAvLyBQYXJzZWFyIGVsIGFyY2hpdm8gU1JUXG4gICAgICAgIGxldCBzZWdtZW50cyA9IHBhcnNlU1JUKHNydENvbnRlbnQpO1xuICAgICAgICBjb25zb2xlLmxvZyhgU2UgZW5jb250cmFyb24gJHtzZWdtZW50cy5sZW5ndGh9IHNlZ21lbnRvcyBkZSBzdWJ0w610dWxvc2ApO1xuXG4gICAgICAgIC8vIFNpZW1wcmUgdXNhciBlbCBtb2RvIGFncnVwYWRvIChkaXZpZGlyIGVuIGdydXBvcyBkZSAzIHBhbGFicmFzKVxuICAgICAgICBzZWdtZW50cyA9IHNlZ21lbnRzLmZsYXRNYXAocHJvY2Vzc1NlZ21lbnQpO1xuICAgICAgICBjb25zb2xlLmxvZyhgRGVzcHXDqXMgZGUgcHJvY2VzYXIsIGhheSAke3NlZ21lbnRzLmxlbmd0aH0gc2VnbWVudG9zIGRlIHN1YnTDrXR1bG9zYCk7XG5cbiAgICAgICAgLy8gRmlsdHJhciBwb3IgdGllbXBvIHNpIGVzIG5lY2VzYXJpb1xuICAgICAgICBpZiAob3B0aW9ucz8uc3RhcnRUaW1lICE9PSB1bmRlZmluZWQgfHwgb3B0aW9ucz8uZW5kVGltZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgY29uc3Qgb3JpZ2luYWxMZW5ndGggPSBzZWdtZW50cy5sZW5ndGg7XG4gICAgICAgICAgc2VnbWVudHMgPSBzZWdtZW50cy5maWx0ZXIoc2VnbWVudCA9PiB7XG4gICAgICAgICAgICBjb25zdCBwYXNzZXNTdGFydEZpbHRlciA9IG9wdGlvbnMuc3RhcnRUaW1lID09PSB1bmRlZmluZWQgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWdtZW50LnN0YXJ0VGltZSA+PSAob3B0aW9ucy5zdGFydFRpbWUgKiAxMDAwKTtcbiAgICAgICAgICAgIGNvbnN0IHBhc3Nlc0VuZEZpbHRlciA9IG9wdGlvbnMuZW5kVGltZSA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlZ21lbnQuZW5kVGltZSA8PSAob3B0aW9ucy5lbmRUaW1lICogMTAwMCk7XG4gICAgICAgICAgICByZXR1cm4gcGFzc2VzU3RhcnRGaWx0ZXIgJiYgcGFzc2VzRW5kRmlsdGVyO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGNvbnNvbGUubG9nKGBGaWx0cmFkbyBwb3IgdGllbXBvOiBkZSAke29yaWdpbmFsTGVuZ3RofSBhICR7c2VnbWVudHMubGVuZ3RofSBzZWdtZW50b3NgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEHDsWFkaXIgbG9zIHN1YnTDrXR1bG9zIGNvbiB1biByZXRyYXNvIGVudHJlIGNhZGEgdW5vXG4gICAgICAgIGNvbnNvbGUubG9nKGBBw7FhZGllbmRvICR7c2VnbWVudHMubGVuZ3RofSBzZWdtZW50b3MgZGUgc3VidMOtdHVsb3MgYWwgdGltZWxpbmUuLi5gKTtcblxuICAgICAgICBzZWdtZW50cy5mb3JFYWNoKChzZWdtZW50LCBpbmRleCkgPT4ge1xuICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgZGlzcGF0Y2goQUREX1RFWFQsIHtcbiAgICAgICAgICAgICAgcGF5bG9hZDogY3JlYXRlU3VidGl0bGVQYXlsb2FkKHNlZ21lbnQudGV4dCwgc2VnbWVudC5zdGFydFRpbWUsIHNlZ21lbnQuZW5kVGltZSksXG4gICAgICAgICAgICAgIG9wdGlvbnM6IHt9LFxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGlmICgoaW5kZXggKyAxKSAlIDEwID09PSAwIHx8IGluZGV4ID09PSBzZWdtZW50cy5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBQcm9ncmVzbzogJHtpbmRleCArIDF9LyR7c2VnbWVudHMubGVuZ3RofSBzdWJ0w610dWxvcyBhw7FhZGlkb3NgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LCBpbmRleCAqIDIwMCk7IC8vIDIwMG1zIGRlIHJldHJhc28gZW50cmUgY2FkYSBzdWJ0w610dWxvXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIGFsIGHDsWFkaXIgc3VidMOtdHVsb3M6XCIsIGVycm9yKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBnZXRBY3RpdmVFbGVtZW50czogYXN5bmMgKCkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gT2J0ZW5lciBlbCBlc3RhZG8gYWN0dWFsXG4gICAgICAgIGNvbnN0IHN0YXRlID0gc3RhdGVNYW5hZ2VyLmdldFN0YXRlKCk7XG5cbiAgICAgICAgLy8gVmVyaWZpY2FyIHNpIGhheSBJRHMgYWN0aXZvc1xuICAgICAgICBpZiAoIXN0YXRlLmFjdGl2ZUlkcyB8fCBzdGF0ZS5hY3RpdmVJZHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgY29uc29sZS5sb2coXCJObyBoYXkgZWxlbWVudG9zIGFjdGl2b3Mgc2VsZWNjaW9uYWRvc1wiKTtcbiAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cblxuICAgICAgICAvLyBWZXJpZmljYXIgc2kgaGF5IGVsZW1lbnRvcyBlbiBlbCB0cmFja0l0ZW1zTWFwXG4gICAgICAgIGlmICghc3RhdGUudHJhY2tJdGVtc01hcCkge1xuICAgICAgICAgIGNvbnNvbGUubG9nKFwiTm8gaGF5IHRyYWNrSXRlbXNNYXAgZGlzcG9uaWJsZVwiKTtcbiAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cblxuICAgICAgICAvLyBPYnRlbmVyIGluZm9ybWFjacOzbiBkZSBsb3MgZWxlbWVudG9zIGFjdGl2b3NcbiAgICAgICAgY29uc3QgYWN0aXZlRWxlbWVudHMgPSBzdGF0ZS5hY3RpdmVJZHNcbiAgICAgICAgICAuZmlsdGVyKGlkID0+IHN0YXRlLnRyYWNrSXRlbXNNYXBbaWRdKVxuICAgICAgICAgIC5tYXAoaWQgPT4ge1xuICAgICAgICAgICAgY29uc3QgaXRlbSA9IHN0YXRlLnRyYWNrSXRlbXNNYXBbaWRdO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICAgIHRyYWNrSWQ6IGl0ZW0udHJhY2tJZCxcbiAgICAgICAgICAgICAgdHlwZTogaXRlbS50eXBlLFxuICAgICAgICAgICAgICBmcm9tOiBpdGVtLmRpc3BsYXk/LmZyb20sXG4gICAgICAgICAgICAgIHRvOiBpdGVtLmRpc3BsYXk/LnRvLFxuICAgICAgICAgICAgICBkdXJhdGlvbjogaXRlbS5kaXNwbGF5ID8gKGl0ZW0uZGlzcGxheS50byAtIGl0ZW0uZGlzcGxheS5mcm9tKSA6IDAsXG4gICAgICAgICAgICAgIGRldGFpbHM6IGl0ZW0uZGV0YWlsc1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9KTtcblxuICAgICAgICBjb25zb2xlLmxvZyhgU2UgZW5jb250cmFyb24gJHthY3RpdmVFbGVtZW50cy5sZW5ndGh9IGVsZW1lbnRvcyBhY3Rpdm9zYCk7XG4gICAgICAgIHJldHVybiBhY3RpdmVFbGVtZW50cztcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBhbCBvYnRlbmVyIGVsZW1lbnRvcyBhY3Rpdm9zOlwiLCBlcnJvcik7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgZ2V0QWxsVGltZWxpbmVFbGVtZW50czogYXN5bmMgKCkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gT2J0ZW5lciBlbCBlc3RhZG8gYWN0dWFsXG4gICAgICAgIGNvbnN0IHN0YXRlID0gc3RhdGVNYW5hZ2VyLmdldFN0YXRlKCk7XG5cbiAgICAgICAgLy8gVmVyaWZpY2FyIHNpIGhheSBlbGVtZW50b3MgZW4gZWwgdHJhY2tJdGVtc01hcFxuICAgICAgICBpZiAoIXN0YXRlLnRyYWNrSXRlbXNNYXAgfHwgT2JqZWN0LmtleXMoc3RhdGUudHJhY2tJdGVtc01hcCkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgY29uc29sZS5sb2coXCJObyBoYXkgZWxlbWVudG9zIGVuIGVsIHRyYWNrSXRlbXNNYXBcIik7XG5cbiAgICAgICAgICAvLyBCdXNjYXIgZWxlbWVudG9zIGVuIG90cmFzIHByb3BpZWRhZGVzIGRlbCBlc3RhZG9cbiAgICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhzdGF0ZSkpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygc3RhdGVba2V5XSA9PT0gJ29iamVjdCcgJiYgc3RhdGVba2V5XSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICBjb25zdCBvYmpWYWx1ZSA9IHN0YXRlW2tleV07XG4gICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBFeHBsb3JhbmRvIHByb3BpZWRhZCBhbHRlcm5hdGl2YTogJHtrZXl9YCk7XG5cbiAgICAgICAgICAgICAgLy8gVmVyaWZpY2FyIHNpIHBhcmVjZSBzZXIgdW4gbWFwYSBkZSBlbGVtZW50b3NcbiAgICAgICAgICAgICAgaWYgKE9iamVjdC5rZXlzKG9ialZhbHVlKS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2FtcGxlID0gb2JqVmFsdWVbT2JqZWN0LmtleXMob2JqVmFsdWUpWzBdXTtcbiAgICAgICAgICAgICAgICBpZiAoc2FtcGxlICYmIHNhbXBsZS5kaXNwbGF5ICYmIHNhbXBsZS50eXBlKSB7XG4gICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgRW5jb250cmFkYSBwb3NpYmxlIGZ1ZW50ZSBhbHRlcm5hdGl2YSBkZSBlbGVtZW50b3MgZW4gcHJvcGllZGFkICR7a2V5fWApO1xuXG4gICAgICAgICAgICAgICAgICAvLyBQcm9jZXNhciBlbGVtZW50b3MgZGUgZXN0YSBwcm9waWVkYWQgYWx0ZXJuYXRpdmFcbiAgICAgICAgICAgICAgICAgIHJldHVybiBPYmplY3QuZW50cmllcyhvYmpWYWx1ZSlcbiAgICAgICAgICAgICAgICAgICAgLmZpbHRlcigoW18sIGl0ZW1dKSA9PiBpdGVtICYmIGl0ZW0uZGlzcGxheSlcbiAgICAgICAgICAgICAgICAgICAgLm1hcCgoW2lkLCBpdGVtXSkgPT4gKHtcbiAgICAgICAgICAgICAgICAgICAgICBpZCxcbiAgICAgICAgICAgICAgICAgICAgICB0cmFja0lkOiBpdGVtLnRyYWNrSWQsXG4gICAgICAgICAgICAgICAgICAgICAgdHlwZTogaXRlbS50eXBlLFxuICAgICAgICAgICAgICAgICAgICAgIGZyb206IGl0ZW0uZGlzcGxheT8uZnJvbSxcbiAgICAgICAgICAgICAgICAgICAgICB0bzogaXRlbS5kaXNwbGF5Py50byxcbiAgICAgICAgICAgICAgICAgICAgICBkdXJhdGlvbjogaXRlbS5kaXNwbGF5ID8gKGl0ZW0uZGlzcGxheS50byAtIGl0ZW0uZGlzcGxheS5mcm9tKSA6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgZGV0YWlsczogaXRlbS5kZXRhaWxzXG4gICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cblxuICAgICAgICAvLyBPYnRlbmVyIHRvZG9zIGxvcyBlbGVtZW50b3NcbiAgICAgICAgY29uc3QgYWxsRWxlbWVudHMgPSBPYmplY3QuZW50cmllcyhzdGF0ZS50cmFja0l0ZW1zTWFwKVxuICAgICAgICAgIC5maWx0ZXIoKFtfLCBpdGVtXSkgPT4gaXRlbSAmJiBpdGVtLmRpc3BsYXkpXG4gICAgICAgICAgLm1hcCgoW2lkLCBpdGVtXSkgPT4gKHtcbiAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgdHJhY2tJZDogaXRlbS50cmFja0lkLFxuICAgICAgICAgICAgdHlwZTogaXRlbS50eXBlLFxuICAgICAgICAgICAgZnJvbTogaXRlbS5kaXNwbGF5Py5mcm9tLFxuICAgICAgICAgICAgdG86IGl0ZW0uZGlzcGxheT8udG8sXG4gICAgICAgICAgICBkdXJhdGlvbjogaXRlbS5kaXNwbGF5ID8gKGl0ZW0uZGlzcGxheS50byAtIGl0ZW0uZGlzcGxheS5mcm9tKSA6IDAsXG4gICAgICAgICAgICBkZXRhaWxzOiBpdGVtLmRldGFpbHNcbiAgICAgICAgICB9KSlcbiAgICAgICAgICAuc29ydCgoYSwgYikgPT4gKGEuZnJvbSB8fCAwKSAtIChiLmZyb20gfHwgMCkpO1xuXG4gICAgICAgIGNvbnNvbGUubG9nKGBTZSBlbmNvbnRyYXJvbiAke2FsbEVsZW1lbnRzLmxlbmd0aH0gZWxlbWVudG9zIGVuIGVsIHRpbWVsaW5lYCk7XG4gICAgICAgIHJldHVybiBhbGxFbGVtZW50cztcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBhbCBvYnRlbmVyIHRvZG9zIGxvcyBlbGVtZW50b3MgZGVsIHRpbWVsaW5lOlwiLCBlcnJvcik7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgcmVtb3ZlU2VnbWVudHM6IGFzeW5jIChzZWdtZW50czogVGltZVNlZ21lbnRbXSkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc29sZS5sb2coXCJJbmljaWFuZG8gZWxpbWluYWNpw7NuIGRlIHNlZ21lbnRvcyBtw7psdGlwbGVzXCIpO1xuXG4gICAgICAgIC8vIE9idGVuZXIgZWwgZXN0YWRvIGFjdHVhbFxuICAgICAgICBjb25zdCBzdGF0ZSA9IHN0YXRlTWFuYWdlci5nZXRTdGF0ZSgpO1xuXG4gICAgICAgIC8vIFZhbGlkYXIgcXVlIGhheWEgZWxlbWVudG9zIGVuIGxhIHRpbWVsaW5lXG4gICAgICAgIGlmICghc3RhdGUuYWN0aXZlSWRzIHx8IHN0YXRlLmFjdGl2ZUlkcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFwiTm8gaGF5IGVsZW1lbnRvcyBzZWxlY2Npb25hZG9zIGVuIGxhIHRpbWVsaW5lXCIpO1xuXG4gICAgICAgICAgLy8gQnVzY2FyIGVsIHByaW1lciBlbGVtZW50byBkaXNwb25pYmxlIGVuIGxhIHRpbWVsaW5lXG4gICAgICAgICAgY29uc3QgdHJhY2tJdGVtc01hcCA9IHN0YXRlLnRyYWNrSXRlbXNNYXAgfHwge307XG4gICAgICAgICAgY29uc3QgdHJhY2tJdGVtcyA9IE9iamVjdC5rZXlzKHRyYWNrSXRlbXNNYXApO1xuXG4gICAgICAgICAgaWYgKHRyYWNrSXRlbXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiTm8gaGF5IGVsZW1lbnRvcyBlbiBsYSB0aW1lbGluZSBwYXJhIGVsaW1pbmFyIHNlZ21lbnRvc1wiKTtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIGhheSBlbGVtZW50b3MgZW4gbGEgdGltZWxpbmVcIik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gU2VsZWNjaW9uYXIgZWwgcHJpbWVyIGVsZW1lbnRvIGRpc3BvbmlibGVcbiAgICAgICAgICBjb25zdCBmaXJzdEl0ZW1JZCA9IHRyYWNrSXRlbXNbMF07XG4gICAgICAgICAgY29uc29sZS5sb2coYFNlbGVjY2lvbmFuZG8gYXV0b23DoXRpY2FtZW50ZSBlbCBlbGVtZW50byBjb24gSUQ6ICR7Zmlyc3RJdGVtSWR9YCk7XG5cbiAgICAgICAgICBkaXNwYXRjaChMQVlFUl9TRUxFQ1QsIHtcbiAgICAgICAgICAgIHBheWxvYWQ6IHtcbiAgICAgICAgICAgICAgaWRzOiBbZmlyc3RJdGVtSWRdXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICAvLyBFc3BlcmFyIGEgcXVlIHNlIGFwbGlxdWUgbGEgc2VsZWNjacOzblxuICAgICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCAzMDApKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEFsbWFjZW5hbW9zIGluZm9ybWFjacOzbiBkZWwgZWxlbWVudG8gc2VsZWNjaW9uYWRvXG4gICAgICAgIGNvbnN0IGN1cnJlbnRTdGF0ZSA9IHN0YXRlTWFuYWdlci5nZXRTdGF0ZSgpO1xuICAgICAgICBpZiAoIWN1cnJlbnRTdGF0ZS5hY3RpdmVJZHMgfHwgY3VycmVudFN0YXRlLmFjdGl2ZUlkcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBzZSBwdWRvIHNlbGVjY2lvbmFyIG5pbmfDum4gZWxlbWVudG8gZW4gbGEgdGltZWxpbmVcIik7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBvcmlnaW5hbEl0ZW1JZCA9IGN1cnJlbnRTdGF0ZS5hY3RpdmVJZHNbMF07XG4gICAgICAgIGNvbnN0IG9yaWdpbmFsSXRlbSA9IGN1cnJlbnRTdGF0ZS50cmFja0l0ZW1zTWFwW29yaWdpbmFsSXRlbUlkXTtcbiAgICAgICAgY29uc3QgdHJhY2tUeXBlID0gb3JpZ2luYWxJdGVtLnR5cGU7XG4gICAgICAgIGNvbnN0IHRyYWNrSWQgPSBvcmlnaW5hbEl0ZW0udHJhY2tJZDtcblxuICAgICAgICBjb25zb2xlLmxvZyhgRWxlbWVudG8gc2VsZWNjaW9uYWRvOiBJRD0ke29yaWdpbmFsSXRlbUlkfSwgdGlwbz0ke3RyYWNrVHlwZX0sIHRyYWNrSWQ9JHt0cmFja0lkfWApO1xuXG4gICAgICAgIC8vIFByb2Nlc2FyIGNhZGEgc2VnbWVudG8gZW4gb3JkZW4gKGRlIGZpbmFsIGEgcHJpbmNpcGlvIHBhcmEgZXZpdGFyIGFmZWN0YXIgcG9zaWNpb25lcylcbiAgICAgICAgZm9yIChsZXQgaSA9IHNlZ21lbnRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgY29uc3Qgc2VnbWVudCA9IHNlZ21lbnRzW2ldO1xuICAgICAgICAgIGNvbnNvbGUubG9nKGBQcm9jZXNhbmRvIHNlZ21lbnRvICR7aSsxfS8ke3NlZ21lbnRzLmxlbmd0aH06ICR7c2VnbWVudC5zdGFydFRpbWV9cyAtICR7c2VnbWVudC5lbmRUaW1lfXNgKTtcblxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBQQVNPIDE6IEhhY2VyIHVuIGNvcnRlIGVuIGVsIHRpZW1wbyBmaW5hbFxuICAgICAgICAgICAgY29uc3QgZW5kTXMgPSBzZWdtZW50LmVuZFRpbWUgKiAxMDAwO1xuICAgICAgICAgICAgZGlzcGF0Y2goQUNUSVZFX1NQTElULCB7XG4gICAgICAgICAgICAgIHBheWxvYWQ6IHt9LFxuICAgICAgICAgICAgICBvcHRpb25zOiB7XG4gICAgICAgICAgICAgICAgdGltZTogZW5kTXMsXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGBQYXNvIDE6IENvcnRlIGFwbGljYWRvIGVuIHRpZW1wbyBmaW5hbCAke3NlZ21lbnQuZW5kVGltZX1zYCk7XG5cbiAgICAgICAgICAgIC8vIEVzcGVyYXIgYSBxdWUgc2UgcHJvY2VzZSBlbCBwcmltZXIgY29ydGVcbiAgICAgICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCA1MDApKTtcblxuICAgICAgICAgICAgLy8gT2J0ZW5lbW9zIGVsIGVzdGFkbyBkZXNwdcOpcyBkZWwgcHJpbWVyIGNvcnRlXG4gICAgICAgICAgICBjb25zdCBzdGF0ZUFmdGVyRmlyc3RDdXQgPSBzdGF0ZU1hbmFnZXIuZ2V0U3RhdGUoKTtcbiAgICAgICAgICAgIGNvbnN0IGVsZW1lbnRzQWZ0ZXJGaXJzdEN1dCA9IE9iamVjdC5lbnRyaWVzKHN0YXRlQWZ0ZXJGaXJzdEN1dC50cmFja0l0ZW1zTWFwKVxuICAgICAgICAgICAgICAuZmlsdGVyKChbXywgaXRlbV0pID0+XG4gICAgICAgICAgICAgICAgaXRlbS50eXBlID09PSB0cmFja1R5cGUgJiZcbiAgICAgICAgICAgICAgICBpdGVtLnRyYWNrSWQgPT09IHRyYWNrSWQgJiZcbiAgICAgICAgICAgICAgICBpdGVtLmRpc3BsYXkgJiZcbiAgICAgICAgICAgICAgICAhaXNOYU4oaXRlbS5kaXNwbGF5LmZyb20pICYmXG4gICAgICAgICAgICAgICAgIWlzTmFOKGl0ZW0uZGlzcGxheS50bylcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAubWFwKChbaWQsIGl0ZW1dKSA9PiAoe1xuICAgICAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgICAgIGZyb206IGl0ZW0uZGlzcGxheS5mcm9tLFxuICAgICAgICAgICAgICAgIHRvOiBpdGVtLmRpc3BsYXkudG8sXG4gICAgICAgICAgICAgICAgZHVyYWNpw7NuOiBpdGVtLmRpc3BsYXkudG8gLSBpdGVtLmRpc3BsYXkuZnJvbVxuICAgICAgICAgICAgICB9KSlcbiAgICAgICAgICAgICAgLnNvcnQoKGEsIGIpID0+IGEuZnJvbSAtIGIuZnJvbSk7XG5cbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiRWxlbWVudG9zIGRlc3B1w6lzIGRlbCBwcmltZXIgY29ydGU6XCIsIGVsZW1lbnRzQWZ0ZXJGaXJzdEN1dCk7XG5cbiAgICAgICAgICAgIC8vIFBBU08gMjogSWRlbnRpZmljYXIgZWwgZWxlbWVudG8gaXpxdWllcmRvIHF1ZSBjb250aWVuZSBlbCB0aWVtcG8gaW5pY2lhbFxuICAgICAgICAgICAgY29uc3Qgc3RhcnRNcyA9IHNlZ21lbnQuc3RhcnRUaW1lICogMTAwMDtcbiAgICAgICAgICAgIGNvbnN0IGxlZnRFbGVtZW50ID0gZWxlbWVudHNBZnRlckZpcnN0Q3V0LmZpbmQoZWxlbSA9PlxuICAgICAgICAgICAgICBlbGVtLmZyb20gPD0gc3RhcnRNcyAmJiBlbGVtLnRvID49IHN0YXJ0TXNcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIGlmICghbGVmdEVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihgTm8gc2UgcHVkbyBpZGVudGlmaWNhciBlbCBlbGVtZW50byBpenF1aWVyZG8gcGFyYSBlbCBzZWdtZW50byAke2krMX1gKTtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGBQYXNvIDI6IEVsZW1lbnRvIGl6cXVpZXJkbyBpZGVudGlmaWNhZG8gKElEOiAke2xlZnRFbGVtZW50LmlkfSlgKTtcblxuICAgICAgICAgICAgLy8gUEFTTyAzOiBTZWxlY2Npb25hciBlbCBlbGVtZW50byBpenF1aWVyZG8geSBoYWNlciBjb3J0ZSBlbiB0aWVtcG8gaW5pY2lhbFxuICAgICAgICAgICAgZGlzcGF0Y2goTEFZRVJfU0VMRUNULCB7XG4gICAgICAgICAgICAgIHBheWxvYWQ6IHtcbiAgICAgICAgICAgICAgICBpZHM6IFtsZWZ0RWxlbWVudC5pZF1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vIEVzcGVyYXIgYSBxdWUgc2UgYXBsaXF1ZSBsYSBzZWxlY2Npw7NuXG4gICAgICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgMzAwKSk7XG5cbiAgICAgICAgICAgIC8vIEFwbGljYXIgZWwgY29ydGUgZW4gZWwgdGllbXBvIGluaWNpYWxcbiAgICAgICAgICAgIGRpc3BhdGNoKEFDVElWRV9TUExJVCwge1xuICAgICAgICAgICAgICBwYXlsb2FkOiB7fSxcbiAgICAgICAgICAgICAgb3B0aW9uczoge1xuICAgICAgICAgICAgICAgIHRpbWU6IHN0YXJ0TXMsXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGBQYXNvIDM6IFNlZ3VuZG8gY29ydGUgYXBsaWNhZG8gZW4gdGllbXBvIGluaWNpYWwgJHtzZWdtZW50LnN0YXJ0VGltZX1zYCk7XG5cbiAgICAgICAgICAgIC8vIEVzcGVyYXIgYSBxdWUgc2UgcHJvY2VzZSBlbCBzZWd1bmRvIGNvcnRlXG4gICAgICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgNTAwKSk7XG5cbiAgICAgICAgICAgIC8vIE9idGVuZW1vcyBlbCBlc3RhZG8gZGVzcHXDqXMgZGVsIHNlZ3VuZG8gY29ydGVcbiAgICAgICAgICAgIGNvbnN0IHN0YXRlQWZ0ZXJTZWNvbmRDdXQgPSBzdGF0ZU1hbmFnZXIuZ2V0U3RhdGUoKTtcbiAgICAgICAgICAgIGNvbnN0IGVsZW1lbnRzQWZ0ZXJTZWNvbmRDdXQgPSBPYmplY3QuZW50cmllcyhzdGF0ZUFmdGVyU2Vjb25kQ3V0LnRyYWNrSXRlbXNNYXApXG4gICAgICAgICAgICAgIC5maWx0ZXIoKFtfLCBpdGVtXSkgPT5cbiAgICAgICAgICAgICAgICBpdGVtLnR5cGUgPT09IHRyYWNrVHlwZSAmJlxuICAgICAgICAgICAgICAgIGl0ZW0udHJhY2tJZCA9PT0gdHJhY2tJZCAmJlxuICAgICAgICAgICAgICAgIGl0ZW0uZGlzcGxheSAmJlxuICAgICAgICAgICAgICAgICFpc05hTihpdGVtLmRpc3BsYXkuZnJvbSkgJiZcbiAgICAgICAgICAgICAgICAhaXNOYU4oaXRlbS5kaXNwbGF5LnRvKVxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgIC5tYXAoKFtpZCwgaXRlbV0pID0+ICh7XG4gICAgICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICAgICAgZnJvbTogaXRlbS5kaXNwbGF5LmZyb20sXG4gICAgICAgICAgICAgICAgdG86IGl0ZW0uZGlzcGxheS50byxcbiAgICAgICAgICAgICAgICBkdXJhY2nDs246IGl0ZW0uZGlzcGxheS50byAtIGl0ZW0uZGlzcGxheS5mcm9tXG4gICAgICAgICAgICAgIH0pKVxuICAgICAgICAgICAgICAuc29ydCgoYSwgYikgPT4gYS5mcm9tIC0gYi5mcm9tKTtcblxuICAgICAgICAgICAgY29uc29sZS5sb2coXCJFbGVtZW50b3MgZGVzcHXDqXMgZGVsIHNlZ3VuZG8gY29ydGU6XCIsIGVsZW1lbnRzQWZ0ZXJTZWNvbmRDdXQpO1xuXG4gICAgICAgICAgICAvLyBQQVNPIDQ6IElkZW50aWZpY2FyIGVsIGVsZW1lbnRvIGRlbCBtZWRpbyB1c2FuZG8gY3JpdGVyaW9zIG3DoXMgcHJlY2lzb3NcbiAgICAgICAgICAgIGNvbnN0IG1pZGRsZUVsZW1lbnRzID0gZWxlbWVudHNBZnRlclNlY29uZEN1dC5maWx0ZXIoZWxlbSA9PlxuICAgICAgICAgICAgICBNYXRoLmFicyhlbGVtLmZyb20gLSBzdGFydE1zKSA8IDUwICYmIE1hdGguYWJzKGVsZW0udG8gLSBlbmRNcykgPCA1MFxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgY29uc29sZS5sb2coXCJFbGVtZW50b3MgcXVlIGNvaW5jaWRlbiBjb24gbG9zIGNyaXRlcmlvcyBkZWwgbWVkaW86XCIsIG1pZGRsZUVsZW1lbnRzKTtcblxuICAgICAgICAgICAgaWYgKG1pZGRsZUVsZW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGBObyBzZSBwdWRvIGlkZW50aWZpY2FyIGVsIGVsZW1lbnRvIGRlbCBtZWRpbyBwYXJhIGVsIHNlZ21lbnRvICR7aSsxfWApO1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gU2kgaGF5IG3DoXMgZGUgdW4gZWxlbWVudG8gcXVlIGNvaW5jaWRlLCB0b21hbW9zIGVsIHByaW1lcm9cbiAgICAgICAgICAgIGNvbnN0IG1pZGRsZUVsZW1lbnQgPSBtaWRkbGVFbGVtZW50c1swXTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGBQYXNvIDQ6IEVsZW1lbnRvIGRlbCBtZWRpbyBpZGVudGlmaWNhZG8gKElEOiAke21pZGRsZUVsZW1lbnQuaWR9KWApO1xuXG4gICAgICAgICAgICAvLyBQQVNPIDU6IFNlbGVjY2lvbmFyIHkgZWxpbWluYXIgZWwgZWxlbWVudG8gZGVsIG1lZGlvXG4gICAgICAgICAgICBkaXNwYXRjaChMQVlFUl9TRUxFQ1QsIHtcbiAgICAgICAgICAgICAgcGF5bG9hZDoge1xuICAgICAgICAgICAgICAgIGlkczogW21pZGRsZUVsZW1lbnQuaWRdXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvLyBFc3BlcmFyIGEgcXVlIHNlIGFwbGlxdWUgbGEgc2VsZWNjacOzblxuICAgICAgICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDMwMCkpO1xuXG4gICAgICAgICAgICAvLyBWZXJpZmljYXIgcXVlIGVsIGVsZW1lbnRvIGVzdMOhIHNlbGVjY2lvbmFkbyBhbnRlcyBkZSBlbGltaW5hcmxvXG4gICAgICAgICAgICBjb25zdCBjdXJyZW50U3RhdGUgPSBzdGF0ZU1hbmFnZXIuZ2V0U3RhdGUoKTtcbiAgICAgICAgICAgIGlmIChjdXJyZW50U3RhdGUuYWN0aXZlSWRzICYmIGN1cnJlbnRTdGF0ZS5hY3RpdmVJZHMuaW5jbHVkZXMobWlkZGxlRWxlbWVudC5pZCkpIHtcbiAgICAgICAgICAgICAgY29uc29sZS5sb2coYEVsZW1lbnRvIGRlbCBtZWRpbyBjb3JyZWN0YW1lbnRlIHNlbGVjY2lvbmFkbywgcHJvY2VkaWVuZG8gY29uIGVsaW1pbmFjacOzbmApO1xuICAgICAgICAgICAgICBkaXNwYXRjaChMQVlFUl9ERUxFVEUpO1xuICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgRWxlbWVudG8gZWxpbWluYWRvIGNvcnJlY3RhbWVudGU6ICR7bWlkZGxlRWxlbWVudC5pZH1gKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBObyBzZSBwdWRvIHNlbGVjY2lvbmFyIG5vcm1hbG1lbnRlLCBpbnRlbnRhbmRvIG3DqXRvZG8gYWx0ZXJuYXRpdm9gKTtcblxuICAgICAgICAgICAgICAvLyBFbmZvcXVlIGFsdGVybmF0aXZvOiBVc2FyIGVsIEVESVRfT0JKRUNUIHBhcmEgXCJvY3VsdGFyXCIgZWwgc2VnbWVudG9cbiAgICAgICAgICAgICAgZGlzcGF0Y2goRURJVF9PQkpFQ1QsIHtcbiAgICAgICAgICAgICAgICBwYXlsb2FkOiB7XG4gICAgICAgICAgICAgICAgICBbbWlkZGxlRWxlbWVudC5pZF06IHtcbiAgICAgICAgICAgICAgICAgICAgZGlzcGxheToge1xuICAgICAgICAgICAgICAgICAgICAgIGZyb206IC05OTk5OSwgLy8gVW4gdmFsb3IgZnVlcmEgZGVsIHJhbmdvIHZpc2libGVcbiAgICAgICAgICAgICAgICAgICAgICB0bzogLTk5OTkwXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHZpc2libGU6IGZhbHNlIC8vIEFkaWNpb25hbG1lbnRlIG1hcmNhcmxvIGNvbW8gbm8gdmlzaWJsZVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBBcGxpY2FkbyBtw6l0b2RvIGFsdGVybmF0aXZvIHBhcmEgb2N1bHRhciBlbCBzZWdtZW50b2ApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBFc3BlcmFyIGEgcXVlIHNlIHByb2Nlc2UgbGEgZWxpbWluYWNpw7NuXG4gICAgICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgNTAwKSk7XG5cbiAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihgRXJyb3IgYWwgcHJvY2VzYXIgZWwgc2VnbWVudG8gJHtpKzF9OmAsIGVycm9yKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBQYXVzYSBlbnRyZSBzZWdtZW50b3NcbiAgICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgNTAwKSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBBY3R1YWxpemFyIGxhIGVzY2FsYSBwYXJhIHJlZnJlc2NhciBsYSB2aXN0YVxuICAgICAgICBjb25zdCB7IHNjYWxlIH0gPSBzdGF0ZU1hbmFnZXIuZ2V0U3RhdGUoKTtcbiAgICAgICAgaWYgKHNjYWxlKSB7XG4gICAgICAgICAgY29uc29sZS5sb2coXCJBY3R1YWxpemFuZG8gZXNjYWxhIHBhcmEgcmVmcmVzY2FyIGxhIHZpc3RhXCIpO1xuXG4gICAgICAgICAgLy8gR3VhcmRhciBlbCB2YWxvciBhY3R1YWwgZGUgc2NhbGUudW5pdFxuICAgICAgICAgIGNvbnN0IG9yaWdpbmFsVW5pdCA9IHNjYWxlLnVuaXQ7XG5cbiAgICAgICAgICAvLyBJbmNyZW1lbnRhciBlbCB2YWxvclxuICAgICAgICAgIHNjYWxlLnVuaXQgKz0gMTtcbiAgICAgICAgICBjb25zb2xlLmxvZyhgU2NhbGUgY2FtYmlhZGE6ICR7b3JpZ2luYWxVbml0fSAtPiAke3NjYWxlLnVuaXR9YCk7XG5cbiAgICAgICAgICAvLyBBc2VndXJhciBxdWUgZWwgY2FtYmlvIHNlYSBub3RhZG8gcG9yIGVsIHNpc3RlbWFcbiAgICAgICAgICBkaXNwYXRjaChUSU1FTElORV9TQ0FMRV9DSEFOR0VELCB7XG4gICAgICAgICAgICBwYXlsb2FkOiB7XG4gICAgICAgICAgICAgIHNjYWxlOiB7XG4gICAgICAgICAgICAgICAgLi4uc2NhbGUsICAvLyBJbmNsdWlyIHRvZGFzIGxhcyBwcm9waWVkYWRlcyBkZSBzY2FsZVxuICAgICAgICAgICAgICAgIHVuaXQ6IHNjYWxlLnVuaXQgIC8vIEV4cGzDrWNpdGFtZW50ZSBlc3RhYmxlY2VyIGVsIG51ZXZvIHZhbG9yXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgLy8gRm9yemFyIHVuYSBhY3R1YWxpemFjacOzbiBhZGljaW9uYWwgdm9sdmllbmRvIGFsIHZhbG9yIG9yaWdpbmFsIGRlc3B1w6lzIGRlIHVuIG1vbWVudG9cbiAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRTdGF0ZSA9IHN0YXRlTWFuYWdlci5nZXRTdGF0ZSgpO1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRTdGF0ZS5zY2FsZSkge1xuICAgICAgICAgICAgICBkaXNwYXRjaChUSU1FTElORV9TQ0FMRV9DSEFOR0VELCB7XG4gICAgICAgICAgICAgICAgcGF5bG9hZDoge1xuICAgICAgICAgICAgICAgICAgc2NhbGU6IHtcbiAgICAgICAgICAgICAgICAgICAgLi4uY3VycmVudFN0YXRlLnNjYWxlLFxuICAgICAgICAgICAgICAgICAgICB1bml0OiBvcmlnaW5hbFVuaXQgIC8vIFZvbHZlciBhbCB2YWxvciBvcmlnaW5hbFxuICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgUmVzdGF1cmFkbyBzY2FsZSBhIHZhbG9yIG9yaWdpbmFsOiAke29yaWdpbmFsVW5pdH1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LCAzMDApO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc29sZS5sb2coXCJFbGltaW5hY2nDs24gZGUgc2VnbWVudG9zIGNvbXBsZXRhZGFcIik7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIGFsIGVsaW1pbmFyIHNlZ21lbnRvczpcIiwgZXJyb3IpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfSxcblxuICAgIGNvbXBhY3RUaW1lbGluZTogYXN5bmMgKCkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc29sZS5sb2coXCI9PT0gSU5JQ0lBTkRPIENPTVBBQ1RBQ0nDk04gREUgTMONTkVBIERFIFRJRU1QTyBERVNERSBJQSA9PT1cIik7XG5cbiAgICAgICAgLy8gT2J0ZW5lciBlbCBlc3RhZG8gYWN0dWFsXG4gICAgICAgIGNvbnN0IGVzdGFkbyA9IHN0YXRlTWFuYWdlci5nZXRTdGF0ZSgpO1xuICAgICAgICBjb25zb2xlLmxvZyhcIkVzdGFkbyBwYXJhIGNvbXBhY3RhY2nDs246XCIsIE9iamVjdC5rZXlzKGVzdGFkbykpO1xuXG4gICAgICAgIC8vIEHDsWFkaXIgdW4gdGllbXBvIGRlIGVzcGVyYSBpbmljaWFsIHBhcmEgYXNlZ3VyYXIgcXVlIGVsIGVzdGFkbyBlc3TDoSBhY3R1YWxpemFkb1xuICAgICAgICBjb25zb2xlLmxvZyhcIkVzcGVyYW5kbyAxIHNlZ3VuZG8gcGFyYSBhc2VndXJhciBjb25zaXN0ZW5jaWEgZGVsIGVzdGFkby4uLlwiKTtcbiAgICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDEwMDApKTtcblxuICAgICAgICAvLyBWZXJpZmljYWNpw7NuIGFkaWNpb25hbCBwYXJhIGFzZWd1cmFybm9zIHF1ZSBsb3MgY2FtYmlvcyBlbiBsYSB0aW1lbGluZSB5YSBzZSBhcGxpY2Fyb25cbiAgICAgICAgY29uc29sZS5sb2coXCJWZXJpZmljYW5kbyBxdWUgbG9zIGVsZW1lbnRvcyBlbiBsYSB0aW1lbGluZSByZWZsZWplbiBsb3MgY2FtYmlvcyBtw6FzIHJlY2llbnRlcy4uLlwiKTtcblxuICAgICAgICAvLyBQZXF1ZcOxYSBwYXVzYSBhZGljaW9uYWwgcGFyYSBhc2VndXJhciBjb25zaXN0ZW5jaWEgZGVsIGVzdGFkb1xuICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgNTAwKSk7XG5cbiAgICAgICAgLy8gQnVzY2FyIGxvcyBlbGVtZW50b3MgZGVsIHRpbWVsaW5lIC0gdXNhbmRvIGxhIHJlZmVyZW5jaWEgYWwgbcOpdG9kbyBkZW50cm8gZGVsIG1pc21vIG9iamV0b1xuICAgICAgICBjb25zdCB0b2Rvc0VsZW1lbnRvcyA9IGF3YWl0IGV4ZWN1dG9yLmdldEFsbFRpbWVsaW5lRWxlbWVudHMoKTtcbiAgICAgICAgY29uc29sZS5sb2coYEVuY29udHJhZG9zICR7dG9kb3NFbGVtZW50b3MubGVuZ3RofSBlbGVtZW50b3MgZW4gbGEgdGltZWxpbmVgKTtcblxuICAgICAgICAvLyBMb2dnaW5nIGRlIGVsZW1lbnRvcyBwYXJhIGRpYWduw7NzdGljb1xuICAgICAgICB0b2Rvc0VsZW1lbnRvcy5mb3JFYWNoKChlbGVtLCBpbmRleCkgPT4ge1xuICAgICAgICAgIGNvbnNvbGUubG9nKGBFbGVtZW50byAke2luZGV4ICsgMX06IElEPSR7ZWxlbS5pZH0sIFRpcG89JHtlbGVtLnR5cGV9LCBUcmFjaz0ke2VsZW0udHJhY2tJZH0sIFRpZW1wbz0ke2VsZW0uZnJvbX1tcy0ke2VsZW0udG99bXMgKGR1cmFjacOzbj0ke2VsZW0udG8tZWxlbS5mcm9tfW1zKWApO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBTaSBubyBoYXkgZWxlbWVudG9zLCBubyBwb2RlbW9zIGNvbXBhY3RhclxuICAgICAgICBpZiAodG9kb3NFbGVtZW50b3MubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgY29uc29sZS5sb2coXCJObyBoYXkgZWxlbWVudG9zIGVuIGVsIHRpbWVsaW5lIHBhcmEgY29tcGFjdGFyXCIpO1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEFncnVwYXIgZWxlbWVudG9zIHBvciB0cmFjayBwYXJhIGFuw6FsaXNpc1xuICAgICAgICBjb25zdCBlbGVtZW50b3NQb3JUcmFjayA9IHt9O1xuICAgICAgICB0b2Rvc0VsZW1lbnRvcy5mb3JFYWNoKGVsZW0gPT4ge1xuICAgICAgICAgIGlmIChlbGVtLnRyYWNrSWQpIHtcbiAgICAgICAgICAgIGlmICghZWxlbWVudG9zUG9yVHJhY2tbZWxlbS50cmFja0lkXSkge1xuICAgICAgICAgICAgICBlbGVtZW50b3NQb3JUcmFja1tlbGVtLnRyYWNrSWRdID0gW107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbGVtZW50b3NQb3JUcmFja1tlbGVtLnRyYWNrSWRdLnB1c2goZWxlbSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICAvLyBPcmRlbmFyIGVsZW1lbnRvcyBlbiBjYWRhIHRyYWNrIHBvciB0aWVtcG9cbiAgICAgICAgT2JqZWN0LmtleXMoZWxlbWVudG9zUG9yVHJhY2spLmZvckVhY2godHJhY2tJZCA9PiB7XG4gICAgICAgICAgZWxlbWVudG9zUG9yVHJhY2tbdHJhY2tJZF0uc29ydCgoYSwgYikgPT4gYS5mcm9tIC0gYi5mcm9tKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgY29uc29sZS5sb2coXCJFbGVtZW50b3MgYWdydXBhZG9zIHBvciB0cmFjazpcIiwgT2JqZWN0LmtleXMoZWxlbWVudG9zUG9yVHJhY2spLmxlbmd0aCk7XG5cbiAgICAgICAgLy8gTG9nZ2luZyBkZSB0cmFja3MgcGFyYSBkaWFnbsOzc3RpY29cbiAgICAgICAgT2JqZWN0LmtleXMoZWxlbWVudG9zUG9yVHJhY2spLmZvckVhY2godHJhY2tJZCA9PiB7XG4gICAgICAgICAgY29uc29sZS5sb2coYFRyYWNrICR7dHJhY2tJZH06ICR7ZWxlbWVudG9zUG9yVHJhY2tbdHJhY2tJZF0ubGVuZ3RofSBlbGVtZW50b3NgKTtcbiAgICAgICAgICAvLyBNb3N0cmFyIGxvcyBlbGVtZW50b3MgZW4gZXN0ZSB0cmFjayBvcmRlbmFkb3NcbiAgICAgICAgICBlbGVtZW50b3NQb3JUcmFja1t0cmFja0lkXS5mb3JFYWNoKChlbGVtLCBpZHgpID0+IHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGAgICR7aWR4KzF9LiBJRD0ke2VsZW0uaWQuc3Vic3RyaW5nKDAsOCl9Li4uIFRpZW1wbz0ke2VsZW0uZnJvbX1tcy0ke2VsZW0udG99bXMgKGR1cmFjacOzbjogJHtlbGVtLnRvLWVsZW0uZnJvbX1tcylgKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gQnVzY2FyIGVzcGFjaW9zIHZhY8Otb3MgZW4gY2FkYSB0cmFja1xuICAgICAgICBjb25zdCBlc3BhY2lvc1ZhY2lvcyA9IFtdO1xuXG4gICAgICAgIE9iamVjdC5rZXlzKGVsZW1lbnRvc1BvclRyYWNrKS5mb3JFYWNoKHRyYWNrSWQgPT4ge1xuICAgICAgICAgIGNvbnN0IGVsZW1lbnRvcyA9IGVsZW1lbnRvc1BvclRyYWNrW3RyYWNrSWRdO1xuXG4gICAgICAgICAgLy8gU2kgaGF5IGFsIG1lbm9zIDIgZWxlbWVudG9zLCBwb2RlbW9zIGJ1c2NhciBlc3BhY2lvc1xuICAgICAgICAgIGlmIChlbGVtZW50b3MubGVuZ3RoID49IDIpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZWxlbWVudG9zLmxlbmd0aCAtIDE7IGkrKykge1xuICAgICAgICAgICAgICBjb25zdCBlbGVtZW50b0FjdHVhbCA9IGVsZW1lbnRvc1tpXTtcbiAgICAgICAgICAgICAgY29uc3QgZWxlbWVudG9TaWd1aWVudGUgPSBlbGVtZW50b3NbaSArIDFdO1xuXG4gICAgICAgICAgICAgIC8vIFZlcmlmaWNhciBzaSBoYXkgdW4gZXNwYWNpbyBlbnRyZSBlbCBmaW4gZGVsIGVsZW1lbnRvIGFjdHVhbCB5IGVsIGluaWNpbyBkZWwgc2lndWllbnRlXG4gICAgICAgICAgICAgIGNvbnN0IGVzcGFjaW8gPSBlbGVtZW50b1NpZ3VpZW50ZS5mcm9tIC0gZWxlbWVudG9BY3R1YWwudG87XG5cbiAgICAgICAgICAgICAgLy8gU2kgZWwgZXNwYWNpbyBlcyBzaWduaWZpY2F0aXZvIChtw6FzIGRlIDEwMG1zKVxuICAgICAgICAgICAgICBpZiAoZXNwYWNpbyA+IDEwMCkge1xuICAgICAgICAgICAgICAgIGVzcGFjaW9zVmFjaW9zLnB1c2goe1xuICAgICAgICAgICAgICAgICAgdHJhY2tJZCxcbiAgICAgICAgICAgICAgICAgIHN0YXJ0OiBlbGVtZW50b0FjdHVhbC50byxcbiAgICAgICAgICAgICAgICAgIGVuZDogZWxlbWVudG9TaWd1aWVudGUuZnJvbSxcbiAgICAgICAgICAgICAgICAgIHNpemU6IGVzcGFjaW8sXG4gICAgICAgICAgICAgICAgICBlbGVtZW50b0FudGVzOiBlbGVtZW50b0FjdHVhbC5pZCxcbiAgICAgICAgICAgICAgICAgIGVsZW1lbnRvRGVzcHVlczogZWxlbWVudG9TaWd1aWVudGUuaWRcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgRW5jb250cmFkbyBlc3BhY2lvIGRlICR7ZXNwYWNpb31tcyAoJHtlc3BhY2lvLzEwMDB9cykgZW4gdHJhY2sgJHt0cmFja0lkfSBlbnRyZSBlbGVtZW50b3MgJHtlbGVtZW50b0FjdHVhbC5pZC5zdWJzdHJpbmcoMCw4KX0uLi4geSAke2VsZW1lbnRvU2lndWllbnRlLmlkLnN1YnN0cmluZygwLDgpfS4uLmApO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBjb25zb2xlLmxvZyhgU2UgZW5jb250cmFyb24gJHtlc3BhY2lvc1ZhY2lvcy5sZW5ndGh9IGVzcGFjaW9zIHZhY8Otb3NgKTtcblxuICAgICAgICAvLyBTaSBubyBoYXkgZXNwYWNpb3MsIG5vIG5lY2VzaXRhbW9zIGNvbXBhY3RhclxuICAgICAgICBpZiAoZXNwYWNpb3NWYWNpb3MubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgY29uc29sZS5sb2coXCJObyBoYXkgZXNwYWNpb3Mgc2lnbmlmaWNhdGl2b3MgcGFyYSBjb21wYWN0YXJcIik7XG4gICAgICAgICAgcmV0dXJuIHRydWU7IC8vIERldm9sdmVtb3MgdHJ1ZSBwb3JxdWUgdMOpY25pY2FtZW50ZSBlc3TDoSBjb21wYWN0YWRvXG4gICAgICAgIH1cblxuICAgICAgICAvLyBPcmRlbmFyIGVzcGFjaW9zIHBvciBwb3NpY2nDs24gKGRlIGl6cXVpZXJkYSBhIGRlcmVjaGEpXG4gICAgICAgIGVzcGFjaW9zVmFjaW9zLnNvcnQoKGEsIGIpID0+IGEuc3RhcnQgLSBiLnN0YXJ0KTtcblxuICAgICAgICAvLyBDYWxjdWxhciBlbCBlc3BhY2lvIHRvdGFsIGEgY29tcGFjdGFyXG4gICAgICAgIGxldCBlc3BhY2lvVG90YWwgPSAwO1xuICAgICAgICBlc3BhY2lvc1ZhY2lvcy5mb3JFYWNoKGVzcGFjaW8gPT4ge1xuICAgICAgICAgIGVzcGFjaW9Ub3RhbCArPSBlc3BhY2lvLnNpemU7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNvbnNvbGUubG9nKGBFc3BhY2lvIHRvdGFsIGEgY29tcGFjdGFyOiAke2VzcGFjaW9Ub3RhbH1tcyAoJHtlc3BhY2lvVG90YWwvMTAwMH1zKWApO1xuICAgICAgICBjb25zb2xlLmxvZyhgUHJlcGFyYW5kbyBhY3R1YWxpemFjaW9uZXMgcGFyYSAke3RvZG9zRWxlbWVudG9zLmxlbmd0aH0gZWxlbWVudG9zLi4uYCk7XG5cbiAgICAgICAgLy8gUHJlcGFyYXIgYWN0dWFsaXphY2lvbmVzIHBhcmEgY2FkYSBlbGVtZW50b1xuICAgICAgICBjb25zdCBhY3R1YWxpemFjaW9uZXMgPSB7fTtcbiAgICAgICAgbGV0IGVsZW1lbnRvc0FNb3ZlciA9IDA7XG5cbiAgICAgICAgLy8gUGFyYSBjYWRhIGVsZW1lbnRvLCBjYWxjdWxhbW9zIGVsIGRlc3BsYXphbWllbnRvIGJhc2FkbyBlbiBsb3MgZXNwYWNpb3MgYW50ZXJpb3Jlc1xuICAgICAgICB0b2Rvc0VsZW1lbnRvcy5mb3JFYWNoKGVsZW1lbnRvID0+IHtcbiAgICAgICAgICBsZXQgZGVzcGxhemFtaWVudG8gPSAwO1xuXG4gICAgICAgICAgLy8gQ2FsY3VsYXIgY3XDoW50byBkZWJlIG1vdmVyc2UgYmFzYWRvIGVuIGxvcyBlc3BhY2lvcyB2YWPDrW9zIGFudGVyaW9yZXNcbiAgICAgICAgICBmb3IgKGNvbnN0IGVzcGFjaW8gb2YgZXNwYWNpb3NWYWNpb3MpIHtcbiAgICAgICAgICAgIC8vIFNpIGVsIGVsZW1lbnRvIGVzdMOhIGRlc3B1w6lzIGRlbCBlc3BhY2lvIHZhY8OtbywgZGViZSBtb3ZlcnNlXG4gICAgICAgICAgICBpZiAoZWxlbWVudG8uZnJvbSA+IGVzcGFjaW8uZW5kKSB7XG4gICAgICAgICAgICAgIGRlc3BsYXphbWllbnRvICs9IGVzcGFjaW8uc2l6ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBTaSBoYXkgZGVzcGxhemFtaWVudG8sIGHDsWFkaXIgYSBsYXMgYWN0dWFsaXphY2lvbmVzXG4gICAgICAgICAgaWYgKGRlc3BsYXphbWllbnRvID4gMCkge1xuICAgICAgICAgICAgY29uc3QgbnVldm9Gcm9tID0gZWxlbWVudG8uZnJvbSAtIGRlc3BsYXphbWllbnRvO1xuICAgICAgICAgICAgY29uc3QgbnVldm9UbyA9IGVsZW1lbnRvLnRvIC0gZGVzcGxhemFtaWVudG87XG5cbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGBFbGVtZW50byAke2VsZW1lbnRvLmlkLnN1YnN0cmluZygwLDgpfS4uLiBzZSBtb3ZlcsOhOiAke2VsZW1lbnRvLmZyb219bXMgLT4gJHtudWV2b0Zyb219bXMgKGRlc3BsYXphbWllbnRvOiAke2Rlc3BsYXphbWllbnRvfW1zKWApO1xuXG4gICAgICAgICAgICBhY3R1YWxpemFjaW9uZXNbZWxlbWVudG8uaWRdID0ge1xuICAgICAgICAgICAgICBkaXNwbGF5OiB7XG4gICAgICAgICAgICAgICAgZnJvbTogbnVldm9Gcm9tLFxuICAgICAgICAgICAgICAgIHRvOiBudWV2b1RvXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBlbGVtZW50b3NBTW92ZXIrKztcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNvbnNvbGUubG9nKGBFbGVtZW50b3MgYSBtb3ZlcjogJHtlbGVtZW50b3NBTW92ZXJ9IGRlICR7dG9kb3NFbGVtZW50b3MubGVuZ3RofSB0b3RhbGApO1xuXG4gICAgICAgIC8vIEFwbGljYXIgbGFzIGFjdHVhbGl6YWNpb25lc1xuICAgICAgICBpZiAoZWxlbWVudG9zQU1vdmVyID4gMCkge1xuICAgICAgICAgIGNvbnNvbGUubG9nKFwiQXBsaWNhbmRvIGFjdHVhbGl6YWNpb25lcyBwYXJhIGNvbXBhY3RhciB0aW1lbGluZS4uLlwiKTtcblxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBkaXNwYXRjaChFRElUX09CSkVDVCwge1xuICAgICAgICAgICAgICBwYXlsb2FkOiBhY3R1YWxpemFjaW9uZXNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc29sZS5sb2coXCJBY3R1YWxpemFjaW9uZXMgYXBsaWNhZGFzIGNvbiDDqXhpdG9cIik7XG4gICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBhbCBhcGxpY2FyIGFjdHVhbGl6YWNpb25lczpcIiwgZXJyb3IpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIFJlZnJlc2NhciBsYSB2aXN0YVxuICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgY29uc3QgeyBzY2FsZSB9ID0gc3RhdGVNYW5hZ2VyLmdldFN0YXRlKCk7XG4gICAgICAgICAgICAgIGlmIChzY2FsZSkge1xuICAgICAgICAgICAgICAgIC8vIEhhY2VyIHVuIHBlcXVlw7FvIGNhbWJpbyBlbiBsYSBlc2NhbGEgcGFyYSBmb3J6YXIgbGEgYWN0dWFsaXphY2nDs25cbiAgICAgICAgICAgICAgICBjb25zdCB1cGRhdGVkU2NhbGUgPSB7IC4uLnNjYWxlIH07XG5cbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHVwZGF0ZWRTY2FsZS51bml0ID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgICAgdXBkYXRlZFNjYWxlLnVuaXQgPSAodXBkYXRlZFNjYWxlLnVuaXQgfHwgMCkgKyAxO1xuXG4gICAgICAgICAgICAgICAgICBkaXNwYXRjaChUSU1FTElORV9TQ0FMRV9DSEFOR0VELCB7XG4gICAgICAgICAgICAgICAgICAgIHBheWxvYWQ6IHsgc2NhbGU6IHVwZGF0ZWRTY2FsZSB9XG4gICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgLy8gVm9sdmVyIGEgbGEgZXNjYWxhIG9yaWdpbmFsXG4gICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY3VycmVudFNjYWxlID0geyAuLi5zdGF0ZU1hbmFnZXIuZ2V0U3RhdGUoKS5zY2FsZSB9O1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50U2NhbGUudW5pdCA9IChjdXJyZW50U2NhbGUudW5pdCB8fCAxKSAtIDE7XG4gICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoKFRJTUVMSU5FX1NDQUxFX0NIQU5HRUQsIHtcbiAgICAgICAgICAgICAgICAgICAgICBwYXlsb2FkOiB7IHNjYWxlOiBjdXJyZW50U2NhbGUgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgIH0sIDMwMCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgYWwgcmVmcmVzY2FyIGxhIHZpc3RhOlwiLCBlcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSwgNTAwKTtcblxuICAgICAgICAgIGNvbnNvbGUubG9nKFwiQ29tcGFjdGFjacOzbiBjb21wbGV0YWRhIGNvbiDDqXhpdG9cIik7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc29sZS5sb2coXCJObyBoYXkgZWxlbWVudG9zIHF1ZSBuZWNlc2l0ZW4gbW92ZXJzZVwiKTtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIGFsIGNvbXBhY3RhciBsYSBsw61uZWEgZGUgdGllbXBvOlwiLCBlcnJvcik7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgc21hcnRUcmltOiBhc3luYyAoKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zb2xlLmxvZyhcIj09PSBJTklDSUFORE8gUFJPQ0VTTyBERSBSRUNPUlRFIElOVEVMSUdFTlRFIERFU0RFIElBID09PVwiKTtcblxuICAgICAgICAvLyAxLiBSZWFsaXphciBsYSBsbGFtYWRhIGFsIEFQSSBwYXJhIGFuYWxpemFyIGxhIHRyYW5zY3JpcGNpw7NuXG4gICAgICAgIGNvbnNvbGUubG9nKFwiU29saWNpdGFuZG8gYW7DoWxpc2lzIGRlIHRyYW5zY3JpcGNpw7NuLi4uXCIpO1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKCcvYXBpL3NtYXJ0LXRyaW0nKTtcblxuICAgICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBFcnJvciBhbCBhbmFsaXphciBsYSB0cmFuc2NyaXBjacOzbjogJHtyZXNwb25zZS5zdGF0dXN9YCk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgICBjb25zb2xlLmxvZyhcIkFuw6FsaXNpcyBkZSB0cmFuc2NyaXBjacOzbiBjb21wbGV0YWRvOlwiLCBkYXRhKTtcblxuICAgICAgICBpZiAoIWRhdGEucmVtb3ZlU2VnbWVudHMgfHwgIUFycmF5LmlzQXJyYXkoZGF0YS5yZW1vdmVTZWdtZW50cykgfHwgZGF0YS5yZW1vdmVTZWdtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICBjb25zb2xlLmxvZyhcIk5vIHNlIGVuY29udHJhcm9uIHNlZ21lbnRvcyBwYXJhIGVsaW1pbmFyXCIpO1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIDIuIENvbnZlcnRpciBsb3Mgc2VnbWVudG9zIGFsIGZvcm1hdG8gcXVlIGVzcGVyYSByZW1vdmVTZWdtZW50c1xuICAgICAgICBjb25zdCBzZWdtZW50cyA9IGRhdGEucmVtb3ZlU2VnbWVudHMubWFwKHNlZ21lbnQgPT4gKHtcbiAgICAgICAgICBzdGFydFRpbWU6IHNlZ21lbnQuc3RhcnRUaW1lLCAvLyBZYSBlc3TDoSBlbiBzZWd1bmRvc1xuICAgICAgICAgIGVuZFRpbWU6IHNlZ21lbnQuZW5kVGltZSAgICAgIC8vIFlhIGVzdMOhIGVuIHNlZ3VuZG9zXG4gICAgICAgIH0pKTtcblxuICAgICAgICBjb25zb2xlLmxvZyhgU2UgZWxpbWluYXLDoW4gJHtzZWdtZW50cy5sZW5ndGh9IHNlZ21lbnRvczpgLFxuICAgICAgICAgIHNlZ21lbnRzLm1hcChzID0+IGAke3Muc3RhcnRUaW1lfXMtJHtzLmVuZFRpbWV9c2ApLmpvaW4oJywgJykpO1xuXG4gICAgICAgIC8vIEFsbWFjZW5hciBpbmZvcm1hY2nDs24gZGVsIGVzdGFkbyBwcmV2aW8gcGFyYSBpZGVudGlmaWNhciB0cmFja3MgeSBlbGVtZW50b3NcbiAgICAgICAgY29uc29sZS5sb2coXCJPYnRlbmllbmRvIGluZm9ybWFjacOzbiBkZWwgZXN0YWRvIGFudGVzIGRlIGVsaW1pbmFyIHNlZ21lbnRvcy4uLlwiKTtcbiAgICAgICAgY29uc3QgZXN0YWRvUHJldmlvID0gc3RhdGVNYW5hZ2VyLmdldFN0YXRlKCk7XG4gICAgICAgIGNvbnN0IGVsZW1lbnRvc1ByZXZpb3MgPSBhd2FpdCBleGVjdXRvci5nZXRBbGxUaW1lbGluZUVsZW1lbnRzKCk7XG5cbiAgICAgICAgLy8gRGV0ZXJtaW5hciBlbCB0cmFja0lkIHByaW5jaXBhbCBiYXNhZG8gZW4gbG9zIGVsZW1lbnRvc1xuICAgICAgICBjb25zdCBjb250YWRvclRyYWNrcyA9IHt9O1xuICAgICAgICBlbGVtZW50b3NQcmV2aW9zLmZvckVhY2goZWxlbSA9PiB7XG4gICAgICAgICAgaWYgKGVsZW0udHJhY2tJZCkge1xuICAgICAgICAgICAgY29udGFkb3JUcmFja3NbZWxlbS50cmFja0lkXSA9IChjb250YWRvclRyYWNrc1tlbGVtLnRyYWNrSWRdIHx8IDApICsgMTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIEVuY29udHJhciBlbCB0cmFjayBjb24gbcOhcyBlbGVtZW50b3NcbiAgICAgICAgbGV0IHRyYWNrSWRQcmluY2lwYWwgPSBcIlwiO1xuICAgICAgICBpZiAoT2JqZWN0LmtleXMoY29udGFkb3JUcmFja3MpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBjb25zdCB0cmFja3NQb3JVc28gPSBPYmplY3QuZW50cmllcyhjb250YWRvclRyYWNrcylcbiAgICAgICAgICAgIC5zb3J0KChhLCBiKSA9PiBiWzFdIC0gYVsxXSk7XG5cbiAgICAgICAgICBpZiAodHJhY2tzUG9yVXNvLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHRyYWNrSWRQcmluY2lwYWwgPSB0cmFja3NQb3JVc29bMF1bMF07XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhgVXNhbmRvIHRyYWNrSWQgcHJpbmNpcGFsOiAke3RyYWNrSWRQcmluY2lwYWx9YCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gMy4gRWxpbWluYXIgbG9zIHNlZ21lbnRvc1xuICAgICAgICBjb25zb2xlLmxvZyhcIkVqZWN1dGFuZG8gZWxpbWluYWNpw7NuIGRlIHNlZ21lbnRvcy4uLlwiKTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgZXhlY3V0b3IucmVtb3ZlU2VnbWVudHMoc2VnbWVudHMpO1xuXG4gICAgICAgIGlmICghcmVzdWx0KSB7XG4gICAgICAgICAgY29uc29sZS5sb2coXCJFcnJvciBhbCBlbGltaW5hciBsb3Mgc2VnbWVudG9zXCIpO1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnNvbGUubG9nKFwiU2VnbWVudG9zIGVsaW1pbmFkb3MgY29ycmVjdGFtZW50ZVwiKTtcblxuICAgICAgICAvLyA0LiBDcmVhciByZWdpc3RybyBkZSBsb3Mgc2VnbWVudG9zIGVsaW1pbmFkb3MgcGFyYSBjb21wYWN0YWNpw7NuXG4gICAgICAgIGNvbnN0IHNlZ21lbnRvc0VsaW1pbmFkb3MgPSBzZWdtZW50cy5tYXAoc2VnbWVudCA9PiAoe1xuICAgICAgICAgIHN0YXJ0OiBzZWdtZW50LnN0YXJ0VGltZSAqIDEwMDAsICAvLyBDb252ZXJ0aXIgYSBtc1xuICAgICAgICAgIGVuZDogc2VnbWVudC5lbmRUaW1lICogMTAwMCwgICAgICAvLyBDb252ZXJ0aXIgYSBtc1xuICAgICAgICAgIHRyYWNrSWQ6IHRyYWNrSWRQcmluY2lwYWwsXG4gICAgICAgICAgc2l6ZTogKHNlZ21lbnQuZW5kVGltZSAtIHNlZ21lbnQuc3RhcnRUaW1lKSAqIDEwMDBcbiAgICAgICAgfSkpO1xuXG4gICAgICAgIGNvbnNvbGUubG9nKFwiU2VnbWVudG9zIHJlZ2lzdHJhZG9zIHBhcmEgY29tcGFjdGFjacOzbjpcIiwgc2VnbWVudG9zRWxpbWluYWRvcyk7XG5cbiAgICAgICAgLy8gNS4gRXNwZXJhciB1biBtb21lbnRvIHBhcmEgcXVlIHNlIGNvbXBsZXRlbiBsYXMgYWN0dWFsaXphY2lvbmVzIGRlbCBET00geSBlbCBlc3RhZG9cbiAgICAgICAgY29uc29sZS5sb2coXCJFc3BlcmFuZG8gNSBzZWd1bmRvcyBwYXJhIGFzZWd1cmFyIHF1ZSBsb3MgY2FtYmlvcyBlbiBsYSB0aW1lbGluZSBlc3TDqW4gY29tcGxldG9zIGFudGVzIGRlIGNvbXBhY3Rhci4uLlwiKTtcbiAgICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDUwMDApKTtcblxuICAgICAgICAvLyA2LiBDb21wYWN0YXIgZWwgdGltZWxpbmUgdXNhbmRvIGVsIGVuZm9xdWUgZGUgc2VnbWVudG9zIHJlZ2lzdHJhZG9zXG4gICAgICAgIGNvbnNvbGUubG9nKFwiQ29tcGFjdGFuZG8gdGltZWxpbmUgYmFzYWRvIGVuIHNlZ21lbnRvcyBlbGltaW5hZG9zLi4uXCIpO1xuXG4gICAgICAgIC8vIE9idGVuZXIgZWxlbWVudG9zIGFjdHVhbGVzIGRlc3B1w6lzIGRlIGxhIGVsaW1pbmFjacOzblxuICAgICAgICBjb25zdCBlbGVtZW50b3NBY3R1YWxlcyA9IGF3YWl0IGV4ZWN1dG9yLmdldEFsbFRpbWVsaW5lRWxlbWVudHMoKTtcbiAgICAgICAgY29uc29sZS5sb2coYFNlIGVuY29udHJhcm9uICR7ZWxlbWVudG9zQWN0dWFsZXMubGVuZ3RofSBlbGVtZW50b3MgZW4gbGEgdGltZWxpbmUgZGVzcHXDqXMgZGUgZWxpbWluYXIgc2VnbWVudG9zYCk7XG5cbiAgICAgICAgLy8gQ2FsY3VsYXIgZWwgZXNwYWNpbyB0b3RhbCBhIGNvbXBhY3RhclxuICAgICAgICBsZXQgZXNwYWNpb1RvdGFsID0gMDtcbiAgICAgICAgc2VnbWVudG9zRWxpbWluYWRvcy5mb3JFYWNoKHNlZ21lbnRvID0+IHtcbiAgICAgICAgICBlc3BhY2lvVG90YWwgKz0gc2VnbWVudG8uc2l6ZTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgY29uc29sZS5sb2coYEVzcGFjaW8gdG90YWwgYSBjb21wYWN0YXI6ICR7ZXNwYWNpb1RvdGFsfW1zICgke2VzcGFjaW9Ub3RhbC8xMDAwfXMpYCk7XG5cbiAgICAgICAgLy8gUHJlcGFyYXIgYWN0dWFsaXphY2lvbmVzIHBhcmEgY2FkYSBlbGVtZW50b1xuICAgICAgICBjb25zdCBhY3R1YWxpemFjaW9uZXMgPSB7fTtcbiAgICAgICAgbGV0IGVsZW1lbnRvc0FNb3ZlciA9IDA7XG5cbiAgICAgICAgLy8gT3JkZW5hciBzZWdtZW50b3MgcG9yIHBvc2ljacOzbiBkZSBpbmljaW9cbiAgICAgICAgY29uc3Qgc2VnbWVudG9zT3JkZW5hZG9zID0gWy4uLnNlZ21lbnRvc0VsaW1pbmFkb3NdLnNvcnQoKGEsIGIpID0+IGEuc3RhcnQgLSBiLnN0YXJ0KTtcblxuICAgICAgICAvLyBQYXJhIGNhZGEgZWxlbWVudG8sIGNhbGN1bGFyIGVsIGRlc3BsYXphbWllbnRvIGJhc2FkbyBlbiBsb3Mgc2VnbWVudG9zIGVsaW1pbmFkb3NcbiAgICAgICAgZWxlbWVudG9zQWN0dWFsZXMuZm9yRWFjaChlbGVtZW50byA9PiB7XG4gICAgICAgICAgbGV0IGRlc3BsYXphbWllbnRvID0gMDtcblxuICAgICAgICAgIC8vIENhbGN1bGFyIGN1w6FudG8gZGViZSBtb3ZlcnNlIGJhc2FkbyBlbiBsb3Mgc2VnbWVudG9zIGVsaW1pbmFkb3MgYW50ZXJpb3Jlc1xuICAgICAgICAgIGZvciAoY29uc3Qgc2VnbWVudG8gb2Ygc2VnbWVudG9zT3JkZW5hZG9zKSB7XG4gICAgICAgICAgICBpZiAoZWxlbWVudG8uZnJvbSA+IHNlZ21lbnRvLnN0YXJ0KSB7XG4gICAgICAgICAgICAgIGRlc3BsYXphbWllbnRvICs9IHNlZ21lbnRvLnNpemU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gU2kgaGF5IGRlc3BsYXphbWllbnRvLCBhw7FhZGlyIGEgbGFzIGFjdHVhbGl6YWNpb25lc1xuICAgICAgICAgIGlmIChkZXNwbGF6YW1pZW50byA+IDApIHtcbiAgICAgICAgICAgIGNvbnN0IG51ZXZvRnJvbSA9IGVsZW1lbnRvLmZyb20gLSBkZXNwbGF6YW1pZW50bztcbiAgICAgICAgICAgIGNvbnN0IG51ZXZvVG8gPSBlbGVtZW50by50byAtIGRlc3BsYXphbWllbnRvO1xuXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhgRWxlbWVudG8gJHtlbGVtZW50by5pZC5zdWJzdHJpbmcoMCw4KX0uLi4gc2UgbW92ZXLDoTogJHtlbGVtZW50by5mcm9tfW1zIC0+ICR7bnVldm9Gcm9tfW1zIChkZXNwbGF6YW1pZW50bzogJHtkZXNwbGF6YW1pZW50b31tcylgKTtcblxuICAgICAgICAgICAgYWN0dWFsaXphY2lvbmVzW2VsZW1lbnRvLmlkXSA9IHtcbiAgICAgICAgICAgICAgZGlzcGxheToge1xuICAgICAgICAgICAgICAgIGZyb206IG51ZXZvRnJvbSxcbiAgICAgICAgICAgICAgICB0bzogbnVldm9Ub1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZWxlbWVudG9zQU1vdmVyKys7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBjb25zb2xlLmxvZyhgRWxlbWVudG9zIGEgbW92ZXI6ICR7ZWxlbWVudG9zQU1vdmVyfSBkZSAke2VsZW1lbnRvc0FjdHVhbGVzLmxlbmd0aH0gdG90YWxgKTtcblxuICAgICAgICAvLyBBcGxpY2FyIGxhcyBhY3R1YWxpemFjaW9uZXNcbiAgICAgICAgaWYgKGVsZW1lbnRvc0FNb3ZlciA+IDApIHtcbiAgICAgICAgICBjb25zb2xlLmxvZyhcIkFwbGljYW5kbyBhY3R1YWxpemFjaW9uZXMgcGFyYSBjb21wYWN0YXIgdGltZWxpbmUuLi5cIik7XG5cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgZGlzcGF0Y2goRURJVF9PQkpFQ1QsIHtcbiAgICAgICAgICAgICAgcGF5bG9hZDogYWN0dWFsaXphY2lvbmVzXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiQWN0dWFsaXphY2lvbmVzIGFwbGljYWRhcyBjb24gw6l4aXRvXCIpO1xuXG4gICAgICAgICAgICAvLyBSZWZyZXNjYXIgbGEgdmlzdGFcbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgc2NhbGUgfSA9IHN0YXRlTWFuYWdlci5nZXRTdGF0ZSgpO1xuICAgICAgICAgICAgICAgIGlmIChzY2FsZSkge1xuICAgICAgICAgICAgICAgICAgY29uc3QgdXBkYXRlZFNjYWxlID0geyAuLi5zY2FsZSB9O1xuICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB1cGRhdGVkU2NhbGUudW5pdCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlZFNjYWxlLnVuaXQgPSAodXBkYXRlZFNjYWxlLnVuaXQgfHwgMCkgKyAxO1xuXG4gICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoKFRJTUVMSU5FX1NDQUxFX0NIQU5HRUQsIHtcbiAgICAgICAgICAgICAgICAgICAgICBwYXlsb2FkOiB7IHNjYWxlOiB1cGRhdGVkU2NhbGUgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBWb2x2ZXIgYSBsYSBlc2NhbGEgb3JpZ2luYWxcbiAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgY29uc3QgY3VycmVudFNjYWxlID0geyAuLi5zdGF0ZU1hbmFnZXIuZ2V0U3RhdGUoKS5zY2FsZSB9O1xuICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRTY2FsZS51bml0ID0gKGN1cnJlbnRTY2FsZS51bml0IHx8IDEpIC0gMTtcbiAgICAgICAgICAgICAgICAgICAgICBkaXNwYXRjaChUSU1FTElORV9TQ0FMRV9DSEFOR0VELCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXlsb2FkOiB7IHNjYWxlOiBjdXJyZW50U2NhbGUgfVxuICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9LCAzMDApO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgYWwgcmVmcmVzY2FyIGxhIHZpc3RhOlwiLCBlcnJvcik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIDUwMCk7XG5cbiAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIGFsIGFwbGljYXIgYWN0dWFsaXphY2lvbmVzOlwiLCBlcnJvcik7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnNvbGUubG9nKFwiTm8gc2UgZW5jb250cmFyb24gZWxlbWVudG9zIHF1ZSBuZWNlc2l0ZW4gbW92ZXJzZVwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnNvbGUubG9nKFwiVGltZWxpbmUgY29tcGFjdGFkbyBjb3JyZWN0YW1lbnRlXCIpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBhbCByZWFsaXphciBlbCByZWNvcnRlIGludGVsaWdlbnRlOlwiLCBlcnJvcik7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIGV4ZWN1dG9yO1xufVxuIl0sIm5hbWVzIjpbImRpc3BhdGNoIiwiQUREX1RFWFQiLCJBRERfVklERU8iLCJBRERfSU1BR0UiLCJBQ1RJVkVfU1BMSVQiLCJMQVlFUl9TRUxFQ1QiLCJMQVlFUl9ERUxFVEUiLCJUSU1FTElORV9TQ0FMRV9DSEFOR0VEIiwiRURJVF9PQkpFQ1QiLCJnZW5lcmF0ZUlkIiwiY3JlYXRlVmlkZW9Db21tYW5kRXhlY3V0b3IiLCJzdGF0ZU1hbmFnZXIiLCJleGVjdXRvciIsImFkZFRleHQiLCJ0ZXh0Iiwib3B0aW9ucyIsInBvc2l0aW9uIiwieCIsInkiLCJmb250U2l6ZSIsImZvbnRGYW1pbHkiLCJjb2xvciIsInN0YXJ0VGltZSIsImVuZFRpbWUiLCJ0ZXh0UGF5bG9hZCIsImlkIiwiZGlzcGxheSIsImZyb20iLCJ0byIsInR5cGUiLCJkZXRhaWxzIiwid2lkdGgiLCJ3b3JkV3JhcCIsInRleHRBbGlnbiIsImJvcmRlcldpZHRoIiwiYm9yZGVyQ29sb3IiLCJib3hTaGFkb3ciLCJibHVyIiwicGF5bG9hZCIsImNoYW5nZUNvbG9yIiwiZWxlbWVudElkIiwiY29uc29sZSIsImxvZyIsImFkZEltYWdlIiwidXJsIiwiZXJyb3IiLCJpbmNsdWRlcyIsIkVycm9yIiwiaGVpZ2h0IiwidW5kZWZpbmVkIiwibG9nVXJsIiwic3RhcnRzV2l0aCIsInN1YnN0cmluZyIsInByZWxvYWRJbWFnZSIsImltYWdlVXJsIiwiUHJvbWlzZSIsInJlc29sdmUiLCJpbWciLCJJbWFnZSIsIm9ubG9hZCIsIm9uZXJyb3IiLCJ3YXJuIiwic3JjIiwiY3JlYXRlQW5kRGlzcGF0Y2hQYXlsb2FkIiwiZmluYWxXaWR0aCIsImZpbmFsSGVpZ2h0IiwiZGltZW5zaW9ucyIsImFzcGVjdFJhdGlvIiwiTWF0aCIsIm1pbiIsImltYWdlUGF5bG9hZCIsIm9wYWNpdHkiLCJzY2FsZU1vZGUiLCJsZWZ0IiwidG9wIiwib3JpZ2luWCIsIm9yaWdpblkiLCJtZXNzYWdlIiwiYWRkVmlkZW8iLCJpc0FQTkciLCJ0b0xvd2VyQ2FzZSIsImVuZHNXaXRoIiwiaXNNT1YiLCJuZWVkc0Z1bGxzY3JlZW4iLCJyZXNvdXJjZUlkIiwiU3RyaW5nIiwiY2hhbmdlRHVyYXRpb24iLCJkdXJhdGlvbiIsImNoYW5nZVRyYW5zaXRpb24iLCJ0cmFuc2l0aW9uIiwiYWRkU3VidGl0bGVzIiwicGFyc2VUaW1lVG9NcyIsInRpbWVTdHJpbmciLCJob3VycyIsIm1pbnV0ZXMiLCJzZWNvbmRzQW5kTXMiLCJzcGxpdCIsInNlY29uZHMiLCJtcyIsInBhcnNlSW50IiwicGFyc2VTUlQiLCJzcnRDb250ZW50Iiwic2VnbWVudHMiLCJibG9ja3MiLCJ0cmltIiwiZm9yRWFjaCIsImJsb2NrIiwibGluZXMiLCJsZW5ndGgiLCJ0aW1lUmFuZ2UiLCJzbGljZSIsImpvaW4iLCJwdXNoIiwic3BsaXRUZXh0SW50b0dyb3VwcyIsIndvcmRzUGVyR3JvdXAiLCJ3b3JkcyIsImdyb3VwcyIsImkiLCJncm91cCIsInByb2Nlc3NTZWdtZW50Iiwic2VnbWVudCIsInRleHRHcm91cHMiLCJ0b3RhbER1cmF0aW9uIiwiZ3JvdXBEdXJhdGlvbiIsIm1hcCIsImdyb3VwVGV4dCIsImluZGV4IiwiY3JlYXRlU3VidGl0bGVQYXlsb2FkIiwidG9VcHBlckNhc2UiLCJmb250VXJsIiwiYmFja2dyb3VuZENvbG9yIiwicGFkZGluZyIsImJvcmRlclJhZGl1cyIsInJlc3BvbnNlIiwiZmV0Y2giLCJvayIsInN0YXR1cyIsImZsYXRNYXAiLCJvcmlnaW5hbExlbmd0aCIsImZpbHRlciIsInBhc3Nlc1N0YXJ0RmlsdGVyIiwicGFzc2VzRW5kRmlsdGVyIiwic2V0VGltZW91dCIsImdldEFjdGl2ZUVsZW1lbnRzIiwic3RhdGUiLCJnZXRTdGF0ZSIsImFjdGl2ZUlkcyIsInRyYWNrSXRlbXNNYXAiLCJhY3RpdmVFbGVtZW50cyIsIml0ZW0iLCJ0cmFja0lkIiwiZ2V0QWxsVGltZWxpbmVFbGVtZW50cyIsIk9iamVjdCIsImtleXMiLCJrZXkiLCJvYmpWYWx1ZSIsInNhbXBsZSIsImVudHJpZXMiLCJfIiwiYWxsRWxlbWVudHMiLCJzb3J0IiwiYSIsImIiLCJyZW1vdmVTZWdtZW50cyIsInRyYWNrSXRlbXMiLCJmaXJzdEl0ZW1JZCIsImlkcyIsImN1cnJlbnRTdGF0ZSIsIm9yaWdpbmFsSXRlbUlkIiwib3JpZ2luYWxJdGVtIiwidHJhY2tUeXBlIiwiZW5kTXMiLCJ0aW1lIiwic3RhdGVBZnRlckZpcnN0Q3V0IiwiZWxlbWVudHNBZnRlckZpcnN0Q3V0IiwiaXNOYU4iLCJkdXJhY2nDs24iLCJzdGFydE1zIiwibGVmdEVsZW1lbnQiLCJmaW5kIiwiZWxlbSIsInN0YXRlQWZ0ZXJTZWNvbmRDdXQiLCJlbGVtZW50c0FmdGVyU2Vjb25kQ3V0IiwibWlkZGxlRWxlbWVudHMiLCJhYnMiLCJtaWRkbGVFbGVtZW50IiwidmlzaWJsZSIsInNjYWxlIiwib3JpZ2luYWxVbml0IiwidW5pdCIsImNvbXBhY3RUaW1lbGluZSIsImVzdGFkbyIsInRvZG9zRWxlbWVudG9zIiwiZWxlbWVudG9zUG9yVHJhY2siLCJpZHgiLCJlc3BhY2lvc1ZhY2lvcyIsImVsZW1lbnRvcyIsImVsZW1lbnRvQWN0dWFsIiwiZWxlbWVudG9TaWd1aWVudGUiLCJlc3BhY2lvIiwic3RhcnQiLCJlbmQiLCJzaXplIiwiZWxlbWVudG9BbnRlcyIsImVsZW1lbnRvRGVzcHVlcyIsImVzcGFjaW9Ub3RhbCIsImFjdHVhbGl6YWNpb25lcyIsImVsZW1lbnRvc0FNb3ZlciIsImVsZW1lbnRvIiwiZGVzcGxhemFtaWVudG8iLCJudWV2b0Zyb20iLCJudWV2b1RvIiwidXBkYXRlZFNjYWxlIiwiY3VycmVudFNjYWxlIiwic21hcnRUcmltIiwiZGF0YSIsImpzb24iLCJBcnJheSIsImlzQXJyYXkiLCJzIiwiZXN0YWRvUHJldmlvIiwiZWxlbWVudG9zUHJldmlvcyIsImNvbnRhZG9yVHJhY2tzIiwidHJhY2tJZFByaW5jaXBhbCIsInRyYWNrc1BvclVzbyIsInJlc3VsdCIsInNlZ21lbnRvc0VsaW1pbmFkb3MiLCJlbGVtZW50b3NBY3R1YWxlcyIsInNlZ21lbnRvIiwic2VnbWVudG9zT3JkZW5hZG9zIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./components/ai-chat/ai-video-commands.ts\n"));

/***/ })

});
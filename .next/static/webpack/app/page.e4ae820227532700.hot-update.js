"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./features/editor/timeline/ruler.tsx":
/*!********************************************!*\
  !*** ./features/editor/timeline/ruler.tsx ***!
  \********************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _constants_constants__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../constants/constants */ \"(app-pages-browser)/./features/editor/constants/constants.ts\");\n/* harmony import */ var _utils_format__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/format */ \"(app-pages-browser)/./features/editor/utils/format.ts\");\n/* harmony import */ var _store_use_store__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../store/use-store */ \"(app-pages-browser)/./features/editor/store/use-store.ts\");\n/* harmony import */ var lodash_debounce__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! lodash/debounce */ \"(app-pages-browser)/./node_modules/lodash/debounce.js\");\n/* harmony import */ var lodash_debounce__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(lodash_debounce__WEBPACK_IMPORTED_MODULE_5__);\n\nvar _s = $RefreshSig$();\n\n\n\n\n\nconst Ruler = (props)=>{\n    _s();\n    const { height = 40, longLineSize = 8, shortLineSize = 10, offsetX = _constants_constants__WEBPACK_IMPORTED_MODULE_2__.TIMELINE_OFFSET_X + _constants_constants__WEBPACK_IMPORTED_MODULE_2__.TIMELINE_OFFSET_CANVAS_LEFT, textOffsetY = 17, textFormat = _utils_format__WEBPACK_IMPORTED_MODULE_3__.formatTimelineUnit, scrollLeft: scrollPos = 0, onClick } = props;\n    const { scale } = (0,_store_use_store__WEBPACK_IMPORTED_MODULE_4__[\"default\"])();\n    const canvasRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const [canvasContext, setCanvasContext] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [canvasSize, setCanvasSize] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)({\n        width: 0,\n        height: height\n    });\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        const canvas = canvasRef.current;\n        if (canvas) {\n            const context = canvas.getContext(\"2d\");\n            setCanvasContext(context);\n            resize(canvas, context, scrollPos);\n        }\n    }, []);\n    const handleResize = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(()=>{\n        resize(canvasRef.current, canvasContext, scrollPos);\n    }, [\n        canvasContext,\n        scrollPos\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        const resizeHandler = lodash_debounce__WEBPACK_IMPORTED_MODULE_5___default()(handleResize, 200);\n        window.addEventListener(\"resize\", resizeHandler);\n        return ()=>{\n            window.removeEventListener(\"resize\", resizeHandler);\n        };\n    }, [\n        handleResize\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (canvasContext) {\n            resize(canvasRef.current, canvasContext, scrollPos);\n        }\n    }, [\n        canvasContext,\n        scrollPos,\n        scale\n    ]);\n    const resize = (canvas, context, scrollPos)=>{\n        if (!canvas || !context) return;\n        const offsetParent = canvas.offsetParent;\n        var _offsetParent_offsetWidth;\n        const width = (_offsetParent_offsetWidth = offsetParent === null || offsetParent === void 0 ? void 0 : offsetParent.offsetWidth) !== null && _offsetParent_offsetWidth !== void 0 ? _offsetParent_offsetWidth : canvas.offsetWidth;\n        const height = canvasSize.height;\n        canvas.width = width;\n        canvas.height = height;\n        draw(context, scrollPos, width, height);\n        setCanvasSize({\n            width,\n            height\n        });\n    };\n    const draw = (context, scrollPos, width, height)=>{\n        const zoom = scale.zoom;\n        const unit = scale.unit;\n        const segments = scale.segments;\n        context.clearRect(0, 0, width, height);\n        context.save();\n        context.strokeStyle = \"#374151\"; // Darker gray for lines\n        context.fillStyle = \"#9CA3AF\"; // Lighter gray for text\n        context.lineWidth = 1;\n        context.font = \"\".concat(_constants_constants__WEBPACK_IMPORTED_MODULE_2__.SMALL_FONT_SIZE, \"px \").concat(_constants_constants__WEBPACK_IMPORTED_MODULE_2__.SECONDARY_FONT);\n        context.textBaseline = \"top\";\n        context.translate(0.5, 0);\n        context.beginPath();\n        const zoomUnit = unit * zoom * _constants_constants__WEBPACK_IMPORTED_MODULE_2__.PREVIEW_FRAME_WIDTH;\n        const minRange = Math.floor(scrollPos / zoomUnit);\n        const maxRange = Math.ceil((scrollPos + width) / zoomUnit);\n        const length = maxRange - minRange;\n        // Draw text before drawing the lines\n        for(let i = 0; i <= length; ++i){\n            const value = i + minRange;\n            if (value < 0) continue;\n            const startValue = value * zoomUnit / zoom;\n            const startPos = (startValue - scrollPos / zoom) * zoom;\n            if (startPos < -zoomUnit || startPos >= width + zoomUnit) continue;\n            const text = textFormat(startValue);\n            // Calculate the textOffsetX value\n            const textWidth = context.measureText(text).width;\n            const textOffsetX = -textWidth / 2;\n            // Adjust textOffsetY so it stays inside the canvas but above the lines\n            context.fillText(text, startPos + textOffsetX + offsetX, textOffsetY);\n        }\n        // Draw long and short lines after the text\n        for(let i = 0; i <= length; ++i){\n            const value = i + minRange;\n            if (value < 0) continue;\n            const startValue = value * zoomUnit;\n            const startPos = startValue - scrollPos + offsetX;\n            for(let j = 0; j < segments; ++j){\n                const pos = startPos + j / segments * zoomUnit;\n                if (pos < 0 || pos >= width) continue;\n                const lineSize = j % segments ? shortLineSize : longLineSize;\n                // Set color based on line size\n                if (lineSize === shortLineSize) {\n                    context.strokeStyle = \"#2A3042\"; // Darker blue-gray for short lines\n                } else {\n                    context.strokeStyle = \"#4B5563\"; // Medium gray for long lines\n                }\n                const origin = 18; // Increase the origin to start lines lower, below the text\n                const [x1, y1] = [\n                    pos,\n                    origin\n                ];\n                const [x2, y2] = [\n                    x1,\n                    y1 + lineSize\n                ];\n                context.beginPath(); // Begin a new path for each line\n                context.moveTo(x1, y1);\n                context.lineTo(x2, y2);\n                context.stroke(); // Draw the line\n            }\n        }\n        context.restore();\n    };\n    const handleClick = (event)=>{\n        const canvas = canvasRef.current;\n        if (!canvas) return;\n        // Get the bounding box of the canvas to calculate the relative click position\n        const rect = canvas.getBoundingClientRect();\n        const clickX = event.clientX - rect.left;\n        // Calculate total x position, including scrollPos\n        const totalX = clickX + scrollPos - _constants_constants__WEBPACK_IMPORTED_MODULE_2__.TIMELINE_OFFSET_X - _constants_constants__WEBPACK_IMPORTED_MODULE_2__.TIMELINE_OFFSET_CANVAS_LEFT;\n        onClick === null || onClick === void 0 ? void 0 : onClick(totalX);\n    // Here you can handle the result as needed\n    };\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: \"border-b border-[#1a1a2e] bg-[#070715]\",\n        style: {\n            position: \"relative\",\n            width: \"100%\",\n            height: \"\".concat(canvasSize.height, \"px\")\n        },\n        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"canvas\", {\n            onMouseUp: handleClick,\n            ref: canvasRef,\n            height: canvasSize.height\n        }, void 0, false, {\n            fileName: \"C:\\\\Users\\\\david\\\\Desktop\\\\ai-video-agent\\\\react-video-editor\\\\features\\\\editor\\\\timeline\\\\ruler.tsx\",\n            lineNumber: 200,\n            columnNumber: 7\n        }, undefined)\n    }, void 0, false, {\n        fileName: \"C:\\\\Users\\\\david\\\\Desktop\\\\ai-video-agent\\\\react-video-editor\\\\features\\\\editor\\\\timeline\\\\ruler.tsx\",\n        lineNumber: 192,\n        columnNumber: 5\n    }, undefined);\n};\n_s(Ruler, \"6NY144mKApz3XNZxWfNgUuY9hO8=\", false, function() {\n    return [\n        _store_use_store__WEBPACK_IMPORTED_MODULE_4__[\"default\"]\n    ];\n});\n_c = Ruler;\n/* harmony default export */ __webpack_exports__[\"default\"] = (Ruler);\nvar _c;\n$RefreshReg$(_c, \"Ruler\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2ZlYXR1cmVzL2VkaXRvci90aW1lbGluZS9ydWxlci50c3giLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBaUU7QUFRakM7QUFDcUI7QUFDWDtBQUNSO0FBY2xDLE1BQU1ZLFFBQVEsQ0FBQ0M7O0lBQ2IsTUFBTSxFQUNKQyxTQUFTLEVBQUUsRUFDWEMsZUFBZSxDQUFDLEVBQ2hCQyxnQkFBZ0IsRUFBRSxFQUNsQkMsVUFBVVQsbUVBQWlCQSxHQUFHRCw2RUFBMkIsRUFDekRXLGNBQWMsRUFBRSxFQUNoQkMsYUFBYVYsNkRBQWtCLEVBQy9CVyxZQUFZQyxZQUFZLENBQUMsRUFDekJDLE9BQU8sRUFDUixHQUFHVDtJQUNKLE1BQU0sRUFBRVUsS0FBSyxFQUFFLEdBQUdiLDREQUFRQTtJQUMxQixNQUFNYyxZQUFZdEIsNkNBQU1BLENBQTJCO0lBQ25ELE1BQU0sQ0FBQ3VCLGVBQWVDLGlCQUFpQixHQUNyQ3ZCLCtDQUFRQSxDQUFrQztJQUM1QyxNQUFNLENBQUN3QixZQUFZQyxjQUFjLEdBQUd6QiwrQ0FBUUEsQ0FBQztRQUMzQzBCLE9BQU87UUFDUGYsUUFBUUE7SUFDVjtJQUVBYixnREFBU0EsQ0FBQztRQUNSLE1BQU02QixTQUFTTixVQUFVTyxPQUFPO1FBQ2hDLElBQUlELFFBQVE7WUFDVixNQUFNRSxVQUFVRixPQUFPRyxVQUFVLENBQUM7WUFDbENQLGlCQUFpQk07WUFDakJFLE9BQU9KLFFBQVFFLFNBQVNYO1FBQzFCO0lBQ0YsR0FBRyxFQUFFO0lBRUwsTUFBTWMsZUFBZW5DLGtEQUFXQSxDQUFDO1FBQy9Ca0MsT0FBT1YsVUFBVU8sT0FBTyxFQUFFTixlQUFlSjtJQUMzQyxHQUFHO1FBQUNJO1FBQWVKO0tBQVU7SUFFN0JwQixnREFBU0EsQ0FBQztRQUNSLE1BQU1tQyxnQkFBZ0J6QixzREFBUUEsQ0FBQ3dCLGNBQWM7UUFDN0NFLE9BQU9DLGdCQUFnQixDQUFDLFVBQVVGO1FBRWxDLE9BQU87WUFDTEMsT0FBT0Us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Q0NpRSxXQUFXWjtZQUNYYSxLQUFLeEU7WUFDTFYsUUFBUWEsV0FBV2IsTUFBTTs7Ozs7Ozs7Ozs7QUFJakM7R0FyTE1GOztRQVdjRix3REFBUUE7OztLQVh0QkU7QUF1TE4sK0RBQWVBLEtBQUtBLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vZmVhdHVyZXMvZWRpdG9yL3RpbWVsaW5lL3J1bGVyLnRzeD8wNjk0Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHVzZUNhbGxiYWNrLCB1c2VFZmZlY3QsIHVzZVJlZiwgdXNlU3RhdGUgfSBmcm9tIFwicmVhY3RcIjtcblxuaW1wb3J0IHtcbiAgUFJFVklFV19GUkFNRV9XSURUSCxcbiAgU0VDT05EQVJZX0ZPTlQsXG4gIFNNQUxMX0ZPTlRfU0laRSxcbiAgVElNRUxJTkVfT0ZGU0VUX0NBTlZBU19MRUZULFxuICBUSU1FTElORV9PRkZTRVRfWCxcbn0gZnJvbSBcIi4uL2NvbnN0YW50cy9jb25zdGFudHNcIjtcbmltcG9ydCB7IGZvcm1hdFRpbWVsaW5lVW5pdCB9IGZyb20gXCIuLi91dGlscy9mb3JtYXRcIjtcbmltcG9ydCB1c2VTdG9yZSBmcm9tIFwiLi4vc3RvcmUvdXNlLXN0b3JlXCI7XG5pbXBvcnQgeyBkZWJvdW5jZSB9IGZyb20gXCJsb2Rhc2hcIjtcblxuaW50ZXJmYWNlIFJ1bGVyUHJvcHMge1xuICBoZWlnaHQ/OiBudW1iZXI7XG4gIGxvbmdMaW5lU2l6ZT86IG51bWJlcjtcbiAgc2hvcnRMaW5lU2l6ZT86IG51bWJlcjtcbiAgb2Zmc2V0WD86IG51bWJlcjtcbiAgdGV4dE9mZnNldFk/OiBudW1iZXI7XG4gIHNjcm9sbFBvcz86IG51bWJlcjtcbiAgdGV4dEZvcm1hdD86IChzY2FsZTogbnVtYmVyKSA9PiBzdHJpbmc7XG4gIHNjcm9sbExlZnQ/OiBudW1iZXI7XG4gIG9uQ2xpY2s/OiAodW5pdHM6IG51bWJlcikgPT4gdm9pZDtcbn1cblxuY29uc3QgUnVsZXIgPSAocHJvcHM6IFJ1bGVyUHJvcHMpID0+IHtcbiAgY29uc3Qge1xuICAgIGhlaWdodCA9IDQwLCAvLyBJbmNyZWFzZWQgaGVpZ2h0IHRvIGdpdmUgc3BhY2UgZm9yIHRoZSB0ZXh0XG4gICAgbG9uZ0xpbmVTaXplID0gOCxcbiAgICBzaG9ydExpbmVTaXplID0gMTAsXG4gICAgb2Zmc2V0WCA9IFRJTUVMSU5FX09GRlNFVF9YICsgVElNRUxJTkVfT0ZGU0VUX0NBTlZBU19MRUZULFxuICAgIHRleHRPZmZzZXRZID0gMTcsIC8vIFBsYWNlIHRoZSB0ZXh0IGFib3ZlIHRoZSBsaW5lcyBidXQgaW5zaWRlIHRoZSBjYW52YXNcbiAgICB0ZXh0Rm9ybWF0ID0gZm9ybWF0VGltZWxpbmVVbml0LFxuICAgIHNjcm9sbExlZnQ6IHNjcm9sbFBvcyA9IDAsXG4gICAgb25DbGljayxcbiAgfSA9IHByb3BzO1xuICBjb25zdCB7IHNjYWxlIH0gPSB1c2VTdG9yZSgpO1xuICBjb25zdCBjYW52YXNSZWYgPSB1c2VSZWY8SFRNTENhbnZhc0VsZW1lbnQgfCBudWxsPihudWxsKTtcbiAgY29uc3QgW2NhbnZhc0NvbnRleHQsIHNldENhbnZhc0NvbnRleHRdID1cbiAgICB1c2VTdGF0ZTxDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQgfCBudWxsPihudWxsKTtcbiAgY29uc3QgW2NhbnZhc1NpemUsIHNldENhbnZhc1NpemVdID0gdXNlU3RhdGUoe1xuICAgIHdpZHRoOiAwLFxuICAgIGhlaWdodDogaGVpZ2h0LCAvLyBJbmNyZWFzZWQgaGVpZ2h0IGZvciB0ZXh0IHNwYWNlXG4gIH0pO1xuXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgY29uc3QgY2FudmFzID0gY2FudmFzUmVmLmN1cnJlbnQ7XG4gICAgaWYgKGNhbnZhcykge1xuICAgICAgY29uc3QgY29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XG4gICAgICBzZXRDYW52YXNDb250ZXh0KGNvbnRleHQpO1xuICAgICAgcmVzaXplKGNhbnZhcywgY29udGV4dCwgc2Nyb2xsUG9zKTtcbiAgICB9XG4gIH0sIFtdKTtcblxuICBjb25zdCBoYW5kbGVSZXNpemUgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgcmVzaXplKGNhbnZhc1JlZi5jdXJyZW50LCBjYW52YXNDb250ZXh0LCBzY3JvbGxQb3MpO1xuICB9LCBbY2FudmFzQ29udGV4dCwgc2Nyb2xsUG9zXSk7XG5cbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCByZXNpemVIYW5kbGVyID0gZGVib3VuY2UoaGFuZGxlUmVzaXplLCAyMDApO1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwicmVzaXplXCIsIHJlc2l6ZUhhbmRsZXIpO1xuXG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwicmVzaXplXCIsIHJlc2l6ZUhhbmRsZXIpO1xuICAgIH07XG4gIH0sIFtoYW5kbGVSZXNpemVdKTtcblxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChjYW52YXNDb250ZXh0KSB7XG4gICAgICByZXNpemUoY2FudmFzUmVmLmN1cnJlbnQsIGNhbnZhc0NvbnRleHQsIHNjcm9sbFBvcyk7XG4gICAgfVxuICB9LCBbY2FudmFzQ29udGV4dCwgc2Nyb2xsUG9zLCBzY2FsZV0pO1xuXG4gIGNvbnN0IHJlc2l6ZSA9IChcbiAgICBjYW52YXM6IEhUTUxDYW52YXNFbGVtZW50IHwgbnVsbCxcbiAgICBjb250ZXh0OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQgfCBudWxsLFxuICAgIHNjcm9sbFBvczogbnVtYmVyLFxuICApID0+IHtcbiAgICBpZiAoIWNhbnZhcyB8fCAhY29udGV4dCkgcmV0dXJuO1xuXG4gICAgY29uc3Qgb2Zmc2V0UGFyZW50ID0gY2FudmFzLm9mZnNldFBhcmVudCBhcyBIVE1MRGl2RWxlbWVudDtcbiAgICBjb25zdCB3aWR0aCA9IG9mZnNldFBhcmVudD8ub2Zmc2V0V2lkdGggPz8gY2FudmFzLm9mZnNldFdpZHRoO1xuICAgIGNvbnN0IGhlaWdodCA9IGNhbnZhc1NpemUuaGVpZ2h0O1xuXG4gICAgY2FudmFzLndpZHRoID0gd2lkdGg7XG4gICAgY2FudmFzLmhlaWdodCA9IGhlaWdodDtcblxuICAgIGRyYXcoY29udGV4dCwgc2Nyb2xsUG9zLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICBzZXRDYW52YXNTaXplKHsgd2lkdGgsIGhlaWdodCB9KTtcbiAgfTtcblxuICBjb25zdCBkcmF3ID0gKFxuICAgIGNvbnRleHQ6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCxcbiAgICBzY3JvbGxQb3M6IG51bWJlcixcbiAgICB3aWR0aDogbnVtYmVyLFxuICAgIGhlaWdodDogbnVtYmVyLFxuICApID0+IHtcbiAgICBjb25zdCB6b29tID0gc2NhbGUuem9vbTtcbiAgICBjb25zdCB1bml0ID0gc2NhbGUudW5pdDtcbiAgICBjb25zdCBzZWdtZW50cyA9IHNjYWxlLnNlZ21lbnRzO1xuICAgIGNvbnRleHQuY2xlYXJSZWN0KDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xuICAgIGNvbnRleHQuc2F2ZSgpO1xuICAgIGNvbnRleHQuc3Ryb2tlU3R5bGUgPSBcIiMzNzQxNTFcIjsgLy8gRGFya2VyIGdyYXkgZm9yIGxpbmVzXG4gICAgY29udGV4dC5maWxsU3R5bGUgPSBcIiM5Q0EzQUZcIjsgLy8gTGlnaHRlciBncmF5IGZvciB0ZXh0XG4gICAgY29udGV4dC5saW5lV2lkdGggPSAxO1xuICAgIGNvbnRleHQuZm9udCA9IGAke1NNQUxMX0ZPTlRfU0laRX1weCAke1NFQ09OREFSWV9GT05UfWA7XG4gICAgY29udGV4dC50ZXh0QmFzZWxpbmUgPSBcInRvcFwiO1xuXG4gICAgY29udGV4dC50cmFuc2xhdGUoMC41LCAwKTtcbiAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xuXG4gICAgY29uc3Qgem9vbVVuaXQgPSB1bml0ICogem9vbSAqIFBSRVZJRVdfRlJBTUVfV0lEVEg7XG4gICAgY29uc3QgbWluUmFuZ2UgPSBNYXRoLmZsb29yKHNjcm9sbFBvcyAvIHpvb21Vbml0KTtcbiAgICBjb25zdCBtYXhSYW5nZSA9IE1hdGguY2VpbCgoc2Nyb2xsUG9zICsgd2lkdGgpIC8gem9vbVVuaXQpO1xuICAgIGNvbnN0IGxlbmd0aCA9IG1heFJhbmdlIC0gbWluUmFuZ2U7XG5cbiAgICAvLyBEcmF3IHRleHQgYmVmb3JlIGRyYXdpbmcgdGhlIGxpbmVzXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPD0gbGVuZ3RoOyArK2kpIHtcbiAgICAgIGNvbnN0IHZhbHVlID0gaSArIG1pblJhbmdlO1xuXG4gICAgICBpZiAodmFsdWUgPCAwKSBjb250aW51ZTtcblxuICAgICAgY29uc3Qgc3RhcnRWYWx1ZSA9ICh2YWx1ZSAqIHpvb21Vbml0KSAvIHpvb207XG4gICAgICBjb25zdCBzdGFydFBvcyA9IChzdGFydFZhbHVlIC0gc2Nyb2xsUG9zIC8gem9vbSkgKiB6b29tO1xuXG4gICAgICBpZiAoc3RhcnRQb3MgPCAtem9vbVVuaXQgfHwgc3RhcnRQb3MgPj0gd2lkdGggKyB6b29tVW5pdCkgY29udGludWU7XG4gICAgICBjb25zdCB0ZXh0ID0gdGV4dEZvcm1hdChzdGFydFZhbHVlKTtcblxuICAgICAgLy8gQ2FsY3VsYXRlIHRoZSB0ZXh0T2Zmc2V0WCB2YWx1ZVxuICAgICAgY29uc3QgdGV4dFdpZHRoID0gY29udGV4dC5tZWFzdXJlVGV4dCh0ZXh0KS53aWR0aDtcbiAgICAgIGNvbnN0IHRleHRPZmZzZXRYID0gLXRleHRXaWR0aCAvIDI7XG5cbiAgICAgIC8vIEFkanVzdCB0ZXh0T2Zmc2V0WSBzbyBpdCBzdGF5cyBpbnNpZGUgdGhlIGNhbnZhcyBidXQgYWJvdmUgdGhlIGxpbmVzXG4gICAgICBjb250ZXh0LmZpbGxUZXh0KHRleHQsIHN0YXJ0UG9zICsgdGV4dE9mZnNldFggKyBvZmZzZXRYLCB0ZXh0T2Zmc2V0WSk7XG4gICAgfVxuXG4gICAgLy8gRHJhdyBsb25nIGFuZCBzaG9ydCBsaW5lcyBhZnRlciB0aGUgdGV4dFxuICAgIGZvciAobGV0IGkgPSAwOyBpIDw9IGxlbmd0aDsgKytpKSB7XG4gICAgICBjb25zdCB2YWx1ZSA9IGkgKyBtaW5SYW5nZTtcblxuICAgICAgaWYgKHZhbHVlIDwgMCkgY29udGludWU7XG5cbiAgICAgIGNvbnN0IHN0YXJ0VmFsdWUgPSB2YWx1ZSAqIHpvb21Vbml0O1xuICAgICAgY29uc3Qgc3RhcnRQb3MgPSBzdGFydFZhbHVlIC0gc2Nyb2xsUG9zICsgb2Zmc2V0WDtcblxuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBzZWdtZW50czsgKytqKSB7XG4gICAgICAgIGNvbnN0IHBvcyA9IHN0YXJ0UG9zICsgKGogLyBzZWdtZW50cykgKiB6b29tVW5pdDtcblxuICAgICAgICBpZiAocG9zIDwgMCB8fCBwb3MgPj0gd2lkdGgpIGNvbnRpbnVlO1xuXG4gICAgICAgIGNvbnN0IGxpbmVTaXplID0gaiAlIHNlZ21lbnRzID8gc2hvcnRMaW5lU2l6ZSA6IGxvbmdMaW5lU2l6ZTtcblxuICAgICAgICAvLyBTZXQgY29sb3IgYmFzZWQgb24gbGluZSBzaXplXG4gICAgICAgIGlmIChsaW5lU2l6ZSA9PT0gc2hvcnRMaW5lU2l6ZSkge1xuICAgICAgICAgIGNvbnRleHQuc3Ryb2tlU3R5bGUgPSBcIiMyQTMwNDJcIjsgLy8gRGFya2VyIGJsdWUtZ3JheSBmb3Igc2hvcnQgbGluZXNcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb250ZXh0LnN0cm9rZVN0eWxlID0gXCIjNEI1NTYzXCI7IC8vIE1lZGl1bSBncmF5IGZvciBsb25nIGxpbmVzXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBvcmlnaW4gPSAxODsgLy8gSW5jcmVhc2UgdGhlIG9yaWdpbiB0byBzdGFydCBsaW5lcyBsb3dlciwgYmVsb3cgdGhlIHRleHRcblxuICAgICAgICBjb25zdCBbeDEsIHkxXSA9IFtwb3MsIG9yaWdpbl07XG4gICAgICAgIGNvbnN0IFt4MiwgeTJdID0gW3gxLCB5MSArIGxpbmVTaXplXTtcblxuICAgICAgICBjb250ZXh0LmJlZ2luUGF0aCgpOyAvLyBCZWdpbiBhIG5ldyBwYXRoIGZvciBlYWNoIGxpbmVcbiAgICAgICAgY29udGV4dC5tb3ZlVG8oeDEsIHkxKTtcbiAgICAgICAgY29udGV4dC5saW5lVG8oeDIsIHkyKTtcbiAgICAgICAgY29udGV4dC5zdHJva2UoKTsgLy8gRHJhdyB0aGUgbGluZVxuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnRleHQucmVzdG9yZSgpO1xuICB9O1xuXG4gIGNvbnN0IGhhbmRsZUNsaWNrID0gKGV2ZW50OiBSZWFjdC5Nb3VzZUV2ZW50PEhUTUxDYW52YXNFbGVtZW50PikgPT4ge1xuICAgIGNvbnN0IGNhbnZhcyA9IGNhbnZhc1JlZi5jdXJyZW50O1xuICAgIGlmICghY2FudmFzKSByZXR1cm47XG5cbiAgICAvLyBHZXQgdGhlIGJvdW5kaW5nIGJveCBvZiB0aGUgY2FudmFzIHRvIGNhbGN1bGF0ZSB0aGUgcmVsYXRpdmUgY2xpY2sgcG9zaXRpb25cbiAgICBjb25zdCByZWN0ID0gY2FudmFzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIGNvbnN0IGNsaWNrWCA9IGV2ZW50LmNsaWVudFggLSByZWN0LmxlZnQ7XG5cbiAgICAvLyBDYWxjdWxhdGUgdG90YWwgeCBwb3NpdGlvbiwgaW5jbHVkaW5nIHNjcm9sbFBvc1xuICAgIGNvbnN0IHRvdGFsWCA9XG4gICAgICBjbGlja1ggKyBzY3JvbGxQb3MgLSBUSU1FTElORV9PRkZTRVRfWCAtIFRJTUVMSU5FX09GRlNFVF9DQU5WQVNfTEVGVDtcblxuICAgIG9uQ2xpY2s/Lih0b3RhbFgpO1xuICAgIC8vIEhlcmUgeW91IGNhbiBoYW5kbGUgdGhlIHJlc3VsdCBhcyBuZWVkZWRcbiAgfTtcblxuICByZXR1cm4gKFxuICAgIDxkaXZcbiAgICAgIGNsYXNzTmFtZT1cImJvcmRlci1iIGJvcmRlci1bIzFhMWEyZV0gYmctWyMwNzA3MTVdXCJcbiAgICAgIHN0eWxlPXt7XG4gICAgICAgIHBvc2l0aW9uOiBcInJlbGF0aXZlXCIsXG4gICAgICAgIHdpZHRoOiBcIjEwMCVcIixcbiAgICAgICAgaGVpZ2h0OiBgJHtjYW52YXNTaXplLmhlaWdodH1weGAsXG4gICAgICB9fVxuICAgID5cbiAgICAgIDxjYW52YXNcbiAgICAgICAgb25Nb3VzZVVwPXtoYW5kbGVDbGlja31cbiAgICAgICAgcmVmPXtjYW52YXNSZWZ9XG4gICAgICAgIGhlaWdodD17Y2FudmFzU2l6ZS5oZWlnaHR9XG4gICAgICAvPlxuICAgIDwvZGl2PlxuICApO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgUnVsZXI7XG4iXSwibmFtZXMiOlsidXNlQ2FsbGJhY2siLCJ1c2VFZmZlY3QiLCJ1c2VSZWYiLCJ1c2VTdGF0ZSIsIlBSRVZJRVdfRlJBTUVfV0lEVEgiLCJTRUNPTkRBUllfRk9OVCIsIlNNQUxMX0ZPTlRfU0laRSIsIlRJTUVMSU5FX09GRlNFVF9DQU5WQVNfTEVGVCIsIlRJTUVMSU5FX09GRlNFVF9YIiwiZm9ybWF0VGltZWxpbmVVbml0IiwidXNlU3RvcmUiLCJkZWJvdW5jZSIsIlJ1bGVyIiwicHJvcHMiLCJoZWlnaHQiLCJsb25nTGluZVNpemUiLCJzaG9ydExpbmVTaXplIiwib2Zmc2V0WCIsInRleHRPZmZzZXRZIiwidGV4dEZvcm1hdCIsInNjcm9sbExlZnQiLCJzY3JvbGxQb3MiLCJvbkNsaWNrIiwic2NhbGUiLCJjYW52YXNSZWYiLCJjYW52YXNDb250ZXh0Iiwic2V0Q2FudmFzQ29udGV4dCIsImNhbnZhc1NpemUiLCJzZXRDYW52YXNTaXplIiwid2lkdGgiLCJjYW52YXMiLCJjdXJyZW50IiwiY29udGV4dCIsImdldENvbnRleHQiLCJyZXNpemUiLCJoYW5kbGVSZXNpemUiLCJyZXNpemVIYW5kbGVyIiwid2luZG93IiwiYWRkRXZlbnRMaXN0ZW5lciIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJvZmZzZXRQYXJlbnQiLCJvZmZzZXRXaWR0aCIsImRyYXciLCJ6b29tIiwidW5pdCIsInNlZ21lbnRzIiwiY2xlYXJSZWN0Iiwic2F2ZSIsInN0cm9rZVN0eWxlIiwiZmlsbFN0eWxlIiwibGluZVdpZHRoIiwiZm9udCIsInRleHRCYXNlbGluZSIsInRyYW5zbGF0ZSIsImJlZ2luUGF0aCIsInpvb21Vbml0IiwibWluUmFuZ2UiLCJNYXRoIiwiZmxvb3IiLCJtYXhSYW5nZSIsImNlaWwiLCJsZW5ndGgiLCJpIiwidmFsdWUiLCJzdGFydFZhbHVlIiwic3RhcnRQb3MiLCJ0ZXh0IiwidGV4dFdpZHRoIiwibWVhc3VyZVRleHQiLCJ0ZXh0T2Zmc2V0WCIsImZpbGxUZXh0IiwiaiIsInBvcyIsImxpbmVTaXplIiwib3JpZ2luIiwieDEiLCJ5MSIsIngyIiwieTIiLCJtb3ZlVG8iLCJsaW5lVG8iLCJzdHJva2UiLCJyZXN0b3JlIiwiaGFuZGxlQ2xpY2siLCJldmVudCIsInJlY3QiLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJjbGlja1giLCJjbGllbnRYIiwibGVmdCIsInRvdGFsWCIsImRpdiIsImNsYXNzTmFtZSIsInN0eWxlIiwicG9zaXRpb24iLCJvbk1vdXNlVXAiLCJyZWYiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./features/editor/timeline/ruler.tsx\n"));

/***/ })

});
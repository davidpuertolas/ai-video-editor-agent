"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./features/editor/timeline/items/video.ts":
/*!*************************************************!*\
  !*** ./features/editor/timeline/items/video.ts ***!
  \*************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _designcombo_timeline__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @designcombo/timeline */ \"(app-pages-browser)/./node_modules/@designcombo/timeline/dist/index.es.js\");\n/* harmony import */ var _utils_thumbnail_cache__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../utils/thumbnail-cache */ \"(app-pages-browser)/./features/editor/utils/thumbnail-cache.ts\");\n/* harmony import */ var _utils_filmstrip__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../utils/filmstrip */ \"(app-pages-browser)/./features/editor/utils/filmstrip.ts\");\n/* harmony import */ var _utils_file__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../utils/file */ \"(app-pages-browser)/./features/editor/utils/file.ts\");\n/* harmony import */ var _controls__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../controls */ \"(app-pages-browser)/./features/editor/timeline/controls/index.ts\");\n\n\n\n\n\nconst EMPTY_FILMSTRIP = {\n    offset: 0,\n    startTime: 0,\n    thumbnailsCount: 0,\n    widthOnScreen: 0\n};\nclass Video extends _designcombo_timeline__WEBPACK_IMPORTED_MODULE_0__.Video {\n    static createControls() {\n        return {\n            controls: (0,_controls__WEBPACK_IMPORTED_MODULE_4__.createMediaControls)()\n        };\n    }\n    initOffscreenCanvas() {\n        if (!this.offscreenCanvas) {\n            this.offscreenCanvas = new OffscreenCanvas(this.width, this.height);\n            this.offscreenCtx = this.offscreenCanvas.getContext(\"2d\");\n        }\n        // Resize if dimensions changed\n        if (this.offscreenCanvas.width !== this.width || this.offscreenCanvas.height !== this.height) {\n            this.offscreenCanvas.width = this.width;\n            this.offscreenCanvas.height = this.height;\n            this.isDirty = true;\n        }\n    }\n    initDimensions() {\n        this.thumbnailWidth = this.thumbnailHeight * this.aspectRatio;\n        const segmentOptions = (0,_utils_filmstrip__WEBPACK_IMPORTED_MODULE_2__.calculateThumbnailSegmentLayout)(this.thumbnailWidth);\n        this.thumbnailsPerSegment = segmentOptions.thumbnailsPerSegment;\n        this.segmentSize = segmentOptions.segmentSize;\n    }\n    async initialize() {\n        var _this_canvas;\n        await this.loadFallbackThumbnail();\n        this.initDimensions();\n        this.onScrollChange({\n            scrollLeft: 0\n        });\n        (_this_canvas = this.canvas) === null || _this_canvas === void 0 ? void 0 : _this_canvas.requestRenderAll();\n        this.createFallbackPattern();\n        await this.prepareAssets();\n        this.onScrollChange({\n            scrollLeft: 0\n        });\n    }\n    async prepareAssets() {\n        if (false) {}\n        try {\n            const { MP4Clip } = await __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_designcombo_frames_dist_frames_js\").then(__webpack_require__.bind(__webpack_require__, /*! @designcombo/frames */ \"(app-pages-browser)/./node_modules/@designcombo/frames/dist/frames.js\"));\n            const file = await (0,_utils_file__WEBPACK_IMPORTED_MODULE_3__.getFileFromUrl)(this.src);\n            const stream = file.stream();\n            this.clip = new MP4Clip(stream);\n        } catch (error) {\n            console.error(\"Error loading MP4Clip:\", error);\n        }\n    }\n    calculateFilmstripDimensions(param) {\n        let { segmentIndex, widthOnScreen } = param;\n        const filmstripOffset = segmentIndex * this.segmentSize;\n        const shouldUseLeftBacklog = segmentIndex > 0;\n        const leftBacklogSize = shouldUseLeftBacklog ? this.segmentSize : 0;\n        const totalWidth = (0,_designcombo_timeline__WEBPACK_IMPORTED_MODULE_0__.timeMsToUnits)(this.duration, this.tScale, this.playbackRate);\n        const rightRemainingSize = totalWidth - widthOnScreen - leftBacklogSize - filmstripOffset;\n        const rightBacklogSize = Math.min(this.segmentSize, rightRemainingSize);\n        const filmstripStartTime = (0,_designcombo_timeline__WEBPACK_IMPORTED_MODULE_0__.unitsToTimeMs)(filmstripOffset, this.tScale);\n        const filmstrimpThumbnailsCount = 1 + Math.round((widthOnScreen + leftBacklogSize + rightBacklogSize) / this.thumbnailWidth);\n        return {\n            filmstripOffset,\n            leftBacklogSize,\n            rightBacklogSize,\n            filmstripStartTime,\n            filmstrimpThumbnailsCount\n        };\n    }\n    // load fallback thumbnail, resize it and cache it\n    async loadFallbackThumbnail() {\n        const fallbackThumbnail = this.previewUrl;\n        if (!fallbackThumbnail) return;\n        console.log(\"[DEBUG] Cargando thumbnail para video:\", this.id, \"URL tipo:\", fallbackThumbnail.substring(0, 30) + \"...\");\n        return new Promise((resolve)=>{\n            const img = new Image();\n            img.crossOrigin = \"anonymous\";\n            // Para URLs de datos y URLs de objeto, no necesitamos añadir parámetros extra\n            if (fallbackThumbnail.startsWith(\"data:\") || fallbackThumbnail.startsWith(\"blob:\")) {\n                img.src = fallbackThumbnail;\n            } else {\n                // Para URLs remotas, añadimos un timestamp para evitar caché\n                img.src = fallbackThumbnail + \"?t=\" + Date.now();\n            }\n            img.onload = ()=>{\n                // Create a temporary canvas to resize the image\n                const canvas = document.createElement(\"canvas\");\n                const ctx = canvas.getContext(\"2d\");\n                // Calculate new width maintaining aspect ratio\n                const aspectRatio = img.width / img.height;\n                const targetHeight = 40;\n                const targetWidth = Math.round(targetHeight * aspectRatio);\n                // Set canvas size and draw resized image\n                canvas.height = targetHeight;\n                canvas.width = targetWidth;\n                ctx.drawImage(img, 0, 0, targetWidth, targetHeight);\n                // Create new image from resized canvas\n                const resizedImg = new Image();\n                resizedImg.src = canvas.toDataURL();\n                // Update aspect ratio and cache the resized image\n                this.aspectRatio = aspectRatio;\n                this.thumbnailWidth = targetWidth;\n                this.thumbnailCache.setThumbnail(\"fallback\", resizedImg);\n                console.log(\"[DEBUG] Thumbnail cargado correctamente para video:\", this.id);\n                resolve();\n            };\n            img.onerror = (err)=>{\n                console.error(\"[ERROR] No se pudo cargar la miniatura:\", err);\n                resolve(); // Resolver de todos modos para no bloquear la carga\n            };\n        });\n    }\n    generateTimestamps(startTime, count) {\n        const timePerThumbnail = (0,_designcombo_timeline__WEBPACK_IMPORTED_MODULE_0__.unitsToTimeMs)(this.thumbnailWidth, this.tScale, this.playbackRate);\n        return Array.from({\n            length: count\n        }, (_, i)=>{\n            const timeInFilmstripe = startTime + i * timePerThumbnail;\n            return Math.ceil(timeInFilmstripe / 1000);\n        });\n    }\n    createFallbackPattern() {\n        var _this_canvas;\n        const canvas = this.canvas;\n        if (!canvas) return;\n        const canvasWidth = this.canvas.width;\n        const maxPatternSize = 12000;\n        const fallbackSource = this.thumbnailCache.getThumbnail(\"fallback\");\n        if (!fallbackSource) return;\n        // Compute the total width and number of segments needed\n        const totalWidthNeeded = Math.min(canvasWidth * 20, maxPatternSize);\n        const segmentsRequired = Math.ceil(totalWidthNeeded / this.segmentSize);\n        this.fallbackSegmentsCount = segmentsRequired;\n        const patternWidth = segmentsRequired * this.segmentSize;\n        // Setup canvas dimensions\n        const offCanvas = document.createElement(\"canvas\");\n        offCanvas.height = this.thumbnailHeight;\n        offCanvas.width = patternWidth;\n        const context = offCanvas.getContext(\"2d\");\n        const thumbnailsTotal = segmentsRequired * this.thumbnailsPerSegment;\n        // Draw the fallback image across the entirety of the canvas horizontally\n        for(let i = 0; i < thumbnailsTotal; i++){\n            const x = i * this.thumbnailWidth;\n            context.drawImage(fallbackSource, x, 0, this.thumbnailWidth, this.thumbnailHeight);\n        }\n        // Create the pattern and apply it\n        const fillPattern = new _designcombo_timeline__WEBPACK_IMPORTED_MODULE_0__.Pattern({\n            source: offCanvas,\n            repeat: \"no-repeat\",\n            offsetX: 0\n        });\n        this.set(\"fill\", fillPattern);\n        (_this_canvas = this.canvas) === null || _this_canvas === void 0 ? void 0 : _this_canvas.requestRenderAll();\n    }\n    async loadAndRenderThumbnails() {\n        if (this.isFetchingThumbnails || !this.clip) return;\n        // set segmentDrawn to segmentToDraw\n        this.loadingFilmstrip = {\n            ...this.nextFilmstrip\n        };\n        this.isFetchingThumbnails = true;\n        // Calculate dimensions and offsets\n        const { startTime, thumbnailsCount } = this.loadingFilmstrip;\n        // Generate required timestamps\n        const timestamps = this.generateTimestamps(startTime, thumbnailsCount);\n        // Match and prepare thumbnails\n        let thumbnailsArr = await this.clip.thumbnailsList(this.thumbnailWidth, {\n            timestamps: timestamps.map((timestamp)=>timestamp * 1e6)\n        });\n        const updatedThumbnails = thumbnailsArr.map((thumbnail)=>{\n            return {\n                ts: Math.round(thumbnail.ts / 1e6),\n                img: thumbnail.img\n            };\n        });\n        // Load all thumbnails in parallel\n        await this.loadThumbnailBatch(updatedThumbnails);\n        this.isDirty = true; // Mark as dirty after preparing new thumbnails\n        // this.isFallbackDirty = true;\n        this.isFetchingThumbnails = false;\n        this.currentFilmstrip = {\n            ...this.loadingFilmstrip\n        };\n        requestAnimationFrame(()=>{\n            var _this_canvas;\n            (_this_canvas = this.canvas) === null || _this_canvas === void 0 ? void 0 : _this_canvas.requestRenderAll();\n        });\n    }\n    async loadThumbnailBatch(thumbnails) {\n        const loadPromises = thumbnails.map(async (thumbnail)=>{\n            if (this.thumbnailCache.getThumbnail(thumbnail.ts)) return;\n            return new Promise((resolve)=>{\n                const img = new Image();\n                img.src = URL.createObjectURL(thumbnail.img);\n                img.onload = ()=>{\n                    URL.revokeObjectURL(img.src); // Clean up the blob URL after image loads\n                    this.thumbnailCache.setThumbnail(thumbnail.ts, img);\n                    resolve();\n                };\n            });\n        });\n        await Promise.all(loadPromises);\n    }\n    _render(ctx) {\n        super._render(ctx);\n        ctx.save();\n        ctx.translate(-this.width / 2, -this.height / 2);\n        // Clip the area to prevent drawing outside\n        ctx.beginPath();\n        ctx.rect(0, 0, this.width, this.height);\n        ctx.clip();\n        this.renderToOffscreen();\n        ctx.drawImage(this.offscreenCanvas, 0, 0);\n        ctx.restore();\n        // this.drawTextIdentity(ctx);\n        this.updateSelected(ctx);\n    }\n    setDuration(duration) {\n        this.duration = duration;\n        this.prevDuration = duration;\n    }\n    async setSrc(src) {\n        super.setSrc(src);\n        this.clip = null;\n        await this.initialize();\n        await this.prepareAssets();\n        this.thumbnailCache.clearCacheButFallback();\n        this.onScale();\n    }\n    onResizeSnap() {\n        this.renderToOffscreen(true);\n    }\n    onResize() {\n        this.renderToOffscreen(true);\n    }\n    renderToOffscreen(force) {\n        if (!this.offscreenCtx) return;\n        if (!this.isDirty && !force) return;\n        this.offscreenCanvas.width = this.width;\n        const ctx = this.offscreenCtx;\n        const { startTime, offset, thumbnailsCount } = this.currentFilmstrip;\n        const thumbnailWidth = this.thumbnailWidth;\n        const thumbnailHeight = this.thumbnailHeight;\n        // Calculate the offset caused by the trimming\n        const trimFromSize = (0,_designcombo_timeline__WEBPACK_IMPORTED_MODULE_0__.timeMsToUnits)(this.trim.from, this.tScale, this.playbackRate);\n        let timeInFilmstripe = startTime;\n        const timePerThumbnail = (0,_designcombo_timeline__WEBPACK_IMPORTED_MODULE_0__.unitsToTimeMs)(thumbnailWidth, this.tScale, this.playbackRate);\n        // Clear the offscreen canvas\n        ctx.clearRect(0, 0, this.width, this.height);\n        // Clip with rounded corners\n        ctx.beginPath();\n        ctx.roundRect(0, 0, this.width, this.height, this.rx);\n        ctx.clip();\n        // Draw thumbnails\n        for(let i = 0; i < thumbnailsCount; i++){\n            let img = this.thumbnailCache.getThumbnail(Math.ceil(timeInFilmstripe / 1000));\n            if (!img) {\n                img = this.thumbnailCache.getThumbnail(\"fallback\");\n            }\n            if (img && img.complete) {\n                const xPosition = i * thumbnailWidth + offset - trimFromSize;\n                ctx.drawImage(img, xPosition, 0, thumbnailWidth, thumbnailHeight);\n                timeInFilmstripe += timePerThumbnail;\n            }\n        }\n        this.isDirty = false;\n    }\n    drawTextIdentity(ctx) {\n        const iconPath = new Path2D(\"M16.5625 0.925L12.5 3.275V0.625L11.875 0H0.625L0 0.625V9.375L0.625 10H11.875L12.5 9.375V6.875L16.5625 9.2125L17.5 8.625V1.475L16.5625 0.925ZM11.25 8.75H1.25V1.25H11.25V8.75ZM16.25 7.5L12.5 5.375V4.725L16.25 2.5V7.5Z\");\n        ctx.save();\n        ctx.translate(-this.width / 2, -this.height / 2);\n        ctx.translate(0, 14);\n        ctx.font = \"600 12px 'Geist variable'\";\n        ctx.fillStyle = \"#f4f4f5\";\n        ctx.textAlign = \"left\";\n        ctx.clip();\n        ctx.fillText(\"Video\", 36, 10);\n        ctx.translate(8, 1);\n        ctx.fillStyle = \"#f4f4f5\";\n        ctx.fill(iconPath);\n        ctx.restore();\n    }\n    setSelected(selected) {\n        this.isSelected = selected;\n        this.set({\n            dirty: true\n        });\n    }\n    updateSelected(ctx) {\n        const borderColor = this.isSelected ? \"rgba(255, 255, 255,1.0)\" : \"rgba(255, 255, 255,0.1)\";\n        ctx.save();\n        ctx.beginPath();\n        ctx.roundRect(-this.width / 2, -this.height / 2, this.width, this.height, 6);\n        ctx.lineWidth = 1;\n        ctx.strokeStyle = borderColor;\n        ctx.stroke();\n        ctx.restore();\n    }\n    calulateWidthOnScreen() {\n        const canvasEl = document.getElementById(\"designcombo-timeline-canvas\");\n        const canvasWidth = canvasEl === null || canvasEl === void 0 ? void 0 : canvasEl.clientWidth;\n        const scrollLeft = this.scrollLeft;\n        const timelineWidth = canvasWidth;\n        const cutFromBottomEdge = Math.max(timelineWidth - (this.width + this.left + scrollLeft), 0);\n        const visibleHeight = Math.min(timelineWidth - this.left - scrollLeft, timelineWidth);\n        return Math.max(visibleHeight - cutFromBottomEdge, 0);\n    }\n    // Calculate the width that is not visible on the screen measured from the left\n    calculateOffscreenWidth(param) {\n        let { scrollLeft } = param;\n        const offscreenWidth = Math.min(this.left + scrollLeft, 0);\n        return Math.abs(offscreenWidth);\n    }\n    onScrollChange(param) {\n        let { scrollLeft, force } = param;\n        const offscreenWidth = this.calculateOffscreenWidth({\n            scrollLeft\n        });\n        const trimFromSize = (0,_designcombo_timeline__WEBPACK_IMPORTED_MODULE_0__.timeMsToUnits)(this.trim.from, this.tScale, this.playbackRate);\n        const offscreenSegments = (0,_utils_filmstrip__WEBPACK_IMPORTED_MODULE_2__.calculateOffscreenSegments)(offscreenWidth, trimFromSize, this.segmentSize);\n        this.offscreenSegments = offscreenSegments;\n        // calculate start segment to draw\n        const segmentToDraw = offscreenSegments;\n        if (this.currentFilmstrip.segmentIndex === segmentToDraw) {\n            return false;\n        }\n        if (segmentToDraw !== this.fallbackSegmentIndex) {\n            const fillPattern = this.fill;\n            if (fillPattern instanceof _designcombo_timeline__WEBPACK_IMPORTED_MODULE_0__.Pattern) {\n                fillPattern.offsetX = this.segmentSize * (segmentToDraw - Math.floor(this.fallbackSegmentsCount / 2));\n            }\n            this.fallbackSegmentIndex = segmentToDraw;\n        }\n        if (!this.isFetchingThumbnails || force) {\n            this.scrollLeft = scrollLeft;\n            const widthOnScreen = this.calulateWidthOnScreen();\n            // With these lines:\n            const { filmstripOffset, filmstripStartTime, filmstrimpThumbnailsCount } = this.calculateFilmstripDimensions({\n                widthOnScreen: this.calulateWidthOnScreen(),\n                segmentIndex: segmentToDraw\n            });\n            this.nextFilmstrip = {\n                segmentIndex: segmentToDraw,\n                offset: filmstripOffset,\n                startTime: filmstripStartTime,\n                thumbnailsCount: filmstrimpThumbnailsCount,\n                widthOnScreen\n            };\n            this.loadAndRenderThumbnails();\n        }\n    }\n    onScale() {\n        this.currentFilmstrip = {\n            ...EMPTY_FILMSTRIP\n        };\n        this.nextFilmstrip = {\n            ...EMPTY_FILMSTRIP,\n            segmentIndex: 0\n        };\n        this.loadingFilmstrip = {\n            ...EMPTY_FILMSTRIP\n        };\n        this.onScrollChange({\n            scrollLeft: this.scrollLeft,\n            force: true\n        });\n    }\n    constructor(props){\n        var _props_metadata;\n        super(props);\n        this.resourceId = \"\";\n        this.isSelected = false;\n        this.itemType = \"video\";\n        this.aspectRatio = 1;\n        this.scrollLeft = 0;\n        this.thumbnailsPerSegment = 0;\n        this.segmentSize = 0;\n        this.offscreenSegments = 0;\n        this.thumbnailWidth = 0;\n        this.thumbnailHeight = 40;\n        this.thumbnailsList = [];\n        this.isFetchingThumbnails = false;\n        this.thumbnailCache = new _utils_thumbnail_cache__WEBPACK_IMPORTED_MODULE_1__[\"default\"]();\n        this.currentFilmstrip = EMPTY_FILMSTRIP;\n        this.nextFilmstrip = {\n            ...EMPTY_FILMSTRIP,\n            segmentIndex: 0\n        };\n        this.loadingFilmstrip = EMPTY_FILMSTRIP;\n        this.offscreenCanvas = null;\n        this.offscreenCtx = null;\n        this.isDirty = true;\n        this.fallbackSegmentIndex = 0;\n        this.fallbackSegmentsCount = 0;\n        this.previewUrl = \"\";\n        this.id = props.id;\n        this.tScale = props.tScale;\n        this.objectCaching = false;\n        this.rx = 4;\n        this.ry = 4;\n        this.display = props.display;\n        this.trim = props.trim;\n        this.duration = props.duration;\n        this.prevDuration = props.duration;\n        this.fill = \"#27272a\";\n        this.borderOpacityWhenMoving = 1;\n        this.metadata = props.metadata;\n        this.aspectRatio = props.aspectRatio;\n        this.src = props.src;\n        this.strokeWidth = 0;\n        this.transparentCorners = false;\n        this.hasBorders = false;\n        this.previewUrl = (_props_metadata = props.metadata) === null || _props_metadata === void 0 ? void 0 : _props_metadata.previewUrl;\n        this.initOffscreenCanvas();\n        this.initialize();\n    }\n}\nVideo.type = \"Video\";\n/* harmony default export */ __webpack_exports__[\"default\"] = (Video);\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2ZlYXR1cmVzL2VkaXRvci90aW1lbGluZS9pdGVtcy92aWRlby50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFPK0I7QUFFMEI7QUFLMUI7QUFDbUI7QUFFQTtBQUVsRCxNQUFNVSxrQkFBNkI7SUFDakNDLFFBQVE7SUFDUkMsV0FBVztJQUNYQyxpQkFBaUI7SUFDakJDLGVBQWU7QUFDakI7QUFRQSxNQUFNYixjQUFjQyx3REFBU0E7SUEwQzNCLE9BQU9hLGlCQUF3RDtRQUM3RCxPQUFPO1lBQUVDLFVBQVVQLDhEQUFtQkE7UUFBRztJQUMzQztJQThCUVEsc0JBQXNCO1FBQzVCLElBQUksQ0FBQyxJQUFJLENBQUNDLGVBQWUsRUFBRTtZQUN6QixJQUFJLENBQUNBLGVBQWUsR0FBRyxJQUFJQyxnQkFBZ0IsSUFBSSxDQUFDQyxLQUFLLEVBQUUsSUFBSSxDQUFDQyxNQUFNO1lBQ2xFLElBQUksQ0FBQ0MsWUFBWSxHQUFHLElBQUksQ0FBQ0osZUFBZSxDQUFDSyxVQUFVLENBQUM7UUFDdEQ7UUFFQSwrQkFBK0I7UUFDL0IsSUFDRSxJQUFJLENBQUNMLGVBQWUsQ0FBQ0UsS0FBSyxLQUFLLElBQUksQ0FBQ0EsS0FBSyxJQUN6QyxJQUFJLENBQUNGLGVBQWUsQ0FBQ0csTUFBTSxLQUFLLElBQUksQ0FBQ0EsTUFBTSxFQUMzQztZQUNBLElBQUksQ0FBQ0gsZUFBZSxDQUFDRSxLQUFLLEdBQUcsSUFBSSxDQUFDQSxLQUFLO1lBQ3ZDLElBQUksQ0FBQ0YsZUFBZSxDQUFDRyxNQUFNLEdBQUcsSUFBSSxDQUFDQSxNQUFNO1lBQ3pDLElBQUksQ0FBQ0csT0FBTyxHQUFHO1FBQ2pCO0lBQ0Y7SUFFT0MsaUJBQWlCO1FBQ3RCLElBQUksQ0FBQ0MsY0FBYyxHQUFHLElBQUksQ0FBQ0MsZUFBZSxHQUFHLElBQUksQ0FBQ0MsV0FBVztRQUU3RCxNQUFNQyxpQkFBaUJ0QixpRkFBK0JBLENBQUMsSUFBSSxDQUFDbUIsY0FBYztRQUMxRSxJQUFJLENB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L2lCTS9CLE1BQ0cyTSxPQUFPO0FBZ2pCaEIsK0RBQWUzTSxLQUFLQSxFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL2ZlYXR1cmVzL2VkaXRvci90aW1lbGluZS9pdGVtcy92aWRlby50cz9mM2U4Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XHJcbiAgQ29udHJvbCxcclxuICBQYXR0ZXJuLFxyXG4gIFZpZGVvIGFzIFZpZGVvQmFzZSxcclxuICBWaWRlb1Byb3BzIGFzIFZpZGVvUHJvcHNCYXNlLFxyXG4gIHRpbWVNc1RvVW5pdHMsXHJcbiAgdW5pdHNUb1RpbWVNcyxcclxufSBmcm9tIFwiQGRlc2lnbmNvbWJvL3RpbWVsaW5lXCI7XHJcbmltcG9ydCB7IEZpbG1zdHJpcCwgRmlsbXN0cmlwQmFja2xvZ09wdGlvbnMgfSBmcm9tIFwiLi4vdHlwZXNcIjtcclxuaW1wb3J0IFRodW1ibmFpbENhY2hlIGZyb20gXCIuLi8uLi91dGlscy90aHVtYm5haWwtY2FjaGVcIjtcclxuaW1wb3J0IHsgSURpc3BsYXksIElNZXRhZGF0YSwgSVRyaW0gfSBmcm9tIFwiQGRlc2lnbmNvbWJvL3R5cGVzXCI7XHJcbmltcG9ydCB7XHJcbiAgY2FsY3VsYXRlT2Zmc2NyZWVuU2VnbWVudHMsXHJcbiAgY2FsY3VsYXRlVGh1bWJuYWlsU2VnbWVudExheW91dCxcclxufSBmcm9tIFwiLi4vLi4vdXRpbHMvZmlsbXN0cmlwXCI7XHJcbmltcG9ydCB7IGdldEZpbGVGcm9tVXJsIH0gZnJvbSBcIi4uLy4uL3V0aWxzL2ZpbGVcIjtcclxuaW1wb3J0IHsgdHlwZSBNUDRDbGlwIH0gZnJvbSBcIkBkZXNpZ25jb21iby9mcmFtZXNcIjtcclxuaW1wb3J0IHsgY3JlYXRlTWVkaWFDb250cm9scyB9IGZyb20gXCIuLi9jb250cm9sc1wiO1xyXG5cclxuY29uc3QgRU1QVFlfRklMTVNUUklQOiBGaWxtc3RyaXAgPSB7XHJcbiAgb2Zmc2V0OiAwLFxyXG4gIHN0YXJ0VGltZTogMCxcclxuICB0aHVtYm5haWxzQ291bnQ6IDAsXHJcbiAgd2lkdGhPblNjcmVlbjogMCxcclxufTtcclxuXHJcbmludGVyZmFjZSBWaWRlb1Byb3BzIGV4dGVuZHMgVmlkZW9Qcm9wc0Jhc2Uge1xyXG4gIGFzcGVjdFJhdGlvOiBudW1iZXI7XHJcbiAgbWV0YWRhdGE6IFBhcnRpYWw8SU1ldGFkYXRhPiAmIHtcclxuICAgIHByZXZpZXdVcmw6IHN0cmluZztcclxuICB9O1xyXG59XHJcbmNsYXNzIFZpZGVvIGV4dGVuZHMgVmlkZW9CYXNlIHtcclxuICBzdGF0aWMgdHlwZSA9IFwiVmlkZW9cIjtcclxuICBwdWJsaWMgY2xpcD86IE1QNENsaXAgfCBudWxsO1xyXG4gIGRlY2xhcmUgaWQ6IHN0cmluZztcclxuICBwdWJsaWMgcmVzb3VyY2VJZDogc3RyaW5nID0gXCJcIjtcclxuICBkZWNsYXJlIHRTY2FsZTogbnVtYmVyO1xyXG4gIHB1YmxpYyBpc1NlbGVjdGVkID0gZmFsc2U7XHJcbiAgZGVjbGFyZSBkaXNwbGF5OiBJRGlzcGxheTtcclxuICBkZWNsYXJlIHRyaW06IElUcmltO1xyXG4gIGRlY2xhcmUgcGxheWJhY2tSYXRlOiBudW1iZXI7XHJcbiAgZGVjbGFyZSBkdXJhdGlvbjogbnVtYmVyO1xyXG4gIHB1YmxpYyBwcmV2RHVyYXRpb246IG51bWJlcjtcclxuICBwdWJsaWMgaXRlbVR5cGUgPSBcInZpZGVvXCI7XHJcbiAgcHVibGljIG1ldGFkYXRhPzogUGFydGlhbDxJTWV0YWRhdGE+O1xyXG4gIGRlY2xhcmUgc3JjOiBzdHJpbmc7XHJcblxyXG4gIHB1YmxpYyBhc3BlY3RSYXRpbyA9IDE7XHJcbiAgcHVibGljIHNjcm9sbExlZnQgPSAwO1xyXG4gIHB1YmxpYyBmaWxtc3RyaXBCYWNrbG9nT3B0aW9ucz86IEZpbG1zdHJpcEJhY2tsb2dPcHRpb25zO1xyXG4gIHB1YmxpYyB0aHVtYm5haWxzUGVyU2VnbWVudCA9IDA7XHJcbiAgcHVibGljIHNlZ21lbnRTaXplID0gMDtcclxuXHJcbiAgcHVibGljIG9mZnNjcmVlblNlZ21lbnRzID0gMDtcclxuICBwdWJsaWMgdGh1bWJuYWlsV2lkdGg6IG51bWJlciA9IDA7XHJcbiAgcHVibGljIHRodW1ibmFpbEhlaWdodDogbnVtYmVyID0gNDA7XHJcbiAgcHVibGljIHRodW1ibmFpbHNMaXN0OiB7IHVybDogc3RyaW5nOyB0czogbnVtYmVyIH1bXSA9IFtdO1xyXG4gIHB1YmxpYyBpc0ZldGNoaW5nVGh1bWJuYWlscyA9IGZhbHNlO1xyXG4gIHB1YmxpYyB0aHVtYm5haWxDYWNoZSA9IG5ldyBUaHVtYm5haWxDYWNoZSgpO1xyXG5cclxuICBwdWJsaWMgY3VycmVudEZpbG1zdHJpcDogRmlsbXN0cmlwID0gRU1QVFlfRklMTVNUUklQO1xyXG4gIHB1YmxpYyBuZXh0RmlsbXN0cmlwOiBGaWxtc3RyaXAgPSB7IC4uLkVNUFRZX0ZJTE1TVFJJUCwgc2VnbWVudEluZGV4OiAwIH07XHJcbiAgcHVibGljIGxvYWRpbmdGaWxtc3RyaXA6IEZpbG1zdHJpcCA9IEVNUFRZX0ZJTE1TVFJJUDtcclxuXHJcbiAgcHJpdmF0ZSBvZmZzY3JlZW5DYW52YXM6IE9mZnNjcmVlbkNhbnZhcyB8IG51bGwgPSBudWxsO1xyXG4gIHByaXZhdGUgb2Zmc2NyZWVuQ3R4OiBPZmZzY3JlZW5DYW52YXNSZW5kZXJpbmdDb250ZXh0MkQgfCBudWxsID0gbnVsbDtcclxuXHJcbiAgcHJpdmF0ZSBpc0RpcnR5OiBib29sZWFuID0gdHJ1ZTtcclxuXHJcbiAgcHJpdmF0ZSBmYWxsYmFja1NlZ21lbnRJbmRleDogbnVtYmVyID0gMDtcclxuICBwcml2YXRlIGZhbGxiYWNrU2VnbWVudHNDb3VudDogbnVtYmVyID0gMDtcclxuICBwcml2YXRlIHByZXZpZXdVcmw6IHN0cmluZyA9IFwiXCI7XHJcblxyXG4gIHN0YXRpYyBjcmVhdGVDb250cm9scygpOiB7IGNvbnRyb2xzOiBSZWNvcmQ8c3RyaW5nLCBDb250cm9sPiB9IHtcclxuICAgIHJldHVybiB7IGNvbnRyb2xzOiBjcmVhdGVNZWRpYUNvbnRyb2xzKCkgfTtcclxuICB9XHJcblxyXG4gIGNvbnN0cnVjdG9yKHByb3BzOiBWaWRlb1Byb3BzKSB7XHJcbiAgICBzdXBlcihwcm9wcyk7XHJcbiAgICB0aGlzLmlkID0gcHJvcHMuaWQ7XHJcbiAgICB0aGlzLnRTY2FsZSA9IHByb3BzLnRTY2FsZTtcclxuICAgIHRoaXMub2JqZWN0Q2FjaGluZyA9IGZhbHNlO1xyXG4gICAgdGhpcy5yeCA9IDQ7XHJcbiAgICB0aGlzLnJ5ID0gNDtcclxuICAgIHRoaXMuZGlzcGxheSA9IHByb3BzLmRpc3BsYXk7XHJcbiAgICB0aGlzLnRyaW0gPSBwcm9wcy50cmltO1xyXG4gICAgdGhpcy5kdXJhdGlvbiA9IHByb3BzLmR1cmF0aW9uO1xyXG4gICAgdGhpcy5wcmV2RHVyYXRpb24gPSBwcm9wcy5kdXJhdGlvbjtcclxuICAgIHRoaXMuZmlsbCA9IFwiIzI3MjcyYVwiO1xyXG4gICAgdGhpcy5ib3JkZXJPcGFjaXR5V2hlbk1vdmluZyA9IDE7XHJcbiAgICB0aGlzLm1ldGFkYXRhID0gcHJvcHMubWV0YWRhdGE7XHJcblxyXG4gICAgdGhpcy5hc3BlY3RSYXRpbyA9IHByb3BzLmFzcGVjdFJhdGlvO1xyXG5cclxuICAgIHRoaXMuc3JjID0gcHJvcHMuc3JjO1xyXG4gICAgdGhpcy5zdHJva2VXaWR0aCA9IDA7XHJcblxyXG4gICAgdGhpcy50cmFuc3BhcmVudENvcm5lcnMgPSBmYWxzZTtcclxuICAgIHRoaXMuaGFzQm9yZGVycyA9IGZhbHNlO1xyXG5cclxuICAgIHRoaXMucHJldmlld1VybCA9IHByb3BzLm1ldGFkYXRhPy5wcmV2aWV3VXJsO1xyXG4gICAgdGhpcy5pbml0T2Zmc2NyZWVuQ2FudmFzKCk7XHJcbiAgICB0aGlzLmluaXRpYWxpemUoKTtcclxuICB9XHJcblxyXG4gIHByaXZhdGUgaW5pdE9mZnNjcmVlbkNhbnZhcygpIHtcclxuICAgIGlmICghdGhpcy5vZmZzY3JlZW5DYW52YXMpIHtcclxuICAgICAgdGhpcy5vZmZzY3JlZW5DYW52YXMgPSBuZXcgT2Zmc2NyZWVuQ2FudmFzKHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTtcclxuICAgICAgdGhpcy5vZmZzY3JlZW5DdHggPSB0aGlzLm9mZnNjcmVlbkNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gUmVzaXplIGlmIGRpbWVuc2lvbnMgY2hhbmdlZFxyXG4gICAgaWYgKFxyXG4gICAgICB0aGlzLm9mZnNjcmVlbkNhbnZhcy53aWR0aCAhPT0gdGhpcy53aWR0aCB8fFxyXG4gICAgICB0aGlzLm9mZnNjcmVlbkNhbnZhcy5oZWlnaHQgIT09IHRoaXMuaGVpZ2h0XHJcbiAgICApIHtcclxuICAgICAgdGhpcy5vZmZzY3JlZW5DYW52YXMud2lkdGggPSB0aGlzLndpZHRoO1xyXG4gICAgICB0aGlzLm9mZnNjcmVlbkNhbnZhcy5oZWlnaHQgPSB0aGlzLmhlaWdodDtcclxuICAgICAgdGhpcy5pc0RpcnR5ID0gdHJ1ZTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHB1YmxpYyBpbml0RGltZW5zaW9ucygpIHtcclxuICAgIHRoaXMudGh1bWJuYWlsV2lkdGggPSB0aGlzLnRodW1ibmFpbEhlaWdodCAqIHRoaXMuYXNwZWN0UmF0aW87XHJcblxyXG4gICAgY29uc3Qgc2VnbWVudE9wdGlvbnMgPSBjYWxjdWxhdGVUaHVtYm5haWxTZWdtZW50TGF5b3V0KHRoaXMudGh1bWJuYWlsV2lkdGgpO1xyXG4gICAgdGhpcy50aHVtYm5haWxzUGVyU2VnbWVudCA9IHNlZ21lbnRPcHRpb25zLnRodW1ibmFpbHNQZXJTZWdtZW50O1xyXG4gICAgdGhpcy5zZWdtZW50U2l6ZSA9IHNlZ21lbnRPcHRpb25zLnNlZ21lbnRTaXplO1xyXG4gIH1cclxuXHJcbiAgcHVibGljIGFzeW5jIGluaXRpYWxpemUoKSB7XHJcbiAgICBhd2FpdCB0aGlzLmxvYWRGYWxsYmFja1RodW1ibmFpbCgpO1xyXG5cclxuICAgIHRoaXMuaW5pdERpbWVuc2lvbnMoKTtcclxuICAgIHRoaXMub25TY3JvbGxDaGFuZ2UoeyBzY3JvbGxMZWZ0OiAwIH0pO1xyXG5cclxuICAgIHRoaXMuY2FudmFzPy5yZXF1ZXN0UmVuZGVyQWxsKCk7XHJcblxyXG4gICAgdGhpcy5jcmVhdGVGYWxsYmFja1BhdHRlcm4oKTtcclxuICAgIGF3YWl0IHRoaXMucHJlcGFyZUFzc2V0cygpO1xyXG5cclxuICAgIHRoaXMub25TY3JvbGxDaGFuZ2UoeyBzY3JvbGxMZWZ0OiAwIH0pO1xyXG4gIH1cclxuXHJcbiAgcHVibGljIGFzeW5jIHByZXBhcmVBc3NldHMoKSB7XHJcbiAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gXCJ1bmRlZmluZWRcIikgcmV0dXJuO1xyXG5cclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IHsgTVA0Q2xpcCB9ID0gYXdhaXQgaW1wb3J0KFwiQGRlc2lnbmNvbWJvL2ZyYW1lc1wiKTtcclxuICAgICAgY29uc3QgZmlsZSA9IGF3YWl0IGdldEZpbGVGcm9tVXJsKHRoaXMuc3JjKTtcclxuICAgICAgY29uc3Qgc3RyZWFtID0gZmlsZS5zdHJlYW0oKTtcclxuICAgICAgdGhpcy5jbGlwID0gbmV3IE1QNENsaXAoc3RyZWFtKTtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBsb2FkaW5nIE1QNENsaXA6XCIsIGVycm9yKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHByaXZhdGUgY2FsY3VsYXRlRmlsbXN0cmlwRGltZW5zaW9ucyh7XHJcbiAgICBzZWdtZW50SW5kZXgsXHJcbiAgICB3aWR0aE9uU2NyZWVuLFxyXG4gIH06IHtcclxuICAgIHNlZ21lbnRJbmRleDogbnVtYmVyO1xyXG4gICAgd2lkdGhPblNjcmVlbjogbnVtYmVyO1xyXG4gIH0pIHtcclxuICAgIGNvbnN0IGZpbG1zdHJpcE9mZnNldCA9IHNlZ21lbnRJbmRleCAqIHRoaXMuc2VnbWVudFNpemU7XHJcbiAgICBjb25zdCBzaG91bGRVc2VMZWZ0QmFja2xvZyA9IHNlZ21lbnRJbmRleCA+IDA7XHJcbiAgICBjb25zdCBsZWZ0QmFja2xvZ1NpemUgPSBzaG91bGRVc2VMZWZ0QmFja2xvZyA/IHRoaXMuc2VnbWVudFNpemUgOiAwO1xyXG5cclxuICAgIGNvbnN0IHRvdGFsV2lkdGggPSB0aW1lTXNUb1VuaXRzKFxyXG4gICAgICB0aGlzLmR1cmF0aW9uLFxyXG4gICAgICB0aGlzLnRTY2FsZSxcclxuICAgICAgdGhpcy5wbGF5YmFja1JhdGUsXHJcbiAgICApO1xyXG5cclxuICAgIGNvbnN0IHJpZ2h0UmVtYWluaW5nU2l6ZSA9XHJcbiAgICAgIHRvdGFsV2lkdGggLSB3aWR0aE9uU2NyZWVuIC0gbGVmdEJhY2tsb2dTaXplIC0gZmlsbXN0cmlwT2Zmc2V0O1xyXG4gICAgY29uc3QgcmlnaHRCYWNrbG9nU2l6ZSA9IE1hdGgubWluKHRoaXMuc2VnbWVudFNpemUsIHJpZ2h0UmVtYWluaW5nU2l6ZSk7XHJcblxyXG4gICAgY29uc3QgZmlsbXN0cmlwU3RhcnRUaW1lID0gdW5pdHNUb1RpbWVNcyhmaWxtc3RyaXBPZmZzZXQsIHRoaXMudFNjYWxlKTtcclxuICAgIGNvbnN0IGZpbG1zdHJpbXBUaHVtYm5haWxzQ291bnQgPVxyXG4gICAgICAxICtcclxuICAgICAgTWF0aC5yb3VuZChcclxuICAgICAgICAod2lkdGhPblNjcmVlbiArIGxlZnRCYWNrbG9nU2l6ZSArIHJpZ2h0QmFja2xvZ1NpemUpIC9cclxuICAgICAgICAgIHRoaXMudGh1bWJuYWlsV2lkdGgsXHJcbiAgICAgICk7XHJcblxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgZmlsbXN0cmlwT2Zmc2V0LFxyXG4gICAgICBsZWZ0QmFja2xvZ1NpemUsXHJcbiAgICAgIHJpZ2h0QmFja2xvZ1NpemUsXHJcbiAgICAgIGZpbG1zdHJpcFN0YXJ0VGltZSxcclxuICAgICAgZmlsbXN0cmltcFRodW1ibmFpbHNDb3VudCxcclxuICAgIH07XHJcbiAgfVxyXG5cclxuICAvLyBsb2FkIGZhbGxiYWNrIHRodW1ibmFpbCwgcmVzaXplIGl0IGFuZCBjYWNoZSBpdFxyXG4gIHByaXZhdGUgYXN5bmMgbG9hZEZhbGxiYWNrVGh1bWJuYWlsKCkge1xyXG4gICAgY29uc3QgZmFsbGJhY2tUaHVtYm5haWwgPSB0aGlzLnByZXZpZXdVcmw7XHJcbiAgICBpZiAoIWZhbGxiYWNrVGh1bWJuYWlsKSByZXR1cm47XHJcblxyXG4gICAgY29uc29sZS5sb2coXCJbREVCVUddIENhcmdhbmRvIHRodW1ibmFpbCBwYXJhIHZpZGVvOlwiLCB0aGlzLmlkLCBcIlVSTCB0aXBvOlwiLCBmYWxsYmFja1RodW1ibmFpbC5zdWJzdHJpbmcoMCwgMzApICsgXCIuLi5cIik7XHJcblxyXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlPHZvaWQ+KChyZXNvbHZlKSA9PiB7XHJcbiAgICAgIGNvbnN0IGltZyA9IG5ldyBJbWFnZSgpO1xyXG4gICAgICBpbWcuY3Jvc3NPcmlnaW4gPSBcImFub255bW91c1wiO1xyXG5cclxuICAgICAgLy8gUGFyYSBVUkxzIGRlIGRhdG9zIHkgVVJMcyBkZSBvYmpldG8sIG5vIG5lY2VzaXRhbW9zIGHDsWFkaXIgcGFyw6FtZXRyb3MgZXh0cmFcclxuICAgICAgaWYgKGZhbGxiYWNrVGh1bWJuYWlsLnN0YXJ0c1dpdGgoJ2RhdGE6JykgfHwgZmFsbGJhY2tUaHVtYm5haWwuc3RhcnRzV2l0aCgnYmxvYjonKSkge1xyXG4gICAgICAgIGltZy5zcmMgPSBmYWxsYmFja1RodW1ibmFpbDtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICAvLyBQYXJhIFVSTHMgcmVtb3RhcywgYcOxYWRpbW9zIHVuIHRpbWVzdGFtcCBwYXJhIGV2aXRhciBjYWNow6lcclxuICAgICAgICBpbWcuc3JjID0gZmFsbGJhY2tUaHVtYm5haWwgKyBcIj90PVwiICsgRGF0ZS5ub3coKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaW1nLm9ubG9hZCA9ICgpID0+IHtcclxuICAgICAgICAvLyBDcmVhdGUgYSB0ZW1wb3JhcnkgY2FudmFzIHRvIHJlc2l6ZSB0aGUgaW1hZ2VcclxuICAgICAgICBjb25zdCBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpO1xyXG4gICAgICAgIGNvbnN0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIikhO1xyXG5cclxuICAgICAgICAvLyBDYWxjdWxhdGUgbmV3IHdpZHRoIG1haW50YWluaW5nIGFzcGVjdCByYXRpb1xyXG4gICAgICAgIGNvbnN0IGFzcGVjdFJhdGlvID0gaW1nLndpZHRoIC8gaW1nLmhlaWdodDtcclxuICAgICAgICBjb25zdCB0YXJnZXRIZWlnaHQgPSA0MDtcclxuICAgICAgICBjb25zdCB0YXJnZXRXaWR0aCA9IE1hdGgucm91bmQodGFyZ2V0SGVpZ2h0ICogYXNwZWN0UmF0aW8pO1xyXG5cclxuICAgICAgICAvLyBTZXQgY2FudmFzIHNpemUgYW5kIGRyYXcgcmVzaXplZCBpbWFnZVxyXG4gICAgICAgIGNhbnZhcy5oZWlnaHQgPSB0YXJnZXRIZWlnaHQ7XHJcbiAgICAgICAgY2FudmFzLndpZHRoID0gdGFyZ2V0V2lkdGg7XHJcbiAgICAgICAgY3R4LmRyYXdJbWFnZShpbWcsIDAsIDAsIHRhcmdldFdpZHRoLCB0YXJnZXRIZWlnaHQpO1xyXG5cclxuICAgICAgICAvLyBDcmVhdGUgbmV3IGltYWdlIGZyb20gcmVzaXplZCBjYW52YXNcclxuICAgICAgICBjb25zdCByZXNpemVkSW1nID0gbmV3IEltYWdlKCk7XHJcbiAgICAgICAgcmVzaXplZEltZy5zcmMgPSBjYW52YXMudG9EYXRhVVJMKCk7XHJcblxyXG4gICAgICAgIC8vIFVwZGF0ZSBhc3BlY3QgcmF0aW8gYW5kIGNhY2hlIHRoZSByZXNpemVkIGltYWdlXHJcbiAgICAgICAgdGhpcy5hc3BlY3RSYXRpbyA9IGFzcGVjdFJhdGlvO1xyXG4gICAgICAgIHRoaXMudGh1bWJuYWlsV2lkdGggPSB0YXJnZXRXaWR0aDtcclxuICAgICAgICB0aGlzLnRodW1ibmFpbENhY2hlLnNldFRodW1ibmFpbChcImZhbGxiYWNrXCIsIHJlc2l6ZWRJbWcpO1xyXG5cclxuICAgICAgICBjb25zb2xlLmxvZyhcIltERUJVR10gVGh1bWJuYWlsIGNhcmdhZG8gY29ycmVjdGFtZW50ZSBwYXJhIHZpZGVvOlwiLCB0aGlzLmlkKTtcclxuICAgICAgICByZXNvbHZlKCk7XHJcbiAgICAgIH07XHJcblxyXG4gICAgICBpbWcub25lcnJvciA9IChlcnIpID0+IHtcclxuICAgICAgICBjb25zb2xlLmVycm9yKFwiW0VSUk9SXSBObyBzZSBwdWRvIGNhcmdhciBsYSBtaW5pYXR1cmE6XCIsIGVycik7XHJcbiAgICAgICAgcmVzb2x2ZSgpOyAvLyBSZXNvbHZlciBkZSB0b2RvcyBtb2RvcyBwYXJhIG5vIGJsb3F1ZWFyIGxhIGNhcmdhXHJcbiAgICAgIH07XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIHByaXZhdGUgZ2VuZXJhdGVUaW1lc3RhbXBzKHN0YXJ0VGltZTogbnVtYmVyLCBjb3VudDogbnVtYmVyKTogbnVtYmVyW10ge1xyXG4gICAgY29uc3QgdGltZVBlclRodW1ibmFpbCA9IHVuaXRzVG9UaW1lTXMoXHJcbiAgICAgIHRoaXMudGh1bWJuYWlsV2lkdGgsXHJcbiAgICAgIHRoaXMudFNjYWxlLFxyXG4gICAgICB0aGlzLnBsYXliYWNrUmF0ZSxcclxuICAgICk7XHJcblxyXG4gICAgcmV0dXJuIEFycmF5LmZyb20oeyBsZW5ndGg6IGNvdW50IH0sIChfLCBpKSA9PiB7XHJcbiAgICAgIGNvbnN0IHRpbWVJbkZpbG1zdHJpcGUgPSBzdGFydFRpbWUgKyBpICogdGltZVBlclRodW1ibmFpbDtcclxuICAgICAgcmV0dXJuIE1hdGguY2VpbCh0aW1lSW5GaWxtc3RyaXBlIC8gMTAwMCk7XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIHByaXZhdGUgY3JlYXRlRmFsbGJhY2tQYXR0ZXJuKCkge1xyXG4gICAgY29uc3QgY2FudmFzID0gdGhpcy5jYW52YXM7XHJcbiAgICBpZiAoIWNhbnZhcykgcmV0dXJuO1xyXG5cclxuICAgIGNvbnN0IGNhbnZhc1dpZHRoID0gdGhpcy5jYW52YXMhLndpZHRoO1xyXG4gICAgY29uc3QgbWF4UGF0dGVyblNpemUgPSAxMjAwMDtcclxuICAgIGNvbnN0IGZhbGxiYWNrU291cmNlID0gdGhpcy50aHVtYm5haWxDYWNoZS5nZXRUaHVtYm5haWwoXCJmYWxsYmFja1wiKTtcclxuXHJcbiAgICBpZiAoIWZhbGxiYWNrU291cmNlKSByZXR1cm47XHJcblxyXG4gICAgLy8gQ29tcHV0ZSB0aGUgdG90YWwgd2lkdGggYW5kIG51bWJlciBvZiBzZWdtZW50cyBuZWVkZWRcclxuICAgIGNvbnN0IHRvdGFsV2lkdGhOZWVkZWQgPSBNYXRoLm1pbihjYW52YXNXaWR0aCAqIDIwLCBtYXhQYXR0ZXJuU2l6ZSk7XHJcbiAgICBjb25zdCBzZWdtZW50c1JlcXVpcmVkID0gTWF0aC5jZWlsKHRvdGFsV2lkdGhOZWVkZWQgLyB0aGlzLnNlZ21lbnRTaXplKTtcclxuICAgIHRoaXMuZmFsbGJhY2tTZWdtZW50c0NvdW50ID0gc2VnbWVudHNSZXF1aXJlZDtcclxuICAgIGNvbnN0IHBhdHRlcm5XaWR0aCA9IHNlZ21lbnRzUmVxdWlyZWQgKiB0aGlzLnNlZ21lbnRTaXplO1xyXG5cclxuICAgIC8vIFNldHVwIGNhbnZhcyBkaW1lbnNpb25zXHJcbiAgICBjb25zdCBvZmZDYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpO1xyXG4gICAgb2ZmQ2FudmFzLmhlaWdodCA9IHRoaXMudGh1bWJuYWlsSGVpZ2h0O1xyXG4gICAgb2ZmQ2FudmFzLndpZHRoID0gcGF0dGVybldpZHRoO1xyXG5cclxuICAgIGNvbnN0IGNvbnRleHQgPSBvZmZDYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpITtcclxuICAgIGNvbnN0IHRodW1ibmFpbHNUb3RhbCA9IHNlZ21lbnRzUmVxdWlyZWQgKiB0aGlzLnRodW1ibmFpbHNQZXJTZWdtZW50O1xyXG5cclxuICAgIC8vIERyYXcgdGhlIGZhbGxiYWNrIGltYWdlIGFjcm9zcyB0aGUgZW50aXJldHkgb2YgdGhlIGNhbnZhcyBob3Jpem9udGFsbHlcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGh1bWJuYWlsc1RvdGFsOyBpKyspIHtcclxuICAgICAgY29uc3QgeCA9IGkgKiB0aGlzLnRodW1ibmFpbFdpZHRoO1xyXG4gICAgICBjb250ZXh0LmRyYXdJbWFnZShcclxuICAgICAgICBmYWxsYmFja1NvdXJjZSxcclxuICAgICAgICB4LFxyXG4gICAgICAgIDAsXHJcbiAgICAgICAgdGhpcy50aHVtYm5haWxXaWR0aCxcclxuICAgICAgICB0aGlzLnRodW1ibmFpbEhlaWdodCxcclxuICAgICAgKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBDcmVhdGUgdGhlIHBhdHRlcm4gYW5kIGFwcGx5IGl0XHJcbiAgICBjb25zdCBmaWxsUGF0dGVybiA9IG5ldyBQYXR0ZXJuKHtcclxuICAgICAgc291cmNlOiBvZmZDYW52YXMsXHJcbiAgICAgIHJlcGVhdDogXCJuby1yZXBlYXRcIixcclxuICAgICAgb2Zmc2V0WDogMCxcclxuICAgIH0pO1xyXG5cclxuICAgIHRoaXMuc2V0KFwiZmlsbFwiLCBmaWxsUGF0dGVybik7XHJcbiAgICB0aGlzLmNhbnZhcz8ucmVxdWVzdFJlbmRlckFsbCgpO1xyXG4gIH1cclxuICBwdWJsaWMgYXN5bmMgbG9hZEFuZFJlbmRlclRodW1ibmFpbHMoKSB7XHJcbiAgICBpZiAodGhpcy5pc0ZldGNoaW5nVGh1bWJuYWlscyB8fCAhdGhpcy5jbGlwKSByZXR1cm47XHJcbiAgICAvLyBzZXQgc2VnbWVudERyYXduIHRvIHNlZ21lbnRUb0RyYXdcclxuICAgIHRoaXMubG9hZGluZ0ZpbG1zdHJpcCA9IHsgLi4udGhpcy5uZXh0RmlsbXN0cmlwIH07XHJcbiAgICB0aGlzLmlzRmV0Y2hpbmdUaHVtYm5haWxzID0gdHJ1ZTtcclxuXHJcbiAgICAvLyBDYWxjdWxhdGUgZGltZW5zaW9ucyBhbmQgb2Zmc2V0c1xyXG4gICAgY29uc3QgeyBzdGFydFRpbWUsIHRodW1ibmFpbHNDb3VudCB9ID0gdGhpcy5sb2FkaW5nRmlsbXN0cmlwO1xyXG5cclxuICAgIC8vIEdlbmVyYXRlIHJlcXVpcmVkIHRpbWVzdGFtcHNcclxuICAgIGNvbnN0IHRpbWVzdGFtcHMgPSB0aGlzLmdlbmVyYXRlVGltZXN0YW1wcyhzdGFydFRpbWUsIHRodW1ibmFpbHNDb3VudCk7XHJcblxyXG4gICAgLy8gTWF0Y2ggYW5kIHByZXBhcmUgdGh1bWJuYWlsc1xyXG4gICAgbGV0IHRodW1ibmFpbHNBcnIgPSBhd2FpdCB0aGlzLmNsaXAudGh1bWJuYWlsc0xpc3QodGhpcy50aHVtYm5haWxXaWR0aCwge1xyXG4gICAgICB0aW1lc3RhbXBzOiB0aW1lc3RhbXBzLm1hcCgodGltZXN0YW1wKSA9PiB0aW1lc3RhbXAgKiAxZTYpLFxyXG4gICAgfSk7XHJcblxyXG4gICAgY29uc3QgdXBkYXRlZFRodW1ibmFpbHMgPSB0aHVtYm5haWxzQXJyLm1hcCgodGh1bWJuYWlsKSA9PiB7XHJcbiAgICAgIHJldHVybiB7XHJcbiAgICAgICAgdHM6IE1hdGgucm91bmQodGh1bWJuYWlsLnRzIC8gMWU2KSxcclxuICAgICAgICBpbWc6IHRodW1ibmFpbC5pbWcsXHJcbiAgICAgIH07XHJcbiAgICB9KTtcclxuXHJcbiAgICAvLyBMb2FkIGFsbCB0aHVtYm5haWxzIGluIHBhcmFsbGVsXHJcbiAgICBhd2FpdCB0aGlzLmxvYWRUaHVtYm5haWxCYXRjaCh1cGRhdGVkVGh1bWJuYWlscyk7XHJcblxyXG4gICAgdGhpcy5pc0RpcnR5ID0gdHJ1ZTsgLy8gTWFyayBhcyBkaXJ0eSBhZnRlciBwcmVwYXJpbmcgbmV3IHRodW1ibmFpbHNcclxuICAgIC8vIHRoaXMuaXNGYWxsYmFja0RpcnR5ID0gdHJ1ZTtcclxuICAgIHRoaXMuaXNGZXRjaGluZ1RodW1ibmFpbHMgPSBmYWxzZTtcclxuXHJcbiAgICB0aGlzLmN1cnJlbnRGaWxtc3RyaXAgPSB7IC4uLnRoaXMubG9hZGluZ0ZpbG1zdHJpcCB9O1xyXG5cclxuICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XHJcbiAgICAgIHRoaXMuY2FudmFzPy5yZXF1ZXN0UmVuZGVyQWxsKCk7XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIHByaXZhdGUgYXN5bmMgbG9hZFRodW1ibmFpbEJhdGNoKHRodW1ibmFpbHM6IHsgdHM6IG51bWJlcjsgaW1nOiBCbG9iIH1bXSkge1xyXG4gICAgY29uc3QgbG9hZFByb21pc2VzID0gdGh1bWJuYWlscy5tYXAoYXN5bmMgKHRodW1ibmFpbCkgPT4ge1xyXG4gICAgICBpZiAodGhpcy50aHVtYm5haWxDYWNoZS5nZXRUaHVtYm5haWwodGh1bWJuYWlsLnRzKSkgcmV0dXJuO1xyXG5cclxuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlPHZvaWQ+KChyZXNvbHZlKSA9PiB7XHJcbiAgICAgICAgY29uc3QgaW1nID0gbmV3IEltYWdlKCk7XHJcbiAgICAgICAgaW1nLnNyYyA9IFVSTC5jcmVhdGVPYmplY3RVUkwodGh1bWJuYWlsLmltZyk7XHJcbiAgICAgICAgaW1nLm9ubG9hZCA9ICgpID0+IHtcclxuICAgICAgICAgIFVSTC5yZXZva2VPYmplY3RVUkwoaW1nLnNyYyk7IC8vIENsZWFuIHVwIHRoZSBibG9iIFVSTCBhZnRlciBpbWFnZSBsb2Fkc1xyXG4gICAgICAgICAgdGhpcy50aHVtYm5haWxDYWNoZS5zZXRUaHVtYm5haWwodGh1bWJuYWlsLnRzLCBpbWcpO1xyXG4gICAgICAgICAgcmVzb2x2ZSgpO1xyXG4gICAgICAgIH07XHJcbiAgICAgIH0pO1xyXG4gICAgfSk7XHJcblxyXG4gICAgYXdhaXQgUHJvbWlzZS5hbGwobG9hZFByb21pc2VzKTtcclxuICB9XHJcblxyXG4gIHB1YmxpYyBfcmVuZGVyKGN0eDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEKSB7XHJcbiAgICBzdXBlci5fcmVuZGVyKGN0eCk7XHJcblxyXG4gICAgY3R4LnNhdmUoKTtcclxuICAgIGN0eC50cmFuc2xhdGUoLXRoaXMud2lkdGggLyAyLCAtdGhpcy5oZWlnaHQgLyAyKTtcclxuXHJcbiAgICAvLyBDbGlwIHRoZSBhcmVhIHRvIHByZXZlbnQgZHJhd2luZyBvdXRzaWRlXHJcbiAgICBjdHguYmVnaW5QYXRoKCk7XHJcbiAgICBjdHgucmVjdCgwLCAwLCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7XHJcbiAgICBjdHguY2xpcCgpO1xyXG5cclxuICAgIHRoaXMucmVuZGVyVG9PZmZzY3JlZW4oKTtcclxuXHJcbiAgICBjdHguZHJhd0ltYWdlKHRoaXMub2Zmc2NyZWVuQ2FudmFzISwgMCwgMCk7XHJcblxyXG4gICAgY3R4LnJlc3RvcmUoKTtcclxuICAgIC8vIHRoaXMuZHJhd1RleHRJZGVudGl0eShjdHgpO1xyXG4gICAgdGhpcy51cGRhdGVTZWxlY3RlZChjdHgpO1xyXG4gIH1cclxuXHJcbiAgcHVibGljIHNldER1cmF0aW9uKGR1cmF0aW9uOiBudW1iZXIpIHtcclxuICAgIHRoaXMuZHVyYXRpb24gPSBkdXJhdGlvbjtcclxuICAgIHRoaXMucHJldkR1cmF0aW9uID0gZHVyYXRpb247XHJcbiAgfVxyXG5cclxuICBwdWJsaWMgYXN5bmMgc2V0U3JjKHNyYzogc3RyaW5nKSB7XHJcbiAgICBzdXBlci5zZXRTcmMoc3JjKTtcclxuICAgIHRoaXMuY2xpcCA9IG51bGw7XHJcbiAgICBhd2FpdCB0aGlzLmluaXRpYWxpemUoKTtcclxuICAgIGF3YWl0IHRoaXMucHJlcGFyZUFzc2V0cygpO1xyXG4gICAgdGhpcy50aHVtYm5haWxDYWNoZS5jbGVhckNhY2hlQnV0RmFsbGJhY2soKTtcclxuICAgIHRoaXMub25TY2FsZSgpO1xyXG4gIH1cclxuICBwdWJsaWMgb25SZXNpemVTbmFwKCkge1xyXG4gICAgdGhpcy5yZW5kZXJUb09mZnNjcmVlbih0cnVlKTtcclxuICB9XHJcbiAgcHVibGljIG9uUmVzaXplKCkge1xyXG4gICAgdGhpcy5yZW5kZXJUb09mZnNjcmVlbih0cnVlKTtcclxuICB9XHJcblxyXG4gIHB1YmxpYyByZW5kZXJUb09mZnNjcmVlbihmb3JjZT86IGJvb2xlYW4pIHtcclxuICAgIGlmICghdGhpcy5vZmZzY3JlZW5DdHgpIHJldHVybjtcclxuICAgIGlmICghdGhpcy5pc0RpcnR5ICYmICFmb3JjZSkgcmV0dXJuO1xyXG5cclxuICAgIHRoaXMub2Zmc2NyZWVuQ2FudmFzIS53aWR0aCA9IHRoaXMud2lkdGg7XHJcbiAgICBjb25zdCBjdHggPSB0aGlzLm9mZnNjcmVlbkN0eDtcclxuICAgIGNvbnN0IHsgc3RhcnRUaW1lLCBvZmZzZXQsIHRodW1ibmFpbHNDb3VudCB9ID0gdGhpcy5jdXJyZW50RmlsbXN0cmlwO1xyXG4gICAgY29uc3QgdGh1bWJuYWlsV2lkdGggPSB0aGlzLnRodW1ibmFpbFdpZHRoO1xyXG4gICAgY29uc3QgdGh1bWJuYWlsSGVpZ2h0ID0gdGhpcy50aHVtYm5haWxIZWlnaHQ7XHJcblxyXG4gICAgLy8gQ2FsY3VsYXRlIHRoZSBvZmZzZXQgY2F1c2VkIGJ5IHRoZSB0cmltbWluZ1xyXG4gICAgY29uc3QgdHJpbUZyb21TaXplID0gdGltZU1zVG9Vbml0cyhcclxuICAgICAgdGhpcy50cmltLmZyb20sXHJcbiAgICAgIHRoaXMudFNjYWxlLFxyXG4gICAgICB0aGlzLnBsYXliYWNrUmF0ZSxcclxuICAgICk7XHJcblxyXG4gICAgbGV0IHRpbWVJbkZpbG1zdHJpcGUgPSBzdGFydFRpbWU7XHJcbiAgICBjb25zdCB0aW1lUGVyVGh1bWJuYWlsID0gdW5pdHNUb1RpbWVNcyhcclxuICAgICAgdGh1bWJuYWlsV2lkdGgsXHJcbiAgICAgIHRoaXMudFNjYWxlLFxyXG4gICAgICB0aGlzLnBsYXliYWNrUmF0ZSxcclxuICAgICk7XHJcblxyXG4gICAgLy8gQ2xlYXIgdGhlIG9mZnNjcmVlbiBjYW52YXNcclxuICAgIGN0eC5jbGVhclJlY3QoMCwgMCwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xyXG5cclxuICAgIC8vIENsaXAgd2l0aCByb3VuZGVkIGNvcm5lcnNcclxuICAgIGN0eC5iZWdpblBhdGgoKTtcclxuICAgIGN0eC5yb3VuZFJlY3QoMCwgMCwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQsIHRoaXMucngpO1xyXG4gICAgY3R4LmNsaXAoKTtcclxuICAgIC8vIERyYXcgdGh1bWJuYWlsc1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aHVtYm5haWxzQ291bnQ7IGkrKykge1xyXG4gICAgICBsZXQgaW1nID0gdGhpcy50aHVtYm5haWxDYWNoZS5nZXRUaHVtYm5haWwoXHJcbiAgICAgICAgTWF0aC5jZWlsKHRpbWVJbkZpbG1zdHJpcGUgLyAxMDAwKSxcclxuICAgICAgKTtcclxuXHJcbiAgICAgIGlmICghaW1nKSB7XHJcbiAgICAgICAgaW1nID0gdGhpcy50aHVtYm5haWxDYWNoZS5nZXRUaHVtYm5haWwoXCJmYWxsYmFja1wiKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKGltZyAmJiBpbWcuY29tcGxldGUpIHtcclxuICAgICAgICBjb25zdCB4UG9zaXRpb24gPSBpICogdGh1bWJuYWlsV2lkdGggKyBvZmZzZXQgLSB0cmltRnJvbVNpemU7XHJcblxyXG4gICAgICAgIGN0eC5kcmF3SW1hZ2UoaW1nLCB4UG9zaXRpb24sIDAsIHRodW1ibmFpbFdpZHRoLCB0aHVtYm5haWxIZWlnaHQpO1xyXG4gICAgICAgIHRpbWVJbkZpbG1zdHJpcGUgKz0gdGltZVBlclRodW1ibmFpbDtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuaXNEaXJ0eSA9IGZhbHNlO1xyXG4gIH1cclxuXHJcbiAgcHVibGljIGRyYXdUZXh0SWRlbnRpdHkoY3R4OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQpIHtcclxuICAgIGNvbnN0IGljb25QYXRoID0gbmV3IFBhdGgyRChcclxuICAgICAgXCJNMTYuNTYyNSAwLjkyNUwxMi41IDMuMjc1VjAuNjI1TDExLjg3NSAwSDAuNjI1TDAgMC42MjVWOS4zNzVMMC42MjUgMTBIMTEuODc1TDEyLjUgOS4zNzVWNi44NzVMMTYuNTYyNSA5LjIxMjVMMTcuNSA4LjYyNVYxLjQ3NUwxNi41NjI1IDAuOTI1Wk0xMS4yNSA4Ljc1SDEuMjVWMS4yNUgxMS4yNVY4Ljc1Wk0xNi4yNSA3LjVMMTIuNSA1LjM3NVY0LjcyNUwxNi4yNSAyLjVWNy41WlwiLFxyXG4gICAgKTtcclxuICAgIGN0eC5zYXZlKCk7XHJcbiAgICBjdHgudHJhbnNsYXRlKC10aGlzLndpZHRoIC8gMiwgLXRoaXMuaGVpZ2h0IC8gMik7XHJcbiAgICBjdHgudHJhbnNsYXRlKDAsIDE0KTtcclxuICAgIGN0eC5mb250ID0gXCI2MDAgMTJweCAnR2Vpc3QgdmFyaWFibGUnXCI7XHJcbiAgICBjdHguZmlsbFN0eWxlID0gXCIjZjRmNGY1XCI7XHJcbiAgICBjdHgudGV4dEFsaWduID0gXCJsZWZ0XCI7XHJcbiAgICBjdHguY2xpcCgpO1xyXG4gICAgY3R4LmZpbGxUZXh0KFwiVmlkZW9cIiwgMzYsIDEwKTtcclxuXHJcbiAgICBjdHgudHJhbnNsYXRlKDgsIDEpO1xyXG5cclxuICAgIGN0eC5maWxsU3R5bGUgPSBcIiNmNGY0ZjVcIjtcclxuICAgIGN0eC5maWxsKGljb25QYXRoKTtcclxuICAgIGN0eC5yZXN0b3JlKCk7XHJcbiAgfVxyXG5cclxuICBwdWJsaWMgc2V0U2VsZWN0ZWQoc2VsZWN0ZWQ6IGJvb2xlYW4pIHtcclxuICAgIHRoaXMuaXNTZWxlY3RlZCA9IHNlbGVjdGVkO1xyXG4gICAgdGhpcy5zZXQoeyBkaXJ0eTogdHJ1ZSB9KTtcclxuICB9XHJcblxyXG4gIHB1YmxpYyB1cGRhdGVTZWxlY3RlZChjdHg6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCkge1xyXG4gICAgY29uc3QgYm9yZGVyQ29sb3IgPSB0aGlzLmlzU2VsZWN0ZWRcclxuICAgICAgPyBcInJnYmEoMjU1LCAyNTUsIDI1NSwxLjApXCJcclxuICAgICAgOiBcInJnYmEoMjU1LCAyNTUsIDI1NSwwLjEpXCI7XHJcbiAgICBjdHguc2F2ZSgpO1xyXG4gICAgY3R4LmJlZ2luUGF0aCgpO1xyXG4gICAgY3R4LnJvdW5kUmVjdChcclxuICAgICAgLXRoaXMud2lkdGggLyAyLFxyXG4gICAgICAtdGhpcy5oZWlnaHQgLyAyLFxyXG4gICAgICB0aGlzLndpZHRoLFxyXG4gICAgICB0aGlzLmhlaWdodCxcclxuICAgICAgNixcclxuICAgICk7XHJcbiAgICBjdHgubGluZVdpZHRoID0gMTtcclxuICAgIGN0eC5zdHJva2VTdHlsZSA9IGJvcmRlckNvbG9yO1xyXG4gICAgY3R4LnN0cm9rZSgpO1xyXG4gICAgY3R4LnJlc3RvcmUoKTtcclxuICB9XHJcblxyXG4gIHB1YmxpYyBjYWx1bGF0ZVdpZHRoT25TY3JlZW4oKSB7XHJcbiAgICBjb25zdCBjYW52YXNFbCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiZGVzaWduY29tYm8tdGltZWxpbmUtY2FudmFzXCIpO1xyXG4gICAgY29uc3QgY2FudmFzV2lkdGggPSBjYW52YXNFbD8uY2xpZW50V2lkdGg7XHJcbiAgICBjb25zdCBzY3JvbGxMZWZ0ID0gdGhpcy5zY3JvbGxMZWZ0O1xyXG4gICAgY29uc3QgdGltZWxpbmVXaWR0aCA9IGNhbnZhc1dpZHRoITtcclxuICAgIGNvbnN0IGN1dEZyb21Cb3R0b21FZGdlID0gTWF0aC5tYXgoXHJcbiAgICAgIHRpbWVsaW5lV2lkdGggLSAodGhpcy53aWR0aCArIHRoaXMubGVmdCArIHNjcm9sbExlZnQpLFxyXG4gICAgICAwLFxyXG4gICAgKTtcclxuICAgIGNvbnN0IHZpc2libGVIZWlnaHQgPSBNYXRoLm1pbihcclxuICAgICAgdGltZWxpbmVXaWR0aCAtIHRoaXMubGVmdCAtIHNjcm9sbExlZnQsXHJcbiAgICAgIHRpbWVsaW5lV2lkdGgsXHJcbiAgICApO1xyXG5cclxuICAgIHJldHVybiBNYXRoLm1heCh2aXNpYmxlSGVpZ2h0IC0gY3V0RnJvbUJvdHRvbUVkZ2UsIDApO1xyXG4gIH1cclxuXHJcbiAgLy8gQ2FsY3VsYXRlIHRoZSB3aWR0aCB0aGF0IGlzIG5vdCB2aXNpYmxlIG9uIHRoZSBzY3JlZW4gbWVhc3VyZWQgZnJvbSB0aGUgbGVmdFxyXG4gIHB1YmxpYyBjYWxjdWxhdGVPZmZzY3JlZW5XaWR0aCh7IHNjcm9sbExlZnQgfTogeyBzY3JvbGxMZWZ0OiBudW1iZXIgfSkge1xyXG4gICAgY29uc3Qgb2Zmc2NyZWVuV2lkdGggPSBNYXRoLm1pbih0aGlzLmxlZnQgKyBzY3JvbGxMZWZ0LCAwKTtcclxuXHJcbiAgICByZXR1cm4gTWF0aC5hYnMob2Zmc2NyZWVuV2lkdGgpO1xyXG4gIH1cclxuXHJcbiAgcHVibGljIG9uU2Nyb2xsQ2hhbmdlKHtcclxuICAgIHNjcm9sbExlZnQsXHJcbiAgICBmb3JjZSxcclxuICB9OiB7XHJcbiAgICBzY3JvbGxMZWZ0OiBudW1iZXI7XHJcbiAgICBmb3JjZT86IGJvb2xlYW47XHJcbiAgfSkge1xyXG4gICAgY29uc3Qgb2Zmc2NyZWVuV2lkdGggPSB0aGlzLmNhbGN1bGF0ZU9mZnNjcmVlbldpZHRoKHsgc2Nyb2xsTGVmdCB9KTtcclxuICAgIGNvbnN0IHRyaW1Gcm9tU2l6ZSA9IHRpbWVNc1RvVW5pdHMoXHJcbiAgICAgIHRoaXMudHJpbS5mcm9tLFxyXG4gICAgICB0aGlzLnRTY2FsZSxcclxuICAgICAgdGhpcy5wbGF5YmFja1JhdGUsXHJcbiAgICApO1xyXG5cclxuICAgIGNvbnN0IG9mZnNjcmVlblNlZ21lbnRzID0gY2FsY3VsYXRlT2Zmc2NyZWVuU2VnbWVudHMoXHJcbiAgICAgIG9mZnNjcmVlbldpZHRoLFxyXG4gICAgICB0cmltRnJvbVNpemUsXHJcbiAgICAgIHRoaXMuc2VnbWVudFNpemUsXHJcbiAgICApO1xyXG5cclxuICAgIHRoaXMub2Zmc2NyZWVuU2VnbWVudHMgPSBvZmZzY3JlZW5TZWdtZW50cztcclxuXHJcbiAgICAvLyBjYWxjdWxhdGUgc3RhcnQgc2VnbWVudCB0byBkcmF3XHJcbiAgICBjb25zdCBzZWdtZW50VG9EcmF3ID0gb2Zmc2NyZWVuU2VnbWVudHM7XHJcblxyXG4gICAgaWYgKHRoaXMuY3VycmVudEZpbG1zdHJpcC5zZWdtZW50SW5kZXggPT09IHNlZ21lbnRUb0RyYXcpIHtcclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChzZWdtZW50VG9EcmF3ICE9PSB0aGlzLmZhbGxiYWNrU2VnbWVudEluZGV4KSB7XHJcbiAgICAgIGNvbnN0IGZpbGxQYXR0ZXJuID0gdGhpcy5maWxsIGFzIFBhdHRlcm47XHJcbiAgICAgIGlmIChmaWxsUGF0dGVybiBpbnN0YW5jZW9mIFBhdHRlcm4pIHtcclxuICAgICAgICBmaWxsUGF0dGVybi5vZmZzZXRYID1cclxuICAgICAgICAgIHRoaXMuc2VnbWVudFNpemUgKlxyXG4gICAgICAgICAgKHNlZ21lbnRUb0RyYXcgLSBNYXRoLmZsb29yKHRoaXMuZmFsbGJhY2tTZWdtZW50c0NvdW50IC8gMikpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB0aGlzLmZhbGxiYWNrU2VnbWVudEluZGV4ID0gc2VnbWVudFRvRHJhdztcclxuICAgIH1cclxuICAgIGlmICghdGhpcy5pc0ZldGNoaW5nVGh1bWJuYWlscyB8fCBmb3JjZSkge1xyXG4gICAgICB0aGlzLnNjcm9sbExlZnQgPSBzY3JvbGxMZWZ0O1xyXG4gICAgICBjb25zdCB3aWR0aE9uU2NyZWVuID0gdGhpcy5jYWx1bGF0ZVdpZHRoT25TY3JlZW4oKTtcclxuICAgICAgLy8gV2l0aCB0aGVzZSBsaW5lczpcclxuICAgICAgY29uc3QgeyBmaWxtc3RyaXBPZmZzZXQsIGZpbG1zdHJpcFN0YXJ0VGltZSwgZmlsbXN0cmltcFRodW1ibmFpbHNDb3VudCB9ID1cclxuICAgICAgICB0aGlzLmNhbGN1bGF0ZUZpbG1zdHJpcERpbWVuc2lvbnMoe1xyXG4gICAgICAgICAgd2lkdGhPblNjcmVlbjogdGhpcy5jYWx1bGF0ZVdpZHRoT25TY3JlZW4oKSxcclxuICAgICAgICAgIHNlZ21lbnRJbmRleDogc2VnbWVudFRvRHJhdyxcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgIHRoaXMubmV4dEZpbG1zdHJpcCA9IHtcclxuICAgICAgICBzZWdtZW50SW5kZXg6IHNlZ21lbnRUb0RyYXcsXHJcbiAgICAgICAgb2Zmc2V0OiBmaWxtc3RyaXBPZmZzZXQsXHJcbiAgICAgICAgc3RhcnRUaW1lOiBmaWxtc3RyaXBTdGFydFRpbWUsXHJcbiAgICAgICAgdGh1bWJuYWlsc0NvdW50OiBmaWxtc3RyaW1wVGh1bWJuYWlsc0NvdW50LFxyXG4gICAgICAgIHdpZHRoT25TY3JlZW4sXHJcbiAgICAgIH07XHJcblxyXG4gICAgICB0aGlzLmxvYWRBbmRSZW5kZXJUaHVtYm5haWxzKCk7XHJcbiAgICB9XHJcbiAgfVxyXG4gIHB1YmxpYyBvblNjYWxlKCkge1xyXG4gICAgdGhpcy5jdXJyZW50RmlsbXN0cmlwID0geyAuLi5FTVBUWV9GSUxNU1RSSVAgfTtcclxuICAgIHRoaXMubmV4dEZpbG1zdHJpcCA9IHsgLi4uRU1QVFlfRklMTVNUUklQLCBzZWdtZW50SW5kZXg6IDAgfTtcclxuICAgIHRoaXMubG9hZGluZ0ZpbG1zdHJpcCA9IHsgLi4uRU1QVFlfRklMTVNUUklQIH07XHJcbiAgICB0aGlzLm9uU2Nyb2xsQ2hhbmdlKHsgc2Nyb2xsTGVmdDogdGhpcy5zY3JvbGxMZWZ0LCBmb3JjZTogdHJ1ZSB9KTtcclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IFZpZGVvO1xyXG4iXSwibmFtZXMiOlsiUGF0dGVybiIsIlZpZGVvIiwiVmlkZW9CYXNlIiwidGltZU1zVG9Vbml0cyIsInVuaXRzVG9UaW1lTXMiLCJUaHVtYm5haWxDYWNoZSIsImNhbGN1bGF0ZU9mZnNjcmVlblNlZ21lbnRzIiwiY2FsY3VsYXRlVGh1bWJuYWlsU2VnbWVudExheW91dCIsImdldEZpbGVGcm9tVXJsIiwiY3JlYXRlTWVkaWFDb250cm9scyIsIkVNUFRZX0ZJTE1TVFJJUCIsIm9mZnNldCIsInN0YXJ0VGltZSIsInRodW1ibmFpbHNDb3VudCIsIndpZHRoT25TY3JlZW4iLCJjcmVhdGVDb250cm9scyIsImNvbnRyb2xzIiwiaW5pdE9mZnNjcmVlbkNhbnZhcyIsIm9mZnNjcmVlbkNhbnZhcyIsIk9mZnNjcmVlbkNhbnZhcyIsIndpZHRoIiwiaGVpZ2h0Iiwib2Zmc2NyZWVuQ3R4IiwiZ2V0Q29udGV4dCIsImlzRGlydHkiLCJpbml0RGltZW5zaW9ucyIsInRodW1ibmFpbFdpZHRoIiwidGh1bWJuYWlsSGVpZ2h0IiwiYXNwZWN0UmF0aW8iLCJzZWdtZW50T3B0aW9ucyIsInRodW1ibmFpbHNQZXJTZWdtZW50Iiwic2VnbWVudFNpemUiLCJpbml0aWFsaXplIiwibG9hZEZhbGxiYWNrVGh1bWJuYWlsIiwib25TY3JvbGxDaGFuZ2UiLCJzY3JvbGxMZWZ0IiwiY2FudmFzIiwicmVxdWVzdFJlbmRlckFsbCIsImNyZWF0ZUZhbGxiYWNrUGF0dGVybiIsInByZXBhcmVBc3NldHMiLCJNUDRDbGlwIiwiZmlsZSIsInNyYyIsInN0cmVhbSIsImNsaXAiLCJlcnJvciIsImNvbnNvbGUiLCJjYWxjdWxhdGVGaWxtc3RyaXBEaW1lbnNpb25zIiwic2VnbWVudEluZGV4IiwiZmlsbXN0cmlwT2Zmc2V0Iiwic2hvdWxkVXNlTGVmdEJhY2tsb2ciLCJsZWZ0QmFja2xvZ1NpemUiLCJ0b3RhbFdpZHRoIiwiZHVyYXRpb24iLCJ0U2NhbGUiLCJwbGF5YmFja1JhdGUiLCJyaWdodFJlbWFpbmluZ1NpemUiLCJyaWdodEJhY2tsb2dTaXplIiwiTWF0aCIsIm1pbiIsImZpbG1zdHJpcFN0YXJ0VGltZSIsImZpbG1zdHJpbXBUaHVtYm5haWxzQ291bnQiLCJyb3VuZCIsImZhbGxiYWNrVGh1bWJuYWlsIiwicHJldmlld1VybCIsImxvZyIsImlkIiwic3Vic3RyaW5nIiwiUHJvbWlzZSIsInJlc29sdmUiLCJpbWciLCJJbWFnZSIsImNyb3NzT3JpZ2luIiwic3RhcnRzV2l0aCIsIkRhdGUiLCJub3ciLCJvbmxvYWQiLCJkb2N1bWVudCIsImNyZWF0ZUVsZW1lbnQiLCJjdHgiLCJ0YXJnZXRIZWlnaHQiLCJ0YXJnZXRXaWR0aCIsImRyYXdJbWFnZSIsInJlc2l6ZWRJbWciLCJ0b0RhdGFVUkwiLCJ0aHVtYm5haWxDYWNoZSIsInNldFRodW1ibmFpbCIsIm9uZXJyb3IiLCJlcnIiLCJnZW5lcmF0ZVRpbWVzdGFtcHMiLCJjb3VudCIsInRpbWVQZXJUaHVtYm5haWwiLCJBcnJheSIsImZyb20iLCJsZW5ndGgiLCJfIiwiaSIsInRpbWVJbkZpbG1zdHJpcGUiLCJjZWlsIiwiY2FudmFzV2lkdGgiLCJtYXhQYXR0ZXJuU2l6ZSIsImZhbGxiYWNrU291cmNlIiwiZ2V0VGh1bWJuYWlsIiwidG90YWxXaWR0aE5lZWRlZCIsInNlZ21lbnRzUmVxdWlyZWQiLCJmYWxsYmFja1NlZ21lbnRzQ291bnQiLCJwYXR0ZXJuV2lkdGgiLCJvZmZDYW52YXMiLCJjb250ZXh0IiwidGh1bWJuYWlsc1RvdGFsIiwieCIsImZpbGxQYXR0ZXJuIiwic291cmNlIiwicmVwZWF0Iiwib2Zmc2V0WCIsInNldCIsImxvYWRBbmRSZW5kZXJUaHVtYm5haWxzIiwiaXNGZXRjaGluZ1RodW1ibmFpbHMiLCJsb2FkaW5nRmlsbXN0cmlwIiwibmV4dEZpbG1zdHJpcCIsInRpbWVzdGFtcHMiLCJ0aHVtYm5haWxzQXJyIiwidGh1bWJuYWlsc0xpc3QiLCJtYXAiLCJ0aW1lc3RhbXAiLCJ1cGRhdGVkVGh1bWJuYWlscyIsInRodW1ibmFpbCIsInRzIiwibG9hZFRodW1ibmFpbEJhdGNoIiwiY3VycmVudEZpbG1zdHJpcCIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsInRodW1ibmFpbHMiLCJsb2FkUHJvbWlzZXMiLCJVUkwiLCJjcmVhdGVPYmplY3RVUkwiLCJyZXZva2VPYmplY3RVUkwiLCJhbGwiLCJfcmVuZGVyIiwic2F2ZSIsInRyYW5zbGF0ZSIsImJlZ2luUGF0aCIsInJlY3QiLCJyZW5kZXJUb09mZnNjcmVlbiIsInJlc3RvcmUiLCJ1cGRhdGVTZWxlY3RlZCIsInNldER1cmF0aW9uIiwicHJldkR1cmF0aW9uIiwic2V0U3JjIiwiY2xlYXJDYWNoZUJ1dEZhbGxiYWNrIiwib25TY2FsZSIsIm9uUmVzaXplU25hcCIsIm9uUmVzaXplIiwiZm9yY2UiLCJ0cmltRnJvbVNpemUiLCJ0cmltIiwiY2xlYXJSZWN0Iiwicm91bmRSZWN0IiwicngiLCJjb21wbGV0ZSIsInhQb3NpdGlvbiIsImRyYXdUZXh0SWRlbnRpdHkiLCJpY29uUGF0aCIsIlBhdGgyRCIsImZvbnQiLCJmaWxsU3R5bGUiLCJ0ZXh0QWxpZ24iLCJmaWxsVGV4dCIsImZpbGwiLCJzZXRTZWxlY3RlZCIsInNlbGVjdGVkIiwiaXNTZWxlY3RlZCIsImRpcnR5IiwiYm9yZGVyQ29sb3IiLCJsaW5lV2lkdGgiLCJzdHJva2VTdHlsZSIsInN0cm9rZSIsImNhbHVsYXRlV2lkdGhPblNjcmVlbiIsImNhbnZhc0VsIiwiZ2V0RWxlbWVudEJ5SWQiLCJjbGllbnRXaWR0aCIsInRpbWVsaW5lV2lkdGgiLCJjdXRGcm9tQm90dG9tRWRnZSIsIm1heCIsImxlZnQiLCJ2aXNpYmxlSGVpZ2h0IiwiY2FsY3VsYXRlT2Zmc2NyZWVuV2lkdGgiLCJvZmZzY3JlZW5XaWR0aCIsImFicyIsIm9mZnNjcmVlblNlZ21lbnRzIiwic2VnbWVudFRvRHJhdyIsImZhbGxiYWNrU2VnbWVudEluZGV4IiwiZmxvb3IiLCJjb25zdHJ1Y3RvciIsInByb3BzIiwicmVzb3VyY2VJZCIsIml0ZW1UeXBlIiwib2JqZWN0Q2FjaGluZyIsInJ5IiwiZGlzcGxheSIsImJvcmRlck9wYWNpdHlXaGVuTW92aW5nIiwibWV0YWRhdGEiLCJzdHJva2VXaWR0aCIsInRyYW5zcGFyZW50Q29ybmVycyIsImhhc0JvcmRlcnMiLCJ0eXBlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./features/editor/timeline/items/video.ts\n"));

/***/ })

});
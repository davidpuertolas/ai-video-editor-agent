"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./features/editor/scene/interactions.tsx":
/*!************************************************!*\
  !*** ./features/editor/scene/interactions.tsx ***!
  \************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SceneInteractions: function() { return /* binding */ SceneInteractions; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _interactify_selection__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @interactify/selection */ \"(app-pages-browser)/./node_modules/@interactify/selection/dist/selecto.esm.js\");\n/* harmony import */ var _interactify_moveable__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @interactify/moveable */ \"(app-pages-browser)/./node_modules/@interactify/moveable/dist/index.es.js\");\n/* harmony import */ var _utils_scene__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/scene */ \"(app-pages-browser)/./features/editor/utils/scene.ts\");\n/* harmony import */ var _designcombo_events__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @designcombo/events */ \"(app-pages-browser)/./node_modules/@designcombo/events/dist/index.es.js\");\n/* harmony import */ var _designcombo_state__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @designcombo/state */ \"(app-pages-browser)/./node_modules/@designcombo/state/dist/index.es.js\");\n/* harmony import */ var _utils_target__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../utils/target */ \"(app-pages-browser)/./features/editor/utils/target.ts\");\n/* harmony import */ var _store_use_store__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../store/use-store */ \"(app-pages-browser)/./features/editor/store/use-store.ts\");\n/* harmony import */ var _utils_time__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../utils/time */ \"(app-pages-browser)/./features/editor/utils/time.ts\");\n/* harmony import */ var _store_use_layout_store__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../store/use-layout-store */ \"(app-pages-browser)/./features/editor/store/use-layout-store.ts\");\n/* __next_internal_client_entry_do_not_use__ SceneInteractions auto */ \nvar _s = $RefreshSig$();\n\n\n\n\n\n\n\n\n\n\nlet holdGroupPosition = null;\nlet dragStartEnd = false;\nfunction SceneInteractions(param) {\n    let { stateManager, viewerRef, zoom, size, containerRef } = param;\n    _s();\n    const [targets, setTargets] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]);\n    const [selection, setSelection] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)();\n    const { activeIds, setState, trackItemDetailsMap, trackItemsMap, playerRef, setSceneMoveableRef } = (0,_store_use_store__WEBPACK_IMPORTED_MODULE_7__[\"default\"])();\n    const { setActiveMenuItem, setShowMenuItem } = (0,_store_use_layout_store__WEBPACK_IMPORTED_MODULE_9__[\"default\"])();\n    const moveableRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const [selectionInfo, setSelectionInfo] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(_utils_target__WEBPACK_IMPORTED_MODULE_6__.emptySelection);\n    // Estado para las líneas guía\n    const [showGuides, setShowGuides] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)({\n        left: false,\n        center: false,\n        right: false,\n        top: false,\n        middle: false,\n        bottom: false\n    });\n    // Constantes para el snap\n    const SNAP_THRESHOLD = 15; // Distancia en píxeles para activar el snap\n    const SNAP_EDGE_THRESHOLD = 5; // Umbral para considerar que un elemento está en el borde\n    // Función para aplicar snap a coordenadas\n    const applySnap = function(value, snapPoints) {\n        let threshold = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : SNAP_THRESHOLD;\n        for (const point of snapPoints){\n            if (Math.abs(value - point) <= threshold) {\n                return point;\n            }\n        }\n        return value;\n    };\n    // Función para actualizar las líneas guía\n    const updateGuideLines = (left, top, width, height)=>{\n        // Puntos de snap para los ejes X e Y\n        const snapPointsX = [\n            0,\n            size.width / 2 - width / 2,\n            size.width - width // Borde derecho\n        ];\n        const snapPointsY = [\n            0,\n            size.height / 2 - height / 2,\n            size.height - height // Borde inferior\n        ];\n        // Verificar proximidad a cada punto de snap\n        const newGuides = {\n            left: Math.abs(left - snapPointsX[0]) <= SNAP_THRESHOLD,\n            center: Math.abs(left - snapPointsX[1]) <= SNAP_THRESHOLD,\n            right: Math.abs(left - snapPointsX[2]) <= SNAP_THRESHOLD,\n            top: Math.abs(top - snapPointsY[0]) <= SNAP_THRESHOLD,\n            middle: Math.abs(top - snapPointsY[1]) <= SNAP_THRESHOLD,\n            bottom: Math.abs(top - snapPointsY[2]) <= SNAP_THRESHOLD\n        };\n        setShowGuides(newGuides);\n    };\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        var _playerRef_current;\n        const updateTargets = (time)=>{\n            const currentTime = time || (0,_utils_time__WEBPACK_IMPORTED_MODULE_8__.getCurrentTime)();\n            const { trackItemsMap } = _store_use_store__WEBPACK_IMPORTED_MODULE_7__[\"default\"].getState();\n            const targetIds = activeIds.filter((id)=>{\n                var _trackItemsMap_id, _trackItemsMap_id1;\n                return ((_trackItemsMap_id = trackItemsMap[id]) === null || _trackItemsMap_id === void 0 ? void 0 : _trackItemsMap_id.display.from) <= currentTime && ((_trackItemsMap_id1 = trackItemsMap[id]) === null || _trackItemsMap_id1 === void 0 ? void 0 : _trackItemsMap_id1.display.to) >= currentTime;\n            });\n            const targets = targetIds.map((id)=>(0,_utils_target__WEBPACK_IMPORTED_MODULE_6__.getTargetById)(id));\n            selection === null || selection === void 0 ? void 0 : selection.setSelectedTargets(targets);\n            const selInfo = (0,_utils_target__WEBPACK_IMPORTED_MODULE_6__.getSelectionByIds)(targetIds);\n            setSelectionInfo(selInfo);\n            setTargets(selInfo.targets);\n        };\n        const timer = setTimeout(()=>{\n            updateTargets();\n        });\n        const onSeeked = (v)=>{\n            setTimeout(()=>{\n                const { fps } = _store_use_store__WEBPACK_IMPORTED_MODULE_7__[\"default\"].getState();\n                const seekedTime = v.detail.frame / fps * 1000;\n                updateTargets(seekedTime);\n            });\n        };\n        playerRef === null || playerRef === void 0 ? void 0 : (_playerRef_current = playerRef.current) === null || _playerRef_current === void 0 ? void 0 : _playerRef_current.addEventListener(\"seeked\", onSeeked);\n        return ()=>{\n            var _playerRef_current;\n            playerRef === null || playerRef === void 0 ? void 0 : (_playerRef_current = playerRef.current) === null || _playerRef_current === void 0 ? void 0 : _playerRef_current.removeEventListener(\"seeked\", onSeeked);\n            clearTimeout(timer);\n        };\n    }, [\n        activeIds,\n        playerRef,\n        trackItemsMap\n    ]);\n    // Función para manejar la selección de elementos\n    const handleSelection = (ids)=>{\n        console.log(\"[DEBUG Interactions] Selecci\\xf3n de elementos:\", ids);\n        // Actualizar el estado de activeIds\n        stateManager.updateState({\n            activeIds: ids\n        }, {\n            updateHistory: false,\n            kind: \"layer:selection\"\n        });\n        // Si se ha seleccionado un solo elemento, cambiar inmediatamente al panel de atributos\n        if (ids && ids.length === 1) {\n            console.log(\"[DEBUG Interactions] Cambiando a panel de atributos directamente desde interactions\");\n            // FORZAR cambio directo al panel de atributos\n            setActiveMenuItem(\"attributes\");\n            setShowMenuItem(true);\n            // Forzar el evento de selección para asegurar que todos los componentes se actualicen\n            (0,_designcombo_events__WEBPACK_IMPORTED_MODULE_4__.dispatch)(_designcombo_state__WEBPACK_IMPORTED_MODULE_5__.LAYER_SELECTION, {\n                payload: {\n                    activeIds: ids\n                }\n            });\n            // Verificar el cambio\n            setTimeout(()=>{\n                const currentMenuItem = _store_use_layout_store__WEBPACK_IMPORTED_MODULE_9__[\"default\"].getState().activeMenuItem;\n                console.log(\"[DEBUG Interactions] Panel despu\\xe9s del cambio:\", currentMenuItem);\n            }, 100);\n        }\n    };\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        var _viewerRef_current;\n        const selection = new _interactify_selection__WEBPACK_IMPORTED_MODULE_10__[\"default\"]({\n            container: (_viewerRef_current = viewerRef.current) === null || _viewerRef_current === void 0 ? void 0 : _viewerRef_current.infiniteViewer.getContainer(),\n            boundContainer: true,\n            hitRate: 0,\n            selectableTargets: [\n                \".designcombo-scene-item\"\n            ],\n            selectFromInside: false,\n            selectByClick: true,\n            toggleContinueSelect: \"shift\"\n        }).on(\"select\", (e)=>{\n            const ids = e.selected.map((el)=>(0,_utils_scene__WEBPACK_IMPORTED_MODULE_3__.getIdFromClassName)(el.className));\n            setTargets(e.selected);\n            // Usar la función handleSelection\n            handleSelection(ids);\n        }).on(\"dragStart\", (e)=>{\n            var _moveableRef_current;\n            const target = e.inputEvent.target;\n            dragStartEnd = false;\n            if (targets.includes(target)) {\n                e.stop();\n            }\n            if (target && (moveableRef === null || moveableRef === void 0 ? void 0 : (_moveableRef_current = moveableRef.current) === null || _moveableRef_current === void 0 ? void 0 : _moveableRef_current.moveable.isMoveableElement(target))) {\n                e.stop();\n            }\n        }).on(\"dragEnd\", ()=>{\n            dragStartEnd = true;\n        }).on(\"selectEnd\", (e)=>{\n            const moveable = moveableRef.current;\n            if (e.isDragStart) {\n                e.inputEvent.preventDefault();\n                setTimeout(()=>{\n                    if (!dragStartEnd) {\n                        moveable === null || moveable === void 0 ? void 0 : moveable.moveable.dragStart(e.inputEvent);\n                    }\n                });\n            } else {\n                const targets = e.selected;\n                const ids = targets.map((el)=>(0,_utils_scene__WEBPACK_IMPORTED_MODULE_3__.getIdFromClassName)(el.className));\n                // Usar la función handleSelection\n                handleSelection(ids);\n                setTargets(targets);\n            }\n        });\n        setSelection(selection);\n        return ()=>{\n            selection.destroy();\n        };\n    }, []);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        const activeSelectionSubscription = stateManager.subscribeToActiveIds((newState)=>{\n            setState(newState);\n            // Si hay un solo elemento seleccionado, asegurarse de que se muestre el panel de atributos\n            if (newState.activeIds && newState.activeIds.length === 1) {\n                setActiveMenuItem(\"attributes\");\n                setShowMenuItem(true);\n            }\n        });\n        return ()=>{\n            activeSelectionSubscription.unsubscribe();\n        };\n    }, []);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        moveableRef.current.moveable.updateRect();\n    }, [\n        trackItemsMap\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        setSceneMoveableRef(moveableRef);\n    }, [\n        moveableRef\n    ]);\n    // Efecto para crear y gestionar las líneas guía\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        // Asegurarse de que el contenedor existe\n        if (!(containerRef === null || containerRef === void 0 ? void 0 : containerRef.current)) return;\n        // Crear los elementos de líneas guía si no existen\n        const createGuideLines = ()=>{\n            const container = containerRef.current;\n            if (!container) return;\n            // Eliminar guías existentes primero\n            document.querySelectorAll(\".guide-line\").forEach((el)=>el.remove());\n            // Crear nuevas guías\n            const guidePositions = [\n                {\n                    name: \"left\",\n                    style: \"left: 0; top: 0; width: 2px; height: \".concat(size.height, \"px;\")\n                },\n                {\n                    name: \"center\",\n                    style: \"left: \".concat(size.width / 2, \"px; top: 0; width: 2px; height: \").concat(size.height, \"px; transform: translateX(-50%);\")\n                },\n                {\n                    name: \"right\",\n                    style: \"left: \".concat(size.width, \"px; top: 0; width: 2px; height: \").concat(size.height, \"px;\")\n                },\n                {\n                    name: \"top\",\n                    style: \"top: 0; left: 0; height: 2px; width: \".concat(size.width, \"px;\")\n                },\n                {\n                    name: \"middle\",\n                    style: \"top: \".concat(size.height / 2, \"px; left: 0; height: 2px; width: \").concat(size.width, \"px; transform: translateY(-50%);\")\n                },\n                {\n                    name: \"bottom\",\n                    style: \"top: \".concat(size.height, \"px; left: 0; height: 2px; width: \").concat(size.width, \"px;\")\n                }\n            ];\n            guidePositions.forEach((guide)=>{\n                const guideElement = document.createElement(\"div\");\n                guideElement.className = \"guide-line guide-\".concat(guide.name);\n                guideElement.setAttribute(\"style\", \"\\n          position: absolute;\\n          background: rgba(156, 90, 250, 0.8);\\n          box-shadow: 0 0 4px rgba(156, 90, 250, 0.5);\\n          pointer-events: none;\\n          opacity: 0;\\n          transition: opacity 0.15s ease-out;\\n          z-index: 9999;\\n          \".concat(guide.style, \"\\n        \"));\n                container.appendChild(guideElement);\n            });\n        };\n        createGuideLines();\n        // Actualizar líneas guía al redimensionar\n        window.addEventListener(\"resize\", createGuideLines);\n        // Limpiar al desmontar\n        return ()=>{\n            window.removeEventListener(\"resize\", createGuideLines);\n            document.querySelectorAll(\".guide-line\").forEach((el)=>el.remove());\n        };\n    }, [\n        containerRef,\n        size\n    ]);\n    // Actualizar visibilidad de las líneas guía\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        document.querySelectorAll(\".guide-line\").forEach((el)=>{\n            const guideName = el.className.split(\" \")[1].replace(\"guide-\", \"\");\n            if (showGuides[guideName]) {\n                el.style.opacity = \"1\";\n            } else {\n                el.style.opacity = \"0\";\n            }\n        });\n        // Ocultar guías después de un tiempo\n        const hideGuidesTimeout = setTimeout(()=>{\n            setShowGuides({\n                left: false,\n                center: false,\n                right: false,\n                top: false,\n                middle: false,\n                bottom: false\n            });\n        }, 1000);\n        return ()=>clearTimeout(hideGuidesTimeout);\n    }, [\n        showGuides\n    ]);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_interactify_moveable__WEBPACK_IMPORTED_MODULE_2__[\"default\"], {\n        ref: moveableRef,\n        rotationPosition: \"bottom\",\n        renderDirections: selectionInfo.controls,\n        ...selectionInfo.ables,\n        origin: false,\n        target: targets,\n        zoom: 1 / zoom,\n        className: \"designcombo-scene-moveable\",\n        onDrag: (param)=>{\n            let { target, beforeTranslate, inputEvent } = param;\n            const targetId = (0,_utils_scene__WEBPACK_IMPORTED_MODULE_3__.getIdFromClassName)(target.className);\n            const trackItem = trackItemDetailsMap[targetId];\n            // Obtener dimensiones del elemento\n            const targetWidth = target.offsetWidth;\n            const targetHeight = target.offsetHeight;\n            // Calcular la posición propuesta\n            let left = parseFloat(trackItem === null || trackItem === void 0 ? void 0 : trackItem.details.left) + beforeTranslate[0];\n            let top = parseFloat(trackItem === null || trackItem === void 0 ? void 0 : trackItem.details.top) + beforeTranslate[1];\n            // Puntos de snap para el eje X (izquierda, centro, derecha)\n            const snapPointsX = [\n                0,\n                size.width / 2 - targetWidth / 2,\n                size.width - targetWidth // Borde derecho\n            ];\n            // Puntos de snap para el eje Y (arriba, centro, abajo)\n            const snapPointsY = [\n                0,\n                size.height / 2 - targetHeight / 2,\n                size.height - targetHeight // Borde inferior\n            ];\n            // Actualizar líneas guía antes de aplicar el snap\n            updateGuideLines(left, top, targetWidth, targetHeight);\n            // Aplicar snap con umbral normal\n            left = applySnap(left, snapPointsX);\n            top = applySnap(top, snapPointsY);\n            // Feedback visual para indicar el snap (opcional)\n            if (snapPointsX.some((point)=>Math.abs(left - point) <= SNAP_EDGE_THRESHOLD) || snapPointsY.some((point)=>Math.abs(top - point) <= SNAP_EDGE_THRESHOLD)) {\n                // Se podría añadir una clase CSS para indicar visualmente el snap\n                target.classList.add(\"snapped-element\");\n                // Añadir pequeña vibración como feedback táctil (opcional)\n                if (inputEvent instanceof MouseEvent && \"vibrate\" in navigator) {\n                    navigator.vibrate(10); // Vibración sutil de 10ms\n                }\n            } else {\n                target.classList.remove(\"snapped-element\");\n            }\n            // Actualizar posición\n            target.style.top = top + \"px\";\n            target.style.left = left + \"px\";\n        },\n        onDragEnd: (param)=>{\n            let { target, isDrag } = param;\n            if (!isDrag) return;\n            const targetId = (0,_utils_scene__WEBPACK_IMPORTED_MODULE_3__.getIdFromClassName)(target.className);\n            // Eliminar la clase de snap al finalizar\n            target.classList.remove(\"snapped-element\");\n            // Ocultar todas las líneas guía\n            setShowGuides({\n                left: false,\n                center: false,\n                right: false,\n                top: false,\n                middle: false,\n                bottom: false\n            });\n            (0,_designcombo_events__WEBPACK_IMPORTED_MODULE_4__.dispatch)(_designcombo_state__WEBPACK_IMPORTED_MODULE_5__.EDIT_OBJECT, {\n                payload: {\n                    [targetId]: {\n                        details: {\n                            left: target.style.left,\n                            top: target.style.top\n                        }\n                    }\n                }\n            });\n        },\n        onScale: (param)=>{\n            let { target, transform, direction } = param;\n            const [xControl, yControl] = direction;\n            const scaleRegex = /scale\\(([^)]+)\\)/;\n            const match = target.style.transform.match(scaleRegex);\n            //get current scale\n            const [scaleX, scaleY] = match[1].split(\",\").map((value)=>parseFloat(value.trim()));\n            //get new Scale\n            const match2 = transform.match(scaleRegex);\n            const [newScaleX, newScaleY] = match2[1].split(\",\").map((value)=>parseFloat(value.trim()));\n            const currentWidth = target.clientWidth * scaleX;\n            const currentHeight = target.clientHeight * scaleY;\n            const newWidth = target.clientWidth * newScaleX;\n            const newHeight = target.clientHeight * newScaleY;\n            target.style.transform = transform;\n            //Move element to initial Left position\n            const diffX = currentWidth - newWidth;\n            let newLeft = parseFloat(target.style.left) - diffX / 2;\n            const diffY = currentHeight - newHeight;\n            let newTop = parseFloat(target.style.top) - diffY / 2;\n            if (xControl === -1) {\n                newLeft += diffX;\n            }\n            if (yControl === -1) {\n                newTop += diffY;\n            }\n            target.style.left = newLeft + \"px\";\n            target.style.top = newTop + \"px\";\n        },\n        onScaleEnd: (param)=>{\n            let { target } = param;\n            if (!target.style.transform) return;\n            const targetId = (0,_utils_scene__WEBPACK_IMPORTED_MODULE_3__.getIdFromClassName)(target.className);\n            (0,_designcombo_events__WEBPACK_IMPORTED_MODULE_4__.dispatch)(_designcombo_state__WEBPACK_IMPORTED_MODULE_5__.EDIT_OBJECT, {\n                payload: {\n                    [targetId]: {\n                        details: {\n                            transform: target.style.transform,\n                            left: parseFloat(target.style.left),\n                            top: parseFloat(target.style.top)\n                        }\n                    }\n                }\n            });\n        },\n        onRotate: (param)=>{\n            let { target, transform } = param;\n            target.style.transform = transform;\n        },\n        onRotateEnd: (param)=>{\n            let { target } = param;\n            if (!target.style.transform) return;\n            const targetId = (0,_utils_scene__WEBPACK_IMPORTED_MODULE_3__.getIdFromClassName)(target.className);\n            (0,_designcombo_events__WEBPACK_IMPORTED_MODULE_4__.dispatch)(_designcombo_state__WEBPACK_IMPORTED_MODULE_5__.EDIT_OBJECT, {\n                payload: {\n                    [targetId]: {\n                        details: {\n                            transform: target.style.transform\n                        }\n                    }\n                }\n            });\n        },\n        onDragGroup: (param)=>{\n            let { events } = param;\n            holdGroupPosition = {};\n            // Obtener el rectángulo que contiene todo el grupo\n            let groupLeft = Infinity;\n            let groupTop = Infinity;\n            let groupRight = -Infinity;\n            let groupBottom = -Infinity;\n            // Primer paso: calcular dimensiones del grupo\n            for(let i = 0; i < events.length; i++){\n                const event = events[i];\n                const id = (0,_utils_scene__WEBPACK_IMPORTED_MODULE_3__.getIdFromClassName)(event.target.className);\n                const trackItem = trackItemDetailsMap[id];\n                const left = parseFloat(trackItem === null || trackItem === void 0 ? void 0 : trackItem.details.left);\n                const top = parseFloat(trackItem === null || trackItem === void 0 ? void 0 : trackItem.details.top);\n                const width = event.target.offsetWidth;\n                const height = event.target.offsetHeight;\n                groupLeft = Math.min(groupLeft, left);\n                groupTop = Math.min(groupTop, top);\n                groupRight = Math.max(groupRight, left + width);\n                groupBottom = Math.max(groupBottom, top + height);\n            }\n            const groupWidth = groupRight - groupLeft;\n            const groupHeight = groupBottom - groupTop;\n            // Calcular el desplazamiento base del grupo (desde el primer elemento)\n            const baseTranslate = events[0].beforeTranslate;\n            // Calcular nueva posición del grupo con posible snap\n            let newGroupLeft = groupLeft + baseTranslate[0];\n            let newGroupTop = groupTop + baseTranslate[1];\n            // Actualizar líneas guía para el grupo\n            updateGuideLines(newGroupLeft, newGroupTop, groupWidth, groupHeight);\n            // Puntos de snap para el grupo\n            const snapPointsX = [\n                0,\n                size.width / 2 - groupWidth / 2,\n                size.width - groupWidth // Borde derecho\n            ];\n            const snapPointsY = [\n                0,\n                size.height / 2 - groupHeight / 2,\n                size.height - groupHeight // Borde inferior\n            ];\n            // Aplicar snap al grupo\n            const snappedGroupLeft = applySnap(newGroupLeft, snapPointsX);\n            const snappedGroupTop = applySnap(newGroupTop, snapPointsY);\n            // Calcular el ajuste necesario después del snap\n            const adjustX = snappedGroupLeft - newGroupLeft;\n            const adjustY = snappedGroupTop - newGroupTop;\n            // Feedback visual para el snap de grupo\n            const isGroupSnapped = Math.abs(adjustX) <= SNAP_EDGE_THRESHOLD || Math.abs(adjustY) <= SNAP_EDGE_THRESHOLD;\n            // Aplicar el movimiento ajustado a cada elemento del grupo\n            for(let i = 0; i < events.length; i++){\n                const event = events[i];\n                const id = (0,_utils_scene__WEBPACK_IMPORTED_MODULE_3__.getIdFromClassName)(event.target.className);\n                const trackItem = trackItemDetailsMap[id];\n                const left = parseFloat(trackItem === null || trackItem === void 0 ? void 0 : trackItem.details.left) + event.beforeTranslate[0] + adjustX;\n                const top = parseFloat(trackItem === null || trackItem === void 0 ? void 0 : trackItem.details.top) + event.beforeTranslate[1] + adjustY;\n                event.target.style.left = \"\".concat(left, \"px\");\n                event.target.style.top = \"\".concat(top, \"px\");\n                // Aplicar clase visual si hay snap\n                if (isGroupSnapped) {\n                    event.target.classList.add(\"snapped-element\");\n                } else {\n                    event.target.classList.remove(\"snapped-element\");\n                }\n                holdGroupPosition[id] = {\n                    left: left,\n                    top: top\n                };\n            }\n            // Feedback táctil si hay snap\n            if (isGroupSnapped && \"vibrate\" in navigator) {\n                navigator.vibrate(10);\n            }\n        },\n        onResize: (param)=>{\n            let { target, width: nextWidth, height: nextHeight, direction } = param;\n            if (direction[1] === 1) {\n                var _target_firstElementChild;\n                const currentWidth = target.clientWidth;\n                const currentHeight = target.clientHeight;\n                // Get new width and height\n                const scaleY = nextHeight / currentHeight;\n                const scale = scaleY;\n                // Update target dimensions\n                target.style.width = \"\".concat(currentWidth * scale, \"px\");\n                target.style.height = \"\".concat(currentHeight * scale, \"px\");\n                // Safely access nested elements\n                const animationDiv = (_target_firstElementChild = target.firstElementChild) === null || _target_firstElementChild === void 0 ? void 0 : _target_firstElementChild.firstElementChild;\n                if (animationDiv) {\n                    animationDiv.style.width = \"\".concat(currentWidth * scale, \"px\");\n                    animationDiv.style.height = \"\".concat(currentHeight * scale, \"px\");\n                    const textDiv = animationDiv.firstElementChild;\n                    if (textDiv) {\n                        const fontSize = parseFloat(getComputedStyle(textDiv).fontSize);\n                        textDiv.style.fontSize = \"\".concat(fontSize * scale, \"px\");\n                        textDiv.style.width = \"\".concat(currentWidth * scale, \"px\");\n                        textDiv.style.height = \"\".concat(currentHeight * scale, \"px\");\n                    }\n                }\n            } else {\n                var _target_firstElementChild1;\n                target.style.width = nextWidth + \"px\";\n                target.style.height = nextHeight + \"px\";\n                // Safely access nested elements\n                const animationDiv = (_target_firstElementChild1 = target.firstElementChild) === null || _target_firstElementChild1 === void 0 ? void 0 : _target_firstElementChild1.firstElementChild;\n                if (animationDiv) {\n                    animationDiv.style.width = \"\".concat(nextWidth, \"px\");\n                    animationDiv.style.height = \"\".concat(nextHeight, \"px\");\n                    const textDiv = animationDiv.firstElementChild;\n                    if (textDiv) {\n                        textDiv.style.width = \"\".concat(nextWidth, \"px\");\n                        textDiv.style.height = \"\".concat(nextHeight, \"px\");\n                    }\n                }\n            }\n        },\n        onResizeEnd: (param)=>{\n            let { target } = param;\n            var _target_firstElementChild_firstElementChild, _target_firstElementChild;\n            const targetId = (0,_utils_scene__WEBPACK_IMPORTED_MODULE_3__.getIdFromClassName)(target.className);\n            const textDiv = (_target_firstElementChild = target.firstElementChild) === null || _target_firstElementChild === void 0 ? void 0 : (_target_firstElementChild_firstElementChild = _target_firstElementChild.firstElementChild) === null || _target_firstElementChild_firstElementChild === void 0 ? void 0 : _target_firstElementChild_firstElementChild.firstElementChild;\n            (0,_designcombo_events__WEBPACK_IMPORTED_MODULE_4__.dispatch)(_designcombo_state__WEBPACK_IMPORTED_MODULE_5__.EDIT_OBJECT, {\n                payload: {\n                    [targetId]: {\n                        details: {\n                            width: parseFloat(target.style.width),\n                            height: parseFloat(target.style.height),\n                            fontSize: parseFloat(textDiv.style.fontSize)\n                        }\n                    }\n                }\n            });\n        },\n        onDragGroupEnd: ()=>{\n            if (holdGroupPosition) {\n                const payload = {};\n                Object.keys(holdGroupPosition).forEach((id)=>{\n                    const left = holdGroupPosition[id].left;\n                    const top = holdGroupPosition[id].top;\n                    // Eliminar la clase de snap\n                    const element = document.querySelector(\".id-\".concat(id));\n                    if (element) {\n                        element.classList.remove(\"snapped-element\");\n                    }\n                    payload[id] = {\n                        details: {\n                            top: \"\".concat(top, \"px\"),\n                            left: \"\".concat(left, \"px\")\n                        }\n                    };\n                });\n                // Ocultar todas las líneas guía\n                setShowGuides({\n                    left: false,\n                    center: false,\n                    right: false,\n                    top: false,\n                    middle: false,\n                    bottom: false\n                });\n                (0,_designcombo_events__WEBPACK_IMPORTED_MODULE_4__.dispatch)(_designcombo_state__WEBPACK_IMPORTED_MODULE_5__.EDIT_OBJECT, {\n                    payload: payload\n                });\n                holdGroupPosition = null;\n            }\n        }\n    }, void 0, false, {\n        fileName: \"C:\\\\Users\\\\david\\\\Desktop\\\\ai-video-agent\\\\react-video-editor\\\\features\\\\editor\\\\scene\\\\interactions.tsx\",\n        lineNumber: 343,\n        columnNumber: 5\n    }, this);\n}\n_s(SceneInteractions, \"6Wdeds8zsEhPUOP36HZVTf+rVEw=\", false, function() {\n    return [\n        _store_use_store__WEBPACK_IMPORTED_MODULE_7__[\"default\"],\n        _store_use_layout_store__WEBPACK_IMPORTED_MODULE_9__[\"default\"]\n    ];\n});\n_c = SceneInteractions;\nvar _c;\n$RefreshReg$(_c, \"SceneInteractions\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2ZlYXR1cmVzL2VkaXRvci9zY2VuZS9pbnRlcmFjdGlvbnMudHN4IiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUVvRDtBQUNMO0FBQ0Y7QUFDTztBQUNMO0FBQ21CO0FBTXpDO0FBQ2lCO0FBRUs7QUFDUTtBQUV2RCxJQUFJZSxvQkFBZ0Q7QUFDcEQsSUFBSUMsZUFBZTtBQVNaLFNBQVNDLGtCQUFrQixLQU1UO1FBTlMsRUFDaENDLFlBQVksRUFDWkMsU0FBUyxFQUNUQyxJQUFJLEVBQ0pDLElBQUksRUFDSkMsWUFBWSxFQUNXLEdBTlM7O0lBT2hDLE1BQU0sQ0FBQ0MsU0FBU0MsV0FBVyxHQUFHdEIsK0NBQVFBLENBQW1CLEVBQUU7SUFDM0QsTUFBTSxDQUFDdUIsV0FBV0MsYUFBYSxHQUFHeEIsK0NBQVFBO0lBQzFDLE1BQU0sRUFDSnlCLFNBQVMsRUFDVEMsUUFBUSxFQUNSQyxtQkFBbUIsRUFDbkJDLGFBQWEsRUFDYkMsU0FBUyxFQUNUQyxtQkFBbUIsRUFDcEIsR0FBR3BCLDREQUFRQTtJQUNaLE1BQU0sRUFBRXFCLGlCQUFpQixFQUFFQyxlQUFlLEVBQUUsR0FBR3BCLG1FQUFjQTtJQUM3RCxNQUFNcUIsY0FBY2xDLDZDQUFNQSxDQUFXO0lBQ3JDLE1BQU0sQ0FBQ21DLGVBQWVDLGlCQUFpQixHQUNyQ25DLCtDQUFRQSxDQUFnQk8seURBQWNBO0lBRXhDLDhCQUE4QjtJQUM5QixNQUFNLENBQUM2QixZQUFZQyxjQUFjLEdBQUdyQywrQ0FBUUEsQ0FBQztRQUMzQ3NDLE1BQU07UUFDTkMsUUFBUTtRQUNSQyxPQUFPO1FBQ1BDLEtBQUs7UUFDTEMsUUFBUTtRQUNSQyxRQUFRO0lBQ1Y7SUFFQSwwQkFBMEI7SUFDMUIsTUFBTUMsaUJBQWlCLElBQUksNENBQTRDO0lBQ3ZFLE1BQU1DLHNCQUFzQixHQUFHLDBEQUEwRDtJQUV6RiwwQ0FBMEM7SUFDMUMsTUFBTUMsWUFBWSxTQUFDQyxPQUFlQztZQUFzQkMs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ck4sbUJBQW1Ca0gsT0FBTyxDQUFDLENBQUM5RDtvQkFDdEMsTUFBTTNCLE9BQU96QixpQkFBa0IsQ0FBQ29ELEdBQUcsQ0FBQzNCLElBQUk7b0JBQ3hDLE1BQU1HLE1BQU01QixpQkFBa0IsQ0FBQ29ELEdBQUcsQ0FBQ3hCLEdBQUc7b0JBRXRDLDRCQUE0QjtvQkFDNUIsTUFBTTBMLFVBQVV0RyxTQUFTdUcsYUFBYSxDQUFDLE9BQVUsT0FBSG5LO29CQUM5QyxJQUFJa0ssU0FBUzt3QkFDWEEsUUFBUW5FLFNBQVMsQ0FBQ2hDLE1BQU0sQ0FBQztvQkFDM0I7b0JBRUFwQyxPQUFPLENBQUMzQixHQUFHLEdBQUc7d0JBQ1o2RixTQUFTOzRCQUNQckgsS0FBSyxHQUFPLE9BQUpBLEtBQUk7NEJBQ1pILE1BQU0sR0FBUSxPQUFMQSxNQUFLO3dCQUNoQjtvQkFDRjtnQkFDRjtnQkFFQSxnQ0FBZ0M7Z0JBQ2hDRCxjQUFjO29CQUNaQyxNQUFNO29CQUNOQyxRQUFRO29CQUNSQyxPQUFPO29CQUNQQyxLQUFLO29CQUNMQyxRQUFRO29CQUNSQyxRQUFRO2dCQUNWO2dCQUVBdkMsNkRBQVFBLENBQUNDLDJEQUFXQSxFQUFFO29CQUNwQnVGLFNBQVNBO2dCQUNYO2dCQUNBL0Usb0JBQW9CO1lBQ3RCO1FBQ0Y7Ozs7OztBQUdOO0dBeHFCZ0JFOztRQWdCVkwsd0RBQVFBO1FBQ21DRSwrREFBY0E7OztLQWpCL0NHIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL2ZlYXR1cmVzL2VkaXRvci9zY2VuZS9pbnRlcmFjdGlvbnMudHN4PzJhZWMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2UgY2xpZW50XCI7XG5cbmltcG9ydCB7IHVzZUVmZmVjdCwgdXNlUmVmLCB1c2VTdGF0ZSB9IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IFNlbGVjdGlvbiBmcm9tIFwiQGludGVyYWN0aWZ5L3NlbGVjdGlvblwiO1xuaW1wb3J0IE1vdmVhYmxlIGZyb20gXCJAaW50ZXJhY3RpZnkvbW92ZWFibGVcIjtcbmltcG9ydCB7IGdldElkRnJvbUNsYXNzTmFtZSB9IGZyb20gXCIuLi91dGlscy9zY2VuZVwiO1xuaW1wb3J0IHsgZGlzcGF0Y2ggfSBmcm9tIFwiQGRlc2lnbmNvbWJvL2V2ZW50c1wiO1xuaW1wb3J0IHsgRURJVF9PQkpFQ1QsIExBWUVSX1NFTEVDVElPTiB9IGZyb20gXCJAZGVzaWduY29tYm8vc3RhdGVcIjtcbmltcG9ydCB7XG4gIFNlbGVjdGlvbkluZm8sXG4gIGVtcHR5U2VsZWN0aW9uLFxuICBnZXRTZWxlY3Rpb25CeUlkcyxcbiAgZ2V0VGFyZ2V0QnlJZCxcbn0gZnJvbSBcIi4uL3V0aWxzL3RhcmdldFwiO1xuaW1wb3J0IHVzZVN0b3JlIGZyb20gXCIuLi9zdG9yZS91c2Utc3RvcmVcIjtcbmltcG9ydCBTdGF0ZU1hbmFnZXIgZnJvbSBcIkBkZXNpZ25jb21iby9zdGF0ZVwiO1xuaW1wb3J0IHsgZ2V0Q3VycmVudFRpbWUgfSBmcm9tIFwiLi4vdXRpbHMvdGltZVwiO1xuaW1wb3J0IHVzZUxheW91dFN0b3JlIGZyb20gXCIuLi9zdG9yZS91c2UtbGF5b3V0LXN0b3JlXCI7XG5cbmxldCBob2xkR3JvdXBQb3NpdGlvbjogUmVjb3JkPHN0cmluZywgYW55PiB8IG51bGwgPSBudWxsO1xubGV0IGRyYWdTdGFydEVuZCA9IGZhbHNlO1xuXG5pbnRlcmZhY2UgU2NlbmVJbnRlcmFjdGlvbnNQcm9wcyB7XG4gIHN0YXRlTWFuYWdlcjogU3RhdGVNYW5hZ2VyO1xuICB2aWV3ZXJSZWY6IFJlYWN0LlJlZk9iamVjdDxhbnk+O1xuICBjb250YWluZXJSZWY6IFJlYWN0LlJlZk9iamVjdDxIVE1MRGl2RWxlbWVudD47XG4gIHpvb206IG51bWJlcjtcbiAgc2l6ZTogeyB3aWR0aDogbnVtYmVyOyBoZWlnaHQ6IG51bWJlciB9O1xufVxuZXhwb3J0IGZ1bmN0aW9uIFNjZW5lSW50ZXJhY3Rpb25zKHtcbiAgc3RhdGVNYW5hZ2VyLFxuICB2aWV3ZXJSZWYsXG4gIHpvb20sXG4gIHNpemUsXG4gIGNvbnRhaW5lclJlZixcbn06IFNjZW5lSW50ZXJhY3Rpb25zUHJvcHMpIHtcbiAgY29uc3QgW3RhcmdldHMsIHNldFRhcmdldHNdID0gdXNlU3RhdGU8SFRNTERpdkVsZW1lbnRbXT4oW10pO1xuICBjb25zdCBbc2VsZWN0aW9uLCBzZXRTZWxlY3Rpb25dID0gdXNlU3RhdGU8U2VsZWN0aW9uPigpO1xuICBjb25zdCB7XG4gICAgYWN0aXZlSWRzLFxuICAgIHNldFN0YXRlLFxuICAgIHRyYWNrSXRlbURldGFpbHNNYXAsXG4gICAgdHJhY2tJdGVtc01hcCxcbiAgICBwbGF5ZXJSZWYsXG4gICAgc2V0U2NlbmVNb3ZlYWJsZVJlZixcbiAgfSA9IHVzZVN0b3JlKCk7XG4gIGNvbnN0IHsgc2V0QWN0aXZlTWVudUl0ZW0sIHNldFNob3dNZW51SXRlbSB9ID0gdXNlTGF5b3V0U3RvcmUoKTtcbiAgY29uc3QgbW92ZWFibGVSZWYgPSB1c2VSZWY8TW92ZWFibGU+KG51bGwpO1xuICBjb25zdCBbc2VsZWN0aW9uSW5mbywgc2V0U2VsZWN0aW9uSW5mb10gPVxuICAgIHVzZVN0YXRlPFNlbGVjdGlvbkluZm8+KGVtcHR5U2VsZWN0aW9uKTtcblxuICAvLyBFc3RhZG8gcGFyYSBsYXMgbMOtbmVhcyBndcOtYVxuICBjb25zdCBbc2hvd0d1aWRlcywgc2V0U2hvd0d1aWRlc10gPSB1c2VTdGF0ZSh7XG4gICAgbGVmdDogZmFsc2UsXG4gICAgY2VudGVyOiBmYWxzZSxcbiAgICByaWdodDogZmFsc2UsXG4gICAgdG9wOiBmYWxzZSxcbiAgICBtaWRkbGU6IGZhbHNlLFxuICAgIGJvdHRvbTogZmFsc2VcbiAgfSk7XG5cbiAgLy8gQ29uc3RhbnRlcyBwYXJhIGVsIHNuYXBcbiAgY29uc3QgU05BUF9USFJFU0hPTEQgPSAxNTsgLy8gRGlzdGFuY2lhIGVuIHDDrXhlbGVzIHBhcmEgYWN0aXZhciBlbCBzbmFwXG4gIGNvbnN0IFNOQVBfRURHRV9USFJFU0hPTEQgPSA1OyAvLyBVbWJyYWwgcGFyYSBjb25zaWRlcmFyIHF1ZSB1biBlbGVtZW50byBlc3TDoSBlbiBlbCBib3JkZVxuXG4gIC8vIEZ1bmNpw7NuIHBhcmEgYXBsaWNhciBzbmFwIGEgY29vcmRlbmFkYXNcbiAgY29uc3QgYXBwbHlTbmFwID0gKHZhbHVlOiBudW1iZXIsIHNuYXBQb2ludHM6IG51bWJlcltdLCB0aHJlc2hvbGQ6IG51bWJlciA9IFNOQVBfVEhSRVNIT0xEKTogbnVtYmVyID0+IHtcbiAgICBmb3IgKGNvbnN0IHBvaW50IG9mIHNuYXBQb2ludHMpIHtcbiAgICAgIGlmIChNYXRoLmFicyh2YWx1ZSAtIHBvaW50KSA8PSB0aHJlc2hvbGQpIHtcbiAgICAgICAgcmV0dXJuIHBvaW50O1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG4gIH07XG5cbiAgLy8gRnVuY2nDs24gcGFyYSBhY3R1YWxpemFyIGxhcyBsw61uZWFzIGd1w61hXG4gIGNvbnN0IHVwZGF0ZUd1aWRlTGluZXMgPSAobGVmdDogbnVtYmVyLCB0b3A6IG51bWJlciwgd2lkdGg6IG51bWJlciwgaGVpZ2h0OiBudW1iZXIpID0+IHtcbiAgICAvLyBQdW50b3MgZGUgc25hcCBwYXJhIGxvcyBlamVzIFggZSBZXG4gICAgY29uc3Qgc25hcFBvaW50c1ggPSBbXG4gICAgICAwLCAvLyBCb3JkZSBpenF1aWVyZG9cbiAgICAgIHNpemUud2lkdGggLyAyIC0gd2lkdGggLyAyLCAvLyBDZW50cm8gaG9yaXpvbnRhbFxuICAgICAgc2l6ZS53aWR0aCAtIHdpZHRoIC8vIEJvcmRlIGRlcmVjaG9cbiAgICBdO1xuXG4gICAgY29uc3Qgc25hcFBvaW50c1kgPSBbXG4gICAgICAwLCAvLyBCb3JkZSBzdXBlcmlvclxuICAgICAgc2l6ZS5oZWlnaHQgLyAyIC0gaGVpZ2h0IC8gMiwgLy8gQ2VudHJvIHZlcnRpY2FsXG4gICAgICBzaXplLmhlaWdodCAtIGhlaWdodCAvLyBCb3JkZSBpbmZlcmlvclxuICAgIF07XG5cbiAgICAvLyBWZXJpZmljYXIgcHJveGltaWRhZCBhIGNhZGEgcHVudG8gZGUgc25hcFxuICAgIGNvbnN0IG5ld0d1aWRlcyA9IHtcbiAgICAgIGxlZnQ6IE1hdGguYWJzKGxlZnQgLSBzbmFwUG9pbnRzWFswXSkgPD0gU05BUF9USFJFU0hPTEQsXG4gICAgICBjZW50ZXI6IE1hdGguYWJzKGxlZnQgLSBzbmFwUG9pbnRzWFsxXSkgPD0gU05BUF9USFJFU0hPTEQsXG4gICAgICByaWdodDogTWF0aC5hYnMobGVmdCAtIHNuYXBQb2ludHNYWzJdKSA8PSBTTkFQX1RIUkVTSE9MRCxcbiAgICAgIHRvcDogTWF0aC5hYnModG9wIC0gc25hcFBvaW50c1lbMF0pIDw9IFNOQVBfVEhSRVNIT0xELFxuICAgICAgbWlkZGxlOiBNYXRoLmFicyh0b3AgLSBzbmFwUG9pbnRzWVsxXSkgPD0gU05BUF9USFJFU0hPTEQsXG4gICAgICBib3R0b206IE1hdGguYWJzKHRvcCAtIHNuYXBQb2ludHNZWzJdKSA8PSBTTkFQX1RIUkVTSE9MRFxuICAgIH07XG5cbiAgICBzZXRTaG93R3VpZGVzKG5ld0d1aWRlcyk7XG4gIH07XG5cbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCB1cGRhdGVUYXJnZXRzID0gKHRpbWU/OiBudW1iZXIpID0+IHtcbiAgICAgIGNvbnN0IGN1cnJlbnRUaW1lID0gdGltZSB8fCBnZXRDdXJyZW50VGltZSgpO1xuICAgICAgY29uc3QgeyB0cmFja0l0ZW1zTWFwIH0gPSB1c2VTdG9yZS5nZXRTdGF0ZSgpO1xuICAgICAgY29uc3QgdGFyZ2V0SWRzID0gYWN0aXZlSWRzLmZpbHRlcigoaWQpID0+IHtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICB0cmFja0l0ZW1zTWFwW2lkXT8uZGlzcGxheS5mcm9tIDw9IGN1cnJlbnRUaW1lICYmXG4gICAgICAgICAgdHJhY2tJdGVtc01hcFtpZF0/LmRpc3BsYXkudG8gPj0gY3VycmVudFRpbWVcbiAgICAgICAgKTtcbiAgICAgIH0pO1xuICAgICAgY29uc3QgdGFyZ2V0cyA9IHRhcmdldElkcy5tYXAoXG4gICAgICAgIChpZCkgPT4gZ2V0VGFyZ2V0QnlJZChpZCkgYXMgSFRNTERpdkVsZW1lbnQsXG4gICAgICApO1xuICAgICAgc2VsZWN0aW9uPy5zZXRTZWxlY3RlZFRhcmdldHModGFyZ2V0cyk7XG4gICAgICBjb25zdCBzZWxJbmZvID0gZ2V0U2VsZWN0aW9uQnlJZHModGFyZ2V0SWRzKTtcblxuICAgICAgc2V0U2VsZWN0aW9uSW5mbyhzZWxJbmZvKTtcbiAgICAgIHNldFRhcmdldHMoc2VsSW5mby50YXJnZXRzIGFzIEhUTUxEaXZFbGVtZW50W10pO1xuICAgIH07XG4gICAgY29uc3QgdGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHVwZGF0ZVRhcmdldHMoKTtcbiAgICB9KTtcblxuICAgIGNvbnN0IG9uU2Vla2VkID0gKHY6IGFueSkgPT4ge1xuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgZnBzIH0gPSB1c2VTdG9yZS5nZXRTdGF0ZSgpO1xuICAgICAgICBjb25zdCBzZWVrZWRUaW1lID0gKHYuZGV0YWlsLmZyYW1lIC8gZnBzKSAqIDEwMDA7XG4gICAgICAgIHVwZGF0ZVRhcmdldHMoc2Vla2VkVGltZSk7XG4gICAgICB9KTtcbiAgICB9O1xuICAgIHBsYXllclJlZj8uY3VycmVudD8uYWRkRXZlbnRMaXN0ZW5lcihcInNlZWtlZFwiLCBvblNlZWtlZCk7XG5cbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgcGxheWVyUmVmPy5jdXJyZW50Py5yZW1vdmVFdmVudExpc3RlbmVyKFwic2Vla2VkXCIsIG9uU2Vla2VkKTtcbiAgICAgIGNsZWFyVGltZW91dCh0aW1lcik7XG4gICAgfTtcbiAgfSwgW2FjdGl2ZUlkcywgcGxheWVyUmVmLCB0cmFja0l0ZW1zTWFwXSk7XG5cbiAgLy8gRnVuY2nDs24gcGFyYSBtYW5lamFyIGxhIHNlbGVjY2nDs24gZGUgZWxlbWVudG9zXG4gIGNvbnN0IGhhbmRsZVNlbGVjdGlvbiA9IChpZHM6IHN0cmluZ1tdKSA9PiB7XG4gICAgY29uc29sZS5sb2coXCJbREVCVUcgSW50ZXJhY3Rpb25zXSBTZWxlY2Npw7NuIGRlIGVsZW1lbnRvczpcIiwgaWRzKTtcblxuICAgIC8vIEFjdHVhbGl6YXIgZWwgZXN0YWRvIGRlIGFjdGl2ZUlkc1xuICAgIHN0YXRlTWFuYWdlci51cGRhdGVTdGF0ZShcbiAgICAgIHtcbiAgICAgICAgYWN0aXZlSWRzOiBpZHMsXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICB1cGRhdGVIaXN0b3J5OiBmYWxzZSxcbiAgICAgICAga2luZDogXCJsYXllcjpzZWxlY3Rpb25cIixcbiAgICAgIH0sXG4gICAgKTtcblxuICAgIC8vIFNpIHNlIGhhIHNlbGVjY2lvbmFkbyB1biBzb2xvIGVsZW1lbnRvLCBjYW1iaWFyIGlubWVkaWF0YW1lbnRlIGFsIHBhbmVsIGRlIGF0cmlidXRvc1xuICAgIGlmIChpZHMgJiYgaWRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgY29uc29sZS5sb2coXCJbREVCVUcgSW50ZXJhY3Rpb25zXSBDYW1iaWFuZG8gYSBwYW5lbCBkZSBhdHJpYnV0b3MgZGlyZWN0YW1lbnRlIGRlc2RlIGludGVyYWN0aW9uc1wiKTtcblxuICAgICAgLy8gRk9SWkFSIGNhbWJpbyBkaXJlY3RvIGFsIHBhbmVsIGRlIGF0cmlidXRvc1xuICAgICAgc2V0QWN0aXZlTWVudUl0ZW0oXCJhdHRyaWJ1dGVzXCIpO1xuICAgICAgc2V0U2hvd01lbnVJdGVtKHRydWUpO1xuXG4gICAgICAvLyBGb3J6YXIgZWwgZXZlbnRvIGRlIHNlbGVjY2nDs24gcGFyYSBhc2VndXJhciBxdWUgdG9kb3MgbG9zIGNvbXBvbmVudGVzIHNlIGFjdHVhbGljZW5cbiAgICAgIGRpc3BhdGNoKExBWUVSX1NFTEVDVElPTiwge1xuICAgICAgICBwYXlsb2FkOiB7XG4gICAgICAgICAgYWN0aXZlSWRzOiBpZHNcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIC8vIFZlcmlmaWNhciBlbCBjYW1iaW9cbiAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBjb25zdCBjdXJyZW50TWVudUl0ZW0gPSB1c2VMYXlvdXRTdG9yZS5nZXRTdGF0ZSgpLmFjdGl2ZU1lbnVJdGVtO1xuICAgICAgICBjb25zb2xlLmxvZyhcIltERUJVRyBJbnRlcmFjdGlvbnNdIFBhbmVsIGRlc3B1w6lzIGRlbCBjYW1iaW86XCIsIGN1cnJlbnRNZW51SXRlbSk7XG4gICAgICB9LCAxMDApO1xuICAgIH1cbiAgfTtcblxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGNvbnN0IHNlbGVjdGlvbiA9IG5ldyBTZWxlY3Rpb24oe1xuICAgICAgY29udGFpbmVyOiB2aWV3ZXJSZWYuY3VycmVudD8uaW5maW5pdGVWaWV3ZXIuZ2V0Q29udGFpbmVyKCksXG4gICAgICBib3VuZENvbnRhaW5lcjogdHJ1ZSxcbiAgICAgIGhpdFJhdGU6IDAsXG4gICAgICBzZWxlY3RhYmxlVGFyZ2V0czogW1wiLmRlc2lnbmNvbWJvLXNjZW5lLWl0ZW1cIl0sXG4gICAgICBzZWxlY3RGcm9tSW5zaWRlOiBmYWxzZSxcbiAgICAgIHNlbGVjdEJ5Q2xpY2s6IHRydWUsXG4gICAgICB0b2dnbGVDb250aW51ZVNlbGVjdDogXCJzaGlmdFwiLFxuICAgIH0pXG4gICAgICAub24oXCJzZWxlY3RcIiwgKGUpID0+IHtcbiAgICAgICAgY29uc3QgaWRzID0gZS5zZWxlY3RlZC5tYXAoKGVsKSA9PiBnZXRJZEZyb21DbGFzc05hbWUoZWwuY2xhc3NOYW1lKSk7XG4gICAgICAgIHNldFRhcmdldHMoZS5zZWxlY3RlZCBhcyBIVE1MRGl2RWxlbWVudFtdKTtcblxuICAgICAgICAvLyBVc2FyIGxhIGZ1bmNpw7NuIGhhbmRsZVNlbGVjdGlvblxuICAgICAgICBoYW5kbGVTZWxlY3Rpb24oaWRzKTtcbiAgICAgIH0pXG4gICAgICAub24oXCJkcmFnU3RhcnRcIiwgKGUpID0+IHtcbiAgICAgICAgY29uc3QgdGFyZ2V0ID0gZS5pbnB1dEV2ZW50LnRhcmdldCBhcyBIVE1MRGl2RWxlbWVudDtcbiAgICAgICAgZHJhZ1N0YXJ0RW5kID0gZmFsc2U7XG5cbiAgICAgICAgaWYgKHRhcmdldHMuaW5jbHVkZXModGFyZ2V0KSkge1xuICAgICAgICAgIGUuc3RvcCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChcbiAgICAgICAgICB0YXJnZXQgJiZcbiAgICAgICAgICBtb3ZlYWJsZVJlZj8uY3VycmVudD8ubW92ZWFibGUuaXNNb3ZlYWJsZUVsZW1lbnQodGFyZ2V0KVxuICAgICAgICApIHtcbiAgICAgICAgICBlLnN0b3AoKTtcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICAgIC5vbihcImRyYWdFbmRcIiwgKCkgPT4ge1xuICAgICAgICBkcmFnU3RhcnRFbmQgPSB0cnVlO1xuICAgICAgfSlcbiAgICAgIC5vbihcInNlbGVjdEVuZFwiLCAoZSkgPT4ge1xuICAgICAgICBjb25zdCBtb3ZlYWJsZSA9IG1vdmVhYmxlUmVmLmN1cnJlbnQ7XG4gICAgICAgIGlmIChlLmlzRHJhZ1N0YXJ0KSB7XG4gICAgICAgICAgZS5pbnB1dEV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICBpZiAoIWRyYWdTdGFydEVuZCkge1xuICAgICAgICAgICAgICBtb3ZlYWJsZT8ubW92ZWFibGUuZHJhZ1N0YXJ0KGUuaW5wdXRFdmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc3QgdGFyZ2V0cyA9IGUuc2VsZWN0ZWQgYXMgSFRNTERpdkVsZW1lbnRbXTtcbiAgICAgICAgICBjb25zdCBpZHMgPSB0YXJnZXRzLm1hcCgoZWwpID0+IGdldElkRnJvbUNsYXNzTmFtZShlbC5jbGFzc05hbWUpKTtcblxuICAgICAgICAgIC8vIFVzYXIgbGEgZnVuY2nDs24gaGFuZGxlU2VsZWN0aW9uXG4gICAgICAgICAgaGFuZGxlU2VsZWN0aW9uKGlkcyk7XG4gICAgICAgICAgc2V0VGFyZ2V0cyh0YXJnZXRzKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgc2V0U2VsZWN0aW9uKHNlbGVjdGlvbik7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHNlbGVjdGlvbi5kZXN0cm95KCk7XG4gICAgfTtcbiAgfSwgW10pO1xuXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgY29uc3QgYWN0aXZlU2VsZWN0aW9uU3Vic2NyaXB0aW9uID0gc3RhdGVNYW5hZ2VyLnN1YnNjcmliZVRvQWN0aXZlSWRzKFxuICAgICAgKG5ld1N0YXRlKSA9PiB7XG4gICAgICAgIHNldFN0YXRlKG5ld1N0YXRlKTtcblxuICAgICAgICAvLyBTaSBoYXkgdW4gc29sbyBlbGVtZW50byBzZWxlY2Npb25hZG8sIGFzZWd1cmFyc2UgZGUgcXVlIHNlIG11ZXN0cmUgZWwgcGFuZWwgZGUgYXRyaWJ1dG9zXG4gICAgICAgIGlmIChuZXdTdGF0ZS5hY3RpdmVJZHMgJiYgbmV3U3RhdGUuYWN0aXZlSWRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgIHNldEFjdGl2ZU1lbnVJdGVtKFwiYXR0cmlidXRlc1wiKTtcbiAgICAgICAgICBzZXRTaG93TWVudUl0ZW0odHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgKTtcblxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBhY3RpdmVTZWxlY3Rpb25TdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICB9O1xuICB9LCBbXSk7XG5cbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBtb3ZlYWJsZVJlZi5jdXJyZW50IS5tb3ZlYWJsZS51cGRhdGVSZWN0KCk7XG4gIH0sIFt0cmFja0l0ZW1zTWFwXSk7XG5cbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBzZXRTY2VuZU1vdmVhYmxlUmVmKG1vdmVhYmxlUmVmKTtcbiAgfSwgW21vdmVhYmxlUmVmXSk7XG5cbiAgLy8gRWZlY3RvIHBhcmEgY3JlYXIgeSBnZXN0aW9uYXIgbGFzIGzDrW5lYXMgZ3XDrWFcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAvLyBBc2VndXJhcnNlIGRlIHF1ZSBlbCBjb250ZW5lZG9yIGV4aXN0ZVxuICAgIGlmICghY29udGFpbmVyUmVmPy5jdXJyZW50KSByZXR1cm47XG5cbiAgICAvLyBDcmVhciBsb3MgZWxlbWVudG9zIGRlIGzDrW5lYXMgZ3XDrWEgc2kgbm8gZXhpc3RlblxuICAgIGNvbnN0IGNyZWF0ZUd1aWRlTGluZXMgPSAoKSA9PiB7XG4gICAgICBjb25zdCBjb250YWluZXIgPSBjb250YWluZXJSZWYuY3VycmVudDtcbiAgICAgIGlmICghY29udGFpbmVyKSByZXR1cm47XG5cbiAgICAgIC8vIEVsaW1pbmFyIGd1w61hcyBleGlzdGVudGVzIHByaW1lcm9cbiAgICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJy5ndWlkZS1saW5lJykuZm9yRWFjaChlbCA9PiBlbC5yZW1vdmUoKSk7XG5cbiAgICAgIC8vIENyZWFyIG51ZXZhcyBndcOtYXNcbiAgICAgIGNvbnN0IGd1aWRlUG9zaXRpb25zID0gW1xuICAgICAgICB7IG5hbWU6ICdsZWZ0Jywgc3R5bGU6IGBsZWZ0OiAwOyB0b3A6IDA7IHdpZHRoOiAycHg7IGhlaWdodDogJHtzaXplLmhlaWdodH1weDtgIH0sXG4gICAgICAgIHsgbmFtZTogJ2NlbnRlcicsIHN0eWxlOiBgbGVmdDogJHtzaXplLndpZHRoLzJ9cHg7IHRvcDogMDsgd2lkdGg6IDJweDsgaGVpZ2h0OiAke3NpemUuaGVpZ2h0fXB4OyB0cmFuc2Zvcm06IHRyYW5zbGF0ZVgoLTUwJSk7YCB9LFxuICAgICAgICB7IG5hbWU6ICdyaWdodCcsIHN0eWxlOiBgbGVmdDogJHtzaXplLndpZHRofXB4OyB0b3A6IDA7IHdpZHRoOiAycHg7IGhlaWdodDogJHtzaXplLmhlaWdodH1weDtgIH0sXG4gICAgICAgIHsgbmFtZTogJ3RvcCcsIHN0eWxlOiBgdG9wOiAwOyBsZWZ0OiAwOyBoZWlnaHQ6IDJweDsgd2lkdGg6ICR7c2l6ZS53aWR0aH1weDtgIH0sXG4gICAgICAgIHsgbmFtZTogJ21pZGRsZScsIHN0eWxlOiBgdG9wOiAke3NpemUuaGVpZ2h0LzJ9cHg7IGxlZnQ6IDA7IGhlaWdodDogMnB4OyB3aWR0aDogJHtzaXplLndpZHRofXB4OyB0cmFuc2Zvcm06IHRyYW5zbGF0ZVkoLTUwJSk7YCB9LFxuICAgICAgICB7IG5hbWU6ICdib3R0b20nLCBzdHlsZTogYHRvcDogJHtzaXplLmhlaWdodH1weDsgbGVmdDogMDsgaGVpZ2h0OiAycHg7IHdpZHRoOiAke3NpemUud2lkdGh9cHg7YCB9XG4gICAgICBdO1xuXG4gICAgICBndWlkZVBvc2l0aW9ucy5mb3JFYWNoKGd1aWRlID0+IHtcbiAgICAgICAgY29uc3QgZ3VpZGVFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIGd1aWRlRWxlbWVudC5jbGFzc05hbWUgPSBgZ3VpZGUtbGluZSBndWlkZS0ke2d1aWRlLm5hbWV9YDtcbiAgICAgICAgZ3VpZGVFbGVtZW50LnNldEF0dHJpYnV0ZSgnc3R5bGUnLCBgXG4gICAgICAgICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgICAgICAgIGJhY2tncm91bmQ6IHJnYmEoMTU2LCA5MCwgMjUwLCAwLjgpO1xuICAgICAgICAgIGJveC1zaGFkb3c6IDAgMCA0cHggcmdiYSgxNTYsIDkwLCAyNTAsIDAuNSk7XG4gICAgICAgICAgcG9pbnRlci1ldmVudHM6IG5vbmU7XG4gICAgICAgICAgb3BhY2l0eTogMDtcbiAgICAgICAgICB0cmFuc2l0aW9uOiBvcGFjaXR5IDAuMTVzIGVhc2Utb3V0O1xuICAgICAgICAgIHotaW5kZXg6IDk5OTk7XG4gICAgICAgICAgJHtndWlkZS5zdHlsZX1cbiAgICAgICAgYCk7XG4gICAgICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZChndWlkZUVsZW1lbnQpO1xuICAgICAgfSk7XG4gICAgfTtcblxuICAgIGNyZWF0ZUd1aWRlTGluZXMoKTtcblxuICAgIC8vIEFjdHVhbGl6YXIgbMOtbmVhcyBndcOtYSBhbCByZWRpbWVuc2lvbmFyXG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIGNyZWF0ZUd1aWRlTGluZXMpO1xuXG4gICAgLy8gTGltcGlhciBhbCBkZXNtb250YXJcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIGNyZWF0ZUd1aWRlTGluZXMpO1xuICAgICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnLmd1aWRlLWxpbmUnKS5mb3JFYWNoKGVsID0+IGVsLnJlbW92ZSgpKTtcbiAgICB9O1xuICB9LCBbY29udGFpbmVyUmVmLCBzaXplXSk7XG5cbiAgLy8gQWN0dWFsaXphciB2aXNpYmlsaWRhZCBkZSBsYXMgbMOtbmVhcyBndcOtYVxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJy5ndWlkZS1saW5lJykuZm9yRWFjaChlbCA9PiB7XG4gICAgICBjb25zdCBndWlkZU5hbWUgPSBlbC5jbGFzc05hbWUuc3BsaXQoJyAnKVsxXS5yZXBsYWNlKCdndWlkZS0nLCAnJyk7XG4gICAgICBpZiAoc2hvd0d1aWRlc1tndWlkZU5hbWUgYXMga2V5b2YgdHlwZW9mIHNob3dHdWlkZXNdKSB7XG4gICAgICAgIChlbCBhcyBIVE1MRWxlbWVudCkuc3R5bGUub3BhY2l0eSA9ICcxJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIChlbCBhcyBIVE1MRWxlbWVudCkuc3R5bGUub3BhY2l0eSA9ICcwJztcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIE9jdWx0YXIgZ3XDrWFzIGRlc3B1w6lzIGRlIHVuIHRpZW1wb1xuICAgIGNvbnN0IGhpZGVHdWlkZXNUaW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICBzZXRTaG93R3VpZGVzKHtcbiAgICAgICAgbGVmdDogZmFsc2UsXG4gICAgICAgIGNlbnRlcjogZmFsc2UsXG4gICAgICAgIHJpZ2h0OiBmYWxzZSxcbiAgICAgICAgdG9wOiBmYWxzZSxcbiAgICAgICAgbWlkZGxlOiBmYWxzZSxcbiAgICAgICAgYm90dG9tOiBmYWxzZVxuICAgICAgfSk7XG4gICAgfSwgMTAwMCk7XG5cbiAgICByZXR1cm4gKCkgPT4gY2xlYXJUaW1lb3V0KGhpZGVHdWlkZXNUaW1lb3V0KTtcbiAgfSwgW3Nob3dHdWlkZXNdKTtcblxuICByZXR1cm4gKFxuICAgIDxNb3ZlYWJsZVxuICAgICAgcmVmPXttb3ZlYWJsZVJlZn1cbiAgICAgIHJvdGF0aW9uUG9zaXRpb249e1wiYm90dG9tXCJ9XG4gICAgICByZW5kZXJEaXJlY3Rpb25zPXtzZWxlY3Rpb25JbmZvLmNvbnRyb2xzfVxuICAgICAgey4uLnNlbGVjdGlvbkluZm8uYWJsZXN9XG4gICAgICBvcmlnaW49e2ZhbHNlfVxuICAgICAgdGFyZ2V0PXt0YXJnZXRzfVxuICAgICAgem9vbT17MSAvIHpvb219XG4gICAgICBjbGFzc05hbWU9XCJkZXNpZ25jb21iby1zY2VuZS1tb3ZlYWJsZVwiXG4gICAgICBvbkRyYWc9eyh7IHRhcmdldCwgYmVmb3JlVHJhbnNsYXRlLCBpbnB1dEV2ZW50IH0pID0+IHtcbiAgICAgICAgY29uc3QgdGFyZ2V0SWQgPSBnZXRJZEZyb21DbGFzc05hbWUodGFyZ2V0LmNsYXNzTmFtZSkgYXMgc3RyaW5nO1xuICAgICAgICBjb25zdCB0cmFja0l0ZW0gPSB0cmFja0l0ZW1EZXRhaWxzTWFwW3RhcmdldElkXTtcblxuICAgICAgICAvLyBPYnRlbmVyIGRpbWVuc2lvbmVzIGRlbCBlbGVtZW50b1xuICAgICAgICBjb25zdCB0YXJnZXRXaWR0aCA9IHRhcmdldC5vZmZzZXRXaWR0aDtcbiAgICAgICAgY29uc3QgdGFyZ2V0SGVpZ2h0ID0gdGFyZ2V0Lm9mZnNldEhlaWdodDtcblxuICAgICAgICAvLyBDYWxjdWxhciBsYSBwb3NpY2nDs24gcHJvcHVlc3RhXG4gICAgICAgIGxldCBsZWZ0ID0gcGFyc2VGbG9hdCh0cmFja0l0ZW0/LmRldGFpbHMubGVmdCBhcyBzdHJpbmcpICsgYmVmb3JlVHJhbnNsYXRlWzBdO1xuICAgICAgICBsZXQgdG9wID0gcGFyc2VGbG9hdCh0cmFja0l0ZW0/LmRldGFpbHMudG9wIGFzIHN0cmluZykgKyBiZWZvcmVUcmFuc2xhdGVbMV07XG5cbiAgICAgICAgLy8gUHVudG9zIGRlIHNuYXAgcGFyYSBlbCBlamUgWCAoaXpxdWllcmRhLCBjZW50cm8sIGRlcmVjaGEpXG4gICAgICAgIGNvbnN0IHNuYXBQb2ludHNYID0gW1xuICAgICAgICAgIDAsIC8vIEJvcmRlIGl6cXVpZXJkb1xuICAgICAgICAgIHNpemUud2lkdGggLyAyIC0gdGFyZ2V0V2lkdGggLyAyLCAvLyBDZW50cm8gaG9yaXpvbnRhbFxuICAgICAgICAgIHNpemUud2lkdGggLSB0YXJnZXRXaWR0aCAvLyBCb3JkZSBkZXJlY2hvXG4gICAgICAgIF07XG5cbiAgICAgICAgLy8gUHVudG9zIGRlIHNuYXAgcGFyYSBlbCBlamUgWSAoYXJyaWJhLCBjZW50cm8sIGFiYWpvKVxuICAgICAgICBjb25zdCBzbmFwUG9pbnRzWSA9IFtcbiAgICAgICAgICAwLCAvLyBCb3JkZSBzdXBlcmlvclxuICAgICAgICAgIHNpemUuaGVpZ2h0IC8gMiAtIHRhcmdldEhlaWdodCAvIDIsIC8vIENlbnRybyB2ZXJ0aWNhbFxuICAgICAgICAgIHNpemUuaGVpZ2h0IC0gdGFyZ2V0SGVpZ2h0IC8vIEJvcmRlIGluZmVyaW9yXG4gICAgICAgIF07XG5cbiAgICAgICAgLy8gQWN0dWFsaXphciBsw61uZWFzIGd1w61hIGFudGVzIGRlIGFwbGljYXIgZWwgc25hcFxuICAgICAgICB1cGRhdGVHdWlkZUxpbmVzKGxlZnQsIHRvcCwgdGFyZ2V0V2lkdGgsIHRhcmdldEhlaWdodCk7XG5cbiAgICAgICAgLy8gQXBsaWNhciBzbmFwIGNvbiB1bWJyYWwgbm9ybWFsXG4gICAgICAgIGxlZnQgPSBhcHBseVNuYXAobGVmdCwgc25hcFBvaW50c1gpO1xuICAgICAgICB0b3AgPSBhcHBseVNuYXAodG9wLCBzbmFwUG9pbnRzWSk7XG5cbiAgICAgICAgLy8gRmVlZGJhY2sgdmlzdWFsIHBhcmEgaW5kaWNhciBlbCBzbmFwIChvcGNpb25hbClcbiAgICAgICAgaWYgKHNuYXBQb2ludHNYLnNvbWUocG9pbnQgPT4gTWF0aC5hYnMobGVmdCAtIHBvaW50KSA8PSBTTkFQX0VER0VfVEhSRVNIT0xEKSB8fFxuICAgICAgICAgICAgc25hcFBvaW50c1kuc29tZShwb2ludCA9PiBNYXRoLmFicyh0b3AgLSBwb2ludCkgPD0gU05BUF9FREdFX1RIUkVTSE9MRCkpIHtcbiAgICAgICAgICAvLyBTZSBwb2Ryw61hIGHDsWFkaXIgdW5hIGNsYXNlIENTUyBwYXJhIGluZGljYXIgdmlzdWFsbWVudGUgZWwgc25hcFxuICAgICAgICAgIHRhcmdldC5jbGFzc0xpc3QuYWRkKCdzbmFwcGVkLWVsZW1lbnQnKTtcblxuICAgICAgICAgIC8vIEHDsWFkaXIgcGVxdWXDsWEgdmlicmFjacOzbiBjb21vIGZlZWRiYWNrIHTDoWN0aWwgKG9wY2lvbmFsKVxuICAgICAgICAgIGlmIChpbnB1dEV2ZW50IGluc3RhbmNlb2YgTW91c2VFdmVudCAmJiAndmlicmF0ZScgaW4gbmF2aWdhdG9yKSB7XG4gICAgICAgICAgICBuYXZpZ2F0b3IudmlicmF0ZSgxMCk7IC8vIFZpYnJhY2nDs24gc3V0aWwgZGUgMTBtc1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0YXJnZXQuY2xhc3NMaXN0LnJlbW92ZSgnc25hcHBlZC1lbGVtZW50Jyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBBY3R1YWxpemFyIHBvc2ljacOzblxuICAgICAgICB0YXJnZXQuc3R5bGUudG9wID0gdG9wICsgXCJweFwiO1xuICAgICAgICB0YXJnZXQuc3R5bGUubGVmdCA9IGxlZnQgKyBcInB4XCI7XG4gICAgICB9fVxuICAgICAgb25EcmFnRW5kPXsoeyB0YXJnZXQsIGlzRHJhZyB9KSA9PiB7XG4gICAgICAgIGlmICghaXNEcmFnKSByZXR1cm47XG4gICAgICAgIGNvbnN0IHRhcmdldElkID0gZ2V0SWRGcm9tQ2xhc3NOYW1lKHRhcmdldC5jbGFzc05hbWUpIGFzIHN0cmluZztcblxuICAgICAgICAvLyBFbGltaW5hciBsYSBjbGFzZSBkZSBzbmFwIGFsIGZpbmFsaXphclxuICAgICAgICB0YXJnZXQuY2xhc3NMaXN0LnJlbW92ZSgnc25hcHBlZC1lbGVtZW50Jyk7XG5cbiAgICAgICAgLy8gT2N1bHRhciB0b2RhcyBsYXMgbMOtbmVhcyBndcOtYVxuICAgICAgICBzZXRTaG93R3VpZGVzKHtcbiAgICAgICAgICBsZWZ0OiBmYWxzZSxcbiAgICAgICAgICBjZW50ZXI6IGZhbHNlLFxuICAgICAgICAgIHJpZ2h0OiBmYWxzZSxcbiAgICAgICAgICB0b3A6IGZhbHNlLFxuICAgICAgICAgIG1pZGRsZTogZmFsc2UsXG4gICAgICAgICAgYm90dG9tOiBmYWxzZVxuICAgICAgICB9KTtcblxuICAgICAgICBkaXNwYXRjaChFRElUX09CSkVDVCwge1xuICAgICAgICAgIHBheWxvYWQ6IHtcbiAgICAgICAgICAgIFt0YXJnZXRJZF06IHtcbiAgICAgICAgICAgICAgZGV0YWlsczoge1xuICAgICAgICAgICAgICAgIGxlZnQ6IHRhcmdldC5zdHlsZS5sZWZ0LFxuICAgICAgICAgICAgICAgIHRvcDogdGFyZ2V0LnN0eWxlLnRvcCxcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgICB9fVxuICAgICAgb25TY2FsZT17KHsgdGFyZ2V0LCB0cmFuc2Zvcm0sIGRpcmVjdGlvbiB9KSA9PiB7XG4gICAgICAgIGNvbnN0IFt4Q29udHJvbCwgeUNvbnRyb2xdID0gZGlyZWN0aW9uO1xuXG4gICAgICAgIGNvbnN0IHNjYWxlUmVnZXggPSAvc2NhbGVcXCgoW14pXSspXFwpLztcbiAgICAgICAgY29uc3QgbWF0Y2ggPSB0YXJnZXQuc3R5bGUudHJhbnNmb3JtLm1hdGNoKHNjYWxlUmVnZXgpITtcblxuICAgICAgICAvL2dldCBjdXJyZW50IHNjYWxlXG4gICAgICAgIGNvbnN0IFtzY2FsZVgsIHNjYWxlWV0gPSBtYXRjaFsxXVxuICAgICAgICAgIC5zcGxpdChcIixcIilcbiAgICAgICAgICAubWFwKCh2YWx1ZSkgPT4gcGFyc2VGbG9hdCh2YWx1ZS50cmltKCkpKTtcblxuICAgICAgICAvL2dldCBuZXcgU2NhbGVcbiAgICAgICAgY29uc3QgbWF0Y2gyID0gdHJhbnNmb3JtLm1hdGNoKHNjYWxlUmVnZXgpITtcbiAgICAgICAgY29uc3QgW25ld1NjYWxlWCwgbmV3U2NhbGVZXSA9IG1hdGNoMlsxXVxuICAgICAgICAgIC5zcGxpdChcIixcIilcbiAgICAgICAgICAubWFwKCh2YWx1ZSkgPT4gcGFyc2VGbG9hdCh2YWx1ZS50cmltKCkpKTtcblxuICAgICAgICBjb25zdCBjdXJyZW50V2lkdGggPSB0YXJnZXQuY2xpZW50V2lkdGggKiBzY2FsZVg7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRIZWlnaHQgPSB0YXJnZXQuY2xpZW50SGVpZ2h0ICogc2NhbGVZO1xuXG4gICAgICAgIGNvbnN0IG5ld1dpZHRoID0gdGFyZ2V0LmNsaWVudFdpZHRoICogbmV3U2NhbGVYO1xuICAgICAgICBjb25zdCBuZXdIZWlnaHQgPSB0YXJnZXQuY2xpZW50SGVpZ2h0ICogbmV3U2NhbGVZO1xuXG4gICAgICAgIHRhcmdldC5zdHlsZS50cmFuc2Zvcm0gPSB0cmFuc2Zvcm07XG5cbiAgICAgICAgLy9Nb3ZlIGVsZW1lbnQgdG8gaW5pdGlhbCBMZWZ0IHBvc2l0aW9uXG4gICAgICAgIGNvbnN0IGRpZmZYID0gY3VycmVudFdpZHRoIC0gbmV3V2lkdGg7XG4gICAgICAgIGxldCBuZXdMZWZ0ID0gcGFyc2VGbG9hdCh0YXJnZXQuc3R5bGUubGVmdCkgLSBkaWZmWCAvIDI7XG5cbiAgICAgICAgY29uc3QgZGlmZlkgPSBjdXJyZW50SGVpZ2h0IC0gbmV3SGVpZ2h0O1xuICAgICAgICBsZXQgbmV3VG9wID0gcGFyc2VGbG9hdCh0YXJnZXQuc3R5bGUudG9wKSAtIGRpZmZZIC8gMjtcblxuICAgICAgICBpZiAoeENvbnRyb2wgPT09IC0xKSB7XG4gICAgICAgICAgbmV3TGVmdCArPSBkaWZmWDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoeUNvbnRyb2wgPT09IC0xKSB7XG4gICAgICAgICAgbmV3VG9wICs9IGRpZmZZO1xuICAgICAgICB9XG4gICAgICAgIHRhcmdldC5zdHlsZS5sZWZ0ID0gbmV3TGVmdCArIFwicHhcIjtcbiAgICAgICAgdGFyZ2V0LnN0eWxlLnRvcCA9IG5ld1RvcCArIFwicHhcIjtcbiAgICAgIH19XG4gICAgICBvblNjYWxlRW5kPXsoeyB0YXJnZXQgfSkgPT4ge1xuICAgICAgICBpZiAoIXRhcmdldC5zdHlsZS50cmFuc2Zvcm0pIHJldHVybjtcbiAgICAgICAgY29uc3QgdGFyZ2V0SWQgPSBnZXRJZEZyb21DbGFzc05hbWUodGFyZ2V0LmNsYXNzTmFtZSkgYXMgc3RyaW5nO1xuXG4gICAgICAgIGRpc3BhdGNoKEVESVRfT0JKRUNULCB7XG4gICAgICAgICAgcGF5bG9hZDoge1xuICAgICAgICAgICAgW3RhcmdldElkXToge1xuICAgICAgICAgICAgICBkZXRhaWxzOiB7XG4gICAgICAgICAgICAgICAgdHJhbnNmb3JtOiB0YXJnZXQuc3R5bGUudHJhbnNmb3JtLFxuICAgICAgICAgICAgICAgIGxlZnQ6IHBhcnNlRmxvYXQodGFyZ2V0LnN0eWxlLmxlZnQpLFxuICAgICAgICAgICAgICAgIHRvcDogcGFyc2VGbG9hdCh0YXJnZXQuc3R5bGUudG9wKSxcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgICB9fVxuICAgICAgb25Sb3RhdGU9eyh7IHRhcmdldCwgdHJhbnNmb3JtIH0pID0+IHtcbiAgICAgICAgdGFyZ2V0LnN0eWxlLnRyYW5zZm9ybSA9IHRyYW5zZm9ybTtcbiAgICAgIH19XG4gICAgICBvblJvdGF0ZUVuZD17KHsgdGFyZ2V0IH0pID0+IHtcbiAgICAgICAgaWYgKCF0YXJnZXQuc3R5bGUudHJhbnNmb3JtKSByZXR1cm47XG4gICAgICAgIGNvbnN0IHRhcmdldElkID0gZ2V0SWRGcm9tQ2xhc3NOYW1lKHRhcmdldC5jbGFzc05hbWUpIGFzIHN0cmluZztcbiAgICAgICAgZGlzcGF0Y2goRURJVF9PQkpFQ1QsIHtcbiAgICAgICAgICBwYXlsb2FkOiB7XG4gICAgICAgICAgICBbdGFyZ2V0SWRdOiB7XG4gICAgICAgICAgICAgIGRldGFpbHM6IHtcbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm06IHRhcmdldC5zdHlsZS50cmFuc2Zvcm0sXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgICAgfX1cbiAgICAgIG9uRHJhZ0dyb3VwPXsoeyBldmVudHMgfSkgPT4ge1xuICAgICAgICBob2xkR3JvdXBQb3NpdGlvbiA9IHt9O1xuXG4gICAgICAgIC8vIE9idGVuZXIgZWwgcmVjdMOhbmd1bG8gcXVlIGNvbnRpZW5lIHRvZG8gZWwgZ3J1cG9cbiAgICAgICAgbGV0IGdyb3VwTGVmdCA9IEluZmluaXR5O1xuICAgICAgICBsZXQgZ3JvdXBUb3AgPSBJbmZpbml0eTtcbiAgICAgICAgbGV0IGdyb3VwUmlnaHQgPSAtSW5maW5pdHk7XG4gICAgICAgIGxldCBncm91cEJvdHRvbSA9IC1JbmZpbml0eTtcblxuICAgICAgICAvLyBQcmltZXIgcGFzbzogY2FsY3VsYXIgZGltZW5zaW9uZXMgZGVsIGdydXBvXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZXZlbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgY29uc3QgZXZlbnQgPSBldmVudHNbaV07XG4gICAgICAgICAgY29uc3QgaWQgPSBnZXRJZEZyb21DbGFzc05hbWUoZXZlbnQudGFyZ2V0LmNsYXNzTmFtZSk7XG4gICAgICAgICAgY29uc3QgdHJhY2tJdGVtID0gdHJhY2tJdGVtRGV0YWlsc01hcFtpZF07XG5cbiAgICAgICAgICBjb25zdCBsZWZ0ID0gcGFyc2VGbG9hdCh0cmFja0l0ZW0/LmRldGFpbHMubGVmdCBhcyBzdHJpbmcpO1xuICAgICAgICAgIGNvbnN0IHRvcCA9IHBhcnNlRmxvYXQodHJhY2tJdGVtPy5kZXRhaWxzLnRvcCBhcyBzdHJpbmcpO1xuICAgICAgICAgIGNvbnN0IHdpZHRoID0gZXZlbnQudGFyZ2V0Lm9mZnNldFdpZHRoO1xuICAgICAgICAgIGNvbnN0IGhlaWdodCA9IGV2ZW50LnRhcmdldC5vZmZzZXRIZWlnaHQ7XG5cbiAgICAgICAgICBncm91cExlZnQgPSBNYXRoLm1pbihncm91cExlZnQsIGxlZnQpO1xuICAgICAgICAgIGdyb3VwVG9wID0gTWF0aC5taW4oZ3JvdXBUb3AsIHRvcCk7XG4gICAgICAgICAgZ3JvdXBSaWdodCA9IE1hdGgubWF4KGdyb3VwUmlnaHQsIGxlZnQgKyB3aWR0aCk7XG4gICAgICAgICAgZ3JvdXBCb3R0b20gPSBNYXRoLm1heChncm91cEJvdHRvbSwgdG9wICsgaGVpZ2h0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGdyb3VwV2lkdGggPSBncm91cFJpZ2h0IC0gZ3JvdXBMZWZ0O1xuICAgICAgICBjb25zdCBncm91cEhlaWdodCA9IGdyb3VwQm90dG9tIC0gZ3JvdXBUb3A7XG5cbiAgICAgICAgLy8gQ2FsY3VsYXIgZWwgZGVzcGxhemFtaWVudG8gYmFzZSBkZWwgZ3J1cG8gKGRlc2RlIGVsIHByaW1lciBlbGVtZW50bylcbiAgICAgICAgY29uc3QgYmFzZVRyYW5zbGF0ZSA9IGV2ZW50c1swXS5iZWZvcmVUcmFuc2xhdGU7XG5cbiAgICAgICAgLy8gQ2FsY3VsYXIgbnVldmEgcG9zaWNpw7NuIGRlbCBncnVwbyBjb24gcG9zaWJsZSBzbmFwXG4gICAgICAgIGxldCBuZXdHcm91cExlZnQgPSBncm91cExlZnQgKyBiYXNlVHJhbnNsYXRlWzBdO1xuICAgICAgICBsZXQgbmV3R3JvdXBUb3AgPSBncm91cFRvcCArIGJhc2VUcmFuc2xhdGVbMV07XG5cbiAgICAgICAgLy8gQWN0dWFsaXphciBsw61uZWFzIGd1w61hIHBhcmEgZWwgZ3J1cG9cbiAgICAgICAgdXBkYXRlR3VpZGVMaW5lcyhuZXdHcm91cExlZnQsIG5ld0dyb3VwVG9wLCBncm91cFdpZHRoLCBncm91cEhlaWdodCk7XG5cbiAgICAgICAgLy8gUHVudG9zIGRlIHNuYXAgcGFyYSBlbCBncnVwb1xuICAgICAgICBjb25zdCBzbmFwUG9pbnRzWCA9IFtcbiAgICAgICAgICAwLCAvLyBCb3JkZSBpenF1aWVyZG9cbiAgICAgICAgICBzaXplLndpZHRoIC8gMiAtIGdyb3VwV2lkdGggLyAyLCAvLyBDZW50cm8gaG9yaXpvbnRhbFxuICAgICAgICAgIHNpemUud2lkdGggLSBncm91cFdpZHRoIC8vIEJvcmRlIGRlcmVjaG9cbiAgICAgICAgXTtcblxuICAgICAgICBjb25zdCBzbmFwUG9pbnRzWSA9IFtcbiAgICAgICAgICAwLCAvLyBCb3JkZSBzdXBlcmlvclxuICAgICAgICAgIHNpemUuaGVpZ2h0IC8gMiAtIGdyb3VwSGVpZ2h0IC8gMiwgLy8gQ2VudHJvIHZlcnRpY2FsXG4gICAgICAgICAgc2l6ZS5oZWlnaHQgLSBncm91cEhlaWdodCAvLyBCb3JkZSBpbmZlcmlvclxuICAgICAgICBdO1xuXG4gICAgICAgIC8vIEFwbGljYXIgc25hcCBhbCBncnVwb1xuICAgICAgICBjb25zdCBzbmFwcGVkR3JvdXBMZWZ0ID0gYXBwbHlTbmFwKG5ld0dyb3VwTGVmdCwgc25hcFBvaW50c1gpO1xuICAgICAgICBjb25zdCBzbmFwcGVkR3JvdXBUb3AgPSBhcHBseVNuYXAobmV3R3JvdXBUb3AsIHNuYXBQb2ludHNZKTtcblxuICAgICAgICAvLyBDYWxjdWxhciBlbCBhanVzdGUgbmVjZXNhcmlvIGRlc3B1w6lzIGRlbCBzbmFwXG4gICAgICAgIGNvbnN0IGFkanVzdFggPSBzbmFwcGVkR3JvdXBMZWZ0IC0gbmV3R3JvdXBMZWZ0O1xuICAgICAgICBjb25zdCBhZGp1c3RZID0gc25hcHBlZEdyb3VwVG9wIC0gbmV3R3JvdXBUb3A7XG5cbiAgICAgICAgLy8gRmVlZGJhY2sgdmlzdWFsIHBhcmEgZWwgc25hcCBkZSBncnVwb1xuICAgICAgICBjb25zdCBpc0dyb3VwU25hcHBlZCA9XG4gICAgICAgICAgTWF0aC5hYnMoYWRqdXN0WCkgPD0gU05BUF9FREdFX1RIUkVTSE9MRCB8fFxuICAgICAgICAgIE1hdGguYWJzKGFkanVzdFkpIDw9IFNOQVBfRURHRV9USFJFU0hPTEQ7XG5cbiAgICAgICAgLy8gQXBsaWNhciBlbCBtb3ZpbWllbnRvIGFqdXN0YWRvIGEgY2FkYSBlbGVtZW50byBkZWwgZ3J1cG9cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBldmVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBjb25zdCBldmVudCA9IGV2ZW50c1tpXTtcbiAgICAgICAgICBjb25zdCBpZCA9IGdldElkRnJvbUNsYXNzTmFtZShldmVudC50YXJnZXQuY2xhc3NOYW1lKTtcbiAgICAgICAgICBjb25zdCB0cmFja0l0ZW0gPSB0cmFja0l0ZW1EZXRhaWxzTWFwW2lkXTtcblxuICAgICAgICAgIGNvbnN0IGxlZnQgPSBwYXJzZUZsb2F0KHRyYWNrSXRlbT8uZGV0YWlscy5sZWZ0IGFzIHN0cmluZykgK1xuICAgICAgICAgICAgZXZlbnQuYmVmb3JlVHJhbnNsYXRlWzBdICsgYWRqdXN0WDtcbiAgICAgICAgICBjb25zdCB0b3AgPSBwYXJzZUZsb2F0KHRyYWNrSXRlbT8uZGV0YWlscy50b3AgYXMgc3RyaW5nKSArXG4gICAgICAgICAgICBldmVudC5iZWZvcmVUcmFuc2xhdGVbMV0gKyBhZGp1c3RZO1xuXG4gICAgICAgICAgZXZlbnQudGFyZ2V0LnN0eWxlLmxlZnQgPSBgJHtsZWZ0fXB4YDtcbiAgICAgICAgICBldmVudC50YXJnZXQuc3R5bGUudG9wID0gYCR7dG9wfXB4YDtcblxuICAgICAgICAgIC8vIEFwbGljYXIgY2xhc2UgdmlzdWFsIHNpIGhheSBzbmFwXG4gICAgICAgICAgaWYgKGlzR3JvdXBTbmFwcGVkKSB7XG4gICAgICAgICAgICBldmVudC50YXJnZXQuY2xhc3NMaXN0LmFkZCgnc25hcHBlZC1lbGVtZW50Jyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGV2ZW50LnRhcmdldC5jbGFzc0xpc3QucmVtb3ZlKCdzbmFwcGVkLWVsZW1lbnQnKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBob2xkR3JvdXBQb3NpdGlvbltpZF0gPSB7XG4gICAgICAgICAgICBsZWZ0OiBsZWZ0LFxuICAgICAgICAgICAgdG9wOiB0b3AsXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEZlZWRiYWNrIHTDoWN0aWwgc2kgaGF5IHNuYXBcbiAgICAgICAgaWYgKGlzR3JvdXBTbmFwcGVkICYmICd2aWJyYXRlJyBpbiBuYXZpZ2F0b3IpIHtcbiAgICAgICAgICBuYXZpZ2F0b3IudmlicmF0ZSgxMCk7XG4gICAgICAgIH1cbiAgICAgIH19XG4gICAgICBvblJlc2l6ZT17KHtcbiAgICAgICAgdGFyZ2V0LFxuICAgICAgICB3aWR0aDogbmV4dFdpZHRoLFxuICAgICAgICBoZWlnaHQ6IG5leHRIZWlnaHQsXG4gICAgICAgIGRpcmVjdGlvbixcbiAgICAgIH0pID0+IHtcbiAgICAgICAgaWYgKGRpcmVjdGlvblsxXSA9PT0gMSkge1xuICAgICAgICAgIGNvbnN0IGN1cnJlbnRXaWR0aCA9IHRhcmdldC5jbGllbnRXaWR0aDtcbiAgICAgICAgICBjb25zdCBjdXJyZW50SGVpZ2h0ID0gdGFyZ2V0LmNsaWVudEhlaWdodDtcblxuICAgICAgICAgIC8vIEdldCBuZXcgd2lkdGggYW5kIGhlaWdodFxuICAgICAgICAgIGNvbnN0IHNjYWxlWSA9IG5leHRIZWlnaHQgLyBjdXJyZW50SGVpZ2h0O1xuICAgICAgICAgIGNvbnN0IHNjYWxlID0gc2NhbGVZO1xuXG4gICAgICAgICAgLy8gVXBkYXRlIHRhcmdldCBkaW1lbnNpb25zXG4gICAgICAgICAgdGFyZ2V0LnN0eWxlLndpZHRoID0gYCR7Y3VycmVudFdpZHRoICogc2NhbGV9cHhgO1xuICAgICAgICAgIHRhcmdldC5zdHlsZS5oZWlnaHQgPSBgJHtjdXJyZW50SGVpZ2h0ICogc2NhbGV9cHhgO1xuXG4gICAgICAgICAgLy8gU2FmZWx5IGFjY2VzcyBuZXN0ZWQgZWxlbWVudHNcbiAgICAgICAgICBjb25zdCBhbmltYXRpb25EaXYgPSB0YXJnZXQuZmlyc3RFbGVtZW50Q2hpbGRcbiAgICAgICAgICAgID8uZmlyc3RFbGVtZW50Q2hpbGQgYXMgSFRNTERpdkVsZW1lbnQgfCBudWxsO1xuICAgICAgICAgIGlmIChhbmltYXRpb25EaXYpIHtcbiAgICAgICAgICAgIGFuaW1hdGlvbkRpdi5zdHlsZS53aWR0aCA9IGAke2N1cnJlbnRXaWR0aCAqIHNjYWxlfXB4YDtcbiAgICAgICAgICAgIGFuaW1hdGlvbkRpdi5zdHlsZS5oZWlnaHQgPSBgJHtjdXJyZW50SGVpZ2h0ICogc2NhbGV9cHhgO1xuXG4gICAgICAgICAgICBjb25zdCB0ZXh0RGl2ID1cbiAgICAgICAgICAgICAgYW5pbWF0aW9uRGl2LmZpcnN0RWxlbWVudENoaWxkIGFzIEhUTUxEaXZFbGVtZW50IHwgbnVsbDtcbiAgICAgICAgICAgIGlmICh0ZXh0RGl2KSB7XG4gICAgICAgICAgICAgIGNvbnN0IGZvbnRTaXplID0gcGFyc2VGbG9hdChnZXRDb21wdXRlZFN0eWxlKHRleHREaXYpLmZvbnRTaXplKTtcbiAgICAgICAgICAgICAgdGV4dERpdi5zdHlsZS5mb250U2l6ZSA9IGAke2ZvbnRTaXplICogc2NhbGV9cHhgO1xuICAgICAgICAgICAgICB0ZXh0RGl2LnN0eWxlLndpZHRoID0gYCR7Y3VycmVudFdpZHRoICogc2NhbGV9cHhgO1xuICAgICAgICAgICAgICB0ZXh0RGl2LnN0eWxlLmhlaWdodCA9IGAke2N1cnJlbnRIZWlnaHQgKiBzY2FsZX1weGA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRhcmdldC5zdHlsZS53aWR0aCA9IG5leHRXaWR0aCArIFwicHhcIjtcbiAgICAgICAgICB0YXJnZXQuc3R5bGUuaGVpZ2h0ID0gbmV4dEhlaWdodCArIFwicHhcIjtcblxuICAgICAgICAgIC8vIFNhZmVseSBhY2Nlc3MgbmVzdGVkIGVsZW1lbnRzXG4gICAgICAgICAgY29uc3QgYW5pbWF0aW9uRGl2ID0gdGFyZ2V0LmZpcnN0RWxlbWVudENoaWxkXG4gICAgICAgICAgICA/LmZpcnN0RWxlbWVudENoaWxkIGFzIEhUTUxEaXZFbGVtZW50IHwgbnVsbDtcbiAgICAgICAgICBpZiAoYW5pbWF0aW9uRGl2KSB7XG4gICAgICAgICAgICBhbmltYXRpb25EaXYuc3R5bGUud2lkdGggPSBgJHtuZXh0V2lkdGh9cHhgO1xuICAgICAgICAgICAgYW5pbWF0aW9uRGl2LnN0eWxlLmhlaWdodCA9IGAke25leHRIZWlnaHR9cHhgO1xuXG4gICAgICAgICAgICBjb25zdCB0ZXh0RGl2ID1cbiAgICAgICAgICAgICAgYW5pbWF0aW9uRGl2LmZpcnN0RWxlbWVudENoaWxkIGFzIEhUTUxEaXZFbGVtZW50IHwgbnVsbDtcbiAgICAgICAgICAgIGlmICh0ZXh0RGl2KSB7XG4gICAgICAgICAgICAgIHRleHREaXYuc3R5bGUud2lkdGggPSBgJHtuZXh0V2lkdGh9cHhgO1xuICAgICAgICAgICAgICB0ZXh0RGl2LnN0eWxlLmhlaWdodCA9IGAke25leHRIZWlnaHR9cHhgO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfX1cbiAgICAgIG9uUmVzaXplRW5kPXsoeyB0YXJnZXQgfSkgPT4ge1xuICAgICAgICBjb25zdCB0YXJnZXRJZCA9IGdldElkRnJvbUNsYXNzTmFtZSh0YXJnZXQuY2xhc3NOYW1lKSBhcyBzdHJpbmc7XG4gICAgICAgIGNvbnN0IHRleHREaXYgPSB0YXJnZXQuZmlyc3RFbGVtZW50Q2hpbGQ/LmZpcnN0RWxlbWVudENoaWxkXG4gICAgICAgICAgPy5maXJzdEVsZW1lbnRDaGlsZCBhcyBIVE1MRGl2RWxlbWVudDtcbiAgICAgICAgZGlzcGF0Y2goRURJVF9PQkpFQ1QsIHtcbiAgICAgICAgICBwYXlsb2FkOiB7XG4gICAgICAgICAgICBbdGFyZ2V0SWRdOiB7XG4gICAgICAgICAgICAgIGRldGFpbHM6IHtcbiAgICAgICAgICAgICAgICB3aWR0aDogcGFyc2VGbG9hdCh0YXJnZXQuc3R5bGUud2lkdGgpLFxuICAgICAgICAgICAgICAgIGhlaWdodDogcGFyc2VGbG9hdCh0YXJnZXQuc3R5bGUuaGVpZ2h0KSxcbiAgICAgICAgICAgICAgICBmb250U2l6ZTogcGFyc2VGbG9hdCh0ZXh0RGl2LnN0eWxlLmZvbnRTaXplKSxcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgICB9fVxuICAgICAgb25EcmFnR3JvdXBFbmQ9eygpID0+IHtcbiAgICAgICAgaWYgKGhvbGRHcm91cFBvc2l0aW9uKSB7XG4gICAgICAgICAgY29uc3QgcGF5bG9hZDogUmVjb3JkPHN0cmluZywgUGFydGlhbDxhbnk+PiA9IHt9O1xuICAgICAgICAgIE9iamVjdC5rZXlzKGhvbGRHcm91cFBvc2l0aW9uKS5mb3JFYWNoKChpZCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgbGVmdCA9IGhvbGRHcm91cFBvc2l0aW9uIVtpZF0ubGVmdDtcbiAgICAgICAgICAgIGNvbnN0IHRvcCA9IGhvbGRHcm91cFBvc2l0aW9uIVtpZF0udG9wO1xuXG4gICAgICAgICAgICAvLyBFbGltaW5hciBsYSBjbGFzZSBkZSBzbmFwXG4gICAgICAgICAgICBjb25zdCBlbGVtZW50ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihgLmlkLSR7aWR9YCk7XG4gICAgICAgICAgICBpZiAoZWxlbWVudCkge1xuICAgICAgICAgICAgICBlbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoJ3NuYXBwZWQtZWxlbWVudCcpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBwYXlsb2FkW2lkXSA9IHtcbiAgICAgICAgICAgICAgZGV0YWlsczoge1xuICAgICAgICAgICAgICAgIHRvcDogYCR7dG9wfXB4YCxcbiAgICAgICAgICAgICAgICBsZWZ0OiBgJHtsZWZ0fXB4YCxcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICAvLyBPY3VsdGFyIHRvZGFzIGxhcyBsw61uZWFzIGd1w61hXG4gICAgICAgICAgc2V0U2hvd0d1aWRlcyh7XG4gICAgICAgICAgICBsZWZ0OiBmYWxzZSxcbiAgICAgICAgICAgIGNlbnRlcjogZmFsc2UsXG4gICAgICAgICAgICByaWdodDogZmFsc2UsXG4gICAgICAgICAgICB0b3A6IGZhbHNlLFxuICAgICAgICAgICAgbWlkZGxlOiBmYWxzZSxcbiAgICAgICAgICAgIGJvdHRvbTogZmFsc2VcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIGRpc3BhdGNoKEVESVRfT0JKRUNULCB7XG4gICAgICAgICAgICBwYXlsb2FkOiBwYXlsb2FkLFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGhvbGRHcm91cFBvc2l0aW9uID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfX1cbiAgICAvPlxuICApO1xufVxuXG4iXSwibmFtZXMiOlsidXNlRWZmZWN0IiwidXNlUmVmIiwidXNlU3RhdGUiLCJTZWxlY3Rpb24iLCJNb3ZlYWJsZSIsImdldElkRnJvbUNsYXNzTmFtZSIsImRpc3BhdGNoIiwiRURJVF9PQkpFQ1QiLCJMQVlFUl9TRUxFQ1RJT04iLCJlbXB0eVNlbGVjdGlvbiIsImdldFNlbGVjdGlvbkJ5SWRzIiwiZ2V0VGFyZ2V0QnlJZCIsInVzZVN0b3JlIiwiZ2V0Q3VycmVudFRpbWUiLCJ1c2VMYXlvdXRTdG9yZSIsImhvbGRHcm91cFBvc2l0aW9uIiwiZHJhZ1N0YXJ0RW5kIiwiU2NlbmVJbnRlcmFjdGlvbnMiLCJzdGF0ZU1hbmFnZXIiLCJ2aWV3ZXJSZWYiLCJ6b29tIiwic2l6ZSIsImNvbnRhaW5lclJlZiIsInRhcmdldHMiLCJzZXRUYXJnZXRzIiwic2VsZWN0aW9uIiwic2V0U2VsZWN0aW9uIiwiYWN0aXZlSWRzIiwic2V0U3RhdGUiLCJ0cmFja0l0ZW1EZXRhaWxzTWFwIiwidHJhY2tJdGVtc01hcCIsInBsYXllclJlZiIsInNldFNjZW5lTW92ZWFibGVSZWYiLCJzZXRBY3RpdmVNZW51SXRlbSIsInNldFNob3dNZW51SXRlbSIsIm1vdmVhYmxlUmVmIiwic2VsZWN0aW9uSW5mbyIsInNldFNlbGVjdGlvbkluZm8iLCJzaG93R3VpZGVzIiwic2V0U2hvd0d1aWRlcyIsImxlZnQiLCJjZW50ZXIiLCJyaWdodCIsInRvcCIsIm1pZGRsZSIsImJvdHRvbSIsIlNOQVBfVEhSRVNIT0xEIiwiU05BUF9FREdFX1RIUkVTSE9MRCIsImFwcGx5U25hcCIsInZhbHVlIiwic25hcFBvaW50cyIsInRocmVzaG9sZCIsInBvaW50IiwiTWF0aCIsImFicyIsInVwZGF0ZUd1aWRlTGluZXMiLCJ3aWR0aCIsImhlaWdodCIsInNuYXBQb2ludHNYIiwic25hcFBvaW50c1kiLCJuZXdHdWlkZXMiLCJ1cGRhdGVUYXJnZXRzIiwidGltZSIsImN1cnJlbnRUaW1lIiwiZ2V0U3RhdGUiLCJ0YXJnZXRJZHMiLCJmaWx0ZXIiLCJpZCIsImRpc3BsYXkiLCJmcm9tIiwidG8iLCJtYXAiLCJzZXRTZWxlY3RlZFRhcmdldHMiLCJzZWxJbmZvIiwidGltZXIiLCJzZXRUaW1lb3V0Iiwib25TZWVrZWQiLCJ2IiwiZnBzIiwic2Vla2VkVGltZSIsImRldGFpbCIsImZyYW1lIiwiY3VycmVudCIsImFkZEV2ZW50TGlzdGVuZXIiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiY2xlYXJUaW1lb3V0IiwiaGFuZGxlU2VsZWN0aW9uIiwiaWRzIiwiY29uc29sZSIsImxvZyIsInVwZGF0ZVN0YXRlIiwidXBkYXRlSGlzdG9yeSIsImtpbmQiLCJsZW5ndGgiLCJwYXlsb2FkIiwiY3VycmVudE1lbnVJdGVtIiwiYWN0aXZlTWVudUl0ZW0iLCJjb250YWluZXIiLCJpbmZpbml0ZVZpZXdlciIsImdldENvbnRhaW5lciIsImJvdW5kQ29udGFpbmVyIiwiaGl0UmF0ZSIsInNlbGVjdGFibGVUYXJnZXRzIiwic2VsZWN0RnJvbUluc2lkZSIsInNlbGVjdEJ5Q2xpY2siLCJ0b2dnbGVDb250aW51ZVNlbGVjdCIsIm9uIiwiZSIsInNlbGVjdGVkIiwiZWwiLCJjbGFzc05hbWUiLCJ0YXJnZXQiLCJpbnB1dEV2ZW50IiwiaW5jbHVkZXMiLCJzdG9wIiwibW92ZWFibGUiLCJpc01vdmVhYmxlRWxlbWVudCIsImlzRHJhZ1N0YXJ0IiwicHJldmVudERlZmF1bHQiLCJkcmFnU3RhcnQiLCJkZXN0cm95IiwiYWN0aXZlU2VsZWN0aW9uU3Vic2NyaXB0aW9uIiwic3Vic2NyaWJlVG9BY3RpdmVJZHMiLCJuZXdTdGF0ZSIsInVuc3Vic2NyaWJlIiwidXBkYXRlUmVjdCIsImNyZWF0ZUd1aWRlTGluZXMiLCJkb2N1bWVudCIsInF1ZXJ5U2VsZWN0b3JBbGwiLCJmb3JFYWNoIiwicmVtb3ZlIiwiZ3VpZGVQb3NpdGlvbnMiLCJuYW1lIiwic3R5bGUiLCJndWlkZSIsImd1aWRlRWxlbWVudCIsImNyZWF0ZUVsZW1lbnQiLCJzZXRBdHRyaWJ1dGUiLCJhcHBlbmRDaGlsZCIsIndpbmRvdyIsImd1aWRlTmFtZSIsInNwbGl0IiwicmVwbGFjZSIsIm9wYWNpdHkiLCJoaWRlR3VpZGVzVGltZW91dCIsInJlZiIsInJvdGF0aW9uUG9zaXRpb24iLCJyZW5kZXJEaXJlY3Rpb25zIiwiY29udHJvbHMiLCJhYmxlcyIsIm9yaWdpbiIsIm9uRHJhZyIsImJlZm9yZVRyYW5zbGF0ZSIsInRhcmdldElkIiwidHJhY2tJdGVtIiwidGFyZ2V0V2lkdGgiLCJvZmZzZXRXaWR0aCIsInRhcmdldEhlaWdodCIsIm9mZnNldEhlaWdodCIsInBhcnNlRmxvYXQiLCJkZXRhaWxzIiwic29tZSIsImNsYXNzTGlzdCIsImFkZCIsIk1vdXNlRXZlbnQiLCJuYXZpZ2F0b3IiLCJ2aWJyYXRlIiwib25EcmFnRW5kIiwiaXNEcmFnIiwib25TY2FsZSIsInRyYW5zZm9ybSIsImRpcmVjdGlvbiIsInhDb250cm9sIiwieUNvbnRyb2wiLCJzY2FsZVJlZ2V4IiwibWF0Y2giLCJzY2FsZVgiLCJzY2FsZVkiLCJ0cmltIiwibWF0Y2gyIiwibmV3U2NhbGVYIiwibmV3U2NhbGVZIiwiY3VycmVudFdpZHRoIiwiY2xpZW50V2lkdGgiLCJjdXJyZW50SGVpZ2h0IiwiY2xpZW50SGVpZ2h0IiwibmV3V2lkdGgiLCJuZXdIZWlnaHQiLCJkaWZmWCIsIm5ld0xlZnQiLCJkaWZmWSIsIm5ld1RvcCIsIm9uU2NhbGVFbmQiLCJvblJvdGF0ZSIsIm9uUm90YXRlRW5kIiwib25EcmFnR3JvdXAiLCJldmVudHMiLCJncm91cExlZnQiLCJJbmZpbml0eSIsImdyb3VwVG9wIiwiZ3JvdXBSaWdodCIsImdyb3VwQm90dG9tIiwiaSIsImV2ZW50IiwibWluIiwibWF4IiwiZ3JvdXBXaWR0aCIsImdyb3VwSGVpZ2h0IiwiYmFzZVRyYW5zbGF0ZSIsIm5ld0dyb3VwTGVmdCIsIm5ld0dyb3VwVG9wIiwic25hcHBlZEdyb3VwTGVmdCIsInNuYXBwZWRHcm91cFRvcCIsImFkanVzdFgiLCJhZGp1c3RZIiwiaXNHcm91cFNuYXBwZWQiLCJvblJlc2l6ZSIsIm5leHRXaWR0aCIsIm5leHRIZWlnaHQiLCJzY2FsZSIsImFuaW1hdGlvbkRpdiIsImZpcnN0RWxlbWVudENoaWxkIiwidGV4dERpdiIsImZvbnRTaXplIiwiZ2V0Q29tcHV0ZWRTdHlsZSIsIm9uUmVzaXplRW5kIiwib25EcmFnR3JvdXBFbmQiLCJPYmplY3QiLCJrZXlzIiwiZWxlbWVudCIsInF1ZXJ5U2VsZWN0b3IiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./features/editor/scene/interactions.tsx\n"));

/***/ })

});
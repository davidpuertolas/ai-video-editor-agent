"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./features/editor/timeline/items/video.ts":
/*!*************************************************!*\
  !*** ./features/editor/timeline/items/video.ts ***!
  \*************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _designcombo_timeline__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @designcombo/timeline */ \"(app-pages-browser)/./node_modules/@designcombo/timeline/dist/index.es.js\");\n/* harmony import */ var _utils_thumbnail_cache__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../utils/thumbnail-cache */ \"(app-pages-browser)/./features/editor/utils/thumbnail-cache.ts\");\n/* harmony import */ var _utils_filmstrip__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../utils/filmstrip */ \"(app-pages-browser)/./features/editor/utils/filmstrip.ts\");\n/* harmony import */ var _utils_file__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../utils/file */ \"(app-pages-browser)/./features/editor/utils/file.ts\");\n/* harmony import */ var _controls__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../controls */ \"(app-pages-browser)/./features/editor/timeline/controls/index.ts\");\n\n\n\n\n\nconst EMPTY_FILMSTRIP = {\n    offset: 0,\n    startTime: 0,\n    thumbnailsCount: 0,\n    widthOnScreen: 0\n};\nclass Video extends _designcombo_timeline__WEBPACK_IMPORTED_MODULE_0__.Video {\n    static createControls() {\n        return {\n            controls: (0,_controls__WEBPACK_IMPORTED_MODULE_4__.createMediaControls)()\n        };\n    }\n    initOffscreenCanvas() {\n        if (!this.offscreenCanvas) {\n            this.offscreenCanvas = new OffscreenCanvas(this.width, this.height);\n            this.offscreenCtx = this.offscreenCanvas.getContext(\"2d\");\n        }\n        // Resize if dimensions changed\n        if (this.offscreenCanvas.width !== this.width || this.offscreenCanvas.height !== this.height) {\n            this.offscreenCanvas.width = this.width;\n            this.offscreenCanvas.height = this.height;\n            this.isDirty = true;\n        }\n    }\n    initDimensions() {\n        this.thumbnailWidth = this.thumbnailHeight * this.aspectRatio;\n        const segmentOptions = (0,_utils_filmstrip__WEBPACK_IMPORTED_MODULE_2__.calculateThumbnailSegmentLayout)(this.thumbnailWidth);\n        this.thumbnailsPerSegment = segmentOptions.thumbnailsPerSegment;\n        this.segmentSize = segmentOptions.segmentSize;\n    }\n    async initialize() {\n        var _this_canvas;\n        await this.loadFallbackThumbnail();\n        this.initDimensions();\n        this.onScrollChange({\n            scrollLeft: 0\n        });\n        (_this_canvas = this.canvas) === null || _this_canvas === void 0 ? void 0 : _this_canvas.requestRenderAll();\n        this.createFallbackPattern();\n        await this.prepareAssets();\n        this.onScrollChange({\n            scrollLeft: 0\n        });\n    }\n    async prepareAssets() {\n        if (false) {}\n        try {\n            const { MP4Clip } = await __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_designcombo_frames_dist_frames_js\").then(__webpack_require__.bind(__webpack_require__, /*! @designcombo/frames */ \"(app-pages-browser)/./node_modules/@designcombo/frames/dist/frames.js\"));\n            const file = await (0,_utils_file__WEBPACK_IMPORTED_MODULE_3__.getFileFromUrl)(this.src);\n            const stream = file.stream();\n            this.clip = new MP4Clip(stream);\n        } catch (error) {\n            console.error(\"Error loading MP4Clip:\", error);\n        }\n    }\n    calculateFilmstripDimensions(param) {\n        let { segmentIndex, widthOnScreen } = param;\n        const filmstripOffset = segmentIndex * this.segmentSize;\n        const shouldUseLeftBacklog = segmentIndex > 0;\n        const leftBacklogSize = shouldUseLeftBacklog ? this.segmentSize : 0;\n        const totalWidth = (0,_designcombo_timeline__WEBPACK_IMPORTED_MODULE_0__.timeMsToUnits)(this.duration, this.tScale, this.playbackRate);\n        const rightRemainingSize = totalWidth - widthOnScreen - leftBacklogSize - filmstripOffset;\n        const rightBacklogSize = Math.min(this.segmentSize, rightRemainingSize);\n        const filmstripStartTime = (0,_designcombo_timeline__WEBPACK_IMPORTED_MODULE_0__.unitsToTimeMs)(filmstripOffset, this.tScale);\n        const filmstrimpThumbnailsCount = 1 + Math.round((widthOnScreen + leftBacklogSize + rightBacklogSize) / this.thumbnailWidth);\n        return {\n            filmstripOffset,\n            leftBacklogSize,\n            rightBacklogSize,\n            filmstripStartTime,\n            filmstrimpThumbnailsCount\n        };\n    }\n    // load fallback thumbnail, resize it and cache it\n    async loadFallbackThumbnail() {\n        const fallbackThumbnail = this.previewUrl;\n        if (!fallbackThumbnail) {\n            console.error(\"[ERROR Video] No hay previewUrl disponible para el video:\", this.id);\n            return;\n        }\n        console.log(\"[DEBUG Video] Cargando thumbnail para video:\", this.id);\n        console.log(\"[DEBUG Video] URL tipo:\", fallbackThumbnail.substring(0, 30) + \"...\");\n        console.log(\"[DEBUG Video] Es data URL:\", fallbackThumbnail.startsWith(\"data:\"));\n        console.log(\"[DEBUG Video] Es blob URL:\", fallbackThumbnail.startsWith(\"blob:\"));\n        return new Promise((resolve)=>{\n            const img = new Image();\n            img.crossOrigin = \"anonymous\";\n            // Para URLs de datos y URLs de objeto, no necesitamos añadir parámetros extra\n            if (fallbackThumbnail.startsWith(\"data:\") || fallbackThumbnail.startsWith(\"blob:\")) {\n                img.src = fallbackThumbnail;\n                console.log(\"[DEBUG Video] Usando URL directamente sin modificaciones\");\n            } else {\n                // Para URLs remotas, añadimos un timestamp para evitar caché\n                const cacheBuster = \"?t=\" + Date.now();\n                img.src = fallbackThumbnail + cacheBuster;\n                console.log(\"[DEBUG Video] A\\xf1adiendo cache-buster a URL remota:\", cacheBuster);\n            }\n            img.onload = ()=>{\n                console.log(\"[DEBUG Video] Imagen cargada correctamente. Tama\\xf1o original:\", img.width, \"x\", img.height);\n                // Create a temporary canvas to resize the image\n                const canvas = document.createElement(\"canvas\");\n                const ctx = canvas.getContext(\"2d\");\n                // Calculate new width maintaining aspect ratio\n                const aspectRatio = img.width / img.height;\n                const targetHeight = 40;\n                const targetWidth = Math.round(targetHeight * aspectRatio);\n                // Set canvas size and draw resized image\n                canvas.height = targetHeight;\n                canvas.width = targetWidth;\n                ctx.drawImage(img, 0, 0, targetWidth, targetHeight);\n                // Create new image from resized canvas\n                const resizedImg = new Image();\n                resizedImg.onload = ()=>{\n                    console.log(\"[DEBUG Video] Imagen redimensionada correctamente:\", targetWidth, \"x\", targetHeight);\n                    // Update aspect ratio and cache the resized image\n                    this.aspectRatio = aspectRatio;\n                    this.thumbnailWidth = targetWidth;\n                    this.thumbnailCache.setThumbnail(\"fallback\", resizedImg);\n                    console.log(\"[DEBUG Video] Thumbnail guardado en cach\\xe9 con ID 'fallback'\");\n                    resolve();\n                };\n                resizedImg.src = canvas.toDataURL();\n            };\n            img.onerror = (err)=>{\n                console.error(\"[ERROR Video] No se pudo cargar la miniatura:\", err);\n                console.error(\"[ERROR Video] URL problem\\xe1tica:\", fallbackThumbnail.substring(0, 100) + \"...\");\n                // Intentar crear una miniatura de color sólido como último recurso\n                try {\n                    console.log(\"[DEBUG Video] Creando miniatura de color s\\xf3lido como fallback\");\n                    const canvas = document.createElement(\"canvas\");\n                    const ctx = canvas.getContext(\"2d\");\n                    // Usar proporciones predeterminadas si no se pueden determinar\n                    const aspectRatio = 16 / 9; // Proporción por defecto\n                    const targetHeight = 40;\n                    const targetWidth = Math.round(targetHeight * aspectRatio);\n                    // Configurar canvas y dibujar un rectángulo\n                    canvas.height = targetHeight;\n                    canvas.width = targetWidth;\n                    ctx.fillStyle = \"#666666\"; // Gris oscuro\n                    ctx.fillRect(0, 0, targetWidth, targetHeight);\n                    // Añadir un poco de texto o indicadores\n                    ctx.fillStyle = \"#ffffff\"; // Blanco\n                    ctx.font = \"12px Arial\";\n                    ctx.fillText(\"Video\", 5, 20);\n                    // Crear imagen del canvas\n                    const placeholderImg = new Image();\n                    placeholderImg.onload = ()=>{\n                        this.aspectRatio = aspectRatio;\n                        this.thumbnailWidth = targetWidth;\n                        this.thumbnailCache.setThumbnail(\"fallback\", placeholderImg);\n                        console.log(\"[DEBUG Video] Thumbnail placeholder creado correctamente\");\n                        resolve();\n                    };\n                    placeholderImg.src = canvas.toDataURL();\n                } catch (fallbackError) {\n                    console.error(\"[ERROR Video] Fallo incluso al crear placeholder:\", fallbackError);\n                    resolve(); // Resolver de todos modos para no bloquear\n                }\n            };\n        });\n    }\n    generateTimestamps(startTime, count) {\n        const timePerThumbnail = (0,_designcombo_timeline__WEBPACK_IMPORTED_MODULE_0__.unitsToTimeMs)(this.thumbnailWidth, this.tScale, this.playbackRate);\n        return Array.from({\n            length: count\n        }, (_, i)=>{\n            const timeInFilmstripe = startTime + i * timePerThumbnail;\n            return Math.ceil(timeInFilmstripe / 1000);\n        });\n    }\n    createFallbackPattern() {\n        var _this_canvas;\n        const canvas = this.canvas;\n        if (!canvas) return;\n        const canvasWidth = this.canvas.width;\n        const maxPatternSize = 12000;\n        const fallbackSource = this.thumbnailCache.getThumbnail(\"fallback\");\n        if (!fallbackSource) return;\n        // Compute the total width and number of segments needed\n        const totalWidthNeeded = Math.min(canvasWidth * 20, maxPatternSize);\n        const segmentsRequired = Math.ceil(totalWidthNeeded / this.segmentSize);\n        this.fallbackSegmentsCount = segmentsRequired;\n        const patternWidth = segmentsRequired * this.segmentSize;\n        // Setup canvas dimensions\n        const offCanvas = document.createElement(\"canvas\");\n        offCanvas.height = this.thumbnailHeight;\n        offCanvas.width = patternWidth;\n        const context = offCanvas.getContext(\"2d\");\n        const thumbnailsTotal = segmentsRequired * this.thumbnailsPerSegment;\n        // Draw the fallback image across the entirety of the canvas horizontally\n        for(let i = 0; i < thumbnailsTotal; i++){\n            const x = i * this.thumbnailWidth;\n            context.drawImage(fallbackSource, x, 0, this.thumbnailWidth, this.thumbnailHeight);\n        }\n        // Create the pattern and apply it\n        const fillPattern = new _designcombo_timeline__WEBPACK_IMPORTED_MODULE_0__.Pattern({\n            source: offCanvas,\n            repeat: \"no-repeat\",\n            offsetX: 0\n        });\n        this.set(\"fill\", fillPattern);\n        (_this_canvas = this.canvas) === null || _this_canvas === void 0 ? void 0 : _this_canvas.requestRenderAll();\n    }\n    async loadAndRenderThumbnails() {\n        if (this.isFetchingThumbnails || !this.clip) return;\n        // set segmentDrawn to segmentToDraw\n        this.loadingFilmstrip = {\n            ...this.nextFilmstrip\n        };\n        this.isFetchingThumbnails = true;\n        // Calculate dimensions and offsets\n        const { startTime, thumbnailsCount } = this.loadingFilmstrip;\n        // Generate required timestamps\n        const timestamps = this.generateTimestamps(startTime, thumbnailsCount);\n        // Match and prepare thumbnails\n        let thumbnailsArr = await this.clip.thumbnailsList(this.thumbnailWidth, {\n            timestamps: timestamps.map((timestamp)=>timestamp * 1e6)\n        });\n        const updatedThumbnails = thumbnailsArr.map((thumbnail)=>{\n            return {\n                ts: Math.round(thumbnail.ts / 1e6),\n                img: thumbnail.img\n            };\n        });\n        // Load all thumbnails in parallel\n        await this.loadThumbnailBatch(updatedThumbnails);\n        this.isDirty = true; // Mark as dirty after preparing new thumbnails\n        // this.isFallbackDirty = true;\n        this.isFetchingThumbnails = false;\n        this.currentFilmstrip = {\n            ...this.loadingFilmstrip\n        };\n        requestAnimationFrame(()=>{\n            var _this_canvas;\n            (_this_canvas = this.canvas) === null || _this_canvas === void 0 ? void 0 : _this_canvas.requestRenderAll();\n        });\n    }\n    async loadThumbnailBatch(thumbnails) {\n        const loadPromises = thumbnails.map(async (thumbnail)=>{\n            if (this.thumbnailCache.getThumbnail(thumbnail.ts)) return;\n            return new Promise((resolve)=>{\n                const img = new Image();\n                img.src = URL.createObjectURL(thumbnail.img);\n                img.onload = ()=>{\n                    URL.revokeObjectURL(img.src); // Clean up the blob URL after image loads\n                    this.thumbnailCache.setThumbnail(thumbnail.ts, img);\n                    resolve();\n                };\n            });\n        });\n        await Promise.all(loadPromises);\n    }\n    _render(ctx) {\n        super._render(ctx);\n        ctx.save();\n        ctx.translate(-this.width / 2, -this.height / 2);\n        // Clip the area to prevent drawing outside\n        ctx.beginPath();\n        ctx.rect(0, 0, this.width, this.height);\n        ctx.clip();\n        this.renderToOffscreen();\n        ctx.drawImage(this.offscreenCanvas, 0, 0);\n        ctx.restore();\n        // this.drawTextIdentity(ctx);\n        this.updateSelected(ctx);\n    }\n    setDuration(duration) {\n        this.duration = duration;\n        this.prevDuration = duration;\n    }\n    async setSrc(src) {\n        super.setSrc(src);\n        this.clip = null;\n        await this.initialize();\n        await this.prepareAssets();\n        this.thumbnailCache.clearCacheButFallback();\n        this.onScale();\n    }\n    onResizeSnap() {\n        this.renderToOffscreen(true);\n    }\n    onResize() {\n        this.renderToOffscreen(true);\n    }\n    renderToOffscreen(force) {\n        if (!this.offscreenCtx) return;\n        if (!this.isDirty && !force) return;\n        this.offscreenCanvas.width = this.width;\n        const ctx = this.offscreenCtx;\n        const { startTime, offset, thumbnailsCount } = this.currentFilmstrip;\n        const thumbnailWidth = this.thumbnailWidth;\n        const thumbnailHeight = this.thumbnailHeight;\n        // Calculate the offset caused by the trimming\n        const trimFromSize = (0,_designcombo_timeline__WEBPACK_IMPORTED_MODULE_0__.timeMsToUnits)(this.trim.from, this.tScale, this.playbackRate);\n        let timeInFilmstripe = startTime;\n        const timePerThumbnail = (0,_designcombo_timeline__WEBPACK_IMPORTED_MODULE_0__.unitsToTimeMs)(thumbnailWidth, this.tScale, this.playbackRate);\n        // Clear the offscreen canvas\n        ctx.clearRect(0, 0, this.width, this.height);\n        // Clip with rounded corners\n        ctx.beginPath();\n        ctx.roundRect(0, 0, this.width, this.height, this.rx);\n        ctx.clip();\n        // Draw thumbnails\n        for(let i = 0; i < thumbnailsCount; i++){\n            let img = this.thumbnailCache.getThumbnail(Math.ceil(timeInFilmstripe / 1000));\n            if (!img) {\n                img = this.thumbnailCache.getThumbnail(\"fallback\");\n            }\n            if (img && img.complete) {\n                const xPosition = i * thumbnailWidth + offset - trimFromSize;\n                ctx.drawImage(img, xPosition, 0, thumbnailWidth, thumbnailHeight);\n                timeInFilmstripe += timePerThumbnail;\n            }\n        }\n        this.isDirty = false;\n    }\n    drawTextIdentity(ctx) {\n        const iconPath = new Path2D(\"M16.5625 0.925L12.5 3.275V0.625L11.875 0H0.625L0 0.625V9.375L0.625 10H11.875L12.5 9.375V6.875L16.5625 9.2125L17.5 8.625V1.475L16.5625 0.925ZM11.25 8.75H1.25V1.25H11.25V8.75ZM16.25 7.5L12.5 5.375V4.725L16.25 2.5V7.5Z\");\n        ctx.save();\n        ctx.translate(-this.width / 2, -this.height / 2);\n        ctx.translate(0, 14);\n        ctx.font = \"600 12px 'Geist variable'\";\n        ctx.fillStyle = \"#f4f4f5\";\n        ctx.textAlign = \"left\";\n        ctx.clip();\n        ctx.fillText(\"Video\", 36, 10);\n        ctx.translate(8, 1);\n        ctx.fillStyle = \"#f4f4f5\";\n        ctx.fill(iconPath);\n        ctx.restore();\n    }\n    setSelected(selected) {\n        this.isSelected = selected;\n        this.set({\n            dirty: true\n        });\n    }\n    updateSelected(ctx) {\n        const borderColor = this.isSelected ? \"rgba(255, 255, 255,1.0)\" : \"rgba(255, 255, 255,0.1)\";\n        ctx.save();\n        ctx.beginPath();\n        ctx.roundRect(-this.width / 2, -this.height / 2, this.width, this.height, 6);\n        ctx.lineWidth = 1;\n        ctx.strokeStyle = borderColor;\n        ctx.stroke();\n        ctx.restore();\n    }\n    calulateWidthOnScreen() {\n        const canvasEl = document.getElementById(\"designcombo-timeline-canvas\");\n        const canvasWidth = canvasEl === null || canvasEl === void 0 ? void 0 : canvasEl.clientWidth;\n        const scrollLeft = this.scrollLeft;\n        const timelineWidth = canvasWidth;\n        const cutFromBottomEdge = Math.max(timelineWidth - (this.width + this.left + scrollLeft), 0);\n        const visibleHeight = Math.min(timelineWidth - this.left - scrollLeft, timelineWidth);\n        return Math.max(visibleHeight - cutFromBottomEdge, 0);\n    }\n    // Calculate the width that is not visible on the screen measured from the left\n    calculateOffscreenWidth(param) {\n        let { scrollLeft } = param;\n        const offscreenWidth = Math.min(this.left + scrollLeft, 0);\n        return Math.abs(offscreenWidth);\n    }\n    onScrollChange(param) {\n        let { scrollLeft, force } = param;\n        const offscreenWidth = this.calculateOffscreenWidth({\n            scrollLeft\n        });\n        const trimFromSize = (0,_designcombo_timeline__WEBPACK_IMPORTED_MODULE_0__.timeMsToUnits)(this.trim.from, this.tScale, this.playbackRate);\n        const offscreenSegments = (0,_utils_filmstrip__WEBPACK_IMPORTED_MODULE_2__.calculateOffscreenSegments)(offscreenWidth, trimFromSize, this.segmentSize);\n        this.offscreenSegments = offscreenSegments;\n        // calculate start segment to draw\n        const segmentToDraw = offscreenSegments;\n        if (this.currentFilmstrip.segmentIndex === segmentToDraw) {\n            return false;\n        }\n        if (segmentToDraw !== this.fallbackSegmentIndex) {\n            const fillPattern = this.fill;\n            if (fillPattern instanceof _designcombo_timeline__WEBPACK_IMPORTED_MODULE_0__.Pattern) {\n                fillPattern.offsetX = this.segmentSize * (segmentToDraw - Math.floor(this.fallbackSegmentsCount / 2));\n            }\n            this.fallbackSegmentIndex = segmentToDraw;\n        }\n        if (!this.isFetchingThumbnails || force) {\n            this.scrollLeft = scrollLeft;\n            const widthOnScreen = this.calulateWidthOnScreen();\n            // With these lines:\n            const { filmstripOffset, filmstripStartTime, filmstrimpThumbnailsCount } = this.calculateFilmstripDimensions({\n                widthOnScreen: this.calulateWidthOnScreen(),\n                segmentIndex: segmentToDraw\n            });\n            this.nextFilmstrip = {\n                segmentIndex: segmentToDraw,\n                offset: filmstripOffset,\n                startTime: filmstripStartTime,\n                thumbnailsCount: filmstrimpThumbnailsCount,\n                widthOnScreen\n            };\n            this.loadAndRenderThumbnails();\n        }\n    }\n    onScale() {\n        this.currentFilmstrip = {\n            ...EMPTY_FILMSTRIP\n        };\n        this.nextFilmstrip = {\n            ...EMPTY_FILMSTRIP,\n            segmentIndex: 0\n        };\n        this.loadingFilmstrip = {\n            ...EMPTY_FILMSTRIP\n        };\n        this.onScrollChange({\n            scrollLeft: this.scrollLeft,\n            force: true\n        });\n    }\n    constructor(props){\n        var _props_metadata;\n        super(props);\n        this.resourceId = \"\";\n        this.isSelected = false;\n        this.itemType = \"video\";\n        this.aspectRatio = 1;\n        this.scrollLeft = 0;\n        this.thumbnailsPerSegment = 0;\n        this.segmentSize = 0;\n        this.offscreenSegments = 0;\n        this.thumbnailWidth = 0;\n        this.thumbnailHeight = 40;\n        this.thumbnailsList = [];\n        this.isFetchingThumbnails = false;\n        this.thumbnailCache = new _utils_thumbnail_cache__WEBPACK_IMPORTED_MODULE_1__[\"default\"]();\n        this.currentFilmstrip = EMPTY_FILMSTRIP;\n        this.nextFilmstrip = {\n            ...EMPTY_FILMSTRIP,\n            segmentIndex: 0\n        };\n        this.loadingFilmstrip = EMPTY_FILMSTRIP;\n        this.offscreenCanvas = null;\n        this.offscreenCtx = null;\n        this.isDirty = true;\n        this.fallbackSegmentIndex = 0;\n        this.fallbackSegmentsCount = 0;\n        this.previewUrl = \"\";\n        this.id = props.id;\n        this.tScale = props.tScale;\n        this.objectCaching = false;\n        this.rx = 4;\n        this.ry = 4;\n        this.display = props.display;\n        this.trim = props.trim;\n        this.duration = props.duration;\n        this.prevDuration = props.duration;\n        this.fill = \"#27272a\";\n        this.borderOpacityWhenMoving = 1;\n        this.metadata = props.metadata;\n        this.aspectRatio = props.aspectRatio;\n        this.src = props.src;\n        this.strokeWidth = 0;\n        this.transparentCorners = false;\n        this.hasBorders = false;\n        this.previewUrl = (_props_metadata = props.metadata) === null || _props_metadata === void 0 ? void 0 : _props_metadata.previewUrl;\n        this.initOffscreenCanvas();\n        this.initialize();\n    }\n}\nVideo.type = \"Video\";\n/* harmony default export */ __webpack_exports__[\"default\"] = (Video);\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2ZlYXR1cmVzL2VkaXRvci90aW1lbGluZS9pdGVtcy92aWRlby50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFPK0I7QUFFMEI7QUFLMUI7QUFDbUI7QUFFQTtBQUVsRCxNQUFNVSxrQkFBNkI7SUFDakNDLFFBQVE7SUFDUkMsV0FBVztJQUNYQyxpQkFBaUI7SUFDakJDLGVBQWU7QUFDakI7QUFRQSxNQUFNYixjQUFjQyx3REFBU0E7SUEwQzNCLE9BQU9hLGlCQUF3RDtRQUM3RCxPQUFPO1lBQUVDLFVBQVVQLDhEQUFtQkE7UUFBRztJQUMzQztJQThCUVEsc0JBQXNCO1FBQzVCLElBQUksQ0FBQyxJQUFJLENBQUNDLGVBQWUsRUFBRTtZQUN6QixJQUFJLENBQUNBLGVBQWUsR0FBRyxJQUFJQyxnQkFBZ0IsSUFBSSxDQUFDQyxLQUFLLEVBQUUsSUFBSSxDQUFDQyxNQUFNO1lBQ2xFLElBQUksQ0FBQ0MsWUFBWSxHQUFHLElBQUksQ0FBQ0osZUFBZSxDQUFDSyxVQUFVLENBQUM7UUFDdEQ7UUFFQSwrQkFBK0I7UUFDL0IsSUFDRSxJQUFJLENBQUNMLGVBQWUsQ0FBQ0UsS0FBSyxLQUFLLElBQUksQ0FBQ0EsS0FBSyxJQUN6QyxJQUFJLENBQUNGLGVBQWUsQ0FBQ0csTUFBTSxLQUFLLElBQUksQ0FBQ0EsTUFBTSxFQUMzQztZQUNBLElBQUksQ0FBQ0gsZUFBZSxDQUFDRSxLQUFLLEdBQUcsSUFBSSxDQUFDQSxLQUFLO1lBQ3ZDLElBQUksQ0FBQ0YsZUFBZSxDQUFDRyxNQUFNLEdBQUcsSUFBSSxDQUFDQSxNQUFNO1lBQ3pDLElBQUksQ0FBQ0csT0FBTyxHQUFHO1FBQ2pCO0lBQ0Y7SUFFT0MsaUJBQWlCO1FBQ3RCLElBQUksQ0FBQ0MsY0FBYyxHQUFHLElBQUksQ0FBQ0MsZUFBZSxHQUFHLElBQUksQ0FBQ0MsV0FBVztRQUU3RCxNQUFNQyxpQkFBaUJ0QixpRkFBK0JBLENBQUMsSUFBSSxDQUFDbUIsY0FBYztRQUMxRSxJQUFJLENB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Q0FBQ0MsUUFBUSxHQUFHUCxNQUFNTyxRQUFRO1FBRTlCLElBQUksQ0FBQ2hMLFdBQVcsR0FBR3lLLE1BQU16SyxXQUFXO1FBRXBDLElBQUksQ0FBQ2MsR0FBRyxHQUFHMkosTUFBTTNKLEdBQUc7UUFDcEIsSUFBSSxDQUFDbUssV0FBVyxHQUFHO1FBRW5CLElBQUksQ0FBQ0Msa0JBQWtCLEdBQUc7UUFDMUIsSUFBSSxDQUFDQyxVQUFVLEdBQUc7UUFFbEIsSUFBSSxDQUFDL0ksVUFBVSxJQUFHcUksa0JBQUFBLE1BQU1PLFFBQVEsY0FBZFAsc0NBQUFBLGdCQUFnQnJJLFVBQVU7UUFDNUMsSUFBSSxDQUFDL0MsbUJBQW1CO1FBQ3hCLElBQUksQ0FBQ2UsVUFBVTtJQUNqQjtBQTRoQkY7QUFwbUJNL0IsTUFDRytNLE9BQU87QUFxbUJoQiwrREFBZS9NLEtBQUtBLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vZmVhdHVyZXMvZWRpdG9yL3RpbWVsaW5lL2l0ZW1zL3ZpZGVvLnRzP2YzZTgiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcclxuICBDb250cm9sLFxyXG4gIFBhdHRlcm4sXHJcbiAgVmlkZW8gYXMgVmlkZW9CYXNlLFxyXG4gIFZpZGVvUHJvcHMgYXMgVmlkZW9Qcm9wc0Jhc2UsXHJcbiAgdGltZU1zVG9Vbml0cyxcclxuICB1bml0c1RvVGltZU1zLFxyXG59IGZyb20gXCJAZGVzaWduY29tYm8vdGltZWxpbmVcIjtcclxuaW1wb3J0IHsgRmlsbXN0cmlwLCBGaWxtc3RyaXBCYWNrbG9nT3B0aW9ucyB9IGZyb20gXCIuLi90eXBlc1wiO1xyXG5pbXBvcnQgVGh1bWJuYWlsQ2FjaGUgZnJvbSBcIi4uLy4uL3V0aWxzL3RodW1ibmFpbC1jYWNoZVwiO1xyXG5pbXBvcnQgeyBJRGlzcGxheSwgSU1ldGFkYXRhLCBJVHJpbSB9IGZyb20gXCJAZGVzaWduY29tYm8vdHlwZXNcIjtcclxuaW1wb3J0IHtcclxuICBjYWxjdWxhdGVPZmZzY3JlZW5TZWdtZW50cyxcclxuICBjYWxjdWxhdGVUaHVtYm5haWxTZWdtZW50TGF5b3V0LFxyXG59IGZyb20gXCIuLi8uLi91dGlscy9maWxtc3RyaXBcIjtcclxuaW1wb3J0IHsgZ2V0RmlsZUZyb21VcmwgfSBmcm9tIFwiLi4vLi4vdXRpbHMvZmlsZVwiO1xyXG5pbXBvcnQgeyB0eXBlIE1QNENsaXAgfSBmcm9tIFwiQGRlc2lnbmNvbWJvL2ZyYW1lc1wiO1xyXG5pbXBvcnQgeyBjcmVhdGVNZWRpYUNvbnRyb2xzIH0gZnJvbSBcIi4uL2NvbnRyb2xzXCI7XHJcblxyXG5jb25zdCBFTVBUWV9GSUxNU1RSSVA6IEZpbG1zdHJpcCA9IHtcclxuICBvZmZzZXQ6IDAsXHJcbiAgc3RhcnRUaW1lOiAwLFxyXG4gIHRodW1ibmFpbHNDb3VudDogMCxcclxuICB3aWR0aE9uU2NyZWVuOiAwLFxyXG59O1xyXG5cclxuaW50ZXJmYWNlIFZpZGVvUHJvcHMgZXh0ZW5kcyBWaWRlb1Byb3BzQmFzZSB7XHJcbiAgYXNwZWN0UmF0aW86IG51bWJlcjtcclxuICBtZXRhZGF0YTogUGFydGlhbDxJTWV0YWRhdGE+ICYge1xyXG4gICAgcHJldmlld1VybDogc3RyaW5nO1xyXG4gIH07XHJcbn1cclxuY2xhc3MgVmlkZW8gZXh0ZW5kcyBWaWRlb0Jhc2Uge1xyXG4gIHN0YXRpYyB0eXBlID0gXCJWaWRlb1wiO1xyXG4gIHB1YmxpYyBjbGlwPzogTVA0Q2xpcCB8IG51bGw7XHJcbiAgZGVjbGFyZSBpZDogc3RyaW5nO1xyXG4gIHB1YmxpYyByZXNvdXJjZUlkOiBzdHJpbmcgPSBcIlwiO1xyXG4gIGRlY2xhcmUgdFNjYWxlOiBudW1iZXI7XHJcbiAgcHVibGljIGlzU2VsZWN0ZWQgPSBmYWxzZTtcclxuICBkZWNsYXJlIGRpc3BsYXk6IElEaXNwbGF5O1xyXG4gIGRlY2xhcmUgdHJpbTogSVRyaW07XHJcbiAgZGVjbGFyZSBwbGF5YmFja1JhdGU6IG51bWJlcjtcclxuICBkZWNsYXJlIGR1cmF0aW9uOiBudW1iZXI7XHJcbiAgcHVibGljIHByZXZEdXJhdGlvbjogbnVtYmVyO1xyXG4gIHB1YmxpYyBpdGVtVHlwZSA9IFwidmlkZW9cIjtcclxuICBwdWJsaWMgbWV0YWRhdGE/OiBQYXJ0aWFsPElNZXRhZGF0YT47XHJcbiAgZGVjbGFyZSBzcmM6IHN0cmluZztcclxuXHJcbiAgcHVibGljIGFzcGVjdFJhdGlvID0gMTtcclxuICBwdWJsaWMgc2Nyb2xsTGVmdCA9IDA7XHJcbiAgcHVibGljIGZpbG1zdHJpcEJhY2tsb2dPcHRpb25zPzogRmlsbXN0cmlwQmFja2xvZ09wdGlvbnM7XHJcbiAgcHVibGljIHRodW1ibmFpbHNQZXJTZWdtZW50ID0gMDtcclxuICBwdWJsaWMgc2VnbWVudFNpemUgPSAwO1xyXG5cclxuICBwdWJsaWMgb2Zmc2NyZWVuU2VnbWVudHMgPSAwO1xyXG4gIHB1YmxpYyB0aHVtYm5haWxXaWR0aDogbnVtYmVyID0gMDtcclxuICBwdWJsaWMgdGh1bWJuYWlsSGVpZ2h0OiBudW1iZXIgPSA0MDtcclxuICBwdWJsaWMgdGh1bWJuYWlsc0xpc3Q6IHsgdXJsOiBzdHJpbmc7IHRzOiBudW1iZXIgfVtdID0gW107XHJcbiAgcHVibGljIGlzRmV0Y2hpbmdUaHVtYm5haWxzID0gZmFsc2U7XHJcbiAgcHVibGljIHRodW1ibmFpbENhY2hlID0gbmV3IFRodW1ibmFpbENhY2hlKCk7XHJcblxyXG4gIHB1YmxpYyBjdXJyZW50RmlsbXN0cmlwOiBGaWxtc3RyaXAgPSBFTVBUWV9GSUxNU1RSSVA7XHJcbiAgcHVibGljIG5leHRGaWxtc3RyaXA6IEZpbG1zdHJpcCA9IHsgLi4uRU1QVFlfRklMTVNUUklQLCBzZWdtZW50SW5kZXg6IDAgfTtcclxuICBwdWJsaWMgbG9hZGluZ0ZpbG1zdHJpcDogRmlsbXN0cmlwID0gRU1QVFlfRklMTVNUUklQO1xyXG5cclxuICBwcml2YXRlIG9mZnNjcmVlbkNhbnZhczogT2Zmc2NyZWVuQ2FudmFzIHwgbnVsbCA9IG51bGw7XHJcbiAgcHJpdmF0ZSBvZmZzY3JlZW5DdHg6IE9mZnNjcmVlbkNhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCB8IG51bGwgPSBudWxsO1xyXG5cclxuICBwcml2YXRlIGlzRGlydHk6IGJvb2xlYW4gPSB0cnVlO1xyXG5cclxuICBwcml2YXRlIGZhbGxiYWNrU2VnbWVudEluZGV4OiBudW1iZXIgPSAwO1xyXG4gIHByaXZhdGUgZmFsbGJhY2tTZWdtZW50c0NvdW50OiBudW1iZXIgPSAwO1xyXG4gIHByaXZhdGUgcHJldmlld1VybDogc3RyaW5nID0gXCJcIjtcclxuXHJcbiAgc3RhdGljIGNyZWF0ZUNvbnRyb2xzKCk6IHsgY29udHJvbHM6IFJlY29yZDxzdHJpbmcsIENvbnRyb2w+IH0ge1xyXG4gICAgcmV0dXJuIHsgY29udHJvbHM6IGNyZWF0ZU1lZGlhQ29udHJvbHMoKSB9O1xyXG4gIH1cclxuXHJcbiAgY29uc3RydWN0b3IocHJvcHM6IFZpZGVvUHJvcHMpIHtcclxuICAgIHN1cGVyKHByb3BzKTtcclxuICAgIHRoaXMuaWQgPSBwcm9wcy5pZDtcclxuICAgIHRoaXMudFNjYWxlID0gcHJvcHMudFNjYWxlO1xyXG4gICAgdGhpcy5vYmplY3RDYWNoaW5nID0gZmFsc2U7XHJcbiAgICB0aGlzLnJ4ID0gNDtcclxuICAgIHRoaXMucnkgPSA0O1xyXG4gICAgdGhpcy5kaXNwbGF5ID0gcHJvcHMuZGlzcGxheTtcclxuICAgIHRoaXMudHJpbSA9IHByb3BzLnRyaW07XHJcbiAgICB0aGlzLmR1cmF0aW9uID0gcHJvcHMuZHVyYXRpb247XHJcbiAgICB0aGlzLnByZXZEdXJhdGlvbiA9IHByb3BzLmR1cmF0aW9uO1xyXG4gICAgdGhpcy5maWxsID0gXCIjMjcyNzJhXCI7XHJcbiAgICB0aGlzLmJvcmRlck9wYWNpdHlXaGVuTW92aW5nID0gMTtcclxuICAgIHRoaXMubWV0YWRhdGEgPSBwcm9wcy5tZXRhZGF0YTtcclxuXHJcbiAgICB0aGlzLmFzcGVjdFJhdGlvID0gcHJvcHMuYXNwZWN0UmF0aW87XHJcblxyXG4gICAgdGhpcy5zcmMgPSBwcm9wcy5zcmM7XHJcbiAgICB0aGlzLnN0cm9rZVdpZHRoID0gMDtcclxuXHJcbiAgICB0aGlzLnRyYW5zcGFyZW50Q29ybmVycyA9IGZhbHNlO1xyXG4gICAgdGhpcy5oYXNCb3JkZXJzID0gZmFsc2U7XHJcblxyXG4gICAgdGhpcy5wcmV2aWV3VXJsID0gcHJvcHMubWV0YWRhdGE/LnByZXZpZXdVcmw7XHJcbiAgICB0aGlzLmluaXRPZmZzY3JlZW5DYW52YXMoKTtcclxuICAgIHRoaXMuaW5pdGlhbGl6ZSgpO1xyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBpbml0T2Zmc2NyZWVuQ2FudmFzKCkge1xyXG4gICAgaWYgKCF0aGlzLm9mZnNjcmVlbkNhbnZhcykge1xyXG4gICAgICB0aGlzLm9mZnNjcmVlbkNhbnZhcyA9IG5ldyBPZmZzY3JlZW5DYW52YXModGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xyXG4gICAgICB0aGlzLm9mZnNjcmVlbkN0eCA9IHRoaXMub2Zmc2NyZWVuQ2FudmFzLmdldENvbnRleHQoXCIyZFwiKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBSZXNpemUgaWYgZGltZW5zaW9ucyBjaGFuZ2VkXHJcbiAgICBpZiAoXHJcbiAgICAgIHRoaXMub2Zmc2NyZWVuQ2FudmFzLndpZHRoICE9PSB0aGlzLndpZHRoIHx8XHJcbiAgICAgIHRoaXMub2Zmc2NyZWVuQ2FudmFzLmhlaWdodCAhPT0gdGhpcy5oZWlnaHRcclxuICAgICkge1xyXG4gICAgICB0aGlzLm9mZnNjcmVlbkNhbnZhcy53aWR0aCA9IHRoaXMud2lkdGg7XHJcbiAgICAgIHRoaXMub2Zmc2NyZWVuQ2FudmFzLmhlaWdodCA9IHRoaXMuaGVpZ2h0O1xyXG4gICAgICB0aGlzLmlzRGlydHkgPSB0cnVlO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcHVibGljIGluaXREaW1lbnNpb25zKCkge1xyXG4gICAgdGhpcy50aHVtYm5haWxXaWR0aCA9IHRoaXMudGh1bWJuYWlsSGVpZ2h0ICogdGhpcy5hc3BlY3RSYXRpbztcclxuXHJcbiAgICBjb25zdCBzZWdtZW50T3B0aW9ucyA9IGNhbGN1bGF0ZVRodW1ibmFpbFNlZ21lbnRMYXlvdXQodGhpcy50aHVtYm5haWxXaWR0aCk7XHJcbiAgICB0aGlzLnRodW1ibmFpbHNQZXJTZWdtZW50ID0gc2VnbWVudE9wdGlvbnMudGh1bWJuYWlsc1BlclNlZ21lbnQ7XHJcbiAgICB0aGlzLnNlZ21lbnRTaXplID0gc2VnbWVudE9wdGlvbnMuc2VnbWVudFNpemU7XHJcbiAgfVxyXG5cclxuICBwdWJsaWMgYXN5bmMgaW5pdGlhbGl6ZSgpIHtcclxuICAgIGF3YWl0IHRoaXMubG9hZEZhbGxiYWNrVGh1bWJuYWlsKCk7XHJcblxyXG4gICAgdGhpcy5pbml0RGltZW5zaW9ucygpO1xyXG4gICAgdGhpcy5vblNjcm9sbENoYW5nZSh7IHNjcm9sbExlZnQ6IDAgfSk7XHJcblxyXG4gICAgdGhpcy5jYW52YXM/LnJlcXVlc3RSZW5kZXJBbGwoKTtcclxuXHJcbiAgICB0aGlzLmNyZWF0ZUZhbGxiYWNrUGF0dGVybigpO1xyXG4gICAgYXdhaXQgdGhpcy5wcmVwYXJlQXNzZXRzKCk7XHJcblxyXG4gICAgdGhpcy5vblNjcm9sbENoYW5nZSh7IHNjcm9sbExlZnQ6IDAgfSk7XHJcbiAgfVxyXG5cclxuICBwdWJsaWMgYXN5bmMgcHJlcGFyZUFzc2V0cygpIHtcclxuICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSBcInVuZGVmaW5lZFwiKSByZXR1cm47XHJcblxyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3QgeyBNUDRDbGlwIH0gPSBhd2FpdCBpbXBvcnQoXCJAZGVzaWduY29tYm8vZnJhbWVzXCIpO1xyXG4gICAgICBjb25zdCBmaWxlID0gYXdhaXQgZ2V0RmlsZUZyb21VcmwodGhpcy5zcmMpO1xyXG4gICAgICBjb25zdCBzdHJlYW0gPSBmaWxlLnN0cmVhbSgpO1xyXG4gICAgICB0aGlzLmNsaXAgPSBuZXcgTVA0Q2xpcChzdHJlYW0pO1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIGxvYWRpbmcgTVA0Q2xpcDpcIiwgZXJyb3IpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBjYWxjdWxhdGVGaWxtc3RyaXBEaW1lbnNpb25zKHtcclxuICAgIHNlZ21lbnRJbmRleCxcclxuICAgIHdpZHRoT25TY3JlZW4sXHJcbiAgfToge1xyXG4gICAgc2VnbWVudEluZGV4OiBudW1iZXI7XHJcbiAgICB3aWR0aE9uU2NyZWVuOiBudW1iZXI7XHJcbiAgfSkge1xyXG4gICAgY29uc3QgZmlsbXN0cmlwT2Zmc2V0ID0gc2VnbWVudEluZGV4ICogdGhpcy5zZWdtZW50U2l6ZTtcclxuICAgIGNvbnN0IHNob3VsZFVzZUxlZnRCYWNrbG9nID0gc2VnbWVudEluZGV4ID4gMDtcclxuICAgIGNvbnN0IGxlZnRCYWNrbG9nU2l6ZSA9IHNob3VsZFVzZUxlZnRCYWNrbG9nID8gdGhpcy5zZWdtZW50U2l6ZSA6IDA7XHJcblxyXG4gICAgY29uc3QgdG90YWxXaWR0aCA9IHRpbWVNc1RvVW5pdHMoXHJcbiAgICAgIHRoaXMuZHVyYXRpb24sXHJcbiAgICAgIHRoaXMudFNjYWxlLFxyXG4gICAgICB0aGlzLnBsYXliYWNrUmF0ZSxcclxuICAgICk7XHJcblxyXG4gICAgY29uc3QgcmlnaHRSZW1haW5pbmdTaXplID1cclxuICAgICAgdG90YWxXaWR0aCAtIHdpZHRoT25TY3JlZW4gLSBsZWZ0QmFja2xvZ1NpemUgLSBmaWxtc3RyaXBPZmZzZXQ7XHJcbiAgICBjb25zdCByaWdodEJhY2tsb2dTaXplID0gTWF0aC5taW4odGhpcy5zZWdtZW50U2l6ZSwgcmlnaHRSZW1haW5pbmdTaXplKTtcclxuXHJcbiAgICBjb25zdCBmaWxtc3RyaXBTdGFydFRpbWUgPSB1bml0c1RvVGltZU1zKGZpbG1zdHJpcE9mZnNldCwgdGhpcy50U2NhbGUpO1xyXG4gICAgY29uc3QgZmlsbXN0cmltcFRodW1ibmFpbHNDb3VudCA9XHJcbiAgICAgIDEgK1xyXG4gICAgICBNYXRoLnJvdW5kKFxyXG4gICAgICAgICh3aWR0aE9uU2NyZWVuICsgbGVmdEJhY2tsb2dTaXplICsgcmlnaHRCYWNrbG9nU2l6ZSkgL1xyXG4gICAgICAgICAgdGhpcy50aHVtYm5haWxXaWR0aCxcclxuICAgICAgKTtcclxuXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBmaWxtc3RyaXBPZmZzZXQsXHJcbiAgICAgIGxlZnRCYWNrbG9nU2l6ZSxcclxuICAgICAgcmlnaHRCYWNrbG9nU2l6ZSxcclxuICAgICAgZmlsbXN0cmlwU3RhcnRUaW1lLFxyXG4gICAgICBmaWxtc3RyaW1wVGh1bWJuYWlsc0NvdW50LFxyXG4gICAgfTtcclxuICB9XHJcblxyXG4gIC8vIGxvYWQgZmFsbGJhY2sgdGh1bWJuYWlsLCByZXNpemUgaXQgYW5kIGNhY2hlIGl0XHJcbiAgcHJpdmF0ZSBhc3luYyBsb2FkRmFsbGJhY2tUaHVtYm5haWwoKSB7XHJcbiAgICBjb25zdCBmYWxsYmFja1RodW1ibmFpbCA9IHRoaXMucHJldmlld1VybDtcclxuICAgIGlmICghZmFsbGJhY2tUaHVtYm5haWwpIHtcclxuICAgICAgY29uc29sZS5lcnJvcihcIltFUlJPUiBWaWRlb10gTm8gaGF5IHByZXZpZXdVcmwgZGlzcG9uaWJsZSBwYXJhIGVsIHZpZGVvOlwiLCB0aGlzLmlkKTtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnNvbGUubG9nKFwiW0RFQlVHIFZpZGVvXSBDYXJnYW5kbyB0aHVtYm5haWwgcGFyYSB2aWRlbzpcIiwgdGhpcy5pZCk7XHJcbiAgICBjb25zb2xlLmxvZyhcIltERUJVRyBWaWRlb10gVVJMIHRpcG86XCIsIGZhbGxiYWNrVGh1bWJuYWlsLnN1YnN0cmluZygwLCAzMCkgKyBcIi4uLlwiKTtcclxuICAgIGNvbnNvbGUubG9nKFwiW0RFQlVHIFZpZGVvXSBFcyBkYXRhIFVSTDpcIiwgZmFsbGJhY2tUaHVtYm5haWwuc3RhcnRzV2l0aCgnZGF0YTonKSk7XHJcbiAgICBjb25zb2xlLmxvZyhcIltERUJVRyBWaWRlb10gRXMgYmxvYiBVUkw6XCIsIGZhbGxiYWNrVGh1bWJuYWlsLnN0YXJ0c1dpdGgoJ2Jsb2I6JykpO1xyXG5cclxuICAgIHJldHVybiBuZXcgUHJvbWlzZTx2b2lkPigocmVzb2x2ZSkgPT4ge1xyXG4gICAgICBjb25zdCBpbWcgPSBuZXcgSW1hZ2UoKTtcclxuICAgICAgaW1nLmNyb3NzT3JpZ2luID0gXCJhbm9ueW1vdXNcIjtcclxuXHJcbiAgICAgIC8vIFBhcmEgVVJMcyBkZSBkYXRvcyB5IFVSTHMgZGUgb2JqZXRvLCBubyBuZWNlc2l0YW1vcyBhw7FhZGlyIHBhcsOhbWV0cm9zIGV4dHJhXHJcbiAgICAgIGlmIChmYWxsYmFja1RodW1ibmFpbC5zdGFydHNXaXRoKCdkYXRhOicpIHx8IGZhbGxiYWNrVGh1bWJuYWlsLnN0YXJ0c1dpdGgoJ2Jsb2I6JykpIHtcclxuICAgICAgICBpbWcuc3JjID0gZmFsbGJhY2tUaHVtYm5haWw7XHJcbiAgICAgICAgY29uc29sZS5sb2coXCJbREVCVUcgVmlkZW9dIFVzYW5kbyBVUkwgZGlyZWN0YW1lbnRlIHNpbiBtb2RpZmljYWNpb25lc1wiKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICAvLyBQYXJhIFVSTHMgcmVtb3RhcywgYcOxYWRpbW9zIHVuIHRpbWVzdGFtcCBwYXJhIGV2aXRhciBjYWNow6lcclxuICAgICAgICBjb25zdCBjYWNoZUJ1c3RlciA9IFwiP3Q9XCIgKyBEYXRlLm5vdygpO1xyXG4gICAgICAgIGltZy5zcmMgPSBmYWxsYmFja1RodW1ibmFpbCArIGNhY2hlQnVzdGVyO1xyXG4gICAgICAgIGNvbnNvbGUubG9nKFwiW0RFQlVHIFZpZGVvXSBBw7FhZGllbmRvIGNhY2hlLWJ1c3RlciBhIFVSTCByZW1vdGE6XCIsIGNhY2hlQnVzdGVyKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaW1nLm9ubG9hZCA9ICgpID0+IHtcclxuICAgICAgICBjb25zb2xlLmxvZyhcIltERUJVRyBWaWRlb10gSW1hZ2VuIGNhcmdhZGEgY29ycmVjdGFtZW50ZS4gVGFtYcOxbyBvcmlnaW5hbDpcIiwgaW1nLndpZHRoLCBcInhcIiwgaW1nLmhlaWdodCk7XHJcblxyXG4gICAgICAgIC8vIENyZWF0ZSBhIHRlbXBvcmFyeSBjYW52YXMgdG8gcmVzaXplIHRoZSBpbWFnZVxyXG4gICAgICAgIGNvbnN0IGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIik7XHJcbiAgICAgICAgY29uc3QgY3R4ID0gY2FudmFzLmdldENvbnRleHQoXCIyZFwiKSE7XHJcblxyXG4gICAgICAgIC8vIENhbGN1bGF0ZSBuZXcgd2lkdGggbWFpbnRhaW5pbmcgYXNwZWN0IHJhdGlvXHJcbiAgICAgICAgY29uc3QgYXNwZWN0UmF0aW8gPSBpbWcud2lkdGggLyBpbWcuaGVpZ2h0O1xyXG4gICAgICAgIGNvbnN0IHRhcmdldEhlaWdodCA9IDQwO1xyXG4gICAgICAgIGNvbnN0IHRhcmdldFdpZHRoID0gTWF0aC5yb3VuZCh0YXJnZXRIZWlnaHQgKiBhc3BlY3RSYXRpbyk7XHJcblxyXG4gICAgICAgIC8vIFNldCBjYW52YXMgc2l6ZSBhbmQgZHJhdyByZXNpemVkIGltYWdlXHJcbiAgICAgICAgY2FudmFzLmhlaWdodCA9IHRhcmdldEhlaWdodDtcclxuICAgICAgICBjYW52YXMud2lkdGggPSB0YXJnZXRXaWR0aDtcclxuICAgICAgICBjdHguZHJhd0ltYWdlKGltZywgMCwgMCwgdGFyZ2V0V2lkdGgsIHRhcmdldEhlaWdodCk7XHJcblxyXG4gICAgICAgIC8vIENyZWF0ZSBuZXcgaW1hZ2UgZnJvbSByZXNpemVkIGNhbnZhc1xyXG4gICAgICAgIGNvbnN0IHJlc2l6ZWRJbWcgPSBuZXcgSW1hZ2UoKTtcclxuICAgICAgICByZXNpemVkSW1nLm9ubG9hZCA9ICgpID0+IHtcclxuICAgICAgICAgIGNvbnNvbGUubG9nKFwiW0RFQlVHIFZpZGVvXSBJbWFnZW4gcmVkaW1lbnNpb25hZGEgY29ycmVjdGFtZW50ZTpcIiwgdGFyZ2V0V2lkdGgsIFwieFwiLCB0YXJnZXRIZWlnaHQpO1xyXG5cclxuICAgICAgICAgIC8vIFVwZGF0ZSBhc3BlY3QgcmF0aW8gYW5kIGNhY2hlIHRoZSByZXNpemVkIGltYWdlXHJcbiAgICAgICAgICB0aGlzLmFzcGVjdFJhdGlvID0gYXNwZWN0UmF0aW87XHJcbiAgICAgICAgICB0aGlzLnRodW1ibmFpbFdpZHRoID0gdGFyZ2V0V2lkdGg7XHJcbiAgICAgICAgICB0aGlzLnRodW1ibmFpbENhY2hlLnNldFRodW1ibmFpbChcImZhbGxiYWNrXCIsIHJlc2l6ZWRJbWcpO1xyXG5cclxuICAgICAgICAgIGNvbnNvbGUubG9nKFwiW0RFQlVHIFZpZGVvXSBUaHVtYm5haWwgZ3VhcmRhZG8gZW4gY2FjaMOpIGNvbiBJRCAnZmFsbGJhY2snXCIpO1xyXG4gICAgICAgICAgcmVzb2x2ZSgpO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIHJlc2l6ZWRJbWcuc3JjID0gY2FudmFzLnRvRGF0YVVSTCgpO1xyXG4gICAgICB9O1xyXG5cclxuICAgICAgaW1nLm9uZXJyb3IgPSAoZXJyKSA9PiB7XHJcbiAgICAgICAgY29uc29sZS5lcnJvcihcIltFUlJPUiBWaWRlb10gTm8gc2UgcHVkbyBjYXJnYXIgbGEgbWluaWF0dXJhOlwiLCBlcnIpO1xyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJbRVJST1IgVmlkZW9dIFVSTCBwcm9ibGVtw6F0aWNhOlwiLCBmYWxsYmFja1RodW1ibmFpbC5zdWJzdHJpbmcoMCwgMTAwKSArIFwiLi4uXCIpO1xyXG5cclxuICAgICAgICAvLyBJbnRlbnRhciBjcmVhciB1bmEgbWluaWF0dXJhIGRlIGNvbG9yIHPDs2xpZG8gY29tbyDDumx0aW1vIHJlY3Vyc29cclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgY29uc29sZS5sb2coXCJbREVCVUcgVmlkZW9dIENyZWFuZG8gbWluaWF0dXJhIGRlIGNvbG9yIHPDs2xpZG8gY29tbyBmYWxsYmFja1wiKTtcclxuICAgICAgICAgIGNvbnN0IGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIik7XHJcbiAgICAgICAgICBjb25zdCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpITtcclxuXHJcbiAgICAgICAgICAvLyBVc2FyIHByb3BvcmNpb25lcyBwcmVkZXRlcm1pbmFkYXMgc2kgbm8gc2UgcHVlZGVuIGRldGVybWluYXJcclxuICAgICAgICAgIGNvbnN0IGFzcGVjdFJhdGlvID0gMTYvOTsgLy8gUHJvcG9yY2nDs24gcG9yIGRlZmVjdG9cclxuICAgICAgICAgIGNvbnN0IHRhcmdldEhlaWdodCA9IDQwO1xyXG4gICAgICAgICAgY29uc3QgdGFyZ2V0V2lkdGggPSBNYXRoLnJvdW5kKHRhcmdldEhlaWdodCAqIGFzcGVjdFJhdGlvKTtcclxuXHJcbiAgICAgICAgICAvLyBDb25maWd1cmFyIGNhbnZhcyB5IGRpYnVqYXIgdW4gcmVjdMOhbmd1bG9cclxuICAgICAgICAgIGNhbnZhcy5oZWlnaHQgPSB0YXJnZXRIZWlnaHQ7XHJcbiAgICAgICAgICBjYW52YXMud2lkdGggPSB0YXJnZXRXaWR0aDtcclxuICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSBcIiM2NjY2NjZcIjsgLy8gR3JpcyBvc2N1cm9cclxuICAgICAgICAgIGN0eC5maWxsUmVjdCgwLCAwLCB0YXJnZXRXaWR0aCwgdGFyZ2V0SGVpZ2h0KTtcclxuXHJcbiAgICAgICAgICAvLyBBw7FhZGlyIHVuIHBvY28gZGUgdGV4dG8gbyBpbmRpY2Fkb3Jlc1xyXG4gICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IFwiI2ZmZmZmZlwiOyAvLyBCbGFuY29cclxuICAgICAgICAgIGN0eC5mb250ID0gXCIxMnB4IEFyaWFsXCI7XHJcbiAgICAgICAgICBjdHguZmlsbFRleHQoXCJWaWRlb1wiLCA1LCAyMCk7XHJcblxyXG4gICAgICAgICAgLy8gQ3JlYXIgaW1hZ2VuIGRlbCBjYW52YXNcclxuICAgICAgICAgIGNvbnN0IHBsYWNlaG9sZGVySW1nID0gbmV3IEltYWdlKCk7XHJcbiAgICAgICAgICBwbGFjZWhvbGRlckltZy5vbmxvYWQgPSAoKSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMuYXNwZWN0UmF0aW8gPSBhc3BlY3RSYXRpbztcclxuICAgICAgICAgICAgdGhpcy50aHVtYm5haWxXaWR0aCA9IHRhcmdldFdpZHRoO1xyXG4gICAgICAgICAgICB0aGlzLnRodW1ibmFpbENhY2hlLnNldFRodW1ibmFpbChcImZhbGxiYWNrXCIsIHBsYWNlaG9sZGVySW1nKTtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coXCJbREVCVUcgVmlkZW9dIFRodW1ibmFpbCBwbGFjZWhvbGRlciBjcmVhZG8gY29ycmVjdGFtZW50ZVwiKTtcclxuICAgICAgICAgICAgcmVzb2x2ZSgpO1xyXG4gICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICBwbGFjZWhvbGRlckltZy5zcmMgPSBjYW52YXMudG9EYXRhVVJMKCk7XHJcbiAgICAgICAgfSBjYXRjaCAoZmFsbGJhY2tFcnJvcikge1xyXG4gICAgICAgICAgY29uc29sZS5lcnJvcihcIltFUlJPUiBWaWRlb10gRmFsbG8gaW5jbHVzbyBhbCBjcmVhciBwbGFjZWhvbGRlcjpcIiwgZmFsbGJhY2tFcnJvcik7XHJcbiAgICAgICAgICByZXNvbHZlKCk7IC8vIFJlc29sdmVyIGRlIHRvZG9zIG1vZG9zIHBhcmEgbm8gYmxvcXVlYXJcclxuICAgICAgICB9XHJcbiAgICAgIH07XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIHByaXZhdGUgZ2VuZXJhdGVUaW1lc3RhbXBzKHN0YXJ0VGltZTogbnVtYmVyLCBjb3VudDogbnVtYmVyKTogbnVtYmVyW10ge1xyXG4gICAgY29uc3QgdGltZVBlclRodW1ibmFpbCA9IHVuaXRzVG9UaW1lTXMoXHJcbiAgICAgIHRoaXMudGh1bWJuYWlsV2lkdGgsXHJcbiAgICAgIHRoaXMudFNjYWxlLFxyXG4gICAgICB0aGlzLnBsYXliYWNrUmF0ZSxcclxuICAgICk7XHJcblxyXG4gICAgcmV0dXJuIEFycmF5LmZyb20oeyBsZW5ndGg6IGNvdW50IH0sIChfLCBpKSA9PiB7XHJcbiAgICAgIGNvbnN0IHRpbWVJbkZpbG1zdHJpcGUgPSBzdGFydFRpbWUgKyBpICogdGltZVBlclRodW1ibmFpbDtcclxuICAgICAgcmV0dXJuIE1hdGguY2VpbCh0aW1lSW5GaWxtc3RyaXBlIC8gMTAwMCk7XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIHByaXZhdGUgY3JlYXRlRmFsbGJhY2tQYXR0ZXJuKCkge1xyXG4gICAgY29uc3QgY2FudmFzID0gdGhpcy5jYW52YXM7XHJcbiAgICBpZiAoIWNhbnZhcykgcmV0dXJuO1xyXG5cclxuICAgIGNvbnN0IGNhbnZhc1dpZHRoID0gdGhpcy5jYW52YXMhLndpZHRoO1xyXG4gICAgY29uc3QgbWF4UGF0dGVyblNpemUgPSAxMjAwMDtcclxuICAgIGNvbnN0IGZhbGxiYWNrU291cmNlID0gdGhpcy50aHVtYm5haWxDYWNoZS5nZXRUaHVtYm5haWwoXCJmYWxsYmFja1wiKTtcclxuXHJcbiAgICBpZiAoIWZhbGxiYWNrU291cmNlKSByZXR1cm47XHJcblxyXG4gICAgLy8gQ29tcHV0ZSB0aGUgdG90YWwgd2lkdGggYW5kIG51bWJlciBvZiBzZWdtZW50cyBuZWVkZWRcclxuICAgIGNvbnN0IHRvdGFsV2lkdGhOZWVkZWQgPSBNYXRoLm1pbihjYW52YXNXaWR0aCAqIDIwLCBtYXhQYXR0ZXJuU2l6ZSk7XHJcbiAgICBjb25zdCBzZWdtZW50c1JlcXVpcmVkID0gTWF0aC5jZWlsKHRvdGFsV2lkdGhOZWVkZWQgLyB0aGlzLnNlZ21lbnRTaXplKTtcclxuICAgIHRoaXMuZmFsbGJhY2tTZWdtZW50c0NvdW50ID0gc2VnbWVudHNSZXF1aXJlZDtcclxuICAgIGNvbnN0IHBhdHRlcm5XaWR0aCA9IHNlZ21lbnRzUmVxdWlyZWQgKiB0aGlzLnNlZ21lbnRTaXplO1xyXG5cclxuICAgIC8vIFNldHVwIGNhbnZhcyBkaW1lbnNpb25zXHJcbiAgICBjb25zdCBvZmZDYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpO1xyXG4gICAgb2ZmQ2FudmFzLmhlaWdodCA9IHRoaXMudGh1bWJuYWlsSGVpZ2h0O1xyXG4gICAgb2ZmQ2FudmFzLndpZHRoID0gcGF0dGVybldpZHRoO1xyXG5cclxuICAgIGNvbnN0IGNvbnRleHQgPSBvZmZDYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpITtcclxuICAgIGNvbnN0IHRodW1ibmFpbHNUb3RhbCA9IHNlZ21lbnRzUmVxdWlyZWQgKiB0aGlzLnRodW1ibmFpbHNQZXJTZWdtZW50O1xyXG5cclxuICAgIC8vIERyYXcgdGhlIGZhbGxiYWNrIGltYWdlIGFjcm9zcyB0aGUgZW50aXJldHkgb2YgdGhlIGNhbnZhcyBob3Jpem9udGFsbHlcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGh1bWJuYWlsc1RvdGFsOyBpKyspIHtcclxuICAgICAgY29uc3QgeCA9IGkgKiB0aGlzLnRodW1ibmFpbFdpZHRoO1xyXG4gICAgICBjb250ZXh0LmRyYXdJbWFnZShcclxuICAgICAgICBmYWxsYmFja1NvdXJjZSxcclxuICAgICAgICB4LFxyXG4gICAgICAgIDAsXHJcbiAgICAgICAgdGhpcy50aHVtYm5haWxXaWR0aCxcclxuICAgICAgICB0aGlzLnRodW1ibmFpbEhlaWdodCxcclxuICAgICAgKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBDcmVhdGUgdGhlIHBhdHRlcm4gYW5kIGFwcGx5IGl0XHJcbiAgICBjb25zdCBmaWxsUGF0dGVybiA9IG5ldyBQYXR0ZXJuKHtcclxuICAgICAgc291cmNlOiBvZmZDYW52YXMsXHJcbiAgICAgIHJlcGVhdDogXCJuby1yZXBlYXRcIixcclxuICAgICAgb2Zmc2V0WDogMCxcclxuICAgIH0pO1xyXG5cclxuICAgIHRoaXMuc2V0KFwiZmlsbFwiLCBmaWxsUGF0dGVybik7XHJcbiAgICB0aGlzLmNhbnZhcz8ucmVxdWVzdFJlbmRlckFsbCgpO1xyXG4gIH1cclxuICBwdWJsaWMgYXN5bmMgbG9hZEFuZFJlbmRlclRodW1ibmFpbHMoKSB7XHJcbiAgICBpZiAodGhpcy5pc0ZldGNoaW5nVGh1bWJuYWlscyB8fCAhdGhpcy5jbGlwKSByZXR1cm47XHJcbiAgICAvLyBzZXQgc2VnbWVudERyYXduIHRvIHNlZ21lbnRUb0RyYXdcclxuICAgIHRoaXMubG9hZGluZ0ZpbG1zdHJpcCA9IHsgLi4udGhpcy5uZXh0RmlsbXN0cmlwIH07XHJcbiAgICB0aGlzLmlzRmV0Y2hpbmdUaHVtYm5haWxzID0gdHJ1ZTtcclxuXHJcbiAgICAvLyBDYWxjdWxhdGUgZGltZW5zaW9ucyBhbmQgb2Zmc2V0c1xyXG4gICAgY29uc3QgeyBzdGFydFRpbWUsIHRodW1ibmFpbHNDb3VudCB9ID0gdGhpcy5sb2FkaW5nRmlsbXN0cmlwO1xyXG5cclxuICAgIC8vIEdlbmVyYXRlIHJlcXVpcmVkIHRpbWVzdGFtcHNcclxuICAgIGNvbnN0IHRpbWVzdGFtcHMgPSB0aGlzLmdlbmVyYXRlVGltZXN0YW1wcyhzdGFydFRpbWUsIHRodW1ibmFpbHNDb3VudCk7XHJcblxyXG4gICAgLy8gTWF0Y2ggYW5kIHByZXBhcmUgdGh1bWJuYWlsc1xyXG4gICAgbGV0IHRodW1ibmFpbHNBcnIgPSBhd2FpdCB0aGlzLmNsaXAudGh1bWJuYWlsc0xpc3QodGhpcy50aHVtYm5haWxXaWR0aCwge1xyXG4gICAgICB0aW1lc3RhbXBzOiB0aW1lc3RhbXBzLm1hcCgodGltZXN0YW1wKSA9PiB0aW1lc3RhbXAgKiAxZTYpLFxyXG4gICAgfSk7XHJcblxyXG4gICAgY29uc3QgdXBkYXRlZFRodW1ibmFpbHMgPSB0aHVtYm5haWxzQXJyLm1hcCgodGh1bWJuYWlsKSA9PiB7XHJcbiAgICAgIHJldHVybiB7XHJcbiAgICAgICAgdHM6IE1hdGgucm91bmQodGh1bWJuYWlsLnRzIC8gMWU2KSxcclxuICAgICAgICBpbWc6IHRodW1ibmFpbC5pbWcsXHJcbiAgICAgIH07XHJcbiAgICB9KTtcclxuXHJcbiAgICAvLyBMb2FkIGFsbCB0aHVtYm5haWxzIGluIHBhcmFsbGVsXHJcbiAgICBhd2FpdCB0aGlzLmxvYWRUaHVtYm5haWxCYXRjaCh1cGRhdGVkVGh1bWJuYWlscyk7XHJcblxyXG4gICAgdGhpcy5pc0RpcnR5ID0gdHJ1ZTsgLy8gTWFyayBhcyBkaXJ0eSBhZnRlciBwcmVwYXJpbmcgbmV3IHRodW1ibmFpbHNcclxuICAgIC8vIHRoaXMuaXNGYWxsYmFja0RpcnR5ID0gdHJ1ZTtcclxuICAgIHRoaXMuaXNGZXRjaGluZ1RodW1ibmFpbHMgPSBmYWxzZTtcclxuXHJcbiAgICB0aGlzLmN1cnJlbnRGaWxtc3RyaXAgPSB7IC4uLnRoaXMubG9hZGluZ0ZpbG1zdHJpcCB9O1xyXG5cclxuICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XHJcbiAgICAgIHRoaXMuY2FudmFzPy5yZXF1ZXN0UmVuZGVyQWxsKCk7XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIHByaXZhdGUgYXN5bmMgbG9hZFRodW1ibmFpbEJhdGNoKHRodW1ibmFpbHM6IHsgdHM6IG51bWJlcjsgaW1nOiBCbG9iIH1bXSkge1xyXG4gICAgY29uc3QgbG9hZFByb21pc2VzID0gdGh1bWJuYWlscy5tYXAoYXN5bmMgKHRodW1ibmFpbCkgPT4ge1xyXG4gICAgICBpZiAodGhpcy50aHVtYm5haWxDYWNoZS5nZXRUaHVtYm5haWwodGh1bWJuYWlsLnRzKSkgcmV0dXJuO1xyXG5cclxuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlPHZvaWQ+KChyZXNvbHZlKSA9PiB7XHJcbiAgICAgICAgY29uc3QgaW1nID0gbmV3IEltYWdlKCk7XHJcbiAgICAgICAgaW1nLnNyYyA9IFVSTC5jcmVhdGVPYmplY3RVUkwodGh1bWJuYWlsLmltZyk7XHJcbiAgICAgICAgaW1nLm9ubG9hZCA9ICgpID0+IHtcclxuICAgICAgICAgIFVSTC5yZXZva2VPYmplY3RVUkwoaW1nLnNyYyk7IC8vIENsZWFuIHVwIHRoZSBibG9iIFVSTCBhZnRlciBpbWFnZSBsb2Fkc1xyXG4gICAgICAgICAgdGhpcy50aHVtYm5haWxDYWNoZS5zZXRUaHVtYm5haWwodGh1bWJuYWlsLnRzLCBpbWcpO1xyXG4gICAgICAgICAgcmVzb2x2ZSgpO1xyXG4gICAgICAgIH07XHJcbiAgICAgIH0pO1xyXG4gICAgfSk7XHJcblxyXG4gICAgYXdhaXQgUHJvbWlzZS5hbGwobG9hZFByb21pc2VzKTtcclxuICB9XHJcblxyXG4gIHB1YmxpYyBfcmVuZGVyKGN0eDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEKSB7XHJcbiAgICBzdXBlci5fcmVuZGVyKGN0eCk7XHJcblxyXG4gICAgY3R4LnNhdmUoKTtcclxuICAgIGN0eC50cmFuc2xhdGUoLXRoaXMud2lkdGggLyAyLCAtdGhpcy5oZWlnaHQgLyAyKTtcclxuXHJcbiAgICAvLyBDbGlwIHRoZSBhcmVhIHRvIHByZXZlbnQgZHJhd2luZyBvdXRzaWRlXHJcbiAgICBjdHguYmVnaW5QYXRoKCk7XHJcbiAgICBjdHgucmVjdCgwLCAwLCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7XHJcbiAgICBjdHguY2xpcCgpO1xyXG5cclxuICAgIHRoaXMucmVuZGVyVG9PZmZzY3JlZW4oKTtcclxuXHJcbiAgICBjdHguZHJhd0ltYWdlKHRoaXMub2Zmc2NyZWVuQ2FudmFzISwgMCwgMCk7XHJcblxyXG4gICAgY3R4LnJlc3RvcmUoKTtcclxuICAgIC8vIHRoaXMuZHJhd1RleHRJZGVudGl0eShjdHgpO1xyXG4gICAgdGhpcy51cGRhdGVTZWxlY3RlZChjdHgpO1xyXG4gIH1cclxuXHJcbiAgcHVibGljIHNldER1cmF0aW9uKGR1cmF0aW9uOiBudW1iZXIpIHtcclxuICAgIHRoaXMuZHVyYXRpb24gPSBkdXJhdGlvbjtcclxuICAgIHRoaXMucHJldkR1cmF0aW9uID0gZHVyYXRpb247XHJcbiAgfVxyXG5cclxuICBwdWJsaWMgYXN5bmMgc2V0U3JjKHNyYzogc3RyaW5nKSB7XHJcbiAgICBzdXBlci5zZXRTcmMoc3JjKTtcclxuICAgIHRoaXMuY2xpcCA9IG51bGw7XHJcbiAgICBhd2FpdCB0aGlzLmluaXRpYWxpemUoKTtcclxuICAgIGF3YWl0IHRoaXMucHJlcGFyZUFzc2V0cygpO1xyXG4gICAgdGhpcy50aHVtYm5haWxDYWNoZS5jbGVhckNhY2hlQnV0RmFsbGJhY2soKTtcclxuICAgIHRoaXMub25TY2FsZSgpO1xyXG4gIH1cclxuICBwdWJsaWMgb25SZXNpemVTbmFwKCkge1xyXG4gICAgdGhpcy5yZW5kZXJUb09mZnNjcmVlbih0cnVlKTtcclxuICB9XHJcbiAgcHVibGljIG9uUmVzaXplKCkge1xyXG4gICAgdGhpcy5yZW5kZXJUb09mZnNjcmVlbih0cnVlKTtcclxuICB9XHJcblxyXG4gIHB1YmxpYyByZW5kZXJUb09mZnNjcmVlbihmb3JjZT86IGJvb2xlYW4pIHtcclxuICAgIGlmICghdGhpcy5vZmZzY3JlZW5DdHgpIHJldHVybjtcclxuICAgIGlmICghdGhpcy5pc0RpcnR5ICYmICFmb3JjZSkgcmV0dXJuO1xyXG5cclxuICAgIHRoaXMub2Zmc2NyZWVuQ2FudmFzIS53aWR0aCA9IHRoaXMud2lkdGg7XHJcbiAgICBjb25zdCBjdHggPSB0aGlzLm9mZnNjcmVlbkN0eDtcclxuICAgIGNvbnN0IHsgc3RhcnRUaW1lLCBvZmZzZXQsIHRodW1ibmFpbHNDb3VudCB9ID0gdGhpcy5jdXJyZW50RmlsbXN0cmlwO1xyXG4gICAgY29uc3QgdGh1bWJuYWlsV2lkdGggPSB0aGlzLnRodW1ibmFpbFdpZHRoO1xyXG4gICAgY29uc3QgdGh1bWJuYWlsSGVpZ2h0ID0gdGhpcy50aHVtYm5haWxIZWlnaHQ7XHJcblxyXG4gICAgLy8gQ2FsY3VsYXRlIHRoZSBvZmZzZXQgY2F1c2VkIGJ5IHRoZSB0cmltbWluZ1xyXG4gICAgY29uc3QgdHJpbUZyb21TaXplID0gdGltZU1zVG9Vbml0cyhcclxuICAgICAgdGhpcy50cmltLmZyb20sXHJcbiAgICAgIHRoaXMudFNjYWxlLFxyXG4gICAgICB0aGlzLnBsYXliYWNrUmF0ZSxcclxuICAgICk7XHJcblxyXG4gICAgbGV0IHRpbWVJbkZpbG1zdHJpcGUgPSBzdGFydFRpbWU7XHJcbiAgICBjb25zdCB0aW1lUGVyVGh1bWJuYWlsID0gdW5pdHNUb1RpbWVNcyhcclxuICAgICAgdGh1bWJuYWlsV2lkdGgsXHJcbiAgICAgIHRoaXMudFNjYWxlLFxyXG4gICAgICB0aGlzLnBsYXliYWNrUmF0ZSxcclxuICAgICk7XHJcblxyXG4gICAgLy8gQ2xlYXIgdGhlIG9mZnNjcmVlbiBjYW52YXNcclxuICAgIGN0eC5jbGVhclJlY3QoMCwgMCwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xyXG5cclxuICAgIC8vIENsaXAgd2l0aCByb3VuZGVkIGNvcm5lcnNcclxuICAgIGN0eC5iZWdpblBhdGgoKTtcclxuICAgIGN0eC5yb3VuZFJlY3QoMCwgMCwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQsIHRoaXMucngpO1xyXG4gICAgY3R4LmNsaXAoKTtcclxuICAgIC8vIERyYXcgdGh1bWJuYWlsc1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aHVtYm5haWxzQ291bnQ7IGkrKykge1xyXG4gICAgICBsZXQgaW1nID0gdGhpcy50aHVtYm5haWxDYWNoZS5nZXRUaHVtYm5haWwoXHJcbiAgICAgICAgTWF0aC5jZWlsKHRpbWVJbkZpbG1zdHJpcGUgLyAxMDAwKSxcclxuICAgICAgKTtcclxuXHJcbiAgICAgIGlmICghaW1nKSB7XHJcbiAgICAgICAgaW1nID0gdGhpcy50aHVtYm5haWxDYWNoZS5nZXRUaHVtYm5haWwoXCJmYWxsYmFja1wiKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKGltZyAmJiBpbWcuY29tcGxldGUpIHtcclxuICAgICAgICBjb25zdCB4UG9zaXRpb24gPSBpICogdGh1bWJuYWlsV2lkdGggKyBvZmZzZXQgLSB0cmltRnJvbVNpemU7XHJcblxyXG4gICAgICAgIGN0eC5kcmF3SW1hZ2UoaW1nLCB4UG9zaXRpb24sIDAsIHRodW1ibmFpbFdpZHRoLCB0aHVtYm5haWxIZWlnaHQpO1xyXG4gICAgICAgIHRpbWVJbkZpbG1zdHJpcGUgKz0gdGltZVBlclRodW1ibmFpbDtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuaXNEaXJ0eSA9IGZhbHNlO1xyXG4gIH1cclxuXHJcbiAgcHVibGljIGRyYXdUZXh0SWRlbnRpdHkoY3R4OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQpIHtcclxuICAgIGNvbnN0IGljb25QYXRoID0gbmV3IFBhdGgyRChcclxuICAgICAgXCJNMTYuNTYyNSAwLjkyNUwxMi41IDMuMjc1VjAuNjI1TDExLjg3NSAwSDAuNjI1TDAgMC42MjVWOS4zNzVMMC42MjUgMTBIMTEuODc1TDEyLjUgOS4zNzVWNi44NzVMMTYuNTYyNSA5LjIxMjVMMTcuNSA4LjYyNVYxLjQ3NUwxNi41NjI1IDAuOTI1Wk0xMS4yNSA4Ljc1SDEuMjVWMS4yNUgxMS4yNVY4Ljc1Wk0xNi4yNSA3LjVMMTIuNSA1LjM3NVY0LjcyNUwxNi4yNSAyLjVWNy41WlwiLFxyXG4gICAgKTtcclxuICAgIGN0eC5zYXZlKCk7XHJcbiAgICBjdHgudHJhbnNsYXRlKC10aGlzLndpZHRoIC8gMiwgLXRoaXMuaGVpZ2h0IC8gMik7XHJcbiAgICBjdHgudHJhbnNsYXRlKDAsIDE0KTtcclxuICAgIGN0eC5mb250ID0gXCI2MDAgMTJweCAnR2Vpc3QgdmFyaWFibGUnXCI7XHJcbiAgICBjdHguZmlsbFN0eWxlID0gXCIjZjRmNGY1XCI7XHJcbiAgICBjdHgudGV4dEFsaWduID0gXCJsZWZ0XCI7XHJcbiAgICBjdHguY2xpcCgpO1xyXG4gICAgY3R4LmZpbGxUZXh0KFwiVmlkZW9cIiwgMzYsIDEwKTtcclxuXHJcbiAgICBjdHgudHJhbnNsYXRlKDgsIDEpO1xyXG5cclxuICAgIGN0eC5maWxsU3R5bGUgPSBcIiNmNGY0ZjVcIjtcclxuICAgIGN0eC5maWxsKGljb25QYXRoKTtcclxuICAgIGN0eC5yZXN0b3JlKCk7XHJcbiAgfVxyXG5cclxuICBwdWJsaWMgc2V0U2VsZWN0ZWQoc2VsZWN0ZWQ6IGJvb2xlYW4pIHtcclxuICAgIHRoaXMuaXNTZWxlY3RlZCA9IHNlbGVjdGVkO1xyXG4gICAgdGhpcy5zZXQoeyBkaXJ0eTogdHJ1ZSB9KTtcclxuICB9XHJcblxyXG4gIHB1YmxpYyB1cGRhdGVTZWxlY3RlZChjdHg6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCkge1xyXG4gICAgY29uc3QgYm9yZGVyQ29sb3IgPSB0aGlzLmlzU2VsZWN0ZWRcclxuICAgICAgPyBcInJnYmEoMjU1LCAyNTUsIDI1NSwxLjApXCJcclxuICAgICAgOiBcInJnYmEoMjU1LCAyNTUsIDI1NSwwLjEpXCI7XHJcbiAgICBjdHguc2F2ZSgpO1xyXG4gICAgY3R4LmJlZ2luUGF0aCgpO1xyXG4gICAgY3R4LnJvdW5kUmVjdChcclxuICAgICAgLXRoaXMud2lkdGggLyAyLFxyXG4gICAgICAtdGhpcy5oZWlnaHQgLyAyLFxyXG4gICAgICB0aGlzLndpZHRoLFxyXG4gICAgICB0aGlzLmhlaWdodCxcclxuICAgICAgNixcclxuICAgICk7XHJcbiAgICBjdHgubGluZVdpZHRoID0gMTtcclxuICAgIGN0eC5zdHJva2VTdHlsZSA9IGJvcmRlckNvbG9yO1xyXG4gICAgY3R4LnN0cm9rZSgpO1xyXG4gICAgY3R4LnJlc3RvcmUoKTtcclxuICB9XHJcblxyXG4gIHB1YmxpYyBjYWx1bGF0ZVdpZHRoT25TY3JlZW4oKSB7XHJcbiAgICBjb25zdCBjYW52YXNFbCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiZGVzaWduY29tYm8tdGltZWxpbmUtY2FudmFzXCIpO1xyXG4gICAgY29uc3QgY2FudmFzV2lkdGggPSBjYW52YXNFbD8uY2xpZW50V2lkdGg7XHJcbiAgICBjb25zdCBzY3JvbGxMZWZ0ID0gdGhpcy5zY3JvbGxMZWZ0O1xyXG4gICAgY29uc3QgdGltZWxpbmVXaWR0aCA9IGNhbnZhc1dpZHRoITtcclxuICAgIGNvbnN0IGN1dEZyb21Cb3R0b21FZGdlID0gTWF0aC5tYXgoXHJcbiAgICAgIHRpbWVsaW5lV2lkdGggLSAodGhpcy53aWR0aCArIHRoaXMubGVmdCArIHNjcm9sbExlZnQpLFxyXG4gICAgICAwLFxyXG4gICAgKTtcclxuICAgIGNvbnN0IHZpc2libGVIZWlnaHQgPSBNYXRoLm1pbihcclxuICAgICAgdGltZWxpbmVXaWR0aCAtIHRoaXMubGVmdCAtIHNjcm9sbExlZnQsXHJcbiAgICAgIHRpbWVsaW5lV2lkdGgsXHJcbiAgICApO1xyXG5cclxuICAgIHJldHVybiBNYXRoLm1heCh2aXNpYmxlSGVpZ2h0IC0gY3V0RnJvbUJvdHRvbUVkZ2UsIDApO1xyXG4gIH1cclxuXHJcbiAgLy8gQ2FsY3VsYXRlIHRoZSB3aWR0aCB0aGF0IGlzIG5vdCB2aXNpYmxlIG9uIHRoZSBzY3JlZW4gbWVhc3VyZWQgZnJvbSB0aGUgbGVmdFxyXG4gIHB1YmxpYyBjYWxjdWxhdGVPZmZzY3JlZW5XaWR0aCh7IHNjcm9sbExlZnQgfTogeyBzY3JvbGxMZWZ0OiBudW1iZXIgfSkge1xyXG4gICAgY29uc3Qgb2Zmc2NyZWVuV2lkdGggPSBNYXRoLm1pbih0aGlzLmxlZnQgKyBzY3JvbGxMZWZ0LCAwKTtcclxuXHJcbiAgICByZXR1cm4gTWF0aC5hYnMob2Zmc2NyZWVuV2lkdGgpO1xyXG4gIH1cclxuXHJcbiAgcHVibGljIG9uU2Nyb2xsQ2hhbmdlKHtcclxuICAgIHNjcm9sbExlZnQsXHJcbiAgICBmb3JjZSxcclxuICB9OiB7XHJcbiAgICBzY3JvbGxMZWZ0OiBudW1iZXI7XHJcbiAgICBmb3JjZT86IGJvb2xlYW47XHJcbiAgfSkge1xyXG4gICAgY29uc3Qgb2Zmc2NyZWVuV2lkdGggPSB0aGlzLmNhbGN1bGF0ZU9mZnNjcmVlbldpZHRoKHsgc2Nyb2xsTGVmdCB9KTtcclxuICAgIGNvbnN0IHRyaW1Gcm9tU2l6ZSA9IHRpbWVNc1RvVW5pdHMoXHJcbiAgICAgIHRoaXMudHJpbS5mcm9tLFxyXG4gICAgICB0aGlzLnRTY2FsZSxcclxuICAgICAgdGhpcy5wbGF5YmFja1JhdGUsXHJcbiAgICApO1xyXG5cclxuICAgIGNvbnN0IG9mZnNjcmVlblNlZ21lbnRzID0gY2FsY3VsYXRlT2Zmc2NyZWVuU2VnbWVudHMoXHJcbiAgICAgIG9mZnNjcmVlbldpZHRoLFxyXG4gICAgICB0cmltRnJvbVNpemUsXHJcbiAgICAgIHRoaXMuc2VnbWVudFNpemUsXHJcbiAgICApO1xyXG5cclxuICAgIHRoaXMub2Zmc2NyZWVuU2VnbWVudHMgPSBvZmZzY3JlZW5TZWdtZW50cztcclxuXHJcbiAgICAvLyBjYWxjdWxhdGUgc3RhcnQgc2VnbWVudCB0byBkcmF3XHJcbiAgICBjb25zdCBzZWdtZW50VG9EcmF3ID0gb2Zmc2NyZWVuU2VnbWVudHM7XHJcblxyXG4gICAgaWYgKHRoaXMuY3VycmVudEZpbG1zdHJpcC5zZWdtZW50SW5kZXggPT09IHNlZ21lbnRUb0RyYXcpIHtcclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChzZWdtZW50VG9EcmF3ICE9PSB0aGlzLmZhbGxiYWNrU2VnbWVudEluZGV4KSB7XHJcbiAgICAgIGNvbnN0IGZpbGxQYXR0ZXJuID0gdGhpcy5maWxsIGFzIFBhdHRlcm47XHJcbiAgICAgIGlmIChmaWxsUGF0dGVybiBpbnN0YW5jZW9mIFBhdHRlcm4pIHtcclxuICAgICAgICBmaWxsUGF0dGVybi5vZmZzZXRYID1cclxuICAgICAgICAgIHRoaXMuc2VnbWVudFNpemUgKlxyXG4gICAgICAgICAgKHNlZ21lbnRUb0RyYXcgLSBNYXRoLmZsb29yKHRoaXMuZmFsbGJhY2tTZWdtZW50c0NvdW50IC8gMikpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB0aGlzLmZhbGxiYWNrU2VnbWVudEluZGV4ID0gc2VnbWVudFRvRHJhdztcclxuICAgIH1cclxuICAgIGlmICghdGhpcy5pc0ZldGNoaW5nVGh1bWJuYWlscyB8fCBmb3JjZSkge1xyXG4gICAgICB0aGlzLnNjcm9sbExlZnQgPSBzY3JvbGxMZWZ0O1xyXG4gICAgICBjb25zdCB3aWR0aE9uU2NyZWVuID0gdGhpcy5jYWx1bGF0ZVdpZHRoT25TY3JlZW4oKTtcclxuICAgICAgLy8gV2l0aCB0aGVzZSBsaW5lczpcclxuICAgICAgY29uc3QgeyBmaWxtc3RyaXBPZmZzZXQsIGZpbG1zdHJpcFN0YXJ0VGltZSwgZmlsbXN0cmltcFRodW1ibmFpbHNDb3VudCB9ID1cclxuICAgICAgICB0aGlzLmNhbGN1bGF0ZUZpbG1zdHJpcERpbWVuc2lvbnMoe1xyXG4gICAgICAgICAgd2lkdGhPblNjcmVlbjogdGhpcy5jYWx1bGF0ZVdpZHRoT25TY3JlZW4oKSxcclxuICAgICAgICAgIHNlZ21lbnRJbmRleDogc2VnbWVudFRvRHJhdyxcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgIHRoaXMubmV4dEZpbG1zdHJpcCA9IHtcclxuICAgICAgICBzZWdtZW50SW5kZXg6IHNlZ21lbnRUb0RyYXcsXHJcbiAgICAgICAgb2Zmc2V0OiBmaWxtc3RyaXBPZmZzZXQsXHJcbiAgICAgICAgc3RhcnRUaW1lOiBmaWxtc3RyaXBTdGFydFRpbWUsXHJcbiAgICAgICAgdGh1bWJuYWlsc0NvdW50OiBmaWxtc3RyaW1wVGh1bWJuYWlsc0NvdW50LFxyXG4gICAgICAgIHdpZHRoT25TY3JlZW4sXHJcbiAgICAgIH07XHJcblxyXG4gICAgICB0aGlzLmxvYWRBbmRSZW5kZXJUaHVtYm5haWxzKCk7XHJcbiAgICB9XHJcbiAgfVxyXG4gIHB1YmxpYyBvblNjYWxlKCkge1xyXG4gICAgdGhpcy5jdXJyZW50RmlsbXN0cmlwID0geyAuLi5FTVBUWV9GSUxNU1RSSVAgfTtcclxuICAgIHRoaXMubmV4dEZpbG1zdHJpcCA9IHsgLi4uRU1QVFlfRklMTVNUUklQLCBzZWdtZW50SW5kZXg6IDAgfTtcclxuICAgIHRoaXMubG9hZGluZ0ZpbG1zdHJpcCA9IHsgLi4uRU1QVFlfRklMTVNUUklQIH07XHJcbiAgICB0aGlzLm9uU2Nyb2xsQ2hhbmdlKHsgc2Nyb2xsTGVmdDogdGhpcy5zY3JvbGxMZWZ0LCBmb3JjZTogdHJ1ZSB9KTtcclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IFZpZGVvO1xyXG4iXSwibmFtZXMiOlsiUGF0dGVybiIsIlZpZGVvIiwiVmlkZW9CYXNlIiwidGltZU1zVG9Vbml0cyIsInVuaXRzVG9UaW1lTXMiLCJUaHVtYm5haWxDYWNoZSIsImNhbGN1bGF0ZU9mZnNjcmVlblNlZ21lbnRzIiwiY2FsY3VsYXRlVGh1bWJuYWlsU2VnbWVudExheW91dCIsImdldEZpbGVGcm9tVXJsIiwiY3JlYXRlTWVkaWFDb250cm9scyIsIkVNUFRZX0ZJTE1TVFJJUCIsIm9mZnNldCIsInN0YXJ0VGltZSIsInRodW1ibmFpbHNDb3VudCIsIndpZHRoT25TY3JlZW4iLCJjcmVhdGVDb250cm9scyIsImNvbnRyb2xzIiwiaW5pdE9mZnNjcmVlbkNhbnZhcyIsIm9mZnNjcmVlbkNhbnZhcyIsIk9mZnNjcmVlbkNhbnZhcyIsIndpZHRoIiwiaGVpZ2h0Iiwib2Zmc2NyZWVuQ3R4IiwiZ2V0Q29udGV4dCIsImlzRGlydHkiLCJpbml0RGltZW5zaW9ucyIsInRodW1ibmFpbFdpZHRoIiwidGh1bWJuYWlsSGVpZ2h0IiwiYXNwZWN0UmF0aW8iLCJzZWdtZW50T3B0aW9ucyIsInRodW1ibmFpbHNQZXJTZWdtZW50Iiwic2VnbWVudFNpemUiLCJpbml0aWFsaXplIiwibG9hZEZhbGxiYWNrVGh1bWJuYWlsIiwib25TY3JvbGxDaGFuZ2UiLCJzY3JvbGxMZWZ0IiwiY2FudmFzIiwicmVxdWVzdFJlbmRlckFsbCIsImNyZWF0ZUZhbGxiYWNrUGF0dGVybiIsInByZXBhcmVBc3NldHMiLCJNUDRDbGlwIiwiZmlsZSIsInNyYyIsInN0cmVhbSIsImNsaXAiLCJlcnJvciIsImNvbnNvbGUiLCJjYWxjdWxhdGVGaWxtc3RyaXBEaW1lbnNpb25zIiwic2VnbWVudEluZGV4IiwiZmlsbXN0cmlwT2Zmc2V0Iiwic2hvdWxkVXNlTGVmdEJhY2tsb2ciLCJsZWZ0QmFja2xvZ1NpemUiLCJ0b3RhbFdpZHRoIiwiZHVyYXRpb24iLCJ0U2NhbGUiLCJwbGF5YmFja1JhdGUiLCJyaWdodFJlbWFpbmluZ1NpemUiLCJyaWdodEJhY2tsb2dTaXplIiwiTWF0aCIsIm1pbiIsImZpbG1zdHJpcFN0YXJ0VGltZSIsImZpbG1zdHJpbXBUaHVtYm5haWxzQ291bnQiLCJyb3VuZCIsImZhbGxiYWNrVGh1bWJuYWlsIiwicHJldmlld1VybCIsImlkIiwibG9nIiwic3Vic3RyaW5nIiwic3RhcnRzV2l0aCIsIlByb21pc2UiLCJyZXNvbHZlIiwiaW1nIiwiSW1hZ2UiLCJjcm9zc09yaWdpbiIsImNhY2hlQnVzdGVyIiwiRGF0ZSIsIm5vdyIsIm9ubG9hZCIsImRvY3VtZW50IiwiY3JlYXRlRWxlbWVudCIsImN0eCIsInRhcmdldEhlaWdodCIsInRhcmdldFdpZHRoIiwiZHJhd0ltYWdlIiwicmVzaXplZEltZyIsInRodW1ibmFpbENhY2hlIiwic2V0VGh1bWJuYWlsIiwidG9EYXRhVVJMIiwib25lcnJvciIsImVyciIsImZpbGxTdHlsZSIsImZpbGxSZWN0IiwiZm9udCIsImZpbGxUZXh0IiwicGxhY2Vob2xkZXJJbWciLCJmYWxsYmFja0Vycm9yIiwiZ2VuZXJhdGVUaW1lc3RhbXBzIiwiY291bnQiLCJ0aW1lUGVyVGh1bWJuYWlsIiwiQXJyYXkiLCJmcm9tIiwibGVuZ3RoIiwiXyIsImkiLCJ0aW1lSW5GaWxtc3RyaXBlIiwiY2VpbCIsImNhbnZhc1dpZHRoIiwibWF4UGF0dGVyblNpemUiLCJmYWxsYmFja1NvdXJjZSIsImdldFRodW1ibmFpbCIsInRvdGFsV2lkdGhOZWVkZWQiLCJzZWdtZW50c1JlcXVpcmVkIiwiZmFsbGJhY2tTZWdtZW50c0NvdW50IiwicGF0dGVybldpZHRoIiwib2ZmQ2FudmFzIiwiY29udGV4dCIsInRodW1ibmFpbHNUb3RhbCIsIngiLCJmaWxsUGF0dGVybiIsInNvdXJjZSIsInJlcGVhdCIsIm9mZnNldFgiLCJzZXQiLCJsb2FkQW5kUmVuZGVyVGh1bWJuYWlscyIsImlzRmV0Y2hpbmdUaHVtYm5haWxzIiwibG9hZGluZ0ZpbG1zdHJpcCIsIm5leHRGaWxtc3RyaXAiLCJ0aW1lc3RhbXBzIiwidGh1bWJuYWlsc0FyciIsInRodW1ibmFpbHNMaXN0IiwibWFwIiwidGltZXN0YW1wIiwidXBkYXRlZFRodW1ibmFpbHMiLCJ0aHVtYm5haWwiLCJ0cyIsImxvYWRUaHVtYm5haWxCYXRjaCIsImN1cnJlbnRGaWxtc3RyaXAiLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJ0aHVtYm5haWxzIiwibG9hZFByb21pc2VzIiwiVVJMIiwiY3JlYXRlT2JqZWN0VVJMIiwicmV2b2tlT2JqZWN0VVJMIiwiYWxsIiwiX3JlbmRlciIsInNhdmUiLCJ0cmFuc2xhdGUiLCJiZWdpblBhdGgiLCJyZWN0IiwicmVuZGVyVG9PZmZzY3JlZW4iLCJyZXN0b3JlIiwidXBkYXRlU2VsZWN0ZWQiLCJzZXREdXJhdGlvbiIsInByZXZEdXJhdGlvbiIsInNldFNyYyIsImNsZWFyQ2FjaGVCdXRGYWxsYmFjayIsIm9uU2NhbGUiLCJvblJlc2l6ZVNuYXAiLCJvblJlc2l6ZSIsImZvcmNlIiwidHJpbUZyb21TaXplIiwidHJpbSIsImNsZWFyUmVjdCIsInJvdW5kUmVjdCIsInJ4IiwiY29tcGxldGUiLCJ4UG9zaXRpb24iLCJkcmF3VGV4dElkZW50aXR5IiwiaWNvblBhdGgiLCJQYXRoMkQiLCJ0ZXh0QWxpZ24iLCJmaWxsIiwic2V0U2VsZWN0ZWQiLCJzZWxlY3RlZCIsImlzU2VsZWN0ZWQiLCJkaXJ0eSIsImJvcmRlckNvbG9yIiwibGluZVdpZHRoIiwic3Ryb2tlU3R5bGUiLCJzdHJva2UiLCJjYWx1bGF0ZVdpZHRoT25TY3JlZW4iLCJjYW52YXNFbCIsImdldEVsZW1lbnRCeUlkIiwiY2xpZW50V2lkdGgiLCJ0aW1lbGluZVdpZHRoIiwiY3V0RnJvbUJvdHRvbUVkZ2UiLCJtYXgiLCJsZWZ0IiwidmlzaWJsZUhlaWdodCIsImNhbGN1bGF0ZU9mZnNjcmVlbldpZHRoIiwib2Zmc2NyZWVuV2lkdGgiLCJhYnMiLCJvZmZzY3JlZW5TZWdtZW50cyIsInNlZ21lbnRUb0RyYXciLCJmYWxsYmFja1NlZ21lbnRJbmRleCIsImZsb29yIiwiY29uc3RydWN0b3IiLCJwcm9wcyIsInJlc291cmNlSWQiLCJpdGVtVHlwZSIsIm9iamVjdENhY2hpbmciLCJyeSIsImRpc3BsYXkiLCJib3JkZXJPcGFjaXR5V2hlbk1vdmluZyIsIm1ldGFkYXRhIiwic3Ryb2tlV2lkdGgiLCJ0cmFuc3BhcmVudENvcm5lcnMiLCJoYXNCb3JkZXJzIiwidHlwZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./features/editor/timeline/items/video.ts\n"));

/***/ })

});
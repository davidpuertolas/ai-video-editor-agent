"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./features/editor/hooks/use-selection-modal.ts":
/*!******************************************************!*\
  !*** ./features/editor/hooks/use-selection-modal.ts ***!
  \******************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useSelectionModal: function() { return /* binding */ useSelectionModal; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _designcombo_events__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @designcombo/events */ \"(app-pages-browser)/./node_modules/@designcombo/events/dist/index.es.js\");\n/* harmony import */ var _designcombo_state__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @designcombo/state */ \"(app-pages-browser)/./node_modules/@designcombo/state/dist/index.es.js\");\n/* harmony import */ var _store_use_store__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../store/use-store */ \"(app-pages-browser)/./features/editor/store/use-store.ts\");\n\n\n\n\nconst useSelectionModal = ()=>{\n    const [isModalOpen, setIsModalOpen] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const [selectedItems, setSelectedItems] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n    const { trackItemsMap, setState, activeIds } = (0,_store_use_store__WEBPACK_IMPORTED_MODULE_3__[\"default\"])();\n    // Variable para almacenar el último tiempo de selección\n    const [lastSelectionTime, setLastSelectionTime] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(0);\n    // Variable para almacenar los últimos IDs seleccionados\n    const [prevActiveIds, setPrevActiveIds] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n    // Variable para almacenar la cantidad de selecciones recientes (para detectar actividad de selección)\n    const [selectionCount, setSelectionCount] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(0);\n    // Flag para forzar mostrar el modal\n    const [forceShowModal, setForceShowModal] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    // Función para detectar si una selección es por arrastre\n    const detectDragSelection = (currentIds, previousIds, currentTime, lastTime)=>{\n        // Detectar arrastre basado en varios criterios\n        const isMultipleSelection = currentIds.length > 1;\n        const isQuickSelection = currentTime - lastTime < 500; // Aumentado a 500ms para mayor sensibilidad\n        const hasSelectionActivity = selectionCount > 2; // Reducido a 2 para mayor sensibilidad\n        // Calculamos si hay cambios significativos en los IDs seleccionados\n        const hasNewIds = currentIds.some((id)=>!previousIds.includes(id));\n        const hasRemovedIds = previousIds.some((id)=>!currentIds.includes(id));\n        const idsChanged = hasNewIds || hasRemovedIds;\n        // Consideramos como arrastre si hay múltiples elementos, selecciones rápidas,\n        // actividad de selección o cambios en los IDs\n        const isDrag = isMultipleSelection || isQuickSelection && hasSelectionActivity || isQuickSelection && idsChanged;\n        console.log(\"[DEBUG Modal] Evaluando selecci\\xf3n como arrastre:\", {\n            isMultipleSelection,\n            isQuickSelection,\n            hasSelectionActivity,\n            idsChanged,\n            selectionCount,\n            timeDiff: currentTime - lastTime,\n            currentIds,\n            previousIds,\n            isDrag\n        });\n        return isDrag;\n    };\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        // Suscribirse a eventos de selección\n        const selectionEvents = _designcombo_events__WEBPACK_IMPORTED_MODULE_1__.subject.pipe((0,_designcombo_events__WEBPACK_IMPORTED_MODULE_1__.filter)((param)=>{\n            let { key } = param;\n            return key.startsWith(_designcombo_state__WEBPACK_IMPORTED_MODULE_2__.LAYER_PREFIX);\n        }));\n        const selectionSubscription = selectionEvents.subscribe((obj)=>{\n            if (obj.key === _designcombo_state__WEBPACK_IMPORTED_MODULE_2__.LAYER_SELECTION) {\n                var _obj_value, _obj_value1;\n                const newActiveIds = ((_obj_value = obj.value) === null || _obj_value === void 0 ? void 0 : _obj_value.payload.activeIds) || [];\n                const now = Date.now();\n                console.log(\"[DEBUG Modal] Evento de selecci\\xf3n recibido:\", {\n                    activeIds: newActiveIds,\n                    time: now,\n                    timeDiff: now - lastSelectionTime,\n                    payloadInfo: (_obj_value1 = obj.value) === null || _obj_value1 === void 0 ? void 0 : _obj_value1.payload,\n                    forceShow: forceShowModal\n                });\n                // Actualizar estado global\n                setState({\n                    activeIds: newActiveIds\n                });\n                // Incrementar contador de selecciones (para detectar actividad)\n                setSelectionCount((prev)=>prev + 1);\n                // Reducir el contador de selecciones después de un tiempo\n                setTimeout(()=>{\n                    setSelectionCount((prev)=>Math.max(0, prev - 1));\n                }, 1000);\n                // Si hay elementos seleccionados\n                if (newActiveIds && newActiveIds.length > 0) {\n                    // Obtenemos los elementos seleccionados\n                    const items = newActiveIds.map((id)=>trackItemsMap[id]).filter(Boolean);\n                    // Actualizamos los elementos seleccionados\n                    setSelectedItems(items);\n                    // Detectar si es una selección por arrastre\n                    const isDragSelection = detectDragSelection(newActiveIds, prevActiveIds, now, lastSelectionTime);\n                    // Si parece ser una selección por arrastre o se ha forzado mostrar el modal\n                    if (isDragSelection || forceShowModal) {\n                        console.log(\"[DEBUG Modal] Mostrando modal por selecci\\xf3n por arrastre o forzado\");\n                        setIsModalOpen(true);\n                        // Resetear el flag de forzar mostrar\n                        setForceShowModal(false);\n                    }\n                    // Actualizamos el tiempo de la última selección\n                    setLastSelectionTime(now);\n                    // Actualizamos los IDs previamente seleccionados\n                    setPrevActiveIds(newActiveIds);\n                } else {\n                    // Si no hay elementos seleccionados, cerramos el modal\n                    console.log(\"[DEBUG Modal] No hay elementos seleccionados, cerrando modal\");\n                    setIsModalOpen(false);\n                    setSelectedItems([]);\n                }\n            }\n        });\n        return ()=>{\n            selectionSubscription.unsubscribe();\n        };\n    }, [\n        trackItemsMap,\n        setState,\n        lastSelectionTime,\n        prevActiveIds,\n        selectionCount,\n        forceShowModal\n    ]);\n    // Si los activeIds cambian fuera de este hook, actualizamos los elementos seleccionados\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (activeIds && activeIds.length > 0) {\n            const items = activeIds.map((id)=>trackItemsMap[id]).filter(Boolean);\n            setSelectedItems(items);\n        }\n    }, [\n        activeIds,\n        trackItemsMap\n    ]);\n    // Escuchar el evento personalizado de arrastre completado\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        const handleDragComplete = (e)=>{\n            console.log(\"[DEBUG Modal] Evento de arrastre completado recibido\", e.detail);\n            // Si hay elementos seleccionados actualmente, mostrar el modal\n            if (activeIds && activeIds.length > 0) {\n                console.log(\"[DEBUG Modal] Hay elementos seleccionados despu\\xe9s del arrastre, mostrando modal\");\n                // Forzar mostrar el modal en el próximo ciclo\n                setForceShowModal(true);\n                // También intentar abrir inmediatamente\n                setIsModalOpen(true);\n                // Forzar un retraso mínimo para asegurar que se muestre después de cualquier otro evento\n                setTimeout(()=>{\n                    if (activeIds && activeIds.length > 0) {\n                        setIsModalOpen(true);\n                        console.log(\"[DEBUG Modal] Forzando apertura del modal despu\\xe9s de retraso\");\n                    }\n                }, 150);\n            }\n        };\n        // Añadir listener para el evento personalizado\n        window.addEventListener(\"timeline-drag-complete\", handleDragComplete);\n        return ()=>{\n            window.removeEventListener(\"timeline-drag-complete\", handleDragComplete);\n        };\n    }, [\n        activeIds\n    ]);\n    const handleClose = ()=>{\n        console.log(\"[DEBUG Modal] Cerrando modal manualmente\");\n        setIsModalOpen(false);\n    };\n    const handleDelete = ()=>{\n        if (selectedItems.length > 0) {\n            const ids = selectedItems.map((item)=>item.id);\n            console.log(\"[DEBUG Modal] Eliminando elementos:\", ids);\n            (0,_designcombo_events__WEBPACK_IMPORTED_MODULE_1__.dispatch)(_designcombo_state__WEBPACK_IMPORTED_MODULE_2__.LAYER_DELETE, {\n                payload: {\n                    ids\n                }\n            });\n            setIsModalOpen(false);\n        }\n    };\n    const handleCopy = ()=>{\n        // Aquí iría la lógica para duplicar los elementos seleccionados\n        console.log(\"[DEBUG Modal] Duplicar elementos\", selectedItems);\n        setIsModalOpen(false);\n    };\n    const handleSplit = ()=>{\n        if (selectedItems.length === 1) {\n            console.log(\"[DEBUG Modal] Dividiendo elemento:\", selectedItems[0].id);\n            (0,_designcombo_events__WEBPACK_IMPORTED_MODULE_1__.dispatch)(_designcombo_state__WEBPACK_IMPORTED_MODULE_2__.ACTIVE_SPLIT, {\n                payload: {\n                    id: selectedItems[0].id\n                }\n            });\n            setIsModalOpen(false);\n        }\n    };\n    const handleTrim = ()=>{\n        if (selectedItems.length === 1) {\n            // Lógica para recortar el elemento seleccionado\n            console.log(\"[DEBUG Modal] Recortar elemento\", selectedItems[0]);\n            setIsModalOpen(false);\n        }\n    };\n    // Método para abrir el modal manualmente (útil para pruebas)\n    const openModal = ()=>{\n        console.log(\"[DEBUG Modal] Abriendo modal manualmente\");\n        setIsModalOpen(true);\n    };\n    return {\n        isModalOpen,\n        selectedItems,\n        handleClose,\n        handleDelete,\n        handleCopy,\n        handleSplit,\n        handleTrim,\n        openModal\n    };\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2ZlYXR1cmVzL2VkaXRvci9ob29rcy91c2Utc2VsZWN0aW9uLW1vZGFsLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUE0QztBQUNvQjtBQUM0QztBQUNsRTtBQUduQyxNQUFNVSxvQkFBb0I7SUFDL0IsTUFBTSxDQUFDQyxhQUFhQyxlQUFlLEdBQUdaLCtDQUFRQSxDQUFDO0lBQy9DLE1BQU0sQ0FBQ2EsZUFBZUMsaUJBQWlCLEdBQUdkLCtDQUFRQSxDQUFlLEVBQUU7SUFDbkUsTUFBTSxFQUFFZSxhQUFhLEVBQUVDLFFBQVEsRUFBRUMsU0FBUyxFQUFFLEdBQUdSLDREQUFRQTtJQUV2RCx3REFBd0Q7SUFDeEQsTUFBTSxDQUFDUyxtQkFBbUJDLHFCQUFxQixHQUFHbkIsK0NBQVFBLENBQUM7SUFDM0Qsd0RBQXdEO0lBQ3hELE1BQU0sQ0FBQ29CLGVBQWVDLGlCQUFpQixHQUFHckIsK0NBQVFBLENBQVcsRUFBRTtJQUMvRCxzR0FBc0c7SUFDdEcsTUFBTSxDQUFDc0IsZ0JBQWdCQyxrQkFBa0IsR0FBR3ZCLCtDQUFRQSxDQUFDO0lBQ3JELG9DQUFvQztJQUNwQyxNQUFNLENBQUN3QixnQkFBZ0JDLGtCQUFrQixHQUFHekIsK0NBQVFBLENBQUM7SUFFckQseURBQXlEO0lBQ3pELE1BQU0wQixzQkFBc0IsQ0FDMUJDLFlBQ0FDLGFBQ0FDLGFBQ0FDO1FBRUEsK0NBQStDO1FBQy9DLE1BQU1DLHNCQUFzQkosV0FBV0ssTUFBTSxHQUFHO1FBQ2hELE1BQU1DLG1CQUFtQkosY0FBY0MsV0FBVyxLQUFLLDRDQUE0QztRQUNuRyxNQUFNSSx1QkFBdUJaLGlCQUFpQixHQUFHLHVDQUF1QztRQUV4RixvRUFBb0U7UUFDcEUsTUFBTWEsWUFBWVIsV0FBV1MsSUFBSSxDQUFDQyxDQUFBQSxLQUFNLENBQUNULFlBQVlVLFFBQVEsQ0FBQ0Q7UUFDOUQsTUFBTUUsZ0JBQWdCWCxZQUFZUSxJQUFJLENBQUNDLENBQUFBLEtBQU0sQ0FBQ1Ys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QzlCVSxRQUFRQyxHQUFHLENBQUMsc0NBQXNDOUIsYUFBYSxDQUFDLEVBQUUsQ0FBQ3dCLEVBQUU7WUFDckVuQyw2REFBUUEsQ0FBQ00sNERBQVlBLEVBQUU7Z0JBQ3JCOEMsU0FBUztvQkFDUGpCLElBQUl4QixhQUFhLENBQUMsRUFBRSxDQUFDd0IsRUFBRTtnQkFDekI7WUFDRjtZQUNBekIsZUFBZTtRQUNqQjtJQUNGO0lBRUEsTUFBTXFFLGFBQWE7UUFDakIsSUFBSXBFLGNBQWNtQixNQUFNLEtBQUssR0FBRztZQUM5QixnREFBZ0Q7WUFDaERVLFFBQVFDLEdBQUcsQ0FBQyxtQ0FBbUM5QixhQUFhLENBQUMsRUFBRTtZQUMvREQsZUFBZTtRQUNqQjtJQUNGO0lBRUEsNkRBQTZEO0lBQzdELE1BQU1zRSxZQUFZO1FBQ2hCeEMsUUFBUUMsR0FBRyxDQUFDO1FBQ1ovQixlQUFlO0lBQ2pCO0lBRUEsT0FBTztRQUNMRDtRQUNBRTtRQUNBOEQ7UUFDQUM7UUFDQUc7UUFDQUM7UUFDQUM7UUFDQUM7SUFDRjtBQUNGLEVBQUUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vZmVhdHVyZXMvZWRpdG9yL2hvb2tzL3VzZS1zZWxlY3Rpb24tbW9kYWwudHM/ZDEzMiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyB1c2VTdGF0ZSwgdXNlRWZmZWN0IH0gZnJvbSAncmVhY3QnO1xyXG5pbXBvcnQgeyBkaXNwYXRjaCwgZmlsdGVyLCBzdWJqZWN0IH0gZnJvbSBcIkBkZXNpZ25jb21iby9ldmVudHNcIjtcclxuaW1wb3J0IHsgTEFZRVJfUFJFRklYLCBMQVlFUl9TRUxFQ1RJT04sIExBWUVSX0RFTEVURSwgRURJVF9PQkpFQ1QsIEFDVElWRV9TUExJVCB9IGZyb20gXCJAZGVzaWduY29tYm8vc3RhdGVcIjtcclxuaW1wb3J0IHVzZVN0b3JlIGZyb20gJy4uL3N0b3JlL3VzZS1zdG9yZSc7XHJcbmltcG9ydCB7IElUcmFja0l0ZW0gfSBmcm9tIFwiQGRlc2lnbmNvbWJvL3R5cGVzXCI7XHJcblxyXG5leHBvcnQgY29uc3QgdXNlU2VsZWN0aW9uTW9kYWwgPSAoKSA9PiB7XHJcbiAgY29uc3QgW2lzTW9kYWxPcGVuLCBzZXRJc01vZGFsT3Blbl0gPSB1c2VTdGF0ZShmYWxzZSk7XHJcbiAgY29uc3QgW3NlbGVjdGVkSXRlbXMsIHNldFNlbGVjdGVkSXRlbXNdID0gdXNlU3RhdGU8SVRyYWNrSXRlbVtdPihbXSk7XHJcbiAgY29uc3QgeyB0cmFja0l0ZW1zTWFwLCBzZXRTdGF0ZSwgYWN0aXZlSWRzIH0gPSB1c2VTdG9yZSgpO1xyXG5cclxuICAvLyBWYXJpYWJsZSBwYXJhIGFsbWFjZW5hciBlbCDDumx0aW1vIHRpZW1wbyBkZSBzZWxlY2Npw7NuXHJcbiAgY29uc3QgW2xhc3RTZWxlY3Rpb25UaW1lLCBzZXRMYXN0U2VsZWN0aW9uVGltZV0gPSB1c2VTdGF0ZSgwKTtcclxuICAvLyBWYXJpYWJsZSBwYXJhIGFsbWFjZW5hciBsb3Mgw7psdGltb3MgSURzIHNlbGVjY2lvbmFkb3NcclxuICBjb25zdCBbcHJldkFjdGl2ZUlkcywgc2V0UHJldkFjdGl2ZUlkc10gPSB1c2VTdGF0ZTxzdHJpbmdbXT4oW10pO1xyXG4gIC8vIFZhcmlhYmxlIHBhcmEgYWxtYWNlbmFyIGxhIGNhbnRpZGFkIGRlIHNlbGVjY2lvbmVzIHJlY2llbnRlcyAocGFyYSBkZXRlY3RhciBhY3RpdmlkYWQgZGUgc2VsZWNjacOzbilcclxuICBjb25zdCBbc2VsZWN0aW9uQ291bnQsIHNldFNlbGVjdGlvbkNvdW50XSA9IHVzZVN0YXRlKDApO1xyXG4gIC8vIEZsYWcgcGFyYSBmb3J6YXIgbW9zdHJhciBlbCBtb2RhbFxyXG4gIGNvbnN0IFtmb3JjZVNob3dNb2RhbCwgc2V0Rm9yY2VTaG93TW9kYWxdID0gdXNlU3RhdGUoZmFsc2UpO1xyXG5cclxuICAvLyBGdW5jacOzbiBwYXJhIGRldGVjdGFyIHNpIHVuYSBzZWxlY2Npw7NuIGVzIHBvciBhcnJhc3RyZVxyXG4gIGNvbnN0IGRldGVjdERyYWdTZWxlY3Rpb24gPSAoXHJcbiAgICBjdXJyZW50SWRzOiBzdHJpbmdbXSxcclxuICAgIHByZXZpb3VzSWRzOiBzdHJpbmdbXSxcclxuICAgIGN1cnJlbnRUaW1lOiBudW1iZXIsXHJcbiAgICBsYXN0VGltZTogbnVtYmVyXHJcbiAgKSA9PiB7XHJcbiAgICAvLyBEZXRlY3RhciBhcnJhc3RyZSBiYXNhZG8gZW4gdmFyaW9zIGNyaXRlcmlvc1xyXG4gICAgY29uc3QgaXNNdWx0aXBsZVNlbGVjdGlvbiA9IGN1cnJlbnRJZHMubGVuZ3RoID4gMTtcclxuICAgIGNvbnN0IGlzUXVpY2tTZWxlY3Rpb24gPSBjdXJyZW50VGltZSAtIGxhc3RUaW1lIDwgNTAwOyAvLyBBdW1lbnRhZG8gYSA1MDBtcyBwYXJhIG1heW9yIHNlbnNpYmlsaWRhZFxyXG4gICAgY29uc3QgaGFzU2VsZWN0aW9uQWN0aXZpdHkgPSBzZWxlY3Rpb25Db3VudCA+IDI7IC8vIFJlZHVjaWRvIGEgMiBwYXJhIG1heW9yIHNlbnNpYmlsaWRhZFxyXG5cclxuICAgIC8vIENhbGN1bGFtb3Mgc2kgaGF5IGNhbWJpb3Mgc2lnbmlmaWNhdGl2b3MgZW4gbG9zIElEcyBzZWxlY2Npb25hZG9zXHJcbiAgICBjb25zdCBoYXNOZXdJZHMgPSBjdXJyZW50SWRzLnNvbWUoaWQgPT4gIXByZXZpb3VzSWRzLmluY2x1ZGVzKGlkKSk7XHJcbiAgICBjb25zdCBoYXNSZW1vdmVkSWRzID0gcHJldmlvdXNJZHMuc29tZShpZCA9PiAhY3VycmVudElkcy5pbmNsdWRlcyhpZCkpO1xyXG4gICAgY29uc3QgaWRzQ2hhbmdlZCA9IGhhc05ld0lkcyB8fCBoYXNSZW1vdmVkSWRzO1xyXG5cclxuICAgIC8vIENvbnNpZGVyYW1vcyBjb21vIGFycmFzdHJlIHNpIGhheSBtw7psdGlwbGVzIGVsZW1lbnRvcywgc2VsZWNjaW9uZXMgcsOhcGlkYXMsXHJcbiAgICAvLyBhY3RpdmlkYWQgZGUgc2VsZWNjacOzbiBvIGNhbWJpb3MgZW4gbG9zIElEc1xyXG4gICAgY29uc3QgaXNEcmFnID0gaXNNdWx0aXBsZVNlbGVjdGlvbiB8fFxyXG4gICAgICAgICAgICAgICAgICAoaXNRdWlja1NlbGVjdGlvbiAmJiBoYXNTZWxlY3Rpb25BY3Rpdml0eSkgfHxcclxuICAgICAgICAgICAgICAgICAgKGlzUXVpY2tTZWxlY3Rpb24gJiYgaWRzQ2hhbmdlZCk7XHJcblxyXG4gICAgY29uc29sZS5sb2coXCJbREVCVUcgTW9kYWxdIEV2YWx1YW5kbyBzZWxlY2Npw7NuIGNvbW8gYXJyYXN0cmU6XCIsIHtcclxuICAgICAgaXNNdWx0aXBsZVNlbGVjdGlvbixcclxuICAgICAgaXNRdWlja1NlbGVjdGlvbixcclxuICAgICAgaGFzU2VsZWN0aW9uQWN0aXZpdHksXHJcbiAgICAgIGlkc0NoYW5nZWQsXHJcbiAgICAgIHNlbGVjdGlvbkNvdW50LFxyXG4gICAgICB0aW1lRGlmZjogY3VycmVudFRpbWUgLSBsYXN0VGltZSxcclxuICAgICAgY3VycmVudElkcyxcclxuICAgICAgcHJldmlvdXNJZHMsXHJcbiAgICAgIGlzRHJhZ1xyXG4gICAgfSk7XHJcblxyXG4gICAgcmV0dXJuIGlzRHJhZztcclxuICB9O1xyXG5cclxuICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgLy8gU3VzY3JpYmlyc2UgYSBldmVudG9zIGRlIHNlbGVjY2nDs25cclxuICAgIGNvbnN0IHNlbGVjdGlvbkV2ZW50cyA9IHN1YmplY3QucGlwZShcclxuICAgICAgZmlsdGVyKCh7IGtleSB9KSA9PiBrZXkuc3RhcnRzV2l0aChMQVlFUl9QUkVGSVgpKSxcclxuICAgICk7XHJcblxyXG4gICAgY29uc3Qgc2VsZWN0aW9uU3Vic2NyaXB0aW9uID0gc2VsZWN0aW9uRXZlbnRzLnN1YnNjcmliZSgob2JqKSA9PiB7XHJcbiAgICAgIGlmIChvYmoua2V5ID09PSBMQVlFUl9TRUxFQ1RJT04pIHtcclxuICAgICAgICBjb25zdCBuZXdBY3RpdmVJZHMgPSBvYmoudmFsdWU/LnBheWxvYWQuYWN0aXZlSWRzIHx8IFtdO1xyXG4gICAgICAgIGNvbnN0IG5vdyA9IERhdGUubm93KCk7XHJcblxyXG4gICAgICAgIGNvbnNvbGUubG9nKFwiW0RFQlVHIE1vZGFsXSBFdmVudG8gZGUgc2VsZWNjacOzbiByZWNpYmlkbzpcIiwge1xyXG4gICAgICAgICAgYWN0aXZlSWRzOiBuZXdBY3RpdmVJZHMsXHJcbiAgICAgICAgICB0aW1lOiBub3csXHJcbiAgICAgICAgICB0aW1lRGlmZjogbm93IC0gbGFzdFNlbGVjdGlvblRpbWUsXHJcbiAgICAgICAgICBwYXlsb2FkSW5mbzogb2JqLnZhbHVlPy5wYXlsb2FkLFxyXG4gICAgICAgICAgZm9yY2VTaG93OiBmb3JjZVNob3dNb2RhbFxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICAvLyBBY3R1YWxpemFyIGVzdGFkbyBnbG9iYWxcclxuICAgICAgICBzZXRTdGF0ZSh7XHJcbiAgICAgICAgICBhY3RpdmVJZHM6IG5ld0FjdGl2ZUlkcyxcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgLy8gSW5jcmVtZW50YXIgY29udGFkb3IgZGUgc2VsZWNjaW9uZXMgKHBhcmEgZGV0ZWN0YXIgYWN0aXZpZGFkKVxyXG4gICAgICAgIHNldFNlbGVjdGlvbkNvdW50KHByZXYgPT4gcHJldiArIDEpO1xyXG5cclxuICAgICAgICAvLyBSZWR1Y2lyIGVsIGNvbnRhZG9yIGRlIHNlbGVjY2lvbmVzIGRlc3B1w6lzIGRlIHVuIHRpZW1wb1xyXG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICAgICAgc2V0U2VsZWN0aW9uQ291bnQocHJldiA9PiBNYXRoLm1heCgwLCBwcmV2IC0gMSkpO1xyXG4gICAgICAgIH0sIDEwMDApO1xyXG5cclxuICAgICAgICAvLyBTaSBoYXkgZWxlbWVudG9zIHNlbGVjY2lvbmFkb3NcclxuICAgICAgICBpZiAobmV3QWN0aXZlSWRzICYmIG5ld0FjdGl2ZUlkcy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAvLyBPYnRlbmVtb3MgbG9zIGVsZW1lbnRvcyBzZWxlY2Npb25hZG9zXHJcbiAgICAgICAgICBjb25zdCBpdGVtcyA9IG5ld0FjdGl2ZUlkc1xyXG4gICAgICAgICAgICAubWFwKGlkID0+IHRyYWNrSXRlbXNNYXBbaWRdKVxyXG4gICAgICAgICAgICAuZmlsdGVyKEJvb2xlYW4pO1xyXG5cclxuICAgICAgICAgIC8vIEFjdHVhbGl6YW1vcyBsb3MgZWxlbWVudG9zIHNlbGVjY2lvbmFkb3NcclxuICAgICAgICAgIHNldFNlbGVjdGVkSXRlbXMoaXRlbXMpO1xyXG5cclxuICAgICAgICAgIC8vIERldGVjdGFyIHNpIGVzIHVuYSBzZWxlY2Npw7NuIHBvciBhcnJhc3RyZVxyXG4gICAgICAgICAgY29uc3QgaXNEcmFnU2VsZWN0aW9uID0gZGV0ZWN0RHJhZ1NlbGVjdGlvbihcclxuICAgICAgICAgICAgbmV3QWN0aXZlSWRzLFxyXG4gICAgICAgICAgICBwcmV2QWN0aXZlSWRzLFxyXG4gICAgICAgICAgICBub3csXHJcbiAgICAgICAgICAgIGxhc3RTZWxlY3Rpb25UaW1lXHJcbiAgICAgICAgICApO1xyXG5cclxuICAgICAgICAgIC8vIFNpIHBhcmVjZSBzZXIgdW5hIHNlbGVjY2nDs24gcG9yIGFycmFzdHJlIG8gc2UgaGEgZm9yemFkbyBtb3N0cmFyIGVsIG1vZGFsXHJcbiAgICAgICAgICBpZiAoaXNEcmFnU2VsZWN0aW9uIHx8IGZvcmNlU2hvd01vZGFsKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiW0RFQlVHIE1vZGFsXSBNb3N0cmFuZG8gbW9kYWwgcG9yIHNlbGVjY2nDs24gcG9yIGFycmFzdHJlIG8gZm9yemFkb1wiKTtcclxuICAgICAgICAgICAgc2V0SXNNb2RhbE9wZW4odHJ1ZSk7XHJcbiAgICAgICAgICAgIC8vIFJlc2V0ZWFyIGVsIGZsYWcgZGUgZm9yemFyIG1vc3RyYXJcclxuICAgICAgICAgICAgc2V0Rm9yY2VTaG93TW9kYWwoZmFsc2UpO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIC8vIEFjdHVhbGl6YW1vcyBlbCB0aWVtcG8gZGUgbGEgw7psdGltYSBzZWxlY2Npw7NuXHJcbiAgICAgICAgICBzZXRMYXN0U2VsZWN0aW9uVGltZShub3cpO1xyXG4gICAgICAgICAgLy8gQWN0dWFsaXphbW9zIGxvcyBJRHMgcHJldmlhbWVudGUgc2VsZWNjaW9uYWRvc1xyXG4gICAgICAgICAgc2V0UHJldkFjdGl2ZUlkcyhuZXdBY3RpdmVJZHMpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAvLyBTaSBubyBoYXkgZWxlbWVudG9zIHNlbGVjY2lvbmFkb3MsIGNlcnJhbW9zIGVsIG1vZGFsXHJcbiAgICAgICAgICBjb25zb2xlLmxvZyhcIltERUJVRyBNb2RhbF0gTm8gaGF5IGVsZW1lbnRvcyBzZWxlY2Npb25hZG9zLCBjZXJyYW5kbyBtb2RhbFwiKTtcclxuICAgICAgICAgIHNldElzTW9kYWxPcGVuKGZhbHNlKTtcclxuICAgICAgICAgIHNldFNlbGVjdGVkSXRlbXMoW10pO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgcmV0dXJuICgpID0+IHtcclxuICAgICAgc2VsZWN0aW9uU3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XHJcbiAgICB9O1xyXG4gIH0sIFt0cmFja0l0ZW1zTWFwLCBzZXRTdGF0ZSwgbGFzdFNlbGVjdGlvblRpbWUsIHByZXZBY3RpdmVJZHMsIHNlbGVjdGlvbkNvdW50LCBmb3JjZVNob3dNb2RhbF0pO1xyXG5cclxuICAvLyBTaSBsb3MgYWN0aXZlSWRzIGNhbWJpYW4gZnVlcmEgZGUgZXN0ZSBob29rLCBhY3R1YWxpemFtb3MgbG9zIGVsZW1lbnRvcyBzZWxlY2Npb25hZG9zXHJcbiAgdXNlRWZmZWN0KCgpID0+IHtcclxuICAgIGlmIChhY3RpdmVJZHMgJiYgYWN0aXZlSWRzLmxlbmd0aCA+IDApIHtcclxuICAgICAgY29uc3QgaXRlbXMgPSBhY3RpdmVJZHNcclxuICAgICAgICAubWFwKGlkID0+IHRyYWNrSXRlbXNNYXBbaWRdKVxyXG4gICAgICAgIC5maWx0ZXIoQm9vbGVhbik7XHJcblxyXG4gICAgICBzZXRTZWxlY3RlZEl0ZW1zKGl0ZW1zKTtcclxuICAgIH1cclxuICB9LCBbYWN0aXZlSWRzLCB0cmFja0l0ZW1zTWFwXSk7XHJcblxyXG4gIC8vIEVzY3VjaGFyIGVsIGV2ZW50byBwZXJzb25hbGl6YWRvIGRlIGFycmFzdHJlIGNvbXBsZXRhZG9cclxuICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgY29uc3QgaGFuZGxlRHJhZ0NvbXBsZXRlID0gKGU6IEN1c3RvbUV2ZW50KSA9PiB7XHJcbiAgICAgIGNvbnNvbGUubG9nKFwiW0RFQlVHIE1vZGFsXSBFdmVudG8gZGUgYXJyYXN0cmUgY29tcGxldGFkbyByZWNpYmlkb1wiLCBlLmRldGFpbCk7XHJcblxyXG4gICAgICAvLyBTaSBoYXkgZWxlbWVudG9zIHNlbGVjY2lvbmFkb3MgYWN0dWFsbWVudGUsIG1vc3RyYXIgZWwgbW9kYWxcclxuICAgICAgaWYgKGFjdGl2ZUlkcyAmJiBhY3RpdmVJZHMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKFwiW0RFQlVHIE1vZGFsXSBIYXkgZWxlbWVudG9zIHNlbGVjY2lvbmFkb3MgZGVzcHXDqXMgZGVsIGFycmFzdHJlLCBtb3N0cmFuZG8gbW9kYWxcIik7XHJcbiAgICAgICAgLy8gRm9yemFyIG1vc3RyYXIgZWwgbW9kYWwgZW4gZWwgcHLDs3hpbW8gY2ljbG9cclxuICAgICAgICBzZXRGb3JjZVNob3dNb2RhbCh0cnVlKTtcclxuXHJcbiAgICAgICAgLy8gVGFtYmnDqW4gaW50ZW50YXIgYWJyaXIgaW5tZWRpYXRhbWVudGVcclxuICAgICAgICBzZXRJc01vZGFsT3Blbih0cnVlKTtcclxuXHJcbiAgICAgICAgLy8gRm9yemFyIHVuIHJldHJhc28gbcOtbmltbyBwYXJhIGFzZWd1cmFyIHF1ZSBzZSBtdWVzdHJlIGRlc3B1w6lzIGRlIGN1YWxxdWllciBvdHJvIGV2ZW50b1xyXG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICAgICAgaWYgKGFjdGl2ZUlkcyAmJiBhY3RpdmVJZHMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICBzZXRJc01vZGFsT3Blbih0cnVlKTtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coXCJbREVCVUcgTW9kYWxdIEZvcnphbmRvIGFwZXJ0dXJhIGRlbCBtb2RhbCBkZXNwdcOpcyBkZSByZXRyYXNvXCIpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0sIDE1MCk7XHJcbiAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgLy8gQcOxYWRpciBsaXN0ZW5lciBwYXJhIGVsIGV2ZW50byBwZXJzb25hbGl6YWRvXHJcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigndGltZWxpbmUtZHJhZy1jb21wbGV0ZScsIGhhbmRsZURyYWdDb21wbGV0ZSBhcyBFdmVudExpc3RlbmVyKTtcclxuXHJcbiAgICByZXR1cm4gKCkgPT4ge1xyXG4gICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigndGltZWxpbmUtZHJhZy1jb21wbGV0ZScsIGhhbmRsZURyYWdDb21wbGV0ZSBhcyBFdmVudExpc3RlbmVyKTtcclxuICAgIH07XHJcbiAgfSwgW2FjdGl2ZUlkc10pO1xyXG5cclxuICBjb25zdCBoYW5kbGVDbG9zZSA9ICgpID0+IHtcclxuICAgIGNvbnNvbGUubG9nKFwiW0RFQlVHIE1vZGFsXSBDZXJyYW5kbyBtb2RhbCBtYW51YWxtZW50ZVwiKTtcclxuICAgIHNldElzTW9kYWxPcGVuKGZhbHNlKTtcclxuICB9O1xyXG5cclxuICBjb25zdCBoYW5kbGVEZWxldGUgPSAoKSA9PiB7XHJcbiAgICBpZiAoc2VsZWN0ZWRJdGVtcy5sZW5ndGggPiAwKSB7XHJcbiAgICAgIGNvbnN0IGlkcyA9IHNlbGVjdGVkSXRlbXMubWFwKGl0ZW0gPT4gaXRlbS5pZCk7XHJcbiAgICAgIGNvbnNvbGUubG9nKFwiW0RFQlVHIE1vZGFsXSBFbGltaW5hbmRvIGVsZW1lbnRvczpcIiwgaWRzKTtcclxuICAgICAgZGlzcGF0Y2goTEFZRVJfREVMRVRFLCB7XHJcbiAgICAgICAgcGF5bG9hZDoge1xyXG4gICAgICAgICAgaWRzXHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuICAgICAgc2V0SXNNb2RhbE9wZW4oZmFsc2UpO1xyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIGNvbnN0IGhhbmRsZUNvcHkgPSAoKSA9PiB7XHJcbiAgICAvLyBBcXXDrSBpcsOtYSBsYSBsw7NnaWNhIHBhcmEgZHVwbGljYXIgbG9zIGVsZW1lbnRvcyBzZWxlY2Npb25hZG9zXHJcbiAgICBjb25zb2xlLmxvZygnW0RFQlVHIE1vZGFsXSBEdXBsaWNhciBlbGVtZW50b3MnLCBzZWxlY3RlZEl0ZW1zKTtcclxuICAgIHNldElzTW9kYWxPcGVuKGZhbHNlKTtcclxuICB9O1xyXG5cclxuICBjb25zdCBoYW5kbGVTcGxpdCA9ICgpID0+IHtcclxuICAgIGlmIChzZWxlY3RlZEl0ZW1zLmxlbmd0aCA9PT0gMSkge1xyXG4gICAgICBjb25zb2xlLmxvZygnW0RFQlVHIE1vZGFsXSBEaXZpZGllbmRvIGVsZW1lbnRvOicsIHNlbGVjdGVkSXRlbXNbMF0uaWQpO1xyXG4gICAgICBkaXNwYXRjaChBQ1RJVkVfU1BMSVQsIHtcclxuICAgICAgICBwYXlsb2FkOiB7XHJcbiAgICAgICAgICBpZDogc2VsZWN0ZWRJdGVtc1swXS5pZCxcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG4gICAgICBzZXRJc01vZGFsT3BlbihmYWxzZSk7XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgY29uc3QgaGFuZGxlVHJpbSA9ICgpID0+IHtcclxuICAgIGlmIChzZWxlY3RlZEl0ZW1zLmxlbmd0aCA9PT0gMSkge1xyXG4gICAgICAvLyBMw7NnaWNhIHBhcmEgcmVjb3J0YXIgZWwgZWxlbWVudG8gc2VsZWNjaW9uYWRvXHJcbiAgICAgIGNvbnNvbGUubG9nKCdbREVCVUcgTW9kYWxdIFJlY29ydGFyIGVsZW1lbnRvJywgc2VsZWN0ZWRJdGVtc1swXSk7XHJcbiAgICAgIHNldElzTW9kYWxPcGVuKGZhbHNlKTtcclxuICAgIH1cclxuICB9O1xyXG5cclxuICAvLyBNw6l0b2RvIHBhcmEgYWJyaXIgZWwgbW9kYWwgbWFudWFsbWVudGUgKMO6dGlsIHBhcmEgcHJ1ZWJhcylcclxuICBjb25zdCBvcGVuTW9kYWwgPSAoKSA9PiB7XHJcbiAgICBjb25zb2xlLmxvZyhcIltERUJVRyBNb2RhbF0gQWJyaWVuZG8gbW9kYWwgbWFudWFsbWVudGVcIik7XHJcbiAgICBzZXRJc01vZGFsT3Blbih0cnVlKTtcclxuICB9O1xyXG5cclxuICByZXR1cm4ge1xyXG4gICAgaXNNb2RhbE9wZW4sXHJcbiAgICBzZWxlY3RlZEl0ZW1zLFxyXG4gICAgaGFuZGxlQ2xvc2UsXHJcbiAgICBoYW5kbGVEZWxldGUsXHJcbiAgICBoYW5kbGVDb3B5LFxyXG4gICAgaGFuZGxlU3BsaXQsXHJcbiAgICBoYW5kbGVUcmltLFxyXG4gICAgb3Blbk1vZGFsIC8vIE51ZXZvIG3DqXRvZG8gcGFyYSBhYnJpciBlbCBtb2RhbCBtYW51YWxtZW50ZVxyXG4gIH07XHJcbn07XHJcbiJdLCJuYW1lcyI6WyJ1c2VTdGF0ZSIsInVzZUVmZmVjdCIsImRpc3BhdGNoIiwiZmlsdGVyIiwic3ViamVjdCIsIkxBWUVSX1BSRUZJWCIsIkxBWUVSX1NFTEVDVElPTiIsIkxBWUVSX0RFTEVURSIsIkFDVElWRV9TUExJVCIsInVzZVN0b3JlIiwidXNlU2VsZWN0aW9uTW9kYWwiLCJpc01vZGFsT3BlbiIsInNldElzTW9kYWxPcGVuIiwic2VsZWN0ZWRJdGVtcyIsInNldFNlbGVjdGVkSXRlbXMiLCJ0cmFja0l0ZW1zTWFwIiwic2V0U3RhdGUiLCJhY3RpdmVJZHMiLCJsYXN0U2VsZWN0aW9uVGltZSIsInNldExhc3RTZWxlY3Rpb25UaW1lIiwicHJldkFjdGl2ZUlkcyIsInNldFByZXZBY3RpdmVJZHMiLCJzZWxlY3Rpb25Db3VudCIsInNldFNlbGVjdGlvbkNvdW50IiwiZm9yY2VTaG93TW9kYWwiLCJzZXRGb3JjZVNob3dNb2RhbCIsImRldGVjdERyYWdTZWxlY3Rpb24iLCJjdXJyZW50SWRzIiwicHJldmlvdXNJZHMiLCJjdXJyZW50VGltZSIsImxhc3RUaW1lIiwiaXNNdWx0aXBsZVNlbGVjdGlvbiIsImxlbmd0aCIsImlzUXVpY2tTZWxlY3Rpb24iLCJoYXNTZWxlY3Rpb25BY3Rpdml0eSIsImhhc05ld0lkcyIsInNvbWUiLCJpZCIsImluY2x1ZGVzIiwiaGFzUmVtb3ZlZElkcyIsImlkc0NoYW5nZWQiLCJpc0RyYWciLCJjb25zb2xlIiwibG9nIiwidGltZURpZmYiLCJzZWxlY3Rpb25FdmVudHMiLCJwaXBlIiwia2V5Iiwic3RhcnRzV2l0aCIsInNlbGVjdGlvblN1YnNjcmlwdGlvbiIsInN1YnNjcmliZSIsIm9iaiIsIm5ld0FjdGl2ZUlkcyIsInZhbHVlIiwicGF5bG9hZCIsIm5vdyIsIkRhdGUiLCJ0aW1lIiwicGF5bG9hZEluZm8iLCJmb3JjZVNob3ciLCJwcmV2Iiwic2V0VGltZW91dCIsIk1hdGgiLCJtYXgiLCJpdGVtcyIsIm1hcCIsIkJvb2xlYW4iLCJpc0RyYWdTZWxlY3Rpb24iLCJ1bnN1YnNjcmliZSIsImhhbmRsZURyYWdDb21wbGV0ZSIsImUiLCJkZXRhaWwiLCJ3aW5kb3ciLCJhZGRFdmVudExpc3RlbmVyIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsImhhbmRsZUNsb3NlIiwiaGFuZGxlRGVsZXRlIiwiaWRzIiwiaXRlbSIsImhhbmRsZUNvcHkiLCJoYW5kbGVTcGxpdCIsImhhbmRsZVRyaW0iLCJvcGVuTW9kYWwiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./features/editor/hooks/use-selection-modal.ts\n"));

/***/ })

});
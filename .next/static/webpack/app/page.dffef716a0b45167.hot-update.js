"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./components/ai-chat/ai-video-commands.ts":
/*!*************************************************!*\
  !*** ./components/ai-chat/ai-video-commands.ts ***!
  \*************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createVideoCommandExecutor: function() { return /* binding */ createVideoCommandExecutor; }\n/* harmony export */ });\n/* harmony import */ var _designcombo_events__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @designcombo/events */ \"(app-pages-browser)/./node_modules/@designcombo/events/dist/index.es.js\");\n/* harmony import */ var _designcombo_state__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @designcombo/state */ \"(app-pages-browser)/./node_modules/@designcombo/state/dist/index.es.js\");\n/* harmony import */ var _designcombo_timeline__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @designcombo/timeline */ \"(app-pages-browser)/./node_modules/@designcombo/timeline/dist/index.es.js\");\n\n\n\nfunction createVideoCommandExecutor(stateManager) {\n    // Crear el objeto executor con todos los métodos\n    const executor = {\n        addText: (text, options)=>{\n            const position = (options === null || options === void 0 ? void 0 : options.position) || {\n                x: 0.5,\n                y: 0.5\n            }; // Centrado por defecto\n            const fontSize = (options === null || options === void 0 ? void 0 : options.fontSize) || 48;\n            const fontFamily = (options === null || options === void 0 ? void 0 : options.fontFamily) || \"Roboto-Bold\";\n            const color = (options === null || options === void 0 ? void 0 : options.color) || \"#FFFFFF\";\n            const startTime = (options === null || options === void 0 ? void 0 : options.startTime) || 0; // Por defecto al inicio\n            const endTime = (options === null || options === void 0 ? void 0 : options.endTime) || 5; // Por defecto 5 segundos de duración\n            // Crear payload para el texto\n            const textPayload = {\n                id: (0,_designcombo_timeline__WEBPACK_IMPORTED_MODULE_2__.generateId)(),\n                display: {\n                    from: startTime * 1000,\n                    to: endTime * 1000 // Convertir a milisegundos\n                },\n                type: \"text\",\n                details: {\n                    text: text,\n                    fontSize: fontSize,\n                    width: 600,\n                    fontFamily: fontFamily,\n                    color: color,\n                    wordWrap: \"break-word\",\n                    textAlign: \"center\",\n                    borderWidth: 0,\n                    borderColor: \"#000000\",\n                    boxShadow: {\n                        color: \"#ffffff\",\n                        x: 0,\n                        y: 0,\n                        blur: 0\n                    }\n                }\n            };\n            // Agregar texto al timeline\n            (0,_designcombo_events__WEBPACK_IMPORTED_MODULE_0__.dispatch)(_designcombo_state__WEBPACK_IMPORTED_MODULE_1__.ADD_TEXT, {\n                payload: textPayload,\n                options: {}\n            });\n        },\n        changeColor: (elementId, color)=>{\n            // Simulación de cambio de color (la implementación real dependerá de la estructura del proyecto)\n            console.log(\"Cambiando color del elemento \".concat(elementId, \" a \").concat(color));\n        // Aquí iría la lógica real para cambiar el color de un elemento\n        },\n        addImage: (url, options)=>{\n            try {\n                // Asegurar que tenemos una URL válida\n                if (!url) {\n                    console.error(\"❌ URL de imagen no v\\xe1lida o vac\\xeda\");\n                    throw new Error(\"URL de imagen no proporcionada\");\n                }\n                console.log(\"=== INICIANDO PROCESO DE A\\xd1ADIR IMAGEN ===\");\n                console.log(\"URL:\", url);\n                console.log(\"Opciones:\", JSON.stringify(options, null, 2));\n                // Verificar si es una URL genérica de referencia, que no debe usarse directamente\n                if (url === \"imagen_adjunta_por_el_usuario.jpg\" || url.includes(\"/url_de_la_imagen\")) {\n                    console.error(\"Error: URL de imagen gen\\xe9rica inv\\xe1lida detectada\", url);\n                    throw new Error(\"La URL de imagen no es v\\xe1lida. Se intent\\xf3 usar un marcador gen\\xe9rico directamente.\");\n                }\n                const width = (options === null || options === void 0 ? void 0 : options.width) || 480;\n                const height = (options === null || options === void 0 ? void 0 : options.height) || 270;\n                const startTime = (options === null || options === void 0 ? void 0 : options.startTime) !== undefined ? options.startTime : 0;\n                const endTime = (options === null || options === void 0 ? void 0 : options.endTime) !== undefined ? options.endTime : startTime + 5;\n                // Detectores de tipo de imagen\n                const isExplicitlyAnimated = (options === null || options === void 0 ? void 0 : options.isAnimated) === true;\n                const isExplicitlyStatic = (options === null || options === void 0 ? void 0 : options.isStatic) === true;\n                const isAPNG = url.toLowerCase().endsWith(\".apng\");\n                const isGIF = url.toLowerCase().endsWith(\".gif\");\n                // Determinar si debe tratarse como imagen animada\n                const shouldTreatAsAnimated = (isExplicitlyAnimated || isAPNG || isGIF) && !isExplicitlyStatic;\n                // Log de modo detectado\n                if (shouldTreatAsAnimated) {\n                    console.log(\"\\uD83D\\uDD36 Detectada imagen animada: \".concat(url));\n                    console.log(\"Tipo: \".concat(isAPNG ? \"APNG\" : isGIF ? \"GIF\" : \"Animada gen\\xe9rica\"));\n                } else if (isAPNG || isGIF) {\n                    console.log(\"\\uD83D\\uDD39 Detectada imagen potencialmente animada pero trat\\xe1ndola como est\\xe1tica: \".concat(url));\n                } else {\n                    console.log(\"\\uD83D\\uDD37 Detectada imagen est\\xe1tica: \".concat(url));\n                }\n                // Para depuración, mostrar parte de la URL (truncada si es data:URL)\n                const logUrl = url.startsWith(\"data:\") ? \"\".concat(url.substring(0, 30), \"... (data URL)\") : url;\n                console.log(\"A\\xf1adiendo imagen desde \".concat(logUrl, \" desde segundo \").concat(startTime, \" hasta \").concat(endTime));\n                // Posición (centrada por defecto)\n                const position = (options === null || options === void 0 ? void 0 : options.position) || {\n                    x: 0.5,\n                    y: 0.5\n                };\n                // Modos de escala\n                const scaleMode = (options === null || options === void 0 ? void 0 : options.scaleMode) || \"fit\";\n                const useFullScreen = scaleMode === \"cover\";\n                // Propiedades para el payload, común para ambos casos\n                const commonPayloadProps = {\n                    from: startTime * 1000,\n                    to: endTime * 1000\n                };\n                // Propiedades de detalle comunes\n                const commonDetailsProps = {\n                    src: url,\n                    width: width,\n                    height: height,\n                    opacity: 100,\n                    scaleMode: scaleMode,\n                    left: position.x,\n                    top: position.y,\n                    originX: \"center\",\n                    originY: \"center\"\n                };\n                // Crear ID único\n                const imageId = (0,_designcombo_timeline__WEBPACK_IMPORTED_MODULE_2__.generateId)();\n                // Crear el payload de imagen simplificado\n                const imagePayload = {\n                    id: imageId,\n                    display: commonPayloadProps,\n                    type: \"image\",\n                    details: {\n                        ...commonDetailsProps,\n                        // Si es animada, añadir atributos específicos\n                        ...shouldTreatAsAnimated && {\n                            isAnimated: true\n                        },\n                        // Si a pantalla completa, ajustar dimensiones\n                        ...useFullScreen && {\n                            width: 1920,\n                            height: 1080\n                        }\n                    }\n                };\n                console.log(\"Payload de imagen a despachar:\", JSON.stringify({\n                    ...imagePayload,\n                    details: {\n                        ...imagePayload.details,\n                        src: imagePayload.details.src.substring(0, 30) + (imagePayload.details.src.length > 30 ? \"...\" : \"\")\n                    }\n                }, null, 2));\n                // Opciones para el dispatch\n                const dispatchOptions = {\n                    scaleMode: scaleMode,\n                    position: position\n                };\n                // Despachar la acción para añadir la imagen\n                (0,_designcombo_events__WEBPACK_IMPORTED_MODULE_0__.dispatch)(_designcombo_state__WEBPACK_IMPORTED_MODULE_1__.ADD_IMAGE, {\n                    payload: imagePayload,\n                    options: dispatchOptions\n                });\n                // Log de éxito\n                if (shouldTreatAsAnimated) {\n                    console.log(\"✅ Imagen animada a\\xf1adida desde \".concat(startTime, \"s hasta \").concat(endTime, \"s\"));\n                } else {\n                    console.log(\"✅ Imagen est\\xe1tica a\\xf1adida desde \".concat(startTime, \"s hasta \").concat(endTime, \"s\"));\n                }\n            } catch (error) {\n                console.error(\"❌ ERROR CR\\xcdTICO al a\\xf1adir imagen:\", error);\n                console.error(\"Detalles completos:\", error.message);\n                console.error(\"Traza:\", error.stack);\n                throw error; // Propagar el error para manejo superior\n            }\n        },\n        addVideo: (url, options)=>{\n            try {\n                console.log(\"=== INICIANDO PROCESO DE A\\xd1ADIR VIDEO ===\");\n                console.log(\"URL:\", url);\n                console.log(\"Opciones:\", JSON.stringify(options, null, 2));\n                // Validación de URL\n                if (!url) {\n                    console.error(\"❌ URL de video no v\\xe1lida o vac\\xeda\");\n                    throw new Error(\"URL de video no proporcionada\");\n                }\n                const width = (options === null || options === void 0 ? void 0 : options.width) || 640;\n                const height = (options === null || options === void 0 ? void 0 : options.height) || 360;\n                const startTime = (options === null || options === void 0 ? void 0 : options.startTime) || 0; // Por defecto al inicio\n                const endTime = (options === null || options === void 0 ? void 0 : options.endTime) || 10; // Por defecto 10 segundos de duración\n                // Detectar si es un archivo AVI o APNG para tratamiento especial\n                const isAVI = url.toLowerCase().endsWith(\".avi\");\n                const isAPNG = url.toLowerCase().endsWith(\".apng\");\n                // Marcador pasado explícitamente - mayor prioridad que la extensión\n                const isExplicitAPNG = (options === null || options === void 0 ? void 0 : options.isAPNG) === true;\n                console.log(\"Formato detectado:\", isAVI ? \"AVI\" : isAPNG ? \"APNG\" : isExplicitAPNG ? \"Expl\\xedcitamente marcado como APNG\" : \"Formato est\\xe1ndar\");\n                // Si es APNG según algún criterio\n                const treatAsAPNG = isAPNG || isExplicitAPNG;\n                const useFullScreen = isAVI || treatAsAPNG || (options === null || options === void 0 ? void 0 : options.scaleMode) === \"cover\";\n                // Para archivos AVI y APNG, respectar duración natural si no se especifica\n                const respectNativeDuration = (isAVI || treatAsAPNG) && !(options === null || options === void 0 ? void 0 : options.endTime);\n                const finalEndTime = respectNativeDuration ? undefined : endTime;\n                // Log para depurar\n                if (treatAsAPNG) {\n                    console.log(\"\\uD83D\\uDD37 A\\xf1adiendo APNG como VIDEO sincronizado desde \".concat(startTime, \"s con duraci\\xf3n \").concat(respectNativeDuration ? \"natural\" : finalEndTime + \"s\"));\n                    console.log(\"\\uD83D\\uDD37 Configuraciones especiales de APNG - useFullScreen: \".concat(useFullScreen, \", syncWithTimeline: \").concat((options === null || options === void 0 ? void 0 : options.syncWithTimeline) || true));\n                } else if (isAVI) {\n                    console.log(\"\\uD83C\\uDFAC A\\xf1adiendo AVI con duraci\\xf3n \".concat(respectNativeDuration ? \"natural\" : \"especificada: \" + finalEndTime, \"s\"));\n                }\n                // Manejar APNG usando un enfoque especial - intentar con un método alternativo si es posible\n                if (treatAsAPNG) {\n                    try {\n                        // Intentar crear un payload especial para APNG que funcione como animación\n                        console.log(\"Probando con una configuraci\\xf3n especial para APNG...\");\n                        // Configuración de opciones importante para archivos APNG\n                        const apngVideoPayload = {\n                            id: (0,_designcombo_timeline__WEBPACK_IMPORTED_MODULE_2__.generateId)(),\n                            display: {\n                                from: startTime * 1000,\n                                to: finalEndTime ? finalEndTime * 1000 : (startTime + 3) * 1000 // 3 segundos por defecto si no hay duración\n                            },\n                            // Probamos una nueva estrategia: tratarlo como imagen en lugar de video\n                            type: \"image\",\n                            details: {\n                                src: url,\n                                width: 1920,\n                                height: 1080,\n                                opacity: 100,\n                                scaleMode: \"cover\",\n                                left: 0.5,\n                                top: 0.5,\n                                originX: \"center\",\n                                originY: \"center\",\n                                // Propiedades para animar\n                                isAnimated: true\n                            }\n                        };\n                        console.log(\"Payload para APNG como imagen animada:\", JSON.stringify(apngVideoPayload, null, 2));\n                        // Usar ADD_IMAGE en lugar de ADD_VIDEO\n                        (0,_designcombo_events__WEBPACK_IMPORTED_MODULE_0__.dispatch)(_designcombo_state__WEBPACK_IMPORTED_MODULE_1__.ADD_IMAGE, {\n                            payload: apngVideoPayload,\n                            options: {\n                                scaleMode: \"cover\",\n                                position: {\n                                    x: 0.5,\n                                    y: 0.5\n                                }\n                            }\n                        });\n                        console.log(\"✅ APNG a\\xf1adido como imagen animada con \\xe9xito\");\n                        return;\n                    } catch (apngError) {\n                        console.error(\"❌ Error al a\\xf1adir APNG como imagen animada:\", apngError);\n                        console.error(\"Detalles:\", apngError.message);\n                        console.error(\"Traza:\", apngError.stack);\n                        console.log(\"\\uD83D\\uDD04 Continuando con el m\\xe9todo est\\xe1ndar como respaldo...\");\n                    // Continuar con el método estándar como respaldo\n                    }\n                }\n                // Crear payload para el video\n                const videoPayload = {\n                    id: (0,_designcombo_timeline__WEBPACK_IMPORTED_MODULE_2__.generateId)(),\n                    display: {\n                        from: startTime * 1000,\n                        to: finalEndTime ? finalEndTime * 1000 : undefined // Usar undefined si queremos respetar la duración natural\n                    },\n                    type: \"video\",\n                    details: {\n                        src: url,\n                        width: width,\n                        height: height,\n                        opacity: 100,\n                        // Para archivos APNG y AVI, configurar propiedades específicas para pantalla completa\n                        ...useFullScreen && {\n                            scaleMode: \"cover\",\n                            left: 0.5,\n                            top: 0.5,\n                            originX: \"center\",\n                            originY: \"center\"\n                        },\n                        // Propiedades especiales para APNG\n                        ...treatAsAPNG && {\n                            isAPNG: true,\n                            autoPlay: true,\n                            loop: false,\n                            syncWithTimeline: (options === null || options === void 0 ? void 0 : options.syncWithTimeline) || true\n                        }\n                    }\n                };\n                console.log(\"Payload de video est\\xe1ndar:\", JSON.stringify(videoPayload, null, 2));\n                // Configuraciones adicionales para el dispatch\n                const dispatchOptions = {\n                    resourceId: \"main\",\n                    scaleMode: useFullScreen ? \"cover\" : \"fit\",\n                    ...useFullScreen && {\n                        position: {\n                            x: 0.5,\n                            y: 0.5\n                        } // Centrar para videos a pantalla completa\n                    },\n                    respectNativeDuration: respectNativeDuration,\n                    // Propiedades específicas para sincronización de APNG\n                    ...treatAsAPNG && {\n                        isAPNG: true,\n                        syncWithTimeline: (options === null || options === void 0 ? void 0 : options.syncWithTimeline) || true,\n                        playbackBehavior: (options === null || options === void 0 ? void 0 : options.playbackBehavior) || \"sync\"\n                    }\n                };\n                console.log(\"Opciones de dispatch:\", JSON.stringify(dispatchOptions, null, 2));\n                // Agregar video al timeline\n                (0,_designcombo_events__WEBPACK_IMPORTED_MODULE_0__.dispatch)(_designcombo_state__WEBPACK_IMPORTED_MODULE_1__.ADD_VIDEO, {\n                    payload: videoPayload,\n                    options: dispatchOptions\n                });\n                // Mensaje de log adaptado al tipo de archivo\n                if (treatAsAPNG) {\n                    console.log(\"✅ Transici\\xf3n APNG a\\xf1adida como VIDEO SINCRONIZADO al timeline desde \".concat(startTime, \"s \").concat(finalEndTime ? \"hasta \".concat(finalEndTime, \"s\") : \"con duraci\\xf3n natural\", \". Dimensiones: \").concat(width, \"x\").concat(height));\n                } else {\n                    console.log(\"✅ Video \".concat(isAVI ? \"AVI\" : \"\", \" a\\xf1adido al timeline desde \").concat(startTime, \"s\").concat(finalEndTime ? \" hasta \".concat(finalEndTime, \"s\") : \" con duraci\\xf3n natural\", \". Dimensiones: \").concat(width, \"x\").concat(height));\n                }\n            } catch (error) {\n                console.error(\"❌ ERROR CR\\xcdTICO al a\\xf1adir video:\", error);\n                console.error(\"Detalles completos:\", error.message);\n                console.error(\"Traza:\", error.stack);\n                throw error; // Propagar el error para manejo superior\n            }\n        },\n        changeDuration: (elementId, duration)=>{\n            // Simulación de cambio de duración (la implementación real dependerá de la estructura del proyecto)\n            console.log(\"Cambiando duraci\\xf3n del elemento \".concat(elementId, \" a \").concat(duration, \"s\"));\n        // Aquí iría la lógica real para cambiar la duración de un elemento\n        },\n        changeTransition: (elementId, transition)=>{\n            // Simulación de cambio de transición (la implementación real dependerá de la estructura del proyecto)\n            console.log(\"Cambiando transici\\xf3n del elemento \".concat(elementId, \" a \").concat(transition));\n        // Aquí iría la lógica real para cambiar la transición de un elemento\n        },\n        addSubtitles: async (options)=>{\n            try {\n                console.log(\"A\\xf1adiendo subt\\xedtulos directamente sin depender del bot\\xf3n\");\n                // Función para parsear el tiempo de formato SRT a milisegundos\n                const parseTimeToMs = (timeString)=>{\n                    const [hours, minutes, secondsAndMs] = timeString.split(\":\");\n                    const [seconds, ms] = secondsAndMs.split(\",\");\n                    return parseInt(hours) * 3600000 + parseInt(minutes) * 60000 + parseInt(seconds) * 1000 + parseInt(ms);\n                };\n                // Función para parsear el archivo SRT\n                const parseSRT = (srtContent)=>{\n                    const segments = [];\n                    const blocks = srtContent.trim().split(\"\\n\\n\");\n                    blocks.forEach((block)=>{\n                        const lines = block.split(\"\\n\");\n                        if (lines.length >= 3) {\n                            const id = parseInt(lines[0]);\n                            const timeRange = lines[1].split(\" --> \");\n                            const startTime = parseTimeToMs(timeRange[0]);\n                            const endTime = parseTimeToMs(timeRange[1]);\n                            const text = lines.slice(2).join(\"\\n\"); // Unir todas las líneas de texto\n                            segments.push({\n                                id,\n                                startTime,\n                                endTime,\n                                text\n                            });\n                        }\n                    });\n                    return segments;\n                };\n                // Función para dividir un texto en grupos de aproximadamente 3 palabras\n                const splitTextIntoGroups = function(text) {\n                    let wordsPerGroup = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 3;\n                    const words = text.split(/\\s+/);\n                    const groups = [];\n                    for(let i = 0; i < words.length; i += wordsPerGroup){\n                        const group = words.slice(i, i + wordsPerGroup).join(\" \");\n                        groups.push(group);\n                    }\n                    return groups;\n                };\n                // Función para procesar un segmento y dividirlo en múltiples segmentos si es necesario\n                const processSegment = (segment)=>{\n                    const textGroups = splitTextIntoGroups(segment.text);\n                    // Si solo hay un grupo, devolver el segmento original\n                    if (textGroups.length <= 1) {\n                        return [\n                            segment\n                        ];\n                    }\n                    // Calcular la duración de cada grupo\n                    const totalDuration = segment.endTime - segment.startTime;\n                    const groupDuration = totalDuration / textGroups.length;\n                    // Crear un nuevo segmento para cada grupo\n                    return textGroups.map((groupText, index)=>{\n                        const startTime = segment.startTime + index * groupDuration;\n                        const endTime = startTime + groupDuration;\n                        return {\n                            id: segment.id * 1000 + index,\n                            startTime,\n                            endTime,\n                            text: groupText\n                        };\n                    });\n                };\n                // Usar el trackId proporcionado o buscar uno existente\n                let subtitlesTrackId = (options === null || options === void 0 ? void 0 : options.trackId) || \"\";\n                if (subtitlesTrackId) {\n                    console.log(\"Usando trackId proporcionado: \".concat(subtitlesTrackId));\n                } else {\n                    // Buscar si ya existe un track de subtítulos usando el método especializado\n                    subtitlesTrackId = await executor.getSubtitlesTrackId() || \"\";\n                    // Si se encontró un track existente\n                    if (subtitlesTrackId) {\n                        console.log(\"Usando track de subt\\xedtulos existente: \".concat(subtitlesTrackId));\n                    } else {\n                        // Si no se encontró un track existente, crear uno nuevo\n                        subtitlesTrackId = \"subtitles-track-\" + (0,_designcombo_timeline__WEBPACK_IMPORTED_MODULE_2__.generateId)();\n                        console.log(\"No se encontraron tracks de subt\\xedtulos, creando uno nuevo: \".concat(subtitlesTrackId));\n                    }\n                }\n                // Función para crear el payload de texto para subtítulos\n                const createSubtitlePayload = (text, startTime, endTime)=>({\n                        id: (0,_designcombo_timeline__WEBPACK_IMPORTED_MODULE_2__.generateId)(),\n                        trackId: subtitlesTrackId,\n                        display: {\n                            from: startTime,\n                            to: endTime\n                        },\n                        type: \"text\",\n                        details: {\n                            text: text.toUpperCase(),\n                            fontSize: 80,\n                            width: 900,\n                            fontUrl: \"/fonts/mrbeast.ttf\",\n                            fontFamily: \"MrBeast\",\n                            color: \"#FFFF00\",\n                            wordWrap: \"break-word\",\n                            textAlign: \"center\",\n                            borderWidth: 20,\n                            borderColor: \"#000000\",\n                            boxShadow: {\n                                color: \"#000000\",\n                                x: 3,\n                                y: 3,\n                                blur: 0\n                            },\n                            backgroundColor: \"transparent\",\n                            padding: 10,\n                            borderRadius: 0\n                        }\n                    });\n                // Cargar el archivo SRT\n                console.log(\"Cargando archivo SRT...\");\n                const response = await fetch(\"/transcriptions/transcription1.srt\");\n                if (!response.ok) {\n                    throw new Error(\"Error al cargar el archivo SRT: \".concat(response.status));\n                }\n                const srtContent = await response.text();\n                console.log(\"Archivo SRT cargado correctamente\");\n                // Parsear el archivo SRT\n                let segments = parseSRT(srtContent);\n                console.log(\"Se encontraron \".concat(segments.length, \" segmentos de subt\\xedtulos\"));\n                // Siempre usar el modo agrupado (dividir en grupos de 3 palabras)\n                segments = segments.flatMap(processSegment);\n                console.log(\"Despu\\xe9s de procesar, hay \".concat(segments.length, \" segmentos de subt\\xedtulos\"));\n                // Filtrar por tiempo si es necesario\n                if ((options === null || options === void 0 ? void 0 : options.startTime) !== undefined || (options === null || options === void 0 ? void 0 : options.endTime) !== undefined) {\n                    const originalLength = segments.length;\n                    segments = segments.filter((segment)=>{\n                        const passesStartFilter = options.startTime === undefined || segment.startTime >= options.startTime * 1000;\n                        const passesEndFilter = options.endTime === undefined || segment.endTime <= options.endTime * 1000;\n                        return passesStartFilter && passesEndFilter;\n                    });\n                    console.log(\"Filtrado por tiempo: de \".concat(originalLength, \" a \").concat(segments.length, \" segmentos\"));\n                }\n                // Añadir los subtítulos con un retraso entre cada uno\n                console.log(\"A\\xf1adiendo \".concat(segments.length, \" segmentos de subt\\xedtulos al timeline usando el track \").concat(subtitlesTrackId, \"...\"));\n                segments.forEach((segment, index)=>{\n                    setTimeout(()=>{\n                        (0,_designcombo_events__WEBPACK_IMPORTED_MODULE_0__.dispatch)(_designcombo_state__WEBPACK_IMPORTED_MODULE_1__.ADD_TEXT, {\n                            payload: createSubtitlePayload(segment.text, segment.startTime, segment.endTime),\n                            options: {\n                                trackId: subtitlesTrackId // Asegurar que se especifica también en las opciones\n                            }\n                        });\n                        if ((index + 1) % 10 === 0 || index === segments.length - 1) {\n                            console.log(\"Progreso: \".concat(index + 1, \"/\").concat(segments.length, \" subt\\xedtulos a\\xf1adidos al track \").concat(subtitlesTrackId));\n                        }\n                    }, index * 50); // Reducir el retraso a 50ms para que sea más rápido\n                });\n                return true;\n            } catch (error) {\n                console.error(\"Error al a\\xf1adir subt\\xedtulos:\", error);\n                return false;\n            }\n        },\n        getActiveElements: async ()=>{\n            try {\n                // Obtener el estado actual\n                const state = stateManager.getState();\n                // Verificar si hay IDs activos\n                if (!state.activeIds || state.activeIds.length === 0) {\n                    console.log(\"No hay elementos activos seleccionados\");\n                    return [];\n                }\n                // Verificar si hay elementos en el trackItemsMap\n                if (!state.trackItemsMap) {\n                    console.log(\"No hay trackItemsMap disponible\");\n                    return [];\n                }\n                // Obtener información de los elementos activos\n                const activeElements = state.activeIds.filter((id)=>state.trackItemsMap[id]).map((id)=>{\n                    var _item_display, _item_display1;\n                    const item = state.trackItemsMap[id];\n                    return {\n                        id,\n                        trackId: item.trackId,\n                        type: item.type,\n                        from: (_item_display = item.display) === null || _item_display === void 0 ? void 0 : _item_display.from,\n                        to: (_item_display1 = item.display) === null || _item_display1 === void 0 ? void 0 : _item_display1.to,\n                        duration: item.display ? item.display.to - item.display.from : 0,\n                        details: item.details\n                    };\n                });\n                console.log(\"Se encontraron \".concat(activeElements.length, \" elementos activos\"));\n                return activeElements;\n            } catch (error) {\n                console.error(\"Error al obtener elementos activos:\", error);\n                return [];\n            }\n        },\n        getAllTimelineElements: async ()=>{\n            try {\n                // Obtener el estado actual\n                const state = stateManager.getState();\n                // Verificar si hay elementos en el trackItemsMap\n                if (!state.trackItemsMap || Object.keys(state.trackItemsMap).length === 0) {\n                    console.log(\"No hay elementos en el trackItemsMap\");\n                    // Buscar elementos en otras propiedades del estado\n                    for (const key of Object.keys(state)){\n                        if (typeof state[key] === \"object\" && state[key] !== null) {\n                            const objValue = state[key];\n                            console.log(\"Explorando propiedad alternativa: \".concat(key));\n                            // Verificar si parece ser un mapa de elementos\n                            if (Object.keys(objValue).length > 0) {\n                                const sample = objValue[Object.keys(objValue)[0]];\n                                if (sample && sample.display && sample.type) {\n                                    console.log(\"Encontrada posible fuente alternativa de elementos en propiedad \".concat(key));\n                                    // Procesar elementos de esta propiedad alternativa\n                                    return Object.entries(objValue).filter((param)=>{\n                                        let [_, item] = param;\n                                        return item && item.display;\n                                    }).map((param)=>{\n                                        let [id, item] = param;\n                                        var _item_display, _item_display1;\n                                        return {\n                                            id,\n                                            trackId: item.trackId,\n                                            type: item.type,\n                                            from: (_item_display = item.display) === null || _item_display === void 0 ? void 0 : _item_display.from,\n                                            to: (_item_display1 = item.display) === null || _item_display1 === void 0 ? void 0 : _item_display1.to,\n                                            duration: item.display ? item.display.to - item.display.from : 0,\n                                            details: item.details\n                                        };\n                                    });\n                                }\n                            }\n                        }\n                    }\n                    return [];\n                }\n                // Obtener todos los elementos\n                const allElements = Object.entries(state.trackItemsMap).filter((param)=>{\n                    let [_, item] = param;\n                    return item && item.display;\n                }).map((param)=>{\n                    let [id, item] = param;\n                    var _item_display, _item_display1;\n                    return {\n                        id,\n                        trackId: item.trackId,\n                        type: item.type,\n                        from: (_item_display = item.display) === null || _item_display === void 0 ? void 0 : _item_display.from,\n                        to: (_item_display1 = item.display) === null || _item_display1 === void 0 ? void 0 : _item_display1.to,\n                        duration: item.display ? item.display.to - item.display.from : 0,\n                        details: item.details\n                    };\n                }).sort((a, b)=>(a.from || 0) - (b.from || 0));\n                console.log(\"Se encontraron \".concat(allElements.length, \" elementos en el timeline\"));\n                return allElements;\n            } catch (error) {\n                console.error(\"Error al obtener todos los elementos del timeline:\", error);\n                return [];\n            }\n        },\n        removeSegments: async (segments)=>{\n            try {\n                console.log(\"Iniciando eliminaci\\xf3n de segmentos m\\xfaltiples\");\n                // Obtener el estado actual\n                const state = stateManager.getState();\n                // Validar que haya elementos en la timeline\n                if (!state.activeIds || state.activeIds.length === 0) {\n                    console.error(\"No hay elementos seleccionados en la timeline\");\n                    // Buscar el primer elemento disponible en la timeline\n                    const trackItemsMap = state.trackItemsMap || {};\n                    const trackItems = Object.keys(trackItemsMap);\n                    if (trackItems.length === 0) {\n                        console.error(\"No hay elementos en la timeline para eliminar segmentos\");\n                        throw new Error(\"No hay elementos en la timeline\");\n                    }\n                    // Seleccionar el primer elemento disponible\n                    const firstItemId = trackItems[0];\n                    console.log(\"Seleccionando autom\\xe1ticamente el elemento con ID: \".concat(firstItemId));\n                    (0,_designcombo_events__WEBPACK_IMPORTED_MODULE_0__.dispatch)(_designcombo_state__WEBPACK_IMPORTED_MODULE_1__.LAYER_SELECT, {\n                        payload: {\n                            ids: [\n                                firstItemId\n                            ]\n                        }\n                    });\n                    // Esperar a que se aplique la selección\n                    await new Promise((resolve)=>setTimeout(resolve, 300));\n                }\n                // Almacenamos información del elemento seleccionado\n                const currentState = stateManager.getState();\n                if (!currentState.activeIds || currentState.activeIds.length === 0) {\n                    throw new Error(\"No se pudo seleccionar ning\\xfan elemento en la timeline\");\n                }\n                const originalItemId = currentState.activeIds[0];\n                const originalItem = currentState.trackItemsMap[originalItemId];\n                const trackType = originalItem.type;\n                const trackId = originalItem.trackId;\n                console.log(\"Elemento seleccionado: ID=\".concat(originalItemId, \", tipo=\").concat(trackType, \", trackId=\").concat(trackId));\n                // Procesar cada segmento en orden (de final a principio para evitar afectar posiciones)\n                for(let i = segments.length - 1; i >= 0; i--){\n                    const segment = segments[i];\n                    console.log(\"Procesando segmento \".concat(i + 1, \"/\").concat(segments.length, \": \").concat(segment.startTime, \"s - \").concat(segment.endTime, \"s\"));\n                    try {\n                        // PASO 1: Hacer un corte en el tiempo final\n                        const endMs = segment.endTime * 1000;\n                        (0,_designcombo_events__WEBPACK_IMPORTED_MODULE_0__.dispatch)(_designcombo_state__WEBPACK_IMPORTED_MODULE_1__.ACTIVE_SPLIT, {\n                            payload: {},\n                            options: {\n                                time: endMs\n                            }\n                        });\n                        console.log(\"Paso 1: Corte aplicado en tiempo final \".concat(segment.endTime, \"s\"));\n                        // Esperar a que se procese el primer corte\n                        await new Promise((resolve)=>setTimeout(resolve, 500));\n                        // Obtenemos el estado después del primer corte\n                        const stateAfterFirstCut = stateManager.getState();\n                        const elementsAfterFirstCut = Object.entries(stateAfterFirstCut.trackItemsMap).filter((param)=>{\n                            let [_, item] = param;\n                            return item.type === trackType && item.trackId === trackId && item.display && !isNaN(item.display.from) && !isNaN(item.display.to);\n                        }).map((param)=>{\n                            let [id, item] = param;\n                            return {\n                                id,\n                                from: item.display.from,\n                                to: item.display.to,\n                                duración: item.display.to - item.display.from\n                            };\n                        }).sort((a, b)=>a.from - b.from);\n                        console.log(\"Elementos despu\\xe9s del primer corte:\", elementsAfterFirstCut);\n                        // PASO 2: Identificar el elemento izquierdo que contiene el tiempo inicial\n                        const startMs = segment.startTime * 1000;\n                        const leftElement = elementsAfterFirstCut.find((elem)=>elem.from <= startMs && elem.to >= startMs);\n                        if (!leftElement) {\n                            console.error(\"No se pudo identificar el elemento izquierdo para el segmento \".concat(i + 1));\n                            continue;\n                        }\n                        console.log(\"Paso 2: Elemento izquierdo identificado (ID: \".concat(leftElement.id, \")\"));\n                        // PASO 3: Seleccionar el elemento izquierdo y hacer corte en tiempo inicial\n                        (0,_designcombo_events__WEBPACK_IMPORTED_MODULE_0__.dispatch)(_designcombo_state__WEBPACK_IMPORTED_MODULE_1__.LAYER_SELECT, {\n                            payload: {\n                                ids: [\n                                    leftElement.id\n                                ]\n                            }\n                        });\n                        // Esperar a que se aplique la selección\n                        await new Promise((resolve)=>setTimeout(resolve, 300));\n                        // Aplicar el corte en el tiempo inicial\n                        (0,_designcombo_events__WEBPACK_IMPORTED_MODULE_0__.dispatch)(_designcombo_state__WEBPACK_IMPORTED_MODULE_1__.ACTIVE_SPLIT, {\n                            payload: {},\n                            options: {\n                                time: startMs\n                            }\n                        });\n                        console.log(\"Paso 3: Segundo corte aplicado en tiempo inicial \".concat(segment.startTime, \"s\"));\n                        // Esperar a que se procese el segundo corte\n                        await new Promise((resolve)=>setTimeout(resolve, 500));\n                        // Obtenemos el estado después del segundo corte\n                        const stateAfterSecondCut = stateManager.getState();\n                        const elementsAfterSecondCut = Object.entries(stateAfterSecondCut.trackItemsMap).filter((param)=>{\n                            let [_, item] = param;\n                            return item.type === trackType && item.trackId === trackId && item.display && !isNaN(item.display.from) && !isNaN(item.display.to);\n                        }).map((param)=>{\n                            let [id, item] = param;\n                            return {\n                                id,\n                                from: item.display.from,\n                                to: item.display.to,\n                                duración: item.display.to - item.display.from\n                            };\n                        }).sort((a, b)=>a.from - b.from);\n                        console.log(\"Elementos despu\\xe9s del segundo corte:\", elementsAfterSecondCut);\n                        // PASO 4: Identificar el elemento del medio usando criterios más precisos\n                        const middleElements = elementsAfterSecondCut.filter((elem)=>Math.abs(elem.from - startMs) < 50 && Math.abs(elem.to - endMs) < 50);\n                        console.log(\"Elementos que coinciden con los criterios del medio:\", middleElements);\n                        if (middleElements.length === 0) {\n                            console.error(\"No se pudo identificar el elemento del medio para el segmento \".concat(i + 1));\n                            continue;\n                        }\n                        // Si hay más de un elemento que coincide, tomamos el primero\n                        const middleElement = middleElements[0];\n                        console.log(\"Paso 4: Elemento del medio identificado (ID: \".concat(middleElement.id, \")\"));\n                        // PASO 5: Seleccionar y eliminar el elemento del medio\n                        (0,_designcombo_events__WEBPACK_IMPORTED_MODULE_0__.dispatch)(_designcombo_state__WEBPACK_IMPORTED_MODULE_1__.LAYER_SELECT, {\n                            payload: {\n                                ids: [\n                                    middleElement.id\n                                ]\n                            }\n                        });\n                        // Esperar a que se aplique la selección\n                        await new Promise((resolve)=>setTimeout(resolve, 300));\n                        // Verificar que el elemento está seleccionado antes de eliminarlo\n                        const currentState = stateManager.getState();\n                        if (currentState.activeIds && currentState.activeIds.includes(middleElement.id)) {\n                            console.log(\"Elemento del medio correctamente seleccionado, procediendo con eliminaci\\xf3n\");\n                            (0,_designcombo_events__WEBPACK_IMPORTED_MODULE_0__.dispatch)(_designcombo_state__WEBPACK_IMPORTED_MODULE_1__.LAYER_DELETE);\n                            console.log(\"Elemento eliminado correctamente: \".concat(middleElement.id));\n                        } else {\n                            console.log(\"No se pudo seleccionar normalmente, intentando m\\xe9todo alternativo\");\n                            // Enfoque alternativo: Usar el EDIT_OBJECT para \"ocultar\" el segmento\n                            (0,_designcombo_events__WEBPACK_IMPORTED_MODULE_0__.dispatch)(_designcombo_state__WEBPACK_IMPORTED_MODULE_1__.EDIT_OBJECT, {\n                                payload: {\n                                    [middleElement.id]: {\n                                        display: {\n                                            from: -99999,\n                                            to: -99990\n                                        },\n                                        visible: false // Adicionalmente marcarlo como no visible\n                                    }\n                                }\n                            });\n                            console.log(\"Aplicado m\\xe9todo alternativo para ocultar el segmento\");\n                        }\n                        // Esperar a que se procese la eliminación\n                        await new Promise((resolve)=>setTimeout(resolve, 500));\n                    } catch (error) {\n                        console.error(\"Error al procesar el segmento \".concat(i + 1, \":\"), error);\n                    }\n                    // Pausa entre segmentos\n                    await new Promise((resolve)=>setTimeout(resolve, 500));\n                }\n                // Actualizar la escala para refrescar la vista\n                const { scale } = stateManager.getState();\n                if (scale) {\n                    console.log(\"Actualizando escala para refrescar la vista\");\n                    // Guardar el valor actual de scale.unit\n                    const originalUnit = scale.unit;\n                    // Incrementar el valor\n                    scale.unit += 1;\n                    console.log(\"Scale cambiada: \".concat(originalUnit, \" -> \").concat(scale.unit));\n                    // Asegurar que el cambio sea notado por el sistema\n                    (0,_designcombo_events__WEBPACK_IMPORTED_MODULE_0__.dispatch)(_designcombo_state__WEBPACK_IMPORTED_MODULE_1__.TIMELINE_SCALE_CHANGED, {\n                        payload: {\n                            scale: {\n                                ...scale,\n                                unit: scale.unit // Explícitamente establecer el nuevo valor\n                            }\n                        }\n                    });\n                    // Forzar una actualización adicional volviendo al valor original después de un momento\n                    setTimeout(()=>{\n                        const currentState = stateManager.getState();\n                        if (currentState.scale) {\n                            (0,_designcombo_events__WEBPACK_IMPORTED_MODULE_0__.dispatch)(_designcombo_state__WEBPACK_IMPORTED_MODULE_1__.TIMELINE_SCALE_CHANGED, {\n                                payload: {\n                                    scale: {\n                                        ...currentState.scale,\n                                        unit: originalUnit // Volver al valor original\n                                    }\n                                }\n                            });\n                            console.log(\"Restaurado scale a valor original: \".concat(originalUnit));\n                        }\n                    }, 300);\n                }\n                console.log(\"Eliminaci\\xf3n de segmentos completada\");\n                return true;\n            } catch (error) {\n                console.error(\"Error al eliminar segmentos:\", error);\n                return false;\n            }\n        },\n        compactTimeline: async ()=>{\n            try {\n                console.log(\"=== INICIANDO COMPACTACI\\xd3N DE L\\xcdNEA DE TIEMPO DESDE IA ===\");\n                // Obtener el estado actual\n                const estado = stateManager.getState();\n                console.log(\"Estado para compactaci\\xf3n:\", Object.keys(estado));\n                // Añadir un tiempo de espera inicial para asegurar que el estado está actualizado\n                console.log(\"Esperando 1 segundo para asegurar consistencia del estado...\");\n                await new Promise((resolve)=>setTimeout(resolve, 1000));\n                // Verificación adicional para asegurarnos que los cambios en la timeline ya se aplicaron\n                console.log(\"Verificando que los elementos en la timeline reflejen los cambios m\\xe1s recientes...\");\n                // Pequeña pausa adicional para asegurar consistencia del estado\n                await new Promise((resolve)=>setTimeout(resolve, 500));\n                // Buscar los elementos del timeline - usando la referencia al método dentro del mismo objeto\n                const todosElementos = await executor.getAllTimelineElements();\n                console.log(\"Encontrados \".concat(todosElementos.length, \" elementos en la timeline\"));\n                // Logging de elementos para diagnóstico\n                todosElementos.forEach((elem, index)=>{\n                    console.log(\"Elemento \".concat(index + 1, \": ID=\").concat(elem.id, \", Tipo=\").concat(elem.type, \", Track=\").concat(elem.trackId, \", Tiempo=\").concat(elem.from, \"ms-\").concat(elem.to, \"ms (duraci\\xf3n=\").concat(elem.to - elem.from, \"ms)\"));\n                });\n                // Si no hay elementos, no podemos compactar\n                if (todosElementos.length === 0) {\n                    console.log(\"No hay elementos en el timeline para compactar\");\n                    return false;\n                }\n                // Agrupar elementos por track para análisis\n                const elementosPorTrack = {};\n                todosElementos.forEach((elem)=>{\n                    if (elem.trackId) {\n                        if (!elementosPorTrack[elem.trackId]) {\n                            elementosPorTrack[elem.trackId] = [];\n                        }\n                        elementosPorTrack[elem.trackId].push(elem);\n                    }\n                });\n                // Ordenar elementos en cada track por tiempo\n                Object.keys(elementosPorTrack).forEach((trackId)=>{\n                    elementosPorTrack[trackId].sort((a, b)=>a.from - b.from);\n                });\n                console.log(\"Elementos agrupados por track:\", Object.keys(elementosPorTrack).length);\n                // Logging de tracks para diagnóstico\n                Object.keys(elementosPorTrack).forEach((trackId)=>{\n                    console.log(\"Track \".concat(trackId, \": \").concat(elementosPorTrack[trackId].length, \" elementos\"));\n                    // Mostrar los elementos en este track ordenados\n                    elementosPorTrack[trackId].forEach((elem, idx)=>{\n                        console.log(\"  \".concat(idx + 1, \". ID=\").concat(elem.id.substring(0, 8), \"... Tiempo=\").concat(elem.from, \"ms-\").concat(elem.to, \"ms (duraci\\xf3n: \").concat(elem.to - elem.from, \"ms)\"));\n                    });\n                });\n                // Buscar espacios vacíos en cada track\n                const espaciosVacios = [];\n                Object.keys(elementosPorTrack).forEach((trackId)=>{\n                    const elementos = elementosPorTrack[trackId];\n                    // Si hay al menos 2 elementos, podemos buscar espacios\n                    if (elementos.length >= 2) {\n                        for(let i = 0; i < elementos.length - 1; i++){\n                            const elementoActual = elementos[i];\n                            const elementoSiguiente = elementos[i + 1];\n                            // Verificar si hay un espacio entre el fin del elemento actual y el inicio del siguiente\n                            const espacio = elementoSiguiente.from - elementoActual.to;\n                            // Si el espacio es significativo (más de 100ms)\n                            if (espacio > 100) {\n                                espaciosVacios.push({\n                                    trackId,\n                                    start: elementoActual.to,\n                                    end: elementoSiguiente.from,\n                                    size: espacio,\n                                    elementoAntes: elementoActual.id,\n                                    elementoDespues: elementoSiguiente.id\n                                });\n                                console.log(\"Encontrado espacio de \".concat(espacio, \"ms (\").concat(espacio / 1000, \"s) en track \").concat(trackId, \" entre elementos \").concat(elementoActual.id.substring(0, 8), \"... y \").concat(elementoSiguiente.id.substring(0, 8), \"...\"));\n                            }\n                        }\n                    }\n                });\n                console.log(\"Se encontraron \".concat(espaciosVacios.length, \" espacios vac\\xedos\"));\n                // Si no hay espacios, no necesitamos compactar\n                if (espaciosVacios.length === 0) {\n                    console.log(\"No hay espacios significativos para compactar\");\n                    return true; // Devolvemos true porque técnicamente está compactado\n                }\n                // Ordenar espacios por posición (de izquierda a derecha)\n                espaciosVacios.sort((a, b)=>a.start - b.start);\n                // Calcular el espacio total a compactar\n                let espacioTotal = 0;\n                espaciosVacios.forEach((espacio)=>{\n                    espacioTotal += espacio.size;\n                });\n                console.log(\"Espacio total a compactar: \".concat(espacioTotal, \"ms (\").concat(espacioTotal / 1000, \"s)\"));\n                console.log(\"Preparando actualizaciones para \".concat(todosElementos.length, \" elementos...\"));\n                // Preparar actualizaciones para cada elemento\n                const actualizaciones = {};\n                let elementosAMover = 0;\n                // Para cada elemento, calculamos el desplazamiento basado en los espacios anteriores\n                todosElementos.forEach((elemento)=>{\n                    let desplazamiento = 0;\n                    // Calcular cuánto debe moverse basado en los espacios vacíos anteriores\n                    for (const espacio of espaciosVacios){\n                        // Si el elemento está después del espacio vacío, debe moverse\n                        if (elemento.from > espacio.end) {\n                            desplazamiento += espacio.size;\n                        }\n                    }\n                    // Si hay desplazamiento, añadir a las actualizaciones\n                    if (desplazamiento > 0) {\n                        const nuevoFrom = elemento.from - desplazamiento;\n                        const nuevoTo = elemento.to - desplazamiento;\n                        console.log(\"Elemento \".concat(elemento.id.substring(0, 8), \"... se mover\\xe1: \").concat(elemento.from, \"ms -> \").concat(nuevoFrom, \"ms (desplazamiento: \").concat(desplazamiento, \"ms)\"));\n                        actualizaciones[elemento.id] = {\n                            display: {\n                                from: nuevoFrom,\n                                to: nuevoTo\n                            }\n                        };\n                        elementosAMover++;\n                    }\n                });\n                console.log(\"Elementos a mover: \".concat(elementosAMover, \" de \").concat(todosElementos.length, \" total\"));\n                // Aplicar las actualizaciones\n                if (elementosAMover > 0) {\n                    console.log(\"Aplicando actualizaciones para compactar timeline...\");\n                    try {\n                        (0,_designcombo_events__WEBPACK_IMPORTED_MODULE_0__.dispatch)(_designcombo_state__WEBPACK_IMPORTED_MODULE_1__.EDIT_OBJECT, {\n                            payload: actualizaciones\n                        });\n                        console.log(\"Actualizaciones aplicadas con \\xe9xito\");\n                    } catch (error) {\n                        console.error(\"Error al aplicar actualizaciones:\", error);\n                        return false;\n                    }\n                    // Refrescar la vista\n                    setTimeout(()=>{\n                        try {\n                            const { scale } = stateManager.getState();\n                            if (scale) {\n                                // Hacer un pequeño cambio en la escala para forzar la actualización\n                                const updatedScale = {\n                                    ...scale\n                                };\n                                if (typeof updatedScale.unit === \"number\") {\n                                    updatedScale.unit = (updatedScale.unit || 0) + 1;\n                                    (0,_designcombo_events__WEBPACK_IMPORTED_MODULE_0__.dispatch)(_designcombo_state__WEBPACK_IMPORTED_MODULE_1__.TIMELINE_SCALE_CHANGED, {\n                                        payload: {\n                                            scale: updatedScale\n                                        }\n                                    });\n                                    // Volver a la escala original\n                                    setTimeout(()=>{\n                                        const currentScale = {\n                                            ...stateManager.getState().scale\n                                        };\n                                        currentScale.unit = (currentScale.unit || 1) - 1;\n                                        (0,_designcombo_events__WEBPACK_IMPORTED_MODULE_0__.dispatch)(_designcombo_state__WEBPACK_IMPORTED_MODULE_1__.TIMELINE_SCALE_CHANGED, {\n                                            payload: {\n                                                scale: currentScale\n                                            }\n                                        });\n                                    }, 300);\n                                }\n                            }\n                        } catch (error) {\n                            console.error(\"Error al refrescar la vista:\", error);\n                        }\n                    }, 500);\n                    console.log(\"Compactaci\\xf3n completada con \\xe9xito\");\n                    return true;\n                } else {\n                    console.log(\"No hay elementos que necesiten moverse\");\n                    return true;\n                }\n            } catch (error) {\n                console.error(\"Error al compactar la l\\xednea de tiempo:\", error);\n                return false;\n            }\n        },\n        smartTrim: async ()=>{\n            try {\n                console.log(\"=== INICIANDO PROCESO DE RECORTE INTELIGENTE DESDE IA ===\");\n                // 1. Realizar la llamada al API para analizar la transcripción\n                console.log(\"Solicitando an\\xe1lisis de transcripci\\xf3n...\");\n                const response = await fetch(\"/api/smart-trim\");\n                if (!response.ok) {\n                    throw new Error(\"Error al analizar la transcripci\\xf3n: \".concat(response.status));\n                }\n                const data = await response.json();\n                console.log(\"An\\xe1lisis de transcripci\\xf3n completado:\", data);\n                if (!data.removeSegments || !Array.isArray(data.removeSegments) || data.removeSegments.length === 0) {\n                    console.log(\"No se encontraron segmentos para eliminar\");\n                    return false;\n                }\n                // 2. Convertir los segmentos al formato que espera removeSegments\n                const segments = data.removeSegments.map((segment)=>({\n                        startTime: segment.startTime,\n                        endTime: segment.endTime // Ya está en segundos\n                    }));\n                console.log(\"Se eliminar\\xe1n \".concat(segments.length, \" segmentos:\"), segments.map((s)=>\"\".concat(s.startTime, \"s-\").concat(s.endTime, \"s\")).join(\", \"));\n                // Almacenar información del estado previo para identificar tracks y elementos\n                console.log(\"Obteniendo informaci\\xf3n del estado antes de eliminar segmentos...\");\n                const estadoPrevio = stateManager.getState();\n                const elementosPrevios = await executor.getAllTimelineElements();\n                // Determinar el trackId principal basado en los elementos\n                const contadorTracks = {};\n                elementosPrevios.forEach((elem)=>{\n                    if (elem.trackId) {\n                        contadorTracks[elem.trackId] = (contadorTracks[elem.trackId] || 0) + 1;\n                    }\n                });\n                // Encontrar el track con más elementos\n                let trackIdPrincipal = \"\";\n                if (Object.keys(contadorTracks).length > 0) {\n                    const tracksPorUso = Object.entries(contadorTracks).sort((a, b)=>b[1] - a[1]);\n                    if (tracksPorUso.length > 0) {\n                        trackIdPrincipal = tracksPorUso[0][0];\n                        console.log(\"Usando trackId principal: \".concat(trackIdPrincipal));\n                    }\n                }\n                // 3. Eliminar los segmentos\n                console.log(\"Ejecutando eliminaci\\xf3n de segmentos...\");\n                const result = await executor.removeSegments(segments);\n                if (!result) {\n                    console.log(\"Error al eliminar los segmentos\");\n                    return false;\n                }\n                console.log(\"Segmentos eliminados correctamente\");\n                // 4. Crear registro de los segmentos eliminados para compactación\n                const segmentosEliminados = segments.map((segment)=>({\n                        start: segment.startTime * 1000,\n                        end: segment.endTime * 1000,\n                        trackId: trackIdPrincipal,\n                        size: (segment.endTime - segment.startTime) * 1000\n                    }));\n                console.log(\"Segmentos registrados para compactaci\\xf3n:\", segmentosEliminados);\n                // 5. Esperar un momento para que se completen las actualizaciones del DOM y el estado\n                console.log(\"Esperando 5 segundos para asegurar que los cambios en la timeline est\\xe9n completos antes de compactar...\");\n                await new Promise((resolve)=>setTimeout(resolve, 5000));\n                // 6. Compactar el timeline usando el enfoque de segmentos registrados\n                console.log(\"Compactando timeline basado en segmentos eliminados...\");\n                // Obtener elementos actuales después de la eliminación\n                const elementosActuales = await executor.getAllTimelineElements();\n                console.log(\"Se encontraron \".concat(elementosActuales.length, \" elementos en la timeline despu\\xe9s de eliminar segmentos\"));\n                // Calcular el espacio total a compactar\n                let espacioTotal = 0;\n                segmentosEliminados.forEach((segmento)=>{\n                    espacioTotal += segmento.size;\n                });\n                console.log(\"Espacio total a compactar: \".concat(espacioTotal, \"ms (\").concat(espacioTotal / 1000, \"s)\"));\n                // Preparar actualizaciones para cada elemento\n                const actualizaciones = {};\n                let elementosAMover = 0;\n                // Ordenar segmentos por posición de inicio\n                const segmentosOrdenados = [\n                    ...segmentosEliminados\n                ].sort((a, b)=>a.start - b.start);\n                // Para cada elemento, calcular el desplazamiento basado en los segmentos eliminados\n                elementosActuales.forEach((elemento)=>{\n                    let desplazamiento = 0;\n                    // Calcular cuánto debe moverse basado en los segmentos eliminados anteriores\n                    for (const segmento of segmentosOrdenados){\n                        if (elemento.from > segmento.start) {\n                            desplazamiento += segmento.size;\n                        }\n                    }\n                    // Si hay desplazamiento, añadir a las actualizaciones\n                    if (desplazamiento > 0) {\n                        const nuevoFrom = elemento.from - desplazamiento;\n                        const nuevoTo = elemento.to - desplazamiento;\n                        console.log(\"Elemento \".concat(elemento.id.substring(0, 8), \"... se mover\\xe1: \").concat(elemento.from, \"ms -> \").concat(nuevoFrom, \"ms (desplazamiento: \").concat(desplazamiento, \"ms)\"));\n                        actualizaciones[elemento.id] = {\n                            display: {\n                                from: nuevoFrom,\n                                to: nuevoTo\n                            }\n                        };\n                        elementosAMover++;\n                    }\n                });\n                console.log(\"Elementos a mover: \".concat(elementosAMover, \" de \").concat(elementosActuales.length, \" total\"));\n                // Aplicar las actualizaciones\n                if (elementosAMover > 0) {\n                    console.log(\"Aplicando actualizaciones para compactar timeline...\");\n                    try {\n                        (0,_designcombo_events__WEBPACK_IMPORTED_MODULE_0__.dispatch)(_designcombo_state__WEBPACK_IMPORTED_MODULE_1__.EDIT_OBJECT, {\n                            payload: actualizaciones\n                        });\n                        console.log(\"Actualizaciones aplicadas con \\xe9xito\");\n                        // Refrescar la vista\n                        setTimeout(()=>{\n                            try {\n                                const { scale } = stateManager.getState();\n                                if (scale) {\n                                    const updatedScale = {\n                                        ...scale\n                                    };\n                                    if (typeof updatedScale.unit === \"number\") {\n                                        updatedScale.unit = (updatedScale.unit || 0) + 1;\n                                        (0,_designcombo_events__WEBPACK_IMPORTED_MODULE_0__.dispatch)(_designcombo_state__WEBPACK_IMPORTED_MODULE_1__.TIMELINE_SCALE_CHANGED, {\n                                            payload: {\n                                                scale: updatedScale\n                                            }\n                                        });\n                                        // Volver a la escala original\n                                        setTimeout(()=>{\n                                            const currentScale = {\n                                                ...stateManager.getState().scale\n                                            };\n                                            currentScale.unit = (currentScale.unit || 1) - 1;\n                                            (0,_designcombo_events__WEBPACK_IMPORTED_MODULE_0__.dispatch)(_designcombo_state__WEBPACK_IMPORTED_MODULE_1__.TIMELINE_SCALE_CHANGED, {\n                                                payload: {\n                                                    scale: currentScale\n                                                }\n                                            });\n                                        }, 300);\n                                    }\n                                }\n                            } catch (error) {\n                                console.error(\"Error al refrescar la vista:\", error);\n                            }\n                        }, 500);\n                    } catch (error) {\n                        console.error(\"Error al aplicar actualizaciones:\", error);\n                        return false;\n                    }\n                } else {\n                    console.log(\"No se encontraron elementos que necesiten moverse\");\n                }\n                console.log(\"Timeline compactado correctamente\");\n                return true;\n            } catch (error) {\n                console.error(\"Error al realizar el recorte inteligente:\", error);\n                return false;\n            }\n        },\n        addMusic: (musicPath, options)=>{\n            try {\n                // Valores predeterminados\n                const startTime = (options === null || options === void 0 ? void 0 : options.startTime) !== undefined ? options.startTime : 0;\n                const endTime = (options === null || options === void 0 ? void 0 : options.endTime) !== undefined ? options.endTime : startTime + 30; // Duración predeterminada más larga para música\n                const volume = (options === null || options === void 0 ? void 0 : options.volume) !== undefined ? options.volume : 80; // Volumen predeterminado al 80%\n                const respectNativeDuration = (options === null || options === void 0 ? void 0 : options.respectNativeDuration) !== undefined ? options.respectNativeDuration : true; // Por defecto, respetar duración nativa\n                console.log(\"A\\xf1adiendo m\\xfasica desde \".concat(musicPath));\n                console.log(\"Tiempos: \".concat(startTime, \"s a \").concat(endTime, \"s, volumen: \").concat(volume, \", respectNativeDuration: \").concat(respectNativeDuration));\n                // Crear payload para la música\n                const audioPayload = {\n                    id: (0,_designcombo_timeline__WEBPACK_IMPORTED_MODULE_2__.generateId)(),\n                    display: {\n                        from: startTime * 1000,\n                        to: endTime * 1000 // Convertir a milisegundos\n                    },\n                    type: \"audio\",\n                    details: {\n                        src: musicPath,\n                        volume: volume,\n                        fadeIn: (options === null || options === void 0 ? void 0 : options.fadeIn) === true,\n                        fadeOut: (options === null || options === void 0 ? void 0 : options.fadeOut) === true\n                    }\n                };\n                // Agregar audio al timeline usando ADD_AUDIO\n                (0,_designcombo_events__WEBPACK_IMPORTED_MODULE_0__.dispatch)(_designcombo_state__WEBPACK_IMPORTED_MODULE_1__.ADD_AUDIO, {\n                    payload: audioPayload,\n                    options: {\n                        respectNativeDuration: respectNativeDuration\n                    }\n                });\n                console.log(\"M\\xfasica agregada exitosamente con ID: \".concat(audioPayload.id));\n                return audioPayload.id;\n            } catch (error) {\n                console.error(\"Error al agregar m\\xfasica:\", error);\n                throw error;\n            }\n        },\n        // Nuevo método para obtener el ID del track de subtítulos\n        getSubtitlesTrackId: async ()=>{\n            try {\n                console.log(\"Buscando track de subt\\xedtulos existente...\");\n                // Obtener todos los elementos del timeline\n                const allElements = await executor.getAllTimelineElements();\n                if (allElements.length === 0) {\n                    console.log(\"No hay elementos en la timeline\");\n                    return null;\n                }\n                // Agrupar elementos por trackId\n                const trackGroups = {};\n                allElements.forEach((element)=>{\n                    if (element.trackId) {\n                        if (!trackGroups[element.trackId]) {\n                            trackGroups[element.trackId] = [];\n                        }\n                        trackGroups[element.trackId].push(element);\n                    }\n                });\n                // Buscar primero tracks con ID que contenga \"subtitles\"\n                for (const [trackId, elements] of Object.entries(trackGroups)){\n                    if (trackId.includes(\"subtitles-track\") && elements.length > 0) {\n                        console.log(\"Encontrado track de subt\\xedtulos por nombre: \".concat(trackId, \" (\").concat(elements.length, \" elementos)\"));\n                        return trackId;\n                    }\n                }\n                // Si no se encuentra por nombre, buscar tracks que solo contengan elementos de texto\n                for (const [trackId, elements] of Object.entries(trackGroups)){\n                    const allTextElements = elements.every((elem)=>elem.type === \"text\");\n                    if (allTextElements && elements.length > 0) {\n                        console.log(\"Encontrado track con solo elementos de texto: \".concat(trackId, \" (\").concat(elements.length, \" elementos)\"));\n                        return trackId;\n                    }\n                }\n                console.log(\"No se encontr\\xf3 ning\\xfan track de subt\\xedtulos\");\n                return null;\n            } catch (error) {\n                console.error(\"Error al buscar track de subt\\xedtulos:\", error);\n                return null;\n            }\n        }\n    };\n    return executor;\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2NvbXBvbmVudHMvYWktY2hhdC9haS12aWRlby1jb21tYW5kcy50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQytDO0FBQ29LO0FBQ2hLO0FBaUY1QyxTQUFTVywyQkFBMkJDLFlBQTBCO0lBQ25FLGlEQUFpRDtJQUNqRCxNQUFNQyxXQUFpQztRQUNyQ0MsU0FBUyxDQUFDQyxNQUFjQztZQUN0QixNQUFNQyxXQUFXRCxDQUFBQSxvQkFBQUEsOEJBQUFBLFFBQVNDLFFBQVEsS0FBSTtnQkFBRUMsR0FBRztnQkFBS0MsR0FBRztZQUFJLEdBQUcsdUJBQXVCO1lBQ2pGLE1BQU1DLFdBQVdKLENBQUFBLG9CQUFBQSw4QkFBQUEsUUFBU0ksUUFBUSxLQUFJO1lBQ3RDLE1BQU1DLGFBQWFMLENBQUFBLG9CQUFBQSw4QkFBQUEsUUFBU0ssVUFBVSxLQUFJO1lBQzFDLE1BQU1DLFFBQVFOLENBQUFBLG9CQUFBQSw4QkFBQUEsUUFBU00sS0FBSyxLQUFJO1lBQ2hDLE1BQU1DLFlBQVlQLENBQUFBLG9CQUFBQSw4QkFBQUEsUUFBU08sU0FBUyxLQUFJLEdBQUcsd0JBQXdCO1lBQ25FLE1BQU1DLFVBQVVSLENBQUFBLG9CQUFBQSw4QkFBQUEsUUFBU1EsT0FBTyxLQUFJLEdBQUcscUNBQXFDO1lBRTVFLDhCQUE4QjtZQUM5QixNQUFNQyxjQUFjO2dCQUNsQkMsSUFBSWhCLGlFQUFVQTtnQkFDZGlCLFNBQVM7b0JBQ1BDLE1BQU1MLFlBQVk7b0JBQ2xCTSxJQUFJTCxVQUFVLEtBQVMsMkJBQTJCO2dCQUNwRDtnQkFDQU0sTUFBTTtnQkFDTkMsU0FBUztvQkFDUGhCLE1BQU1BO29CQUNOSyxVQUFVQTtvQkFDVlksT0FBTztvQkFDUFgsWUFBWUE7b0JBQ1pDLE9BQU9BO29CQUNQVyxVQUFVO29CQUNWQyxXQUFXO29CQUNYQyxhQUFhO29CQUNiQyxhQUFhO29CQUNiQyxXQUFXO3dCQUNUZixPQUFPO3dCQUNQSixHQUFHO3dCQUNIQyxHQUFHO3dC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cGFjazovL19OX0UvLi9jb21wb25lbnRzL2FpLWNoYXQvYWktdmlkZW8tY29tbWFuZHMudHM/MjYyMyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgU3RhdGVNYW5hZ2VyIGZyb20gXCJAZGVzaWduY29tYm8vc3RhdGVcIjtcbmltcG9ydCB7IGRpc3BhdGNoIH0gZnJvbSBcIkBkZXNpZ25jb21iby9ldmVudHNcIjtcbmltcG9ydCB7IERFU0lHTl9BRERfVEVYVCwgREVTSUdOX0FERF9BVURJTywgREVTSUdOX0FERF9JTUFHRSwgQUREX1RFWFQsIEFERF9WSURFTywgQUREX0lNQUdFLCBBRERfQVVESU8sIEFDVElWRV9TUExJVCwgTEFZRVJfU0VMRUNULCBMQVlFUl9ERUxFVEUsIFRJTUVMSU5FX1NDQUxFX0NIQU5HRUQsIEVESVRfT0JKRUNUIH0gZnJvbSBcIkBkZXNpZ25jb21iby9zdGF0ZVwiO1xuaW1wb3J0IHsgZ2VuZXJhdGVJZCB9IGZyb20gXCJAZGVzaWduY29tYm8vdGltZWxpbmVcIjtcblxuXG5leHBvcnQgaW50ZXJmYWNlIFZpZGVvQ29tbWFuZEV4ZWN1dG9yIHtcbiAgYWRkVGV4dDogKHRleHQ6IHN0cmluZywgb3B0aW9ucz86IFRleHRPcHRpb25zKSA9PiB2b2lkO1xuICBjaGFuZ2VDb2xvcjogKGVsZW1lbnRJZDogc3RyaW5nLCBjb2xvcjogc3RyaW5nKSA9PiB2b2lkO1xuICBhZGRJbWFnZTogKHVybDogc3RyaW5nLCBvcHRpb25zPzogSW1hZ2VPcHRpb25zKSA9PiB2b2lkO1xuICBhZGRWaWRlbzogKHVybDogc3RyaW5nLCBvcHRpb25zPzogVmlkZW9PcHRpb25zKSA9PiB2b2lkO1xuICBjaGFuZ2VEdXJhdGlvbjogKGVsZW1lbnRJZDogc3RyaW5nLCBkdXJhdGlvbjogbnVtYmVyKSA9PiB2b2lkO1xuICBjaGFuZ2VUcmFuc2l0aW9uOiAoZWxlbWVudElkOiBzdHJpbmcsIHRyYW5zaXRpb246IHN0cmluZykgPT4gdm9pZDtcbiAgYWRkU3VidGl0bGVzOiAob3B0aW9ucz86IFN1YnRpdGxlT3B0aW9ucykgPT4gdm9pZDtcbiAgcmVtb3ZlU2VnbWVudHM6IChzZWdtZW50czogVGltZVNlZ21lbnRbXSkgPT4gdm9pZDtcbiAgZ2V0QWN0aXZlRWxlbWVudHM6ICgpID0+IFByb21pc2U8YW55W10+O1xuICBnZXRBbGxUaW1lbGluZUVsZW1lbnRzOiAoKSA9PiBQcm9taXNlPGFueVtdPjtcbiAgY29tcGFjdFRpbWVsaW5lOiAoKSA9PiBQcm9taXNlPGJvb2xlYW4+O1xuICBzbWFydFRyaW06ICgpID0+IFByb21pc2U8Ym9vbGVhbj47XG4gIGFkZE11c2ljOiAobXVzaWNQYXRoOiBzdHJpbmcsIG9wdGlvbnM/OiBNdXNpY09wdGlvbnMpID0+IHZvaWQ7XG4gIGdldFN1YnRpdGxlc1RyYWNrSWQ6ICgpID0+IFByb21pc2U8c3RyaW5nIHwgbnVsbD47XG59XG5cbmludGVyZmFjZSBUZXh0T3B0aW9ucyB7XG4gIGZvbnRTaXplPzogbnVtYmVyO1xuICBmb250RmFtaWx5Pzogc3RyaW5nO1xuICBjb2xvcj86IHN0cmluZztcbiAgcG9zaXRpb24/OiB7IHg6IG51bWJlcjsgeTogbnVtYmVyIH07XG4gIHN0YXJ0VGltZT86IG51bWJlcjsgLy8gZW4gc2VndW5kb3NcbiAgZW5kVGltZT86IG51bWJlcjsgLy8gZW4gc2VndW5kb3Ncbn1cblxuaW50ZXJmYWNlIEltYWdlT3B0aW9ucyB7XG4gIHdpZHRoPzogbnVtYmVyO1xuICBoZWlnaHQ/OiBudW1iZXI7XG4gIHBvc2l0aW9uPzogeyB4OiBudW1iZXI7IHk6IG51bWJlciB9O1xuICBzdGFydFRpbWU/OiBudW1iZXI7IC8vIGVuIHNlZ3VuZG9zXG4gIGVuZFRpbWU/OiBudW1iZXI7IC8vIGVuIHNlZ3VuZG9zXG4gIGlzQW5pbWF0ZWQ/OiBib29sZWFuO1xuICBpc1N0YXRpYz86IGJvb2xlYW47IC8vIFBhcmEgZm9yemFyIHRyYXRhciB1bmEgaW1hZ2VuIGFuaW1hZGEgY29tbyBlc3TDoXRpY2FcbiAgc2NhbGVNb2RlPzogc3RyaW5nO1xufVxuXG5pbnRlcmZhY2UgVmlkZW9PcHRpb25zIHtcbiAgd2lkdGg/OiBudW1iZXI7XG4gIGhlaWdodD86IG51bWJlcjtcbiAgcG9zaXRpb24/OiB7IHg6IG51bWJlcjsgeTogbnVtYmVyIH07XG4gIHN0YXJ0VGltZT86IG51bWJlcjsgLy8gZW4gc2VndW5kb3NcbiAgZW5kVGltZT86IG51bWJlcjsgLy8gZW4gc2VndW5kb3NcbiAgc2NhbGVNb2RlPzogc3RyaW5nO1xuICBpc0FQTkc/OiBib29sZWFuO1xuICBzeW5jV2l0aFRpbWVsaW5lPzogYm9vbGVhbjtcbiAgcGxheWJhY2tCZWhhdmlvcj86IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBTdWJ0aXRsZU9wdGlvbnMge1xuICBncm91cFdvcmRzPzogYm9vbGVhbjsgLy8gU2kgc2UgZGViZW4gYWdydXBhciBwYWxhYnJhcyAodHJ1ZSkgbyB1c2FyIHN1YnTDrXR1bG9zIGNvbXBsZXRvcyAoZmFsc2UpXG4gIHN0YXJ0VGltZT86IG51bWJlcjsgICAvLyBUaWVtcG8gZGUgaW5pY2lvIHBhcmEgZmlsdHJhciBzdWJ0w610dWxvcyAob3BjaW9uYWwpXG4gIGVuZFRpbWU/OiBudW1iZXI7ICAgICAvLyBUaWVtcG8gZGUgZmluIHBhcmEgZmlsdHJhciBzdWJ0w610dWxvcyAob3BjaW9uYWwpXG4gIHRyYWNrSWQ/OiBzdHJpbmc7ICAgICAvLyBJRCBkZWwgdHJhY2sgYWwgcXVlIGFncmVnYXIgbG9zIHN1YnTDrXR1bG9zIChvcGNpb25hbClcbn1cblxuaW50ZXJmYWNlIE11c2ljT3B0aW9ucyB7XG4gIHN0YXJ0VGltZT86IG51bWJlcjsgLy8gZW4gc2VndW5kb3NcbiAgZW5kVGltZT86IG51bWJlcjsgLy8gZW4gc2VndW5kb3NcbiAgdm9sdW1lPzogbnVtYmVyOyAvLyAwLTEwMFxuICBmYWRlSW4/OiBib29sZWFuO1xuICBmYWRlT3V0PzogYm9vbGVhbjtcbiAgcmVzcGVjdE5hdGl2ZUR1cmF0aW9uPzogYm9vbGVhbjsgLy8gUmVzcGV0YXIgbGEgZHVyYWNpw7NuIG5hdGl2YSBkZWwgYXJjaGl2byBkZSBhdWRpb1xufVxuXG4vLyBUaXBvIHBhcmEgcmVwcmVzZW50YXIgdW4gc2VnbWVudG8gZGUgc3VidMOtdHVsb1xuaW50ZXJmYWNlIFN1YnRpdGxlU2VnbWVudCB7XG4gIGlkOiBudW1iZXI7XG4gIHN0YXJ0VGltZTogbnVtYmVyOyAvLyBlbiBtaWxpc2VndW5kb3NcbiAgZW5kVGltZTogbnVtYmVyOyAgIC8vIGVuIG1pbGlzZWd1bmRvc1xuICB0ZXh0OiBzdHJpbmc7XG59XG5cbmludGVyZmFjZSBUaW1lU2VnbWVudCB7XG4gIHN0YXJ0VGltZTogbnVtYmVyOyAvLyBUaWVtcG8gZGUgaW5pY2lvIGVuIHNlZ3VuZG9zXG4gIGVuZFRpbWU6IG51bWJlcjsgICAvLyBUaWVtcG8gZmluYWwgZW4gc2VndW5kb3Ncbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVZpZGVvQ29tbWFuZEV4ZWN1dG9yKHN0YXRlTWFuYWdlcjogU3RhdGVNYW5hZ2VyKTogVmlkZW9Db21tYW5kRXhlY3V0b3Ige1xuICAvLyBDcmVhciBlbCBvYmpldG8gZXhlY3V0b3IgY29uIHRvZG9zIGxvcyBtw6l0b2Rvc1xuICBjb25zdCBleGVjdXRvcjogVmlkZW9Db21tYW5kRXhlY3V0b3IgPSB7XG4gICAgYWRkVGV4dDogKHRleHQ6IHN0cmluZywgb3B0aW9ucz86IFRleHRPcHRpb25zKSA9PiB7XG4gICAgICBjb25zdCBwb3NpdGlvbiA9IG9wdGlvbnM/LnBvc2l0aW9uIHx8IHsgeDogMC41LCB5OiAwLjUgfTsgLy8gQ2VudHJhZG8gcG9yIGRlZmVjdG9cbiAgICAgIGNvbnN0IGZvbnRTaXplID0gb3B0aW9ucz8uZm9udFNpemUgfHwgNDg7XG4gICAgICBjb25zdCBmb250RmFtaWx5ID0gb3B0aW9ucz8uZm9udEZhbWlseSB8fCBcIlJvYm90by1Cb2xkXCI7XG4gICAgICBjb25zdCBjb2xvciA9IG9wdGlvbnM/LmNvbG9yIHx8IFwiI0ZGRkZGRlwiO1xuICAgICAgY29uc3Qgc3RhcnRUaW1lID0gb3B0aW9ucz8uc3RhcnRUaW1lIHx8IDA7IC8vIFBvciBkZWZlY3RvIGFsIGluaWNpb1xuICAgICAgY29uc3QgZW5kVGltZSA9IG9wdGlvbnM/LmVuZFRpbWUgfHwgNTsgLy8gUG9yIGRlZmVjdG8gNSBzZWd1bmRvcyBkZSBkdXJhY2nDs25cblxuICAgICAgLy8gQ3JlYXIgcGF5bG9hZCBwYXJhIGVsIHRleHRvXG4gICAgICBjb25zdCB0ZXh0UGF5bG9hZCA9IHtcbiAgICAgICAgaWQ6IGdlbmVyYXRlSWQoKSxcbiAgICAgICAgZGlzcGxheToge1xuICAgICAgICAgIGZyb206IHN0YXJ0VGltZSAqIDEwMDAsIC8vIENvbnZlcnRpciBhIG1pbGlzZWd1bmRvc1xuICAgICAgICAgIHRvOiBlbmRUaW1lICogMTAwMCAgICAgLy8gQ29udmVydGlyIGEgbWlsaXNlZ3VuZG9zXG4gICAgICAgIH0sXG4gICAgICAgIHR5cGU6ICd0ZXh0JyxcbiAgICAgICAgZGV0YWlsczoge1xuICAgICAgICAgIHRleHQ6IHRleHQsXG4gICAgICAgICAgZm9udFNpemU6IGZvbnRTaXplLFxuICAgICAgICAgIHdpZHRoOiA2MDAsXG4gICAgICAgICAgZm9udEZhbWlseTogZm9udEZhbWlseSxcbiAgICAgICAgICBjb2xvcjogY29sb3IsXG4gICAgICAgICAgd29yZFdyYXA6ICdicmVhay13b3JkJyxcbiAgICAgICAgICB0ZXh0QWxpZ246ICdjZW50ZXInLFxuICAgICAgICAgIGJvcmRlcldpZHRoOiAwLFxuICAgICAgICAgIGJvcmRlckNvbG9yOiAnIzAwMDAwMCcsXG4gICAgICAgICAgYm94U2hhZG93OiB7XG4gICAgICAgICAgICBjb2xvcjogJyNmZmZmZmYnLFxuICAgICAgICAgICAgeDogMCxcbiAgICAgICAgICAgIHk6IDAsXG4gICAgICAgICAgICBibHVyOiAwLFxuICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICB9O1xuXG4gICAgICAvLyBBZ3JlZ2FyIHRleHRvIGFsIHRpbWVsaW5lXG4gICAgICBkaXNwYXRjaChBRERfVEVYVCwge1xuICAgICAgICBwYXlsb2FkOiB0ZXh0UGF5bG9hZCxcbiAgICAgICAgb3B0aW9uczoge30sXG4gICAgICB9KTtcbiAgICB9LFxuXG4gICAgY2hhbmdlQ29sb3I6IChlbGVtZW50SWQ6IHN0cmluZywgY29sb3I6IHN0cmluZykgPT4ge1xuICAgICAgLy8gU2ltdWxhY2nDs24gZGUgY2FtYmlvIGRlIGNvbG9yIChsYSBpbXBsZW1lbnRhY2nDs24gcmVhbCBkZXBlbmRlcsOhIGRlIGxhIGVzdHJ1Y3R1cmEgZGVsIHByb3llY3RvKVxuICAgICAgY29uc29sZS5sb2coYENhbWJpYW5kbyBjb2xvciBkZWwgZWxlbWVudG8gJHtlbGVtZW50SWR9IGEgJHtjb2xvcn1gKTtcblxuICAgICAgLy8gQXF1w60gaXLDrWEgbGEgbMOzZ2ljYSByZWFsIHBhcmEgY2FtYmlhciBlbCBjb2xvciBkZSB1biBlbGVtZW50b1xuICAgIH0sXG5cbiAgICBhZGRJbWFnZTogKHVybDogc3RyaW5nLCBvcHRpb25zPzogSW1hZ2VPcHRpb25zKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgLy8gQXNlZ3VyYXIgcXVlIHRlbmVtb3MgdW5hIFVSTCB2w6FsaWRhXG4gICAgICBpZiAoIXVybCkge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCLinYwgVVJMIGRlIGltYWdlbiBubyB2w6FsaWRhIG8gdmFjw61hXCIpO1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVSTCBkZSBpbWFnZW4gbm8gcHJvcG9yY2lvbmFkYVwiKTtcbiAgICAgIH1cblxuICAgICAgICBjb25zb2xlLmxvZyhcIj09PSBJTklDSUFORE8gUFJPQ0VTTyBERSBBw5FBRElSIElNQUdFTiA9PT1cIik7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiVVJMOlwiLCB1cmwpO1xuICAgICAgICBjb25zb2xlLmxvZyhcIk9wY2lvbmVzOlwiLCBKU09OLnN0cmluZ2lmeShvcHRpb25zLCBudWxsLCAyKSk7XG5cbiAgICAgIC8vIFZlcmlmaWNhciBzaSBlcyB1bmEgVVJMIGdlbsOpcmljYSBkZSByZWZlcmVuY2lhLCBxdWUgbm8gZGViZSB1c2Fyc2UgZGlyZWN0YW1lbnRlXG4gICAgICBpZiAodXJsID09PSAnaW1hZ2VuX2FkanVudGFfcG9yX2VsX3VzdWFyaW8uanBnJyB8fCB1cmwuaW5jbHVkZXMoJy91cmxfZGVfbGFfaW1hZ2VuJykpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yOiBVUkwgZGUgaW1hZ2VuIGdlbsOpcmljYSBpbnbDoWxpZGEgZGV0ZWN0YWRhXCIsIHVybCk7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkxhIFVSTCBkZSBpbWFnZW4gbm8gZXMgdsOhbGlkYS4gU2UgaW50ZW50w7MgdXNhciB1biBtYXJjYWRvciBnZW7DqXJpY28gZGlyZWN0YW1lbnRlLlwiKTtcbiAgICAgIH1cblxuICAgICAgY29uc3Qgd2lkdGggPSBvcHRpb25zPy53aWR0aCB8fCA0ODA7XG4gICAgICBjb25zdCBoZWlnaHQgPSBvcHRpb25zPy5oZWlnaHQgfHwgMjcwO1xuICAgICAgY29uc3Qgc3RhcnRUaW1lID0gb3B0aW9ucz8uc3RhcnRUaW1lICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLnN0YXJ0VGltZSA6IDA7XG4gICAgICBjb25zdCBlbmRUaW1lID0gb3B0aW9ucz8uZW5kVGltZSAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5lbmRUaW1lIDogc3RhcnRUaW1lICsgNTtcblxuICAgICAgICAvLyBEZXRlY3RvcmVzIGRlIHRpcG8gZGUgaW1hZ2VuXG4gICAgICAgIGNvbnN0IGlzRXhwbGljaXRseUFuaW1hdGVkID0gb3B0aW9ucz8uaXNBbmltYXRlZCA9PT0gdHJ1ZTtcbiAgICAgICAgY29uc3QgaXNFeHBsaWNpdGx5U3RhdGljID0gb3B0aW9ucz8uaXNTdGF0aWMgPT09IHRydWU7XG4gICAgICAgIGNvbnN0IGlzQVBORyA9IHVybC50b0xvd2VyQ2FzZSgpLmVuZHNXaXRoKCcuYXBuZycpO1xuICAgICAgICBjb25zdCBpc0dJRiA9IHVybC50b0xvd2VyQ2FzZSgpLmVuZHNXaXRoKCcuZ2lmJyk7XG5cbiAgICAgICAgLy8gRGV0ZXJtaW5hciBzaSBkZWJlIHRyYXRhcnNlIGNvbW8gaW1hZ2VuIGFuaW1hZGFcbiAgICAgICAgY29uc3Qgc2hvdWxkVHJlYXRBc0FuaW1hdGVkID0gKGlzRXhwbGljaXRseUFuaW1hdGVkIHx8IGlzQVBORyB8fCBpc0dJRikgJiYgIWlzRXhwbGljaXRseVN0YXRpYztcblxuICAgICAgICAvLyBMb2cgZGUgbW9kbyBkZXRlY3RhZG9cbiAgICAgICAgaWYgKHNob3VsZFRyZWF0QXNBbmltYXRlZCkge1xuICAgICAgICAgIGNvbnNvbGUubG9nKGDwn5S2IERldGVjdGFkYSBpbWFnZW4gYW5pbWFkYTogJHt1cmx9YCk7XG4gICAgICAgICAgY29uc29sZS5sb2coYFRpcG86ICR7aXNBUE5HID8gJ0FQTkcnIDogaXNHSUYgPyAnR0lGJyA6ICdBbmltYWRhIGdlbsOpcmljYSd9YCk7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNBUE5HIHx8IGlzR0lGKSB7XG4gICAgICAgICAgY29uc29sZS5sb2coYPCflLkgRGV0ZWN0YWRhIGltYWdlbiBwb3RlbmNpYWxtZW50ZSBhbmltYWRhIHBlcm8gdHJhdMOhbmRvbGEgY29tbyBlc3TDoXRpY2E6ICR7dXJsfWApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnNvbGUubG9nKGDwn5S3IERldGVjdGFkYSBpbWFnZW4gZXN0w6F0aWNhOiAke3VybH1gKTtcbiAgICAgICAgfVxuXG4gICAgICAvLyBQYXJhIGRlcHVyYWNpw7NuLCBtb3N0cmFyIHBhcnRlIGRlIGxhIFVSTCAodHJ1bmNhZGEgc2kgZXMgZGF0YTpVUkwpXG4gICAgICBjb25zdCBsb2dVcmwgPSB1cmwuc3RhcnRzV2l0aCgnZGF0YTonKVxuICAgICAgICA/IGAke3VybC5zdWJzdHJpbmcoMCwgMzApfS4uLiAoZGF0YSBVUkwpYFxuICAgICAgICA6IHVybDtcbiAgICAgIGNvbnNvbGUubG9nKGBBw7FhZGllbmRvIGltYWdlbiBkZXNkZSAke2xvZ1VybH0gZGVzZGUgc2VndW5kbyAke3N0YXJ0VGltZX0gaGFzdGEgJHtlbmRUaW1lfWApO1xuXG4gICAgICAgIC8vIFBvc2ljacOzbiAoY2VudHJhZGEgcG9yIGRlZmVjdG8pXG4gICAgICAgIGNvbnN0IHBvc2l0aW9uID0gb3B0aW9ucz8ucG9zaXRpb24gfHwgeyB4OiAwLjUsIHk6IDAuNSB9O1xuXG4gICAgICAgIC8vIE1vZG9zIGRlIGVzY2FsYVxuICAgICAgICBjb25zdCBzY2FsZU1vZGUgPSBvcHRpb25zPy5zY2FsZU1vZGUgfHwgXCJmaXRcIjtcbiAgICAgICAgY29uc3QgdXNlRnVsbFNjcmVlbiA9IHNjYWxlTW9kZSA9PT0gXCJjb3ZlclwiO1xuXG4gICAgICAgIC8vIFByb3BpZWRhZGVzIHBhcmEgZWwgcGF5bG9hZCwgY29tw7puIHBhcmEgYW1ib3MgY2Fzb3NcbiAgICAgICAgY29uc3QgY29tbW9uUGF5bG9hZFByb3BzID0ge1xuICAgICAgICAgIGZyb206IHN0YXJ0VGltZSAqIDEwMDAsXG4gICAgICAgICAgdG86IGVuZFRpbWUgKiAxMDAwXG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gUHJvcGllZGFkZXMgZGUgZGV0YWxsZSBjb211bmVzXG4gICAgICAgIGNvbnN0IGNvbW1vbkRldGFpbHNQcm9wcyA9IHtcbiAgICAgICAgICBzcmM6IHVybCxcbiAgICAgICAgICB3aWR0aDogd2lkdGgsXG4gICAgICAgICAgaGVpZ2h0OiBoZWlnaHQsXG4gICAgICAgICAgb3BhY2l0eTogMTAwLFxuICAgICAgICAgIHNjYWxlTW9kZTogc2NhbGVNb2RlLFxuICAgICAgICAgIGxlZnQ6IHBvc2l0aW9uLngsXG4gICAgICAgICAgdG9wOiBwb3NpdGlvbi55LFxuICAgICAgICAgIG9yaWdpblg6IFwiY2VudGVyXCIsXG4gICAgICAgICAgb3JpZ2luWTogXCJjZW50ZXJcIlxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIENyZWFyIElEIMO6bmljb1xuICAgICAgICBjb25zdCBpbWFnZUlkID0gZ2VuZXJhdGVJZCgpO1xuXG4gICAgICAgIC8vIENyZWFyIGVsIHBheWxvYWQgZGUgaW1hZ2VuIHNpbXBsaWZpY2Fkb1xuICAgICAgICBjb25zdCBpbWFnZVBheWxvYWQgPSB7XG4gICAgICAgICAgaWQ6IGltYWdlSWQsXG4gICAgICAgICAgZGlzcGxheTogY29tbW9uUGF5bG9hZFByb3BzLFxuICAgICAgICAgIHR5cGU6ICdpbWFnZScsXG4gICAgICAgICAgZGV0YWlsczoge1xuICAgICAgICAgICAgLi4uY29tbW9uRGV0YWlsc1Byb3BzLFxuICAgICAgICAgICAgLy8gU2kgZXMgYW5pbWFkYSwgYcOxYWRpciBhdHJpYnV0b3MgZXNwZWPDrWZpY29zXG4gICAgICAgICAgICAuLi4oc2hvdWxkVHJlYXRBc0FuaW1hdGVkICYmIHtcbiAgICAgICAgICAgICAgaXNBbmltYXRlZDogdHJ1ZSxcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgLy8gU2kgYSBwYW50YWxsYSBjb21wbGV0YSwgYWp1c3RhciBkaW1lbnNpb25lc1xuICAgICAgICAgICAgLi4uKHVzZUZ1bGxTY3JlZW4gJiYge1xuICAgICAgICAgICAgICB3aWR0aDogMTkyMCxcbiAgICAgICAgICAgICAgaGVpZ2h0OiAxMDgwXG4gICAgICAgICAgICB9KVxuICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBjb25zb2xlLmxvZyhcIlBheWxvYWQgZGUgaW1hZ2VuIGEgZGVzcGFjaGFyOlwiLCBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgLi4uaW1hZ2VQYXlsb2FkLFxuICAgICAgICAgIGRldGFpbHM6IHtcbiAgICAgICAgICAgIC4uLmltYWdlUGF5bG9hZC5kZXRhaWxzLFxuICAgICAgICAgICAgc3JjOiBpbWFnZVBheWxvYWQuZGV0YWlscy5zcmMuc3Vic3RyaW5nKDAsIDMwKSArIChpbWFnZVBheWxvYWQuZGV0YWlscy5zcmMubGVuZ3RoID4gMzAgPyAnLi4uJyA6ICcnKVxuICAgICAgICAgIH1cbiAgICAgICAgfSwgbnVsbCwgMikpO1xuXG4gICAgICAgIC8vIE9wY2lvbmVzIHBhcmEgZWwgZGlzcGF0Y2hcbiAgICAgICAgY29uc3QgZGlzcGF0Y2hPcHRpb25zID0ge1xuICAgICAgICAgIHNjYWxlTW9kZTogc2NhbGVNb2RlLFxuICAgICAgICAgIHBvc2l0aW9uOiBwb3NpdGlvbixcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBEZXNwYWNoYXIgbGEgYWNjacOzbiBwYXJhIGHDsWFkaXIgbGEgaW1hZ2VuXG4gICAgICAgIGRpc3BhdGNoKEFERF9JTUFHRSwge1xuICAgICAgICAgIHBheWxvYWQ6IGltYWdlUGF5bG9hZCxcbiAgICAgICAgICBvcHRpb25zOiBkaXNwYXRjaE9wdGlvbnNcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gTG9nIGRlIMOpeGl0b1xuICAgICAgICBpZiAoc2hvdWxkVHJlYXRBc0FuaW1hdGVkKSB7XG4gICAgICAgICAgY29uc29sZS5sb2coYOKchSBJbWFnZW4gYW5pbWFkYSBhw7FhZGlkYSBkZXNkZSAke3N0YXJ0VGltZX1zIGhhc3RhICR7ZW5kVGltZX1zYCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc29sZS5sb2coYOKchSBJbWFnZW4gZXN0w6F0aWNhIGHDsWFkaWRhIGRlc2RlICR7c3RhcnRUaW1lfXMgaGFzdGEgJHtlbmRUaW1lfXNgKTtcbiAgICAgICAgfVxuXG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKFwi4p2MIEVSUk9SIENSw41USUNPIGFsIGHDsWFkaXIgaW1hZ2VuOlwiLCBlcnJvcik7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJEZXRhbGxlcyBjb21wbGV0b3M6XCIsIGVycm9yLm1lc3NhZ2UpO1xuICAgICAgICBjb25zb2xlLmVycm9yKFwiVHJhemE6XCIsIGVycm9yLnN0YWNrKTtcbiAgICAgICAgdGhyb3cgZXJyb3I7IC8vIFByb3BhZ2FyIGVsIGVycm9yIHBhcmEgbWFuZWpvIHN1cGVyaW9yXG4gICAgICB9XG4gICAgfSxcblxuICAgIGFkZFZpZGVvOiAodXJsOiBzdHJpbmcsIG9wdGlvbnM/OiBWaWRlb09wdGlvbnMpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiPT09IElOSUNJQU5ETyBQUk9DRVNPIERFIEHDkUFESVIgVklERU8gPT09XCIpO1xuICAgICAgICBjb25zb2xlLmxvZyhcIlVSTDpcIiwgdXJsKTtcbiAgICAgICAgY29uc29sZS5sb2coXCJPcGNpb25lczpcIiwgSlNPTi5zdHJpbmdpZnkob3B0aW9ucywgbnVsbCwgMikpO1xuXG4gICAgICAgIC8vIFZhbGlkYWNpw7NuIGRlIFVSTFxuICAgICAgICBpZiAoIXVybCkge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCLinYwgVVJMIGRlIHZpZGVvIG5vIHbDoWxpZGEgbyB2YWPDrWFcIik7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVVJMIGRlIHZpZGVvIG5vIHByb3BvcmNpb25hZGFcIik7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB3aWR0aCA9IG9wdGlvbnM/LndpZHRoIHx8IDY0MDtcbiAgICAgICAgY29uc3QgaGVpZ2h0ID0gb3B0aW9ucz8uaGVpZ2h0IHx8IDM2MDtcbiAgICAgICAgY29uc3Qgc3RhcnRUaW1lID0gb3B0aW9ucz8uc3RhcnRUaW1lIHx8IDA7IC8vIFBvciBkZWZlY3RvIGFsIGluaWNpb1xuICAgICAgICBjb25zdCBlbmRUaW1lID0gb3B0aW9ucz8uZW5kVGltZSB8fCAxMDsgLy8gUG9yIGRlZmVjdG8gMTAgc2VndW5kb3MgZGUgZHVyYWNpw7NuXG5cbiAgICAgICAgLy8gRGV0ZWN0YXIgc2kgZXMgdW4gYXJjaGl2byBBVkkgbyBBUE5HIHBhcmEgdHJhdGFtaWVudG8gZXNwZWNpYWxcbiAgICAgICAgY29uc3QgaXNBVkkgPSB1cmwudG9Mb3dlckNhc2UoKS5lbmRzV2l0aCgnLmF2aScpO1xuICAgICAgICBjb25zdCBpc0FQTkcgPSB1cmwudG9Mb3dlckNhc2UoKS5lbmRzV2l0aCgnLmFwbmcnKTtcbiAgICAgICAgLy8gTWFyY2Fkb3IgcGFzYWRvIGV4cGzDrWNpdGFtZW50ZSAtIG1heW9yIHByaW9yaWRhZCBxdWUgbGEgZXh0ZW5zacOzblxuICAgICAgICBjb25zdCBpc0V4cGxpY2l0QVBORyA9IG9wdGlvbnM/LmlzQVBORyA9PT0gdHJ1ZTtcblxuICAgICAgICBjb25zb2xlLmxvZyhcIkZvcm1hdG8gZGV0ZWN0YWRvOlwiLFxuICAgICAgICAgIGlzQVZJID8gXCJBVklcIiA6IGlzQVBORyA/IFwiQVBOR1wiIDogaXNFeHBsaWNpdEFQTkcgPyBcIkV4cGzDrWNpdGFtZW50ZSBtYXJjYWRvIGNvbW8gQVBOR1wiIDogXCJGb3JtYXRvIGVzdMOhbmRhclwiKTtcblxuICAgICAgICAvLyBTaSBlcyBBUE5HIHNlZ8O6biBhbGfDum4gY3JpdGVyaW9cbiAgICAgICAgY29uc3QgdHJlYXRBc0FQTkcgPSBpc0FQTkcgfHwgaXNFeHBsaWNpdEFQTkc7XG4gICAgICAgIGNvbnN0IHVzZUZ1bGxTY3JlZW4gPSBpc0FWSSB8fCB0cmVhdEFzQVBORyB8fCAob3B0aW9ucz8uc2NhbGVNb2RlID09PSBcImNvdmVyXCIpO1xuXG4gICAgICAgIC8vIFBhcmEgYXJjaGl2b3MgQVZJIHkgQVBORywgcmVzcGVjdGFyIGR1cmFjacOzbiBuYXR1cmFsIHNpIG5vIHNlIGVzcGVjaWZpY2FcbiAgICAgICAgY29uc3QgcmVzcGVjdE5hdGl2ZUR1cmF0aW9uID0gKGlzQVZJIHx8IHRyZWF0QXNBUE5HKSAmJiAhb3B0aW9ucz8uZW5kVGltZTtcbiAgICAgICAgY29uc3QgZmluYWxFbmRUaW1lID0gcmVzcGVjdE5hdGl2ZUR1cmF0aW9uID8gdW5kZWZpbmVkIDogZW5kVGltZTtcblxuICAgICAgICAvLyBMb2cgcGFyYSBkZXB1cmFyXG4gICAgICAgIGlmICh0cmVhdEFzQVBORykge1xuICAgICAgICAgIGNvbnNvbGUubG9nKGDwn5S3IEHDsWFkaWVuZG8gQVBORyBjb21vIFZJREVPIHNpbmNyb25pemFkbyBkZXNkZSAke3N0YXJ0VGltZX1zIGNvbiBkdXJhY2nDs24gJHtyZXNwZWN0TmF0aXZlRHVyYXRpb24gPyAnbmF0dXJhbCcgOiBmaW5hbEVuZFRpbWUgKyAncyd9YCk7XG4gICAgICAgICAgY29uc29sZS5sb2coYPCflLcgQ29uZmlndXJhY2lvbmVzIGVzcGVjaWFsZXMgZGUgQVBORyAtIHVzZUZ1bGxTY3JlZW46ICR7dXNlRnVsbFNjcmVlbn0sIHN5bmNXaXRoVGltZWxpbmU6ICR7b3B0aW9ucz8uc3luY1dpdGhUaW1lbGluZSB8fCB0cnVlfWApO1xuICAgICAgICB9IGVsc2UgaWYgKGlzQVZJKSB7XG4gICAgICAgICAgY29uc29sZS5sb2coYPCfjqwgQcOxYWRpZW5kbyBBVkkgY29uIGR1cmFjacOzbiAke3Jlc3BlY3ROYXRpdmVEdXJhdGlvbiA/ICduYXR1cmFsJyA6ICdlc3BlY2lmaWNhZGE6ICcgKyBmaW5hbEVuZFRpbWV9c2ApO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gTWFuZWphciBBUE5HIHVzYW5kbyB1biBlbmZvcXVlIGVzcGVjaWFsIC0gaW50ZW50YXIgY29uIHVuIG3DqXRvZG8gYWx0ZXJuYXRpdm8gc2kgZXMgcG9zaWJsZVxuICAgICAgICBpZiAodHJlYXRBc0FQTkcpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gSW50ZW50YXIgY3JlYXIgdW4gcGF5bG9hZCBlc3BlY2lhbCBwYXJhIEFQTkcgcXVlIGZ1bmNpb25lIGNvbW8gYW5pbWFjacOzblxuICAgICAgICAgICAgY29uc29sZS5sb2coXCJQcm9iYW5kbyBjb24gdW5hIGNvbmZpZ3VyYWNpw7NuIGVzcGVjaWFsIHBhcmEgQVBORy4uLlwiKTtcblxuICAgICAgICAgICAgLy8gQ29uZmlndXJhY2nDs24gZGUgb3BjaW9uZXMgaW1wb3J0YW50ZSBwYXJhIGFyY2hpdm9zIEFQTkdcbiAgICAgICAgICAgIGNvbnN0IGFwbmdWaWRlb1BheWxvYWQgPSB7XG4gICAgICAgICAgICBpZDogZ2VuZXJhdGVJZCgpLFxuICAgICAgICAgICAgZGlzcGxheToge1xuICAgICAgICAgICAgICBmcm9tOiBzdGFydFRpbWUgKiAxMDAwLCAvLyBDb252ZXJ0aXIgYSBtaWxpc2VndW5kb3NcbiAgICAgICAgICAgICAgICB0bzogZmluYWxFbmRUaW1lID8gZmluYWxFbmRUaW1lICogMTAwMCA6IChzdGFydFRpbWUgKyAzKSAqIDEwMDAgLy8gMyBzZWd1bmRvcyBwb3IgZGVmZWN0byBzaSBubyBoYXkgZHVyYWNpw7NuXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAvLyBQcm9iYW1vcyB1bmEgbnVldmEgZXN0cmF0ZWdpYTogdHJhdGFybG8gY29tbyBpbWFnZW4gZW4gbHVnYXIgZGUgdmlkZW9cbiAgICAgICAgICAgIHR5cGU6ICdpbWFnZScsXG4gICAgICAgICAgICBkZXRhaWxzOiB7XG4gICAgICAgICAgICAgIHNyYzogdXJsLFxuICAgICAgICAgICAgICAgIHdpZHRoOiAxOTIwLCAvLyBBbmNobyBwYXJhIHBhbnRhbGxhIGNvbXBsZXRhXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiAxMDgwLCAvLyBBbHRvIHBhcmEgcGFudGFsbGEgY29tcGxldGFcbiAgICAgICAgICAgICAgb3BhY2l0eTogMTAwLFxuICAgICAgICAgICAgICAgIHNjYWxlTW9kZTogXCJjb3ZlclwiLCAvLyBQYXJhIGxsZW5hciB0b2RhIGxhIHBhbnRhbGxhXG4gICAgICAgICAgICAgICAgbGVmdDogMC41LCAvLyBDZW50cmFkbyBob3Jpem9udGFsbWVudGVcbiAgICAgICAgICAgICAgICB0b3A6IDAuNSwgIC8vIENlbnRyYWRvIHZlcnRpY2FsbWVudGVcbiAgICAgICAgICAgICAgICBvcmlnaW5YOiBcImNlbnRlclwiLCAvLyBPcmlnZW4gZW4gZWwgY2VudHJvXG4gICAgICAgICAgICAgICAgb3JpZ2luWTogXCJjZW50ZXJcIiwgLy8gT3JpZ2VuIGVuIGVsIGNlbnRyb1xuICAgICAgICAgICAgICAgIC8vIFByb3BpZWRhZGVzIHBhcmEgYW5pbWFyXG4gICAgICAgICAgICAgICAgaXNBbmltYXRlZDogdHJ1ZVxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgY29uc29sZS5sb2coXCJQYXlsb2FkIHBhcmEgQVBORyBjb21vIGltYWdlbiBhbmltYWRhOlwiLCBKU09OLnN0cmluZ2lmeShhcG5nVmlkZW9QYXlsb2FkLCBudWxsLCAyKSk7XG5cbiAgICAgICAgICAgIC8vIFVzYXIgQUREX0lNQUdFIGVuIGx1Z2FyIGRlIEFERF9WSURFT1xuICAgICAgICAgIGRpc3BhdGNoKEFERF9JTUFHRSwge1xuICAgICAgICAgICAgICBwYXlsb2FkOiBhcG5nVmlkZW9QYXlsb2FkLFxuICAgICAgICAgICAgb3B0aW9uczoge1xuICAgICAgICAgICAgICAgIHNjYWxlTW9kZTogXCJjb3ZlclwiLFxuICAgICAgICAgICAgICAgIHBvc2l0aW9uOiB7IHg6IDAuNSwgeTogMC41IH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwi4pyFIEFQTkcgYcOxYWRpZG8gY29tbyBpbWFnZW4gYW5pbWFkYSBjb24gw6l4aXRvXCIpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH0gY2F0Y2ggKGFwbmdFcnJvcikge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIuKdjCBFcnJvciBhbCBhw7FhZGlyIEFQTkcgY29tbyBpbWFnZW4gYW5pbWFkYTpcIiwgYXBuZ0Vycm9yKTtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJEZXRhbGxlczpcIiwgYXBuZ0Vycm9yLm1lc3NhZ2UpO1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIlRyYXphOlwiLCBhcG5nRXJyb3Iuc3RhY2spO1xuICAgICAgICAgICAgY29uc29sZS5sb2coXCLwn5SEIENvbnRpbnVhbmRvIGNvbiBlbCBtw6l0b2RvIGVzdMOhbmRhciBjb21vIHJlc3BhbGRvLi4uXCIpO1xuICAgICAgICAgICAgLy8gQ29udGludWFyIGNvbiBlbCBtw6l0b2RvIGVzdMOhbmRhciBjb21vIHJlc3BhbGRvXG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgIC8vIENyZWFyIHBheWxvYWQgcGFyYSBlbCB2aWRlb1xuICAgICAgY29uc3QgdmlkZW9QYXlsb2FkID0ge1xuICAgICAgICBpZDogZ2VuZXJhdGVJZCgpLFxuICAgICAgICBkaXNwbGF5OiB7XG4gICAgICAgICAgZnJvbTogc3RhcnRUaW1lICogMTAwMCwgLy8gQ29udmVydGlyIGEgbWlsaXNlZ3VuZG9zXG4gICAgICAgICAgICB0bzogZmluYWxFbmRUaW1lID8gZmluYWxFbmRUaW1lICogMTAwMCA6IHVuZGVmaW5lZCAvLyBVc2FyIHVuZGVmaW5lZCBzaSBxdWVyZW1vcyByZXNwZXRhciBsYSBkdXJhY2nDs24gbmF0dXJhbFxuICAgICAgICB9LFxuICAgICAgICB0eXBlOiAndmlkZW8nLFxuICAgICAgICBkZXRhaWxzOiB7XG4gICAgICAgICAgc3JjOiB1cmwsXG4gICAgICAgICAgd2lkdGg6IHdpZHRoLFxuICAgICAgICAgIGhlaWdodDogaGVpZ2h0LFxuICAgICAgICAgIG9wYWNpdHk6IDEwMCxcbiAgICAgICAgICAgIC8vIFBhcmEgYXJjaGl2b3MgQVBORyB5IEFWSSwgY29uZmlndXJhciBwcm9waWVkYWRlcyBlc3BlY8OtZmljYXMgcGFyYSBwYW50YWxsYSBjb21wbGV0YVxuICAgICAgICAgICAgLi4uKHVzZUZ1bGxTY3JlZW4gJiYge1xuICAgICAgICAgICAgICBzY2FsZU1vZGU6IFwiY292ZXJcIiwgLy8gVXNhciBcImNvdmVyXCIgZW4gbHVnYXIgZGUgXCJmaXRcIiBwYXJhIGFzZWd1cmFyIHF1ZSBjdWJyYSB0b2RvXG4gICAgICAgICAgICAgIGxlZnQ6IDAuNSwgLy8gQ2VudHJhZG8gaG9yaXpvbnRhbG1lbnRlXG4gICAgICAgICAgICAgIHRvcDogMC41LCAgLy8gQ2VudHJhZG8gdmVydGljYWxtZW50ZVxuICAgICAgICAgICAgICBvcmlnaW5YOiBcImNlbnRlclwiLCAvLyBPcmlnZW4gZW4gZWwgY2VudHJvXG4gICAgICAgICAgICAgIG9yaWdpblk6IFwiY2VudGVyXCIsIC8vIE9yaWdlbiBlbiBlbCBjZW50cm9cbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgLy8gUHJvcGllZGFkZXMgZXNwZWNpYWxlcyBwYXJhIEFQTkdcbiAgICAgICAgICAgIC4uLih0cmVhdEFzQVBORyAmJiB7XG4gICAgICAgICAgICAgIGlzQVBORzogdHJ1ZSxcbiAgICAgICAgICAgICAgYXV0b1BsYXk6IHRydWUsXG4gICAgICAgICAgICAgIGxvb3A6IGZhbHNlLFxuICAgICAgICAgICAgICBzeW5jV2l0aFRpbWVsaW5lOiBvcHRpb25zPy5zeW5jV2l0aFRpbWVsaW5lIHx8IHRydWVcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfSxcbiAgICAgICAgfTtcblxuICAgICAgICBjb25zb2xlLmxvZyhcIlBheWxvYWQgZGUgdmlkZW8gZXN0w6FuZGFyOlwiLCBKU09OLnN0cmluZ2lmeSh2aWRlb1BheWxvYWQsIG51bGwsIDIpKTtcblxuICAgICAgICAvLyBDb25maWd1cmFjaW9uZXMgYWRpY2lvbmFsZXMgcGFyYSBlbCBkaXNwYXRjaFxuICAgICAgICBjb25zdCBkaXNwYXRjaE9wdGlvbnMgPSB7XG4gICAgICAgICAgcmVzb3VyY2VJZDogXCJtYWluXCIsXG4gICAgICAgICAgc2NhbGVNb2RlOiB1c2VGdWxsU2NyZWVuID8gXCJjb3ZlclwiIDogXCJmaXRcIiwgLy8gVXNhciBjb3ZlciBwYXJhIHBhbnRhbGxhIGNvbXBsZXRhLCBmaXQgcGFyYSBvdHJvcyB2aWRlb3NcbiAgICAgICAgICAuLi4odXNlRnVsbFNjcmVlbiAmJiB7XG4gICAgICAgICAgICBwb3NpdGlvbjogeyB4OiAwLjUsIHk6IDAuNSB9IC8vIENlbnRyYXIgcGFyYSB2aWRlb3MgYSBwYW50YWxsYSBjb21wbGV0YVxuICAgICAgICAgIH0pLFxuICAgICAgICAgIHJlc3BlY3ROYXRpdmVEdXJhdGlvbjogcmVzcGVjdE5hdGl2ZUR1cmF0aW9uLFxuICAgICAgICAgIC8vIFByb3BpZWRhZGVzIGVzcGVjw61maWNhcyBwYXJhIHNpbmNyb25pemFjacOzbiBkZSBBUE5HXG4gICAgICAgICAgLi4uKHRyZWF0QXNBUE5HICYmIHtcbiAgICAgICAgICAgIGlzQVBORzogdHJ1ZSxcbiAgICAgICAgICAgIHN5bmNXaXRoVGltZWxpbmU6IG9wdGlvbnM/LnN5bmNXaXRoVGltZWxpbmUgfHwgdHJ1ZSxcbiAgICAgICAgICAgIHBsYXliYWNrQmVoYXZpb3I6IG9wdGlvbnM/LnBsYXliYWNrQmVoYXZpb3IgfHwgXCJzeW5jXCJcbiAgICAgICAgICB9KVxuICAgICAgICB9O1xuXG4gICAgICAgIGNvbnNvbGUubG9nKFwiT3BjaW9uZXMgZGUgZGlzcGF0Y2g6XCIsIEpTT04uc3RyaW5naWZ5KGRpc3BhdGNoT3B0aW9ucywgbnVsbCwgMikpO1xuXG4gICAgICAvLyBBZ3JlZ2FyIHZpZGVvIGFsIHRpbWVsaW5lXG4gICAgICBkaXNwYXRjaChBRERfVklERU8sIHtcbiAgICAgICAgcGF5bG9hZDogdmlkZW9QYXlsb2FkLFxuICAgICAgICAgIG9wdGlvbnM6IGRpc3BhdGNoT3B0aW9ucyxcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gTWVuc2FqZSBkZSBsb2cgYWRhcHRhZG8gYWwgdGlwbyBkZSBhcmNoaXZvXG4gICAgICAgIGlmICh0cmVhdEFzQVBORykge1xuICAgICAgICAgIGNvbnNvbGUubG9nKGDinIUgVHJhbnNpY2nDs24gQVBORyBhw7FhZGlkYSBjb21vIFZJREVPIFNJTkNST05JWkFETyBhbCB0aW1lbGluZSBkZXNkZSAke3N0YXJ0VGltZX1zICR7ZmluYWxFbmRUaW1lID8gYGhhc3RhICR7ZmluYWxFbmRUaW1lfXNgIDogJ2NvbiBkdXJhY2nDs24gbmF0dXJhbCd9LiBEaW1lbnNpb25lczogJHt3aWR0aH14JHtoZWlnaHR9YCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc29sZS5sb2coYOKchSBWaWRlbyAke2lzQVZJID8gJ0FWSScgOiAnJ30gYcOxYWRpZG8gYWwgdGltZWxpbmUgZGVzZGUgJHtzdGFydFRpbWV9cyR7ZmluYWxFbmRUaW1lID8gYCBoYXN0YSAke2ZpbmFsRW5kVGltZX1zYCA6ICcgY29uIGR1cmFjacOzbiBuYXR1cmFsJ30uIERpbWVuc2lvbmVzOiAke3dpZHRofXgke2hlaWdodH1gKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcIuKdjCBFUlJPUiBDUsONVElDTyBhbCBhw7FhZGlyIHZpZGVvOlwiLCBlcnJvcik7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJEZXRhbGxlcyBjb21wbGV0b3M6XCIsIGVycm9yLm1lc3NhZ2UpO1xuICAgICAgICBjb25zb2xlLmVycm9yKFwiVHJhemE6XCIsIGVycm9yLnN0YWNrKTtcbiAgICAgICAgdGhyb3cgZXJyb3I7IC8vIFByb3BhZ2FyIGVsIGVycm9yIHBhcmEgbWFuZWpvIHN1cGVyaW9yXG4gICAgICB9XG4gICAgfSxcblxuICAgIGNoYW5nZUR1cmF0aW9uOiAoZWxlbWVudElkOiBzdHJpbmcsIGR1cmF0aW9uOiBudW1iZXIpID0+IHtcbiAgICAgIC8vIFNpbXVsYWNpw7NuIGRlIGNhbWJpbyBkZSBkdXJhY2nDs24gKGxhIGltcGxlbWVudGFjacOzbiByZWFsIGRlcGVuZGVyw6EgZGUgbGEgZXN0cnVjdHVyYSBkZWwgcHJveWVjdG8pXG4gICAgICBjb25zb2xlLmxvZyhgQ2FtYmlhbmRvIGR1cmFjacOzbiBkZWwgZWxlbWVudG8gJHtlbGVtZW50SWR9IGEgJHtkdXJhdGlvbn1zYCk7XG5cbiAgICAgIC8vIEFxdcOtIGlyw61hIGxhIGzDs2dpY2EgcmVhbCBwYXJhIGNhbWJpYXIgbGEgZHVyYWNpw7NuIGRlIHVuIGVsZW1lbnRvXG4gICAgfSxcblxuICAgIGNoYW5nZVRyYW5zaXRpb246IChlbGVtZW50SWQ6IHN0cmluZywgdHJhbnNpdGlvbjogc3RyaW5nKSA9PiB7XG4gICAgICAvLyBTaW11bGFjacOzbiBkZSBjYW1iaW8gZGUgdHJhbnNpY2nDs24gKGxhIGltcGxlbWVudGFjacOzbiByZWFsIGRlcGVuZGVyw6EgZGUgbGEgZXN0cnVjdHVyYSBkZWwgcHJveWVjdG8pXG4gICAgICBjb25zb2xlLmxvZyhgQ2FtYmlhbmRvIHRyYW5zaWNpw7NuIGRlbCBlbGVtZW50byAke2VsZW1lbnRJZH0gYSAke3RyYW5zaXRpb259YCk7XG5cbiAgICAgIC8vIEFxdcOtIGlyw61hIGxhIGzDs2dpY2EgcmVhbCBwYXJhIGNhbWJpYXIgbGEgdHJhbnNpY2nDs24gZGUgdW4gZWxlbWVudG9cbiAgICB9LFxuXG4gICAgYWRkU3VidGl0bGVzOiBhc3luYyAob3B0aW9ucz86IFN1YnRpdGxlT3B0aW9ucykgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc29sZS5sb2coXCJBw7FhZGllbmRvIHN1YnTDrXR1bG9zIGRpcmVjdGFtZW50ZSBzaW4gZGVwZW5kZXIgZGVsIGJvdMOzblwiKTtcblxuICAgICAgICAvLyBUaXBvIHBhcmEgcmVwcmVzZW50YXIgdW4gc2VnbWVudG8gZGUgc3VidMOtdHVsb1xuICAgICAgICBpbnRlcmZhY2UgU3VidGl0bGVTZWdtZW50IHtcbiAgICAgICAgICBpZDogbnVtYmVyO1xuICAgICAgICAgIHN0YXJ0VGltZTogbnVtYmVyOyAvLyBlbiBtaWxpc2VndW5kb3NcbiAgICAgICAgICBlbmRUaW1lOiBudW1iZXI7ICAgLy8gZW4gbWlsaXNlZ3VuZG9zXG4gICAgICAgICAgdGV4dDogc3RyaW5nO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRnVuY2nDs24gcGFyYSBwYXJzZWFyIGVsIHRpZW1wbyBkZSBmb3JtYXRvIFNSVCBhIG1pbGlzZWd1bmRvc1xuICAgICAgICBjb25zdCBwYXJzZVRpbWVUb01zID0gKHRpbWVTdHJpbmc6IHN0cmluZyk6IG51bWJlciA9PiB7XG4gICAgICAgICAgY29uc3QgW2hvdXJzLCBtaW51dGVzLCBzZWNvbmRzQW5kTXNdID0gdGltZVN0cmluZy5zcGxpdCgnOicpO1xuICAgICAgICAgIGNvbnN0IFtzZWNvbmRzLCBtc10gPSBzZWNvbmRzQW5kTXMuc3BsaXQoJywnKTtcblxuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICBwYXJzZUludChob3VycykgKiAzNjAwMDAwICtcbiAgICAgICAgICAgIHBhcnNlSW50KG1pbnV0ZXMpICogNjAwMDAgK1xuICAgICAgICAgICAgcGFyc2VJbnQoc2Vjb25kcykgKiAxMDAwICtcbiAgICAgICAgICAgIHBhcnNlSW50KG1zKVxuICAgICAgICAgICk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gRnVuY2nDs24gcGFyYSBwYXJzZWFyIGVsIGFyY2hpdm8gU1JUXG4gICAgICAgIGNvbnN0IHBhcnNlU1JUID0gKHNydENvbnRlbnQ6IHN0cmluZyk6IFN1YnRpdGxlU2VnbWVudFtdID0+IHtcbiAgICAgICAgICBjb25zdCBzZWdtZW50czogU3VidGl0bGVTZWdtZW50W10gPSBbXTtcbiAgICAgICAgICBjb25zdCBibG9ja3MgPSBzcnRDb250ZW50LnRyaW0oKS5zcGxpdCgnXFxuXFxuJyk7XG5cbiAgICAgICAgICBibG9ja3MuZm9yRWFjaChibG9jayA9PiB7XG4gICAgICAgICAgICBjb25zdCBsaW5lcyA9IGJsb2NrLnNwbGl0KCdcXG4nKTtcbiAgICAgICAgICAgIGlmIChsaW5lcy5sZW5ndGggPj0gMykge1xuICAgICAgICAgICAgICBjb25zdCBpZCA9IHBhcnNlSW50KGxpbmVzWzBdKTtcbiAgICAgICAgICAgICAgY29uc3QgdGltZVJhbmdlID0gbGluZXNbMV0uc3BsaXQoJyAtLT4gJyk7XG4gICAgICAgICAgICAgIGNvbnN0IHN0YXJ0VGltZSA9IHBhcnNlVGltZVRvTXModGltZVJhbmdlWzBdKTtcbiAgICAgICAgICAgICAgY29uc3QgZW5kVGltZSA9IHBhcnNlVGltZVRvTXModGltZVJhbmdlWzFdKTtcbiAgICAgICAgICAgICAgY29uc3QgdGV4dCA9IGxpbmVzLnNsaWNlKDIpLmpvaW4oJ1xcbicpOyAvLyBVbmlyIHRvZGFzIGxhcyBsw61uZWFzIGRlIHRleHRvXG5cbiAgICAgICAgICAgICAgc2VnbWVudHMucHVzaCh7XG4gICAgICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICAgICAgc3RhcnRUaW1lLFxuICAgICAgICAgICAgICAgIGVuZFRpbWUsXG4gICAgICAgICAgICAgICAgdGV4dFxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIHJldHVybiBzZWdtZW50cztcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBGdW5jacOzbiBwYXJhIGRpdmlkaXIgdW4gdGV4dG8gZW4gZ3J1cG9zIGRlIGFwcm94aW1hZGFtZW50ZSAzIHBhbGFicmFzXG4gICAgICAgIGNvbnN0IHNwbGl0VGV4dEludG9Hcm91cHMgPSAodGV4dDogc3RyaW5nLCB3b3Jkc1Blckdyb3VwID0gMyk6IHN0cmluZ1tdID0+IHtcbiAgICAgICAgICBjb25zdCB3b3JkcyA9IHRleHQuc3BsaXQoL1xccysvKTtcbiAgICAgICAgICBjb25zdCBncm91cHM6IHN0cmluZ1tdID0gW107XG5cbiAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHdvcmRzLmxlbmd0aDsgaSArPSB3b3Jkc1Blckdyb3VwKSB7XG4gICAgICAgICAgICBjb25zdCBncm91cCA9IHdvcmRzLnNsaWNlKGksIGkgKyB3b3Jkc1Blckdyb3VwKS5qb2luKCcgJyk7XG4gICAgICAgICAgICBncm91cHMucHVzaChncm91cCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIGdyb3VwcztcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBGdW5jacOzbiBwYXJhIHByb2Nlc2FyIHVuIHNlZ21lbnRvIHkgZGl2aWRpcmxvIGVuIG3Dumx0aXBsZXMgc2VnbWVudG9zIHNpIGVzIG5lY2VzYXJpb1xuICAgICAgICBjb25zdCBwcm9jZXNzU2VnbWVudCA9IChzZWdtZW50OiBTdWJ0aXRsZVNlZ21lbnQpOiBTdWJ0aXRsZVNlZ21lbnRbXSA9PiB7XG4gICAgICAgICAgY29uc3QgdGV4dEdyb3VwcyA9IHNwbGl0VGV4dEludG9Hcm91cHMoc2VnbWVudC50ZXh0KTtcblxuICAgICAgICAgIC8vIFNpIHNvbG8gaGF5IHVuIGdydXBvLCBkZXZvbHZlciBlbCBzZWdtZW50byBvcmlnaW5hbFxuICAgICAgICAgIGlmICh0ZXh0R3JvdXBzLmxlbmd0aCA8PSAxKSB7XG4gICAgICAgICAgICByZXR1cm4gW3NlZ21lbnRdO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIENhbGN1bGFyIGxhIGR1cmFjacOzbiBkZSBjYWRhIGdydXBvXG4gICAgICAgICAgY29uc3QgdG90YWxEdXJhdGlvbiA9IHNlZ21lbnQuZW5kVGltZSAtIHNlZ21lbnQuc3RhcnRUaW1lO1xuICAgICAgICAgIGNvbnN0IGdyb3VwRHVyYXRpb24gPSB0b3RhbER1cmF0aW9uIC8gdGV4dEdyb3Vwcy5sZW5ndGg7XG5cbiAgICAgICAgICAvLyBDcmVhciB1biBudWV2byBzZWdtZW50byBwYXJhIGNhZGEgZ3J1cG9cbiAgICAgICAgICByZXR1cm4gdGV4dEdyb3Vwcy5tYXAoKGdyb3VwVGV4dCwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHN0YXJ0VGltZSA9IHNlZ21lbnQuc3RhcnRUaW1lICsgKGluZGV4ICogZ3JvdXBEdXJhdGlvbik7XG4gICAgICAgICAgICBjb25zdCBlbmRUaW1lID0gc3RhcnRUaW1lICsgZ3JvdXBEdXJhdGlvbjtcblxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgaWQ6IHNlZ21lbnQuaWQgKiAxMDAwICsgaW5kZXgsIC8vIEdlbmVyYXIgdW4gSUQgw7puaWNvXG4gICAgICAgICAgICAgIHN0YXJ0VGltZSxcbiAgICAgICAgICAgICAgZW5kVGltZSxcbiAgICAgICAgICAgICAgdGV4dDogZ3JvdXBUZXh0XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIFVzYXIgZWwgdHJhY2tJZCBwcm9wb3JjaW9uYWRvIG8gYnVzY2FyIHVubyBleGlzdGVudGVcbiAgICAgICAgbGV0IHN1YnRpdGxlc1RyYWNrSWQgPSBvcHRpb25zPy50cmFja0lkIHx8IFwiXCI7XG5cbiAgICAgICAgaWYgKHN1YnRpdGxlc1RyYWNrSWQpIHtcbiAgICAgICAgICBjb25zb2xlLmxvZyhgVXNhbmRvIHRyYWNrSWQgcHJvcG9yY2lvbmFkbzogJHtzdWJ0aXRsZXNUcmFja0lkfWApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIEJ1c2NhciBzaSB5YSBleGlzdGUgdW4gdHJhY2sgZGUgc3VidMOtdHVsb3MgdXNhbmRvIGVsIG3DqXRvZG8gZXNwZWNpYWxpemFkb1xuICAgICAgICAgIHN1YnRpdGxlc1RyYWNrSWQgPSBhd2FpdCBleGVjdXRvci5nZXRTdWJ0aXRsZXNUcmFja0lkKCkgfHwgXCJcIjtcblxuICAgICAgICAgIC8vIFNpIHNlIGVuY29udHLDsyB1biB0cmFjayBleGlzdGVudGVcbiAgICAgICAgICBpZiAoc3VidGl0bGVzVHJhY2tJZCkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coYFVzYW5kbyB0cmFjayBkZSBzdWJ0w610dWxvcyBleGlzdGVudGU6ICR7c3VidGl0bGVzVHJhY2tJZH1gKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gU2kgbm8gc2UgZW5jb250csOzIHVuIHRyYWNrIGV4aXN0ZW50ZSwgY3JlYXIgdW5vIG51ZXZvXG4gICAgICAgICAgICBzdWJ0aXRsZXNUcmFja0lkID0gXCJzdWJ0aXRsZXMtdHJhY2stXCIgKyBnZW5lcmF0ZUlkKCk7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhgTm8gc2UgZW5jb250cmFyb24gdHJhY2tzIGRlIHN1YnTDrXR1bG9zLCBjcmVhbmRvIHVubyBudWV2bzogJHtzdWJ0aXRsZXNUcmFja0lkfWApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEZ1bmNpw7NuIHBhcmEgY3JlYXIgZWwgcGF5bG9hZCBkZSB0ZXh0byBwYXJhIHN1YnTDrXR1bG9zXG4gICAgICAgIGNvbnN0IGNyZWF0ZVN1YnRpdGxlUGF5bG9hZCA9ICh0ZXh0OiBzdHJpbmcsIHN0YXJ0VGltZTogbnVtYmVyLCBlbmRUaW1lOiBudW1iZXIpID0+ICh7XG4gICAgICAgICAgaWQ6IGdlbmVyYXRlSWQoKSxcbiAgICAgICAgICB0cmFja0lkOiBzdWJ0aXRsZXNUcmFja0lkLCAvLyBVc2FyIGVsIG1pc21vIHRyYWNrSWQgcGFyYSB0b2RvcyBsb3Mgc3VidMOtdHVsb3NcbiAgICAgICAgICBkaXNwbGF5OiB7XG4gICAgICAgICAgICBmcm9tOiBzdGFydFRpbWUsXG4gICAgICAgICAgICB0bzogZW5kVGltZSxcbiAgICAgICAgICB9LFxuICAgICAgICAgIHR5cGU6ICd0ZXh0JyxcbiAgICAgICAgICBkZXRhaWxzOiB7XG4gICAgICAgICAgICB0ZXh0OiB0ZXh0LnRvVXBwZXJDYXNlKCksIC8vIENvbnZlcnRpciBhIG1hecO6c2N1bGFzIGNvbW8gTXJCZWFzdFxuICAgICAgICAgICAgZm9udFNpemU6IDgwLCAvLyBUYW1hw7FvIG3DoXMgZ3JhbmRlIHBhcmEgZXN0aWxvIE1yQmVhc3RcbiAgICAgICAgICAgIHdpZHRoOiA5MDAsXG4gICAgICAgICAgICBmb250VXJsOiAnL2ZvbnRzL21yYmVhc3QudHRmJywgLy8gVXNhciBsYSBmdWVudGUgTXJCZWFzdFxuICAgICAgICAgICAgZm9udEZhbWlseTogJ01yQmVhc3QnLCAvLyBOb21icmUgZGUgbGEgZnVlbnRlIE1yQmVhc3RcbiAgICAgICAgICAgIGNvbG9yOiAnI0ZGRkYwMCcsIC8vIEFtYXJpbGxvIGJyaWxsYW50ZVxuICAgICAgICAgICAgd29yZFdyYXA6ICdicmVhay13b3JkJyxcbiAgICAgICAgICAgIHRleHRBbGlnbjogJ2NlbnRlcicsXG4gICAgICAgICAgICBib3JkZXJXaWR0aDogMjAsIC8vIFN0cm9rZSBuZWdybyBncnVlc29cbiAgICAgICAgICAgIGJvcmRlckNvbG9yOiAnIzAwMDAwMCcsXG4gICAgICAgICAgICBib3hTaGFkb3c6IHtcbiAgICAgICAgICAgICAgY29sb3I6ICcjMDAwMDAwJyxcbiAgICAgICAgICAgICAgeDogMyxcbiAgICAgICAgICAgICAgeTogMyxcbiAgICAgICAgICAgICAgYmx1cjogMCwgLy8gU2luIGRlc2VuZm9xdWUgcGFyYSB1biBlc3RpbG8gbcOhcyBpbXBhY3RhbnRlXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiAndHJhbnNwYXJlbnQnLCAvLyBTaW4gZm9uZG8gcGFyYSBxdWUgZGVzdGFxdWUgbcOhc1xuICAgICAgICAgICAgcGFkZGluZzogMTAsXG4gICAgICAgICAgICBib3JkZXJSYWRpdXM6IDAsIC8vIFNpbiBib3JkZXMgcmVkb25kZWFkb3MgcGFyYSB1biBlc3RpbG8gbcOhcyBpbXBhY3RhbnRlXG4gICAgICAgICAgfSxcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gQ2FyZ2FyIGVsIGFyY2hpdm8gU1JUXG4gICAgICAgIGNvbnNvbGUubG9nKFwiQ2FyZ2FuZG8gYXJjaGl2byBTUlQuLi5cIik7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goJy90cmFuc2NyaXB0aW9ucy90cmFuc2NyaXB0aW9uMS5zcnQnKTtcbiAgICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRXJyb3IgYWwgY2FyZ2FyIGVsIGFyY2hpdm8gU1JUOiAke3Jlc3BvbnNlLnN0YXR1c31gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHNydENvbnRlbnQgPSBhd2FpdCByZXNwb25zZS50ZXh0KCk7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiQXJjaGl2byBTUlQgY2FyZ2FkbyBjb3JyZWN0YW1lbnRlXCIpO1xuXG4gICAgICAgIC8vIFBhcnNlYXIgZWwgYXJjaGl2byBTUlRcbiAgICAgICAgbGV0IHNlZ21lbnRzID0gcGFyc2VTUlQoc3J0Q29udGVudCk7XG4gICAgICAgIGNvbnNvbGUubG9nKGBTZSBlbmNvbnRyYXJvbiAke3NlZ21lbnRzLmxlbmd0aH0gc2VnbWVudG9zIGRlIHN1YnTDrXR1bG9zYCk7XG5cbiAgICAgICAgLy8gU2llbXByZSB1c2FyIGVsIG1vZG8gYWdydXBhZG8gKGRpdmlkaXIgZW4gZ3J1cG9zIGRlIDMgcGFsYWJyYXMpXG4gICAgICAgIHNlZ21lbnRzID0gc2VnbWVudHMuZmxhdE1hcChwcm9jZXNzU2VnbWVudCk7XG4gICAgICAgIGNvbnNvbGUubG9nKGBEZXNwdcOpcyBkZSBwcm9jZXNhciwgaGF5ICR7c2VnbWVudHMubGVuZ3RofSBzZWdtZW50b3MgZGUgc3VidMOtdHVsb3NgKTtcblxuICAgICAgICAvLyBGaWx0cmFyIHBvciB0aWVtcG8gc2kgZXMgbmVjZXNhcmlvXG4gICAgICAgIGlmIChvcHRpb25zPy5zdGFydFRpbWUgIT09IHVuZGVmaW5lZCB8fCBvcHRpb25zPy5lbmRUaW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBjb25zdCBvcmlnaW5hbExlbmd0aCA9IHNlZ21lbnRzLmxlbmd0aDtcbiAgICAgICAgICBzZWdtZW50cyA9IHNlZ21lbnRzLmZpbHRlcihzZWdtZW50ID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHBhc3Nlc1N0YXJ0RmlsdGVyID0gb3B0aW9ucy5zdGFydFRpbWUgPT09IHVuZGVmaW5lZCB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlZ21lbnQuc3RhcnRUaW1lID49IChvcHRpb25zLnN0YXJ0VGltZSAqIDEwMDApO1xuICAgICAgICAgICAgY29uc3QgcGFzc2VzRW5kRmlsdGVyID0gb3B0aW9ucy5lbmRUaW1lID09PSB1bmRlZmluZWQgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VnbWVudC5lbmRUaW1lIDw9IChvcHRpb25zLmVuZFRpbWUgKiAxMDAwKTtcbiAgICAgICAgICAgIHJldHVybiBwYXNzZXNTdGFydEZpbHRlciAmJiBwYXNzZXNFbmRGaWx0ZXI7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgY29uc29sZS5sb2coYEZpbHRyYWRvIHBvciB0aWVtcG86IGRlICR7b3JpZ2luYWxMZW5ndGh9IGEgJHtzZWdtZW50cy5sZW5ndGh9IHNlZ21lbnRvc2ApO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQcOxYWRpciBsb3Mgc3VidMOtdHVsb3MgY29uIHVuIHJldHJhc28gZW50cmUgY2FkYSB1bm9cbiAgICAgICAgY29uc29sZS5sb2coYEHDsWFkaWVuZG8gJHtzZWdtZW50cy5sZW5ndGh9IHNlZ21lbnRvcyBkZSBzdWJ0w610dWxvcyBhbCB0aW1lbGluZSB1c2FuZG8gZWwgdHJhY2sgJHtzdWJ0aXRsZXNUcmFja0lkfS4uLmApO1xuXG4gICAgICAgIHNlZ21lbnRzLmZvckVhY2goKHNlZ21lbnQsIGluZGV4KSA9PiB7XG4gICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICBkaXNwYXRjaChBRERfVEVYVCwge1xuICAgICAgICAgICAgICBwYXlsb2FkOiBjcmVhdGVTdWJ0aXRsZVBheWxvYWQoc2VnbWVudC50ZXh0LCBzZWdtZW50LnN0YXJ0VGltZSwgc2VnbWVudC5lbmRUaW1lKSxcbiAgICAgICAgICAgICAgb3B0aW9uczoge1xuICAgICAgICAgICAgICAgIHRyYWNrSWQ6IHN1YnRpdGxlc1RyYWNrSWQgLy8gQXNlZ3VyYXIgcXVlIHNlIGVzcGVjaWZpY2EgdGFtYmnDqW4gZW4gbGFzIG9wY2lvbmVzXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaWYgKChpbmRleCArIDEpICUgMTAgPT09IDAgfHwgaW5kZXggPT09IHNlZ21lbnRzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgICAgY29uc29sZS5sb2coYFByb2dyZXNvOiAke2luZGV4ICsgMX0vJHtzZWdtZW50cy5sZW5ndGh9IHN1YnTDrXR1bG9zIGHDsWFkaWRvcyBhbCB0cmFjayAke3N1YnRpdGxlc1RyYWNrSWR9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSwgaW5kZXggKiA1MCk7IC8vIFJlZHVjaXIgZWwgcmV0cmFzbyBhIDUwbXMgcGFyYSBxdWUgc2VhIG3DoXMgcsOhcGlkb1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBhbCBhw7FhZGlyIHN1YnTDrXR1bG9zOlwiLCBlcnJvcik7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgZ2V0QWN0aXZlRWxlbWVudHM6IGFzeW5jICgpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIC8vIE9idGVuZXIgZWwgZXN0YWRvIGFjdHVhbFxuICAgICAgICBjb25zdCBzdGF0ZSA9IHN0YXRlTWFuYWdlci5nZXRTdGF0ZSgpO1xuXG4gICAgICAgIC8vIFZlcmlmaWNhciBzaSBoYXkgSURzIGFjdGl2b3NcbiAgICAgICAgaWYgKCFzdGF0ZS5hY3RpdmVJZHMgfHwgc3RhdGUuYWN0aXZlSWRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIGNvbnNvbGUubG9nKFwiTm8gaGF5IGVsZW1lbnRvcyBhY3Rpdm9zIHNlbGVjY2lvbmFkb3NcIik7XG4gICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVmVyaWZpY2FyIHNpIGhheSBlbGVtZW50b3MgZW4gZWwgdHJhY2tJdGVtc01hcFxuICAgICAgICBpZiAoIXN0YXRlLnRyYWNrSXRlbXNNYXApIHtcbiAgICAgICAgICBjb25zb2xlLmxvZyhcIk5vIGhheSB0cmFja0l0ZW1zTWFwIGRpc3BvbmlibGVcIik7XG4gICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gT2J0ZW5lciBpbmZvcm1hY2nDs24gZGUgbG9zIGVsZW1lbnRvcyBhY3Rpdm9zXG4gICAgICAgIGNvbnN0IGFjdGl2ZUVsZW1lbnRzID0gc3RhdGUuYWN0aXZlSWRzXG4gICAgICAgICAgLmZpbHRlcihpZCA9PiBzdGF0ZS50cmFja0l0ZW1zTWFwW2lkXSlcbiAgICAgICAgICAubWFwKGlkID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGl0ZW0gPSBzdGF0ZS50cmFja0l0ZW1zTWFwW2lkXTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgICB0cmFja0lkOiBpdGVtLnRyYWNrSWQsXG4gICAgICAgICAgICAgIHR5cGU6IGl0ZW0udHlwZSxcbiAgICAgICAgICAgICAgZnJvbTogaXRlbS5kaXNwbGF5Py5mcm9tLFxuICAgICAgICAgICAgICB0bzogaXRlbS5kaXNwbGF5Py50byxcbiAgICAgICAgICAgICAgZHVyYXRpb246IGl0ZW0uZGlzcGxheSA/IChpdGVtLmRpc3BsYXkudG8gLSBpdGVtLmRpc3BsYXkuZnJvbSkgOiAwLFxuICAgICAgICAgICAgICBkZXRhaWxzOiBpdGVtLmRldGFpbHNcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgY29uc29sZS5sb2coYFNlIGVuY29udHJhcm9uICR7YWN0aXZlRWxlbWVudHMubGVuZ3RofSBlbGVtZW50b3MgYWN0aXZvc2ApO1xuICAgICAgICByZXR1cm4gYWN0aXZlRWxlbWVudHM7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgYWwgb2J0ZW5lciBlbGVtZW50b3MgYWN0aXZvczpcIiwgZXJyb3IpO1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgfSxcblxuICAgIGdldEFsbFRpbWVsaW5lRWxlbWVudHM6IGFzeW5jICgpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIC8vIE9idGVuZXIgZWwgZXN0YWRvIGFjdHVhbFxuICAgICAgICBjb25zdCBzdGF0ZSA9IHN0YXRlTWFuYWdlci5nZXRTdGF0ZSgpO1xuXG4gICAgICAgIC8vIFZlcmlmaWNhciBzaSBoYXkgZWxlbWVudG9zIGVuIGVsIHRyYWNrSXRlbXNNYXBcbiAgICAgICAgaWYgKCFzdGF0ZS50cmFja0l0ZW1zTWFwIHx8IE9iamVjdC5rZXlzKHN0YXRlLnRyYWNrSXRlbXNNYXApLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIGNvbnNvbGUubG9nKFwiTm8gaGF5IGVsZW1lbnRvcyBlbiBlbCB0cmFja0l0ZW1zTWFwXCIpO1xuXG4gICAgICAgICAgLy8gQnVzY2FyIGVsZW1lbnRvcyBlbiBvdHJhcyBwcm9waWVkYWRlcyBkZWwgZXN0YWRvXG4gICAgICAgICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMoc3RhdGUpKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHN0YXRlW2tleV0gPT09ICdvYmplY3QnICYmIHN0YXRlW2tleV0gIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgY29uc3Qgb2JqVmFsdWUgPSBzdGF0ZVtrZXldO1xuICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgRXhwbG9yYW5kbyBwcm9waWVkYWQgYWx0ZXJuYXRpdmE6ICR7a2V5fWApO1xuXG4gICAgICAgICAgICAgIC8vIFZlcmlmaWNhciBzaSBwYXJlY2Ugc2VyIHVuIG1hcGEgZGUgZWxlbWVudG9zXG4gICAgICAgICAgICAgIGlmIChPYmplY3Qua2V5cyhvYmpWYWx1ZSkubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHNhbXBsZSA9IG9ialZhbHVlW09iamVjdC5rZXlzKG9ialZhbHVlKVswXV07XG4gICAgICAgICAgICAgICAgaWYgKHNhbXBsZSAmJiBzYW1wbGUuZGlzcGxheSAmJiBzYW1wbGUudHlwZSkge1xuICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coYEVuY29udHJhZGEgcG9zaWJsZSBmdWVudGUgYWx0ZXJuYXRpdmEgZGUgZWxlbWVudG9zIGVuIHByb3BpZWRhZCAke2tleX1gKTtcblxuICAgICAgICAgICAgICAgICAgLy8gUHJvY2VzYXIgZWxlbWVudG9zIGRlIGVzdGEgcHJvcGllZGFkIGFsdGVybmF0aXZhXG4gICAgICAgICAgICAgICAgICByZXR1cm4gT2JqZWN0LmVudHJpZXMob2JqVmFsdWUpXG4gICAgICAgICAgICAgICAgICAgIC5maWx0ZXIoKFtfLCBpdGVtXSkgPT4gaXRlbSAmJiBpdGVtLmRpc3BsYXkpXG4gICAgICAgICAgICAgICAgICAgIC5tYXAoKFtpZCwgaXRlbV0pID0+ICh7XG4gICAgICAgICAgICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICAgICAgICAgICAgdHJhY2tJZDogaXRlbS50cmFja0lkLFxuICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IGl0ZW0udHlwZSxcbiAgICAgICAgICAgICAgICAgICAgICBmcm9tOiBpdGVtLmRpc3BsYXk/LmZyb20sXG4gICAgICAgICAgICAgICAgICAgICAgdG86IGl0ZW0uZGlzcGxheT8udG8sXG4gICAgICAgICAgICAgICAgICAgICAgZHVyYXRpb246IGl0ZW0uZGlzcGxheSA/IChpdGVtLmRpc3BsYXkudG8gLSBpdGVtLmRpc3BsYXkuZnJvbSkgOiAwLFxuICAgICAgICAgICAgICAgICAgICAgIGRldGFpbHM6IGl0ZW0uZGV0YWlsc1xuICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gT2J0ZW5lciB0b2RvcyBsb3MgZWxlbWVudG9zXG4gICAgICAgIGNvbnN0IGFsbEVsZW1lbnRzID0gT2JqZWN0LmVudHJpZXMoc3RhdGUudHJhY2tJdGVtc01hcClcbiAgICAgICAgICAuZmlsdGVyKChbXywgaXRlbV0pID0+IGl0ZW0gJiYgaXRlbS5kaXNwbGF5KVxuICAgICAgICAgIC5tYXAoKFtpZCwgaXRlbV0pID0+ICh7XG4gICAgICAgICAgICBpZCxcbiAgICAgICAgICAgIHRyYWNrSWQ6IGl0ZW0udHJhY2tJZCxcbiAgICAgICAgICAgIHR5cGU6IGl0ZW0udHlwZSxcbiAgICAgICAgICAgIGZyb206IGl0ZW0uZGlzcGxheT8uZnJvbSxcbiAgICAgICAgICAgIHRvOiBpdGVtLmRpc3BsYXk/LnRvLFxuICAgICAgICAgICAgZHVyYXRpb246IGl0ZW0uZGlzcGxheSA/IChpdGVtLmRpc3BsYXkudG8gLSBpdGVtLmRpc3BsYXkuZnJvbSkgOiAwLFxuICAgICAgICAgICAgZGV0YWlsczogaXRlbS5kZXRhaWxzXG4gICAgICAgICAgfSkpXG4gICAgICAgICAgLnNvcnQoKGEsIGIpID0+IChhLmZyb20gfHwgMCkgLSAoYi5mcm9tIHx8IDApKTtcblxuICAgICAgICBjb25zb2xlLmxvZyhgU2UgZW5jb250cmFyb24gJHthbGxFbGVtZW50cy5sZW5ndGh9IGVsZW1lbnRvcyBlbiBlbCB0aW1lbGluZWApO1xuICAgICAgICByZXR1cm4gYWxsRWxlbWVudHM7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgYWwgb2J0ZW5lciB0b2RvcyBsb3MgZWxlbWVudG9zIGRlbCB0aW1lbGluZTpcIiwgZXJyb3IpO1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgfSxcblxuICAgIHJlbW92ZVNlZ21lbnRzOiBhc3luYyAoc2VnbWVudHM6IFRpbWVTZWdtZW50W10pID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiSW5pY2lhbmRvIGVsaW1pbmFjacOzbiBkZSBzZWdtZW50b3MgbcO6bHRpcGxlc1wiKTtcblxuICAgICAgICAvLyBPYnRlbmVyIGVsIGVzdGFkbyBhY3R1YWxcbiAgICAgICAgY29uc3Qgc3RhdGUgPSBzdGF0ZU1hbmFnZXIuZ2V0U3RhdGUoKTtcblxuICAgICAgICAvLyBWYWxpZGFyIHF1ZSBoYXlhIGVsZW1lbnRvcyBlbiBsYSB0aW1lbGluZVxuICAgICAgICBpZiAoIXN0YXRlLmFjdGl2ZUlkcyB8fCBzdGF0ZS5hY3RpdmVJZHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihcIk5vIGhheSBlbGVtZW50b3Mgc2VsZWNjaW9uYWRvcyBlbiBsYSB0aW1lbGluZVwiKTtcblxuICAgICAgICAgIC8vIEJ1c2NhciBlbCBwcmltZXIgZWxlbWVudG8gZGlzcG9uaWJsZSBlbiBsYSB0aW1lbGluZVxuICAgICAgICAgIGNvbnN0IHRyYWNrSXRlbXNNYXAgPSBzdGF0ZS50cmFja0l0ZW1zTWFwIHx8IHt9O1xuICAgICAgICAgIGNvbnN0IHRyYWNrSXRlbXMgPSBPYmplY3Qua2V5cyh0cmFja0l0ZW1zTWFwKTtcblxuICAgICAgICAgIGlmICh0cmFja0l0ZW1zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIk5vIGhheSBlbGVtZW50b3MgZW4gbGEgdGltZWxpbmUgcGFyYSBlbGltaW5hciBzZWdtZW50b3NcIik7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBoYXkgZWxlbWVudG9zIGVuIGxhIHRpbWVsaW5lXCIpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIFNlbGVjY2lvbmFyIGVsIHByaW1lciBlbGVtZW50byBkaXNwb25pYmxlXG4gICAgICAgICAgY29uc3QgZmlyc3RJdGVtSWQgPSB0cmFja0l0ZW1zWzBdO1xuICAgICAgICAgIGNvbnNvbGUubG9nKGBTZWxlY2Npb25hbmRvIGF1dG9tw6F0aWNhbWVudGUgZWwgZWxlbWVudG8gY29uIElEOiAke2ZpcnN0SXRlbUlkfWApO1xuXG4gICAgICAgICAgZGlzcGF0Y2goTEFZRVJfU0VMRUNULCB7XG4gICAgICAgICAgICBwYXlsb2FkOiB7XG4gICAgICAgICAgICAgIGlkczogW2ZpcnN0SXRlbUlkXVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgLy8gRXNwZXJhciBhIHF1ZSBzZSBhcGxpcXVlIGxhIHNlbGVjY2nDs25cbiAgICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgMzAwKSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBBbG1hY2VuYW1vcyBpbmZvcm1hY2nDs24gZGVsIGVsZW1lbnRvIHNlbGVjY2lvbmFkb1xuICAgICAgICBjb25zdCBjdXJyZW50U3RhdGUgPSBzdGF0ZU1hbmFnZXIuZ2V0U3RhdGUoKTtcbiAgICAgICAgaWYgKCFjdXJyZW50U3RhdGUuYWN0aXZlSWRzIHx8IGN1cnJlbnRTdGF0ZS5hY3RpdmVJZHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gc2UgcHVkbyBzZWxlY2Npb25hciBuaW5nw7puIGVsZW1lbnRvIGVuIGxhIHRpbWVsaW5lXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qgb3JpZ2luYWxJdGVtSWQgPSBjdXJyZW50U3RhdGUuYWN0aXZlSWRzWzBdO1xuICAgICAgICBjb25zdCBvcmlnaW5hbEl0ZW0gPSBjdXJyZW50U3RhdGUudHJhY2tJdGVtc01hcFtvcmlnaW5hbEl0ZW1JZF07XG4gICAgICAgIGNvbnN0IHRyYWNrVHlwZSA9IG9yaWdpbmFsSXRlbS50eXBlO1xuICAgICAgICBjb25zdCB0cmFja0lkID0gb3JpZ2luYWxJdGVtLnRyYWNrSWQ7XG5cbiAgICAgICAgY29uc29sZS5sb2coYEVsZW1lbnRvIHNlbGVjY2lvbmFkbzogSUQ9JHtvcmlnaW5hbEl0ZW1JZH0sIHRpcG89JHt0cmFja1R5cGV9LCB0cmFja0lkPSR7dHJhY2tJZH1gKTtcblxuICAgICAgICAvLyBQcm9jZXNhciBjYWRhIHNlZ21lbnRvIGVuIG9yZGVuIChkZSBmaW5hbCBhIHByaW5jaXBpbyBwYXJhIGV2aXRhciBhZmVjdGFyIHBvc2ljaW9uZXMpXG4gICAgICAgIGZvciAobGV0IGkgPSBzZWdtZW50cy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgIGNvbnN0IHNlZ21lbnQgPSBzZWdtZW50c1tpXTtcbiAgICAgICAgICBjb25zb2xlLmxvZyhgUHJvY2VzYW5kbyBzZWdtZW50byAke2krMX0vJHtzZWdtZW50cy5sZW5ndGh9OiAke3NlZ21lbnQuc3RhcnRUaW1lfXMgLSAke3NlZ21lbnQuZW5kVGltZX1zYCk7XG5cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gUEFTTyAxOiBIYWNlciB1biBjb3J0ZSBlbiBlbCB0aWVtcG8gZmluYWxcbiAgICAgICAgICAgIGNvbnN0IGVuZE1zID0gc2VnbWVudC5lbmRUaW1lICogMTAwMDtcbiAgICAgICAgICAgIGRpc3BhdGNoKEFDVElWRV9TUExJVCwge1xuICAgICAgICAgICAgICBwYXlsb2FkOiB7fSxcbiAgICAgICAgICAgICAgb3B0aW9uczoge1xuICAgICAgICAgICAgICAgIHRpbWU6IGVuZE1zLFxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhgUGFzbyAxOiBDb3J0ZSBhcGxpY2FkbyBlbiB0aWVtcG8gZmluYWwgJHtzZWdtZW50LmVuZFRpbWV9c2ApO1xuXG4gICAgICAgICAgICAvLyBFc3BlcmFyIGEgcXVlIHNlIHByb2Nlc2UgZWwgcHJpbWVyIGNvcnRlXG4gICAgICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgNTAwKSk7XG5cbiAgICAgICAgICAgIC8vIE9idGVuZW1vcyBlbCBlc3RhZG8gZGVzcHXDqXMgZGVsIHByaW1lciBjb3J0ZVxuICAgICAgICAgICAgY29uc3Qgc3RhdGVBZnRlckZpcnN0Q3V0ID0gc3RhdGVNYW5hZ2VyLmdldFN0YXRlKCk7XG4gICAgICAgICAgICBjb25zdCBlbGVtZW50c0FmdGVyRmlyc3RDdXQgPSBPYmplY3QuZW50cmllcyhzdGF0ZUFmdGVyRmlyc3RDdXQudHJhY2tJdGVtc01hcClcbiAgICAgICAgICAgICAgLmZpbHRlcigoW18sIGl0ZW1dKSA9PlxuICAgICAgICAgICAgICAgIGl0ZW0udHlwZSA9PT0gdHJhY2tUeXBlICYmXG4gICAgICAgICAgICAgICAgaXRlbS50cmFja0lkID09PSB0cmFja0lkICYmXG4gICAgICAgICAgICAgICAgaXRlbS5kaXNwbGF5ICYmXG4gICAgICAgICAgICAgICAgIWlzTmFOKGl0ZW0uZGlzcGxheS5mcm9tKSAmJlxuICAgICAgICAgICAgICAgICFpc05hTihpdGVtLmRpc3BsYXkudG8pXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgLm1hcCgoW2lkLCBpdGVtXSkgPT4gKHtcbiAgICAgICAgICAgICAgICBpZCxcbiAgICAgICAgICAgICAgICBmcm9tOiBpdGVtLmRpc3BsYXkuZnJvbSxcbiAgICAgICAgICAgICAgICB0bzogaXRlbS5kaXNwbGF5LnRvLFxuICAgICAgICAgICAgICAgIGR1cmFjacOzbjogaXRlbS5kaXNwbGF5LnRvIC0gaXRlbS5kaXNwbGF5LmZyb21cbiAgICAgICAgICAgICAgfSkpXG4gICAgICAgICAgICAgIC5zb3J0KChhLCBiKSA9PiBhLmZyb20gLSBiLmZyb20pO1xuXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIkVsZW1lbnRvcyBkZXNwdcOpcyBkZWwgcHJpbWVyIGNvcnRlOlwiLCBlbGVtZW50c0FmdGVyRmlyc3RDdXQpO1xuXG4gICAgICAgICAgICAvLyBQQVNPIDI6IElkZW50aWZpY2FyIGVsIGVsZW1lbnRvIGl6cXVpZXJkbyBxdWUgY29udGllbmUgZWwgdGllbXBvIGluaWNpYWxcbiAgICAgICAgICAgIGNvbnN0IHN0YXJ0TXMgPSBzZWdtZW50LnN0YXJ0VGltZSAqIDEwMDA7XG4gICAgICAgICAgICBjb25zdCBsZWZ0RWxlbWVudCA9IGVsZW1lbnRzQWZ0ZXJGaXJzdEN1dC5maW5kKGVsZW0gPT5cbiAgICAgICAgICAgICAgZWxlbS5mcm9tIDw9IHN0YXJ0TXMgJiYgZWxlbS50byA+PSBzdGFydE1zXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICBpZiAoIWxlZnRFbGVtZW50KSB7XG4gICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYE5vIHNlIHB1ZG8gaWRlbnRpZmljYXIgZWwgZWxlbWVudG8gaXpxdWllcmRvIHBhcmEgZWwgc2VnbWVudG8gJHtpKzF9YCk7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhgUGFzbyAyOiBFbGVtZW50byBpenF1aWVyZG8gaWRlbnRpZmljYWRvIChJRDogJHtsZWZ0RWxlbWVudC5pZH0pYCk7XG5cbiAgICAgICAgICAgIC8vIFBBU08gMzogU2VsZWNjaW9uYXIgZWwgZWxlbWVudG8gaXpxdWllcmRvIHkgaGFjZXIgY29ydGUgZW4gdGllbXBvIGluaWNpYWxcbiAgICAgICAgICAgIGRpc3BhdGNoKExBWUVSX1NFTEVDVCwge1xuICAgICAgICAgICAgICBwYXlsb2FkOiB7XG4gICAgICAgICAgICAgICAgaWRzOiBbbGVmdEVsZW1lbnQuaWRdXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvLyBFc3BlcmFyIGEgcXVlIHNlIGFwbGlxdWUgbGEgc2VsZWNjacOzblxuICAgICAgICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDMwMCkpO1xuXG4gICAgICAgICAgICAvLyBBcGxpY2FyIGVsIGNvcnRlIGVuIGVsIHRpZW1wbyBpbmljaWFsXG4gICAgICAgICAgICBkaXNwYXRjaChBQ1RJVkVfU1BMSVQsIHtcbiAgICAgICAgICAgICAgcGF5bG9hZDoge30sXG4gICAgICAgICAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgICAgICAgICB0aW1lOiBzdGFydE1zLFxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhgUGFzbyAzOiBTZWd1bmRvIGNvcnRlIGFwbGljYWRvIGVuIHRpZW1wbyBpbmljaWFsICR7c2VnbWVudC5zdGFydFRpbWV9c2ApO1xuXG4gICAgICAgICAgICAvLyBFc3BlcmFyIGEgcXVlIHNlIHByb2Nlc2UgZWwgc2VndW5kbyBjb3J0ZVxuICAgICAgICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDUwMCkpO1xuXG4gICAgICAgICAgICAvLyBPYnRlbmVtb3MgZWwgZXN0YWRvIGRlc3B1w6lzIGRlbCBzZWd1bmRvIGNvcnRlXG4gICAgICAgICAgICBjb25zdCBzdGF0ZUFmdGVyU2Vjb25kQ3V0ID0gc3RhdGVNYW5hZ2VyLmdldFN0YXRlKCk7XG4gICAgICAgICAgICBjb25zdCBlbGVtZW50c0FmdGVyU2Vjb25kQ3V0ID0gT2JqZWN0LmVudHJpZXMoc3RhdGVBZnRlclNlY29uZEN1dC50cmFja0l0ZW1zTWFwKVxuICAgICAgICAgICAgICAuZmlsdGVyKChbXywgaXRlbV0pID0+XG4gICAgICAgICAgICAgICAgaXRlbS50eXBlID09PSB0cmFja1R5cGUgJiZcbiAgICAgICAgICAgICAgICBpdGVtLnRyYWNrSWQgPT09IHRyYWNrSWQgJiZcbiAgICAgICAgICAgICAgICBpdGVtLmRpc3BsYXkgJiZcbiAgICAgICAgICAgICAgICAhaXNOYU4oaXRlbS5kaXNwbGF5LmZyb20pICYmXG4gICAgICAgICAgICAgICAgIWlzTmFOKGl0ZW0uZGlzcGxheS50bylcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAubWFwKChbaWQsIGl0ZW1dKSA9PiAoe1xuICAgICAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgICAgIGZyb206IGl0ZW0uZGlzcGxheS5mcm9tLFxuICAgICAgICAgICAgICAgIHRvOiBpdGVtLmRpc3BsYXkudG8sXG4gICAgICAgICAgICAgICAgZHVyYWNpw7NuOiBpdGVtLmRpc3BsYXkudG8gLSBpdGVtLmRpc3BsYXkuZnJvbVxuICAgICAgICAgICAgICB9KSlcbiAgICAgICAgICAgICAgLnNvcnQoKGEsIGIpID0+IGEuZnJvbSAtIGIuZnJvbSk7XG5cbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiRWxlbWVudG9zIGRlc3B1w6lzIGRlbCBzZWd1bmRvIGNvcnRlOlwiLCBlbGVtZW50c0FmdGVyU2Vjb25kQ3V0KTtcblxuICAgICAgICAgICAgLy8gUEFTTyA0OiBJZGVudGlmaWNhciBlbCBlbGVtZW50byBkZWwgbWVkaW8gdXNhbmRvIGNyaXRlcmlvcyBtw6FzIHByZWNpc29zXG4gICAgICAgICAgICBjb25zdCBtaWRkbGVFbGVtZW50cyA9IGVsZW1lbnRzQWZ0ZXJTZWNvbmRDdXQuZmlsdGVyKGVsZW0gPT5cbiAgICAgICAgICAgICAgTWF0aC5hYnMoZWxlbS5mcm9tIC0gc3RhcnRNcykgPCA1MCAmJiBNYXRoLmFicyhlbGVtLnRvIC0gZW5kTXMpIDwgNTBcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiRWxlbWVudG9zIHF1ZSBjb2luY2lkZW4gY29uIGxvcyBjcml0ZXJpb3MgZGVsIG1lZGlvOlwiLCBtaWRkbGVFbGVtZW50cyk7XG5cbiAgICAgICAgICAgIGlmIChtaWRkbGVFbGVtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihgTm8gc2UgcHVkbyBpZGVudGlmaWNhciBlbCBlbGVtZW50byBkZWwgbWVkaW8gcGFyYSBlbCBzZWdtZW50byAke2krMX1gKTtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFNpIGhheSBtw6FzIGRlIHVuIGVsZW1lbnRvIHF1ZSBjb2luY2lkZSwgdG9tYW1vcyBlbCBwcmltZXJvXG4gICAgICAgICAgICBjb25zdCBtaWRkbGVFbGVtZW50ID0gbWlkZGxlRWxlbWVudHNbMF07XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhgUGFzbyA0OiBFbGVtZW50byBkZWwgbWVkaW8gaWRlbnRpZmljYWRvIChJRDogJHttaWRkbGVFbGVtZW50LmlkfSlgKTtcblxuICAgICAgICAgICAgLy8gUEFTTyA1OiBTZWxlY2Npb25hciB5IGVsaW1pbmFyIGVsIGVsZW1lbnRvIGRlbCBtZWRpb1xuICAgICAgICAgICAgZGlzcGF0Y2goTEFZRVJfU0VMRUNULCB7XG4gICAgICAgICAgICAgIHBheWxvYWQ6IHtcbiAgICAgICAgICAgICAgICBpZHM6IFttaWRkbGVFbGVtZW50LmlkXVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgLy8gRXNwZXJhciBhIHF1ZSBzZSBhcGxpcXVlIGxhIHNlbGVjY2nDs25cbiAgICAgICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCAzMDApKTtcblxuICAgICAgICAgICAgLy8gVmVyaWZpY2FyIHF1ZSBlbCBlbGVtZW50byBlc3TDoSBzZWxlY2Npb25hZG8gYW50ZXMgZGUgZWxpbWluYXJsb1xuICAgICAgICAgICAgY29uc3QgY3VycmVudFN0YXRlID0gc3RhdGVNYW5hZ2VyLmdldFN0YXRlKCk7XG4gICAgICAgICAgICBpZiAoY3VycmVudFN0YXRlLmFjdGl2ZUlkcyAmJiBjdXJyZW50U3RhdGUuYWN0aXZlSWRzLmluY2x1ZGVzKG1pZGRsZUVsZW1lbnQuaWQpKSB7XG4gICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBFbGVtZW50byBkZWwgbWVkaW8gY29ycmVjdGFtZW50ZSBzZWxlY2Npb25hZG8sIHByb2NlZGllbmRvIGNvbiBlbGltaW5hY2nDs25gKTtcbiAgICAgICAgICAgICAgZGlzcGF0Y2goTEFZRVJfREVMRVRFKTtcbiAgICAgICAgICAgICAgY29uc29sZS5sb2coYEVsZW1lbnRvIGVsaW1pbmFkbyBjb3JyZWN0YW1lbnRlOiAke21pZGRsZUVsZW1lbnQuaWR9YCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgTm8gc2UgcHVkbyBzZWxlY2Npb25hciBub3JtYWxtZW50ZSwgaW50ZW50YW5kbyBtw6l0b2RvIGFsdGVybmF0aXZvYCk7XG5cbiAgICAgICAgICAgICAgLy8gRW5mb3F1ZSBhbHRlcm5hdGl2bzogVXNhciBlbCBFRElUX09CSkVDVCBwYXJhIFwib2N1bHRhclwiIGVsIHNlZ21lbnRvXG4gICAgICAgICAgICAgIGRpc3BhdGNoKEVESVRfT0JKRUNULCB7XG4gICAgICAgICAgICAgICAgcGF5bG9hZDoge1xuICAgICAgICAgICAgICAgICAgW21pZGRsZUVsZW1lbnQuaWRdOiB7XG4gICAgICAgICAgICAgICAgICAgIGRpc3BsYXk6IHtcbiAgICAgICAgICAgICAgICAgICAgICBmcm9tOiAtOTk5OTksIC8vIFVuIHZhbG9yIGZ1ZXJhIGRlbCByYW5nbyB2aXNpYmxlXG4gICAgICAgICAgICAgICAgICAgICAgdG86IC05OTk5MFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB2aXNpYmxlOiBmYWxzZSAvLyBBZGljaW9uYWxtZW50ZSBtYXJjYXJsbyBjb21vIG5vIHZpc2libGVcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgQXBsaWNhZG8gbcOpdG9kbyBhbHRlcm5hdGl2byBwYXJhIG9jdWx0YXIgZWwgc2VnbWVudG9gKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gRXNwZXJhciBhIHF1ZSBzZSBwcm9jZXNlIGxhIGVsaW1pbmFjacOzblxuICAgICAgICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDUwMCkpO1xuXG4gICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIGFsIHByb2Nlc2FyIGVsIHNlZ21lbnRvICR7aSsxfTpgLCBlcnJvcik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gUGF1c2EgZW50cmUgc2VnbWVudG9zXG4gICAgICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDUwMCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQWN0dWFsaXphciBsYSBlc2NhbGEgcGFyYSByZWZyZXNjYXIgbGEgdmlzdGFcbiAgICAgICAgY29uc3QgeyBzY2FsZSB9ID0gc3RhdGVNYW5hZ2VyLmdldFN0YXRlKCk7XG4gICAgICAgIGlmIChzY2FsZSkge1xuICAgICAgICAgIGNvbnNvbGUubG9nKFwiQWN0dWFsaXphbmRvIGVzY2FsYSBwYXJhIHJlZnJlc2NhciBsYSB2aXN0YVwiKTtcblxuICAgICAgICAgIC8vIEd1YXJkYXIgZWwgdmFsb3IgYWN0dWFsIGRlIHNjYWxlLnVuaXRcbiAgICAgICAgICBjb25zdCBvcmlnaW5hbFVuaXQgPSBzY2FsZS51bml0O1xuXG4gICAgICAgICAgLy8gSW5jcmVtZW50YXIgZWwgdmFsb3JcbiAgICAgICAgICBzY2FsZS51bml0ICs9IDE7XG4gICAgICAgICAgY29uc29sZS5sb2coYFNjYWxlIGNhbWJpYWRhOiAke29yaWdpbmFsVW5pdH0gLT4gJHtzY2FsZS51bml0fWApO1xuXG4gICAgICAgICAgLy8gQXNlZ3VyYXIgcXVlIGVsIGNhbWJpbyBzZWEgbm90YWRvIHBvciBlbCBzaXN0ZW1hXG4gICAgICAgICAgZGlzcGF0Y2goVElNRUxJTkVfU0NBTEVfQ0hBTkdFRCwge1xuICAgICAgICAgICAgcGF5bG9hZDoge1xuICAgICAgICAgICAgICBzY2FsZToge1xuICAgICAgICAgICAgICAgIC4uLnNjYWxlLCAgLy8gSW5jbHVpciB0b2RhcyBsYXMgcHJvcGllZGFkZXMgZGUgc2NhbGVcbiAgICAgICAgICAgICAgICB1bml0OiBzY2FsZS51bml0ICAvLyBFeHBsw61jaXRhbWVudGUgZXN0YWJsZWNlciBlbCBudWV2byB2YWxvclxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIC8vIEZvcnphciB1bmEgYWN0dWFsaXphY2nDs24gYWRpY2lvbmFsIHZvbHZpZW5kbyBhbCB2YWxvciBvcmlnaW5hbCBkZXNwdcOpcyBkZSB1biBtb21lbnRvXG4gICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBjdXJyZW50U3RhdGUgPSBzdGF0ZU1hbmFnZXIuZ2V0U3RhdGUoKTtcbiAgICAgICAgICAgIGlmIChjdXJyZW50U3RhdGUuc2NhbGUpIHtcbiAgICAgICAgICAgICAgZGlzcGF0Y2goVElNRUxJTkVfU0NBTEVfQ0hBTkdFRCwge1xuICAgICAgICAgICAgICAgIHBheWxvYWQ6IHtcbiAgICAgICAgICAgICAgICAgIHNjYWxlOiB7XG4gICAgICAgICAgICAgICAgICAgIC4uLmN1cnJlbnRTdGF0ZS5zY2FsZSxcbiAgICAgICAgICAgICAgICAgICAgdW5pdDogb3JpZ2luYWxVbml0ICAvLyBWb2x2ZXIgYWwgdmFsb3Igb3JpZ2luYWxcbiAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgY29uc29sZS5sb2coYFJlc3RhdXJhZG8gc2NhbGUgYSB2YWxvciBvcmlnaW5hbDogJHtvcmlnaW5hbFVuaXR9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSwgMzAwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnNvbGUubG9nKFwiRWxpbWluYWNpw7NuIGRlIHNlZ21lbnRvcyBjb21wbGV0YWRhXCIpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBhbCBlbGltaW5hciBzZWdtZW50b3M6XCIsIGVycm9yKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBjb21wYWN0VGltZWxpbmU6IGFzeW5jICgpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiPT09IElOSUNJQU5ETyBDT01QQUNUQUNJw5NOIERFIEzDjU5FQSBERSBUSUVNUE8gREVTREUgSUEgPT09XCIpO1xuXG4gICAgICAgIC8vIE9idGVuZXIgZWwgZXN0YWRvIGFjdHVhbFxuICAgICAgICBjb25zdCBlc3RhZG8gPSBzdGF0ZU1hbmFnZXIuZ2V0U3RhdGUoKTtcbiAgICAgICAgY29uc29sZS5sb2coXCJFc3RhZG8gcGFyYSBjb21wYWN0YWNpw7NuOlwiLCBPYmplY3Qua2V5cyhlc3RhZG8pKTtcblxuICAgICAgICAvLyBBw7FhZGlyIHVuIHRpZW1wbyBkZSBlc3BlcmEgaW5pY2lhbCBwYXJhIGFzZWd1cmFyIHF1ZSBlbCBlc3RhZG8gZXN0w6EgYWN0dWFsaXphZG9cbiAgICAgICAgY29uc29sZS5sb2coXCJFc3BlcmFuZG8gMSBzZWd1bmRvIHBhcmEgYXNlZ3VyYXIgY29uc2lzdGVuY2lhIGRlbCBlc3RhZG8uLi5cIik7XG4gICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCAxMDAwKSk7XG5cbiAgICAgICAgLy8gVmVyaWZpY2FjacOzbiBhZGljaW9uYWwgcGFyYSBhc2VndXJhcm5vcyBxdWUgbG9zIGNhbWJpb3MgZW4gbGEgdGltZWxpbmUgeWEgc2UgYXBsaWNhcm9uXG4gICAgICAgIGNvbnNvbGUubG9nKFwiVmVyaWZpY2FuZG8gcXVlIGxvcyBlbGVtZW50b3MgZW4gbGEgdGltZWxpbmUgcmVmbGVqZW4gbG9zIGNhbWJpb3MgbcOhcyByZWNpZW50ZXMuLi5cIik7XG5cbiAgICAgICAgLy8gUGVxdWXDsWEgcGF1c2EgYWRpY2lvbmFsIHBhcmEgYXNlZ3VyYXIgY29uc2lzdGVuY2lhIGRlbCBlc3RhZG9cbiAgICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDUwMCkpO1xuXG4gICAgICAgIC8vIEJ1c2NhciBsb3MgZWxlbWVudG9zIGRlbCB0aW1lbGluZSAtIHVzYW5kbyBsYSByZWZlcmVuY2lhIGFsIG3DqXRvZG8gZGVudHJvIGRlbCBtaXNtbyBvYmpldG9cbiAgICAgICAgY29uc3QgdG9kb3NFbGVtZW50b3MgPSBhd2FpdCBleGVjdXRvci5nZXRBbGxUaW1lbGluZUVsZW1lbnRzKCk7XG4gICAgICAgIGNvbnNvbGUubG9nKGBFbmNvbnRyYWRvcyAke3RvZG9zRWxlbWVudG9zLmxlbmd0aH0gZWxlbWVudG9zIGVuIGxhIHRpbWVsaW5lYCk7XG5cbiAgICAgICAgLy8gTG9nZ2luZyBkZSBlbGVtZW50b3MgcGFyYSBkaWFnbsOzc3RpY29cbiAgICAgICAgdG9kb3NFbGVtZW50b3MuZm9yRWFjaCgoZWxlbSwgaW5kZXgpID0+IHtcbiAgICAgICAgICBjb25zb2xlLmxvZyhgRWxlbWVudG8gJHtpbmRleCArIDF9OiBJRD0ke2VsZW0uaWR9LCBUaXBvPSR7ZWxlbS50eXBlfSwgVHJhY2s9JHtlbGVtLnRyYWNrSWR9LCBUaWVtcG89JHtlbGVtLmZyb219bXMtJHtlbGVtLnRvfW1zIChkdXJhY2nDs249JHtlbGVtLnRvLWVsZW0uZnJvbX1tcylgKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gU2kgbm8gaGF5IGVsZW1lbnRvcywgbm8gcG9kZW1vcyBjb21wYWN0YXJcbiAgICAgICAgaWYgKHRvZG9zRWxlbWVudG9zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIGNvbnNvbGUubG9nKFwiTm8gaGF5IGVsZW1lbnRvcyBlbiBlbCB0aW1lbGluZSBwYXJhIGNvbXBhY3RhclwiKTtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBBZ3J1cGFyIGVsZW1lbnRvcyBwb3IgdHJhY2sgcGFyYSBhbsOhbGlzaXNcbiAgICAgICAgY29uc3QgZWxlbWVudG9zUG9yVHJhY2sgPSB7fTtcbiAgICAgICAgdG9kb3NFbGVtZW50b3MuZm9yRWFjaChlbGVtID0+IHtcbiAgICAgICAgICBpZiAoZWxlbS50cmFja0lkKSB7XG4gICAgICAgICAgICBpZiAoIWVsZW1lbnRvc1BvclRyYWNrW2VsZW0udHJhY2tJZF0pIHtcbiAgICAgICAgICAgICAgZWxlbWVudG9zUG9yVHJhY2tbZWxlbS50cmFja0lkXSA9IFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxlbWVudG9zUG9yVHJhY2tbZWxlbS50cmFja0lkXS5wdXNoKGVsZW0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gT3JkZW5hciBlbGVtZW50b3MgZW4gY2FkYSB0cmFjayBwb3IgdGllbXBvXG4gICAgICAgIE9iamVjdC5rZXlzKGVsZW1lbnRvc1BvclRyYWNrKS5mb3JFYWNoKHRyYWNrSWQgPT4ge1xuICAgICAgICAgIGVsZW1lbnRvc1BvclRyYWNrW3RyYWNrSWRdLnNvcnQoKGEsIGIpID0+IGEuZnJvbSAtIGIuZnJvbSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNvbnNvbGUubG9nKFwiRWxlbWVudG9zIGFncnVwYWRvcyBwb3IgdHJhY2s6XCIsIE9iamVjdC5rZXlzKGVsZW1lbnRvc1BvclRyYWNrKS5sZW5ndGgpO1xuXG4gICAgICAgIC8vIExvZ2dpbmcgZGUgdHJhY2tzIHBhcmEgZGlhZ27Ds3N0aWNvXG4gICAgICAgIE9iamVjdC5rZXlzKGVsZW1lbnRvc1BvclRyYWNrKS5mb3JFYWNoKHRyYWNrSWQgPT4ge1xuICAgICAgICAgIGNvbnNvbGUubG9nKGBUcmFjayAke3RyYWNrSWR9OiAke2VsZW1lbnRvc1BvclRyYWNrW3RyYWNrSWRdLmxlbmd0aH0gZWxlbWVudG9zYCk7XG4gICAgICAgICAgLy8gTW9zdHJhciBsb3MgZWxlbWVudG9zIGVuIGVzdGUgdHJhY2sgb3JkZW5hZG9zXG4gICAgICAgICAgZWxlbWVudG9zUG9yVHJhY2tbdHJhY2tJZF0uZm9yRWFjaCgoZWxlbSwgaWR4KSA9PiB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhgICAke2lkeCsxfS4gSUQ9JHtlbGVtLmlkLnN1YnN0cmluZygwLDgpfS4uLiBUaWVtcG89JHtlbGVtLmZyb219bXMtJHtlbGVtLnRvfW1zIChkdXJhY2nDs246ICR7ZWxlbS50by1lbGVtLmZyb219bXMpYCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIEJ1c2NhciBlc3BhY2lvcyB2YWPDrW9zIGVuIGNhZGEgdHJhY2tcbiAgICAgICAgY29uc3QgZXNwYWNpb3NWYWNpb3MgPSBbXTtcblxuICAgICAgICBPYmplY3Qua2V5cyhlbGVtZW50b3NQb3JUcmFjaykuZm9yRWFjaCh0cmFja0lkID0+IHtcbiAgICAgICAgICBjb25zdCBlbGVtZW50b3MgPSBlbGVtZW50b3NQb3JUcmFja1t0cmFja0lkXTtcblxuICAgICAgICAgIC8vIFNpIGhheSBhbCBtZW5vcyAyIGVsZW1lbnRvcywgcG9kZW1vcyBidXNjYXIgZXNwYWNpb3NcbiAgICAgICAgICBpZiAoZWxlbWVudG9zLmxlbmd0aCA+PSAyKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGVsZW1lbnRvcy5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAgICAgICAgICAgY29uc3QgZWxlbWVudG9BY3R1YWwgPSBlbGVtZW50b3NbaV07XG4gICAgICAgICAgICAgIGNvbnN0IGVsZW1lbnRvU2lndWllbnRlID0gZWxlbWVudG9zW2kgKyAxXTtcblxuICAgICAgICAgICAgICAvLyBWZXJpZmljYXIgc2kgaGF5IHVuIGVzcGFjaW8gZW50cmUgZWwgZmluIGRlbCBlbGVtZW50byBhY3R1YWwgeSBlbCBpbmljaW8gZGVsIHNpZ3VpZW50ZVxuICAgICAgICAgICAgICBjb25zdCBlc3BhY2lvID0gZWxlbWVudG9TaWd1aWVudGUuZnJvbSAtIGVsZW1lbnRvQWN0dWFsLnRvO1xuXG4gICAgICAgICAgICAgIC8vIFNpIGVsIGVzcGFjaW8gZXMgc2lnbmlmaWNhdGl2byAobcOhcyBkZSAxMDBtcylcbiAgICAgICAgICAgICAgaWYgKGVzcGFjaW8gPiAxMDApIHtcbiAgICAgICAgICAgICAgICBlc3BhY2lvc1ZhY2lvcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgIHRyYWNrSWQsXG4gICAgICAgICAgICAgICAgICBzdGFydDogZWxlbWVudG9BY3R1YWwudG8sXG4gICAgICAgICAgICAgICAgICBlbmQ6IGVsZW1lbnRvU2lndWllbnRlLmZyb20sXG4gICAgICAgICAgICAgICAgICBzaXplOiBlc3BhY2lvLFxuICAgICAgICAgICAgICAgICAgZWxlbWVudG9BbnRlczogZWxlbWVudG9BY3R1YWwuaWQsXG4gICAgICAgICAgICAgICAgICBlbGVtZW50b0Rlc3B1ZXM6IGVsZW1lbnRvU2lndWllbnRlLmlkXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coYEVuY29udHJhZG8gZXNwYWNpbyBkZSAke2VzcGFjaW99bXMgKCR7ZXNwYWNpby8xMDAwfXMpIGVuIHRyYWNrICR7dHJhY2tJZH0gZW50cmUgZWxlbWVudG9zICR7ZWxlbWVudG9BY3R1YWwuaWQuc3Vic3RyaW5nKDAsOCl9Li4uIHkgJHtlbGVtZW50b1NpZ3VpZW50ZS5pZC5zdWJzdHJpbmcoMCw4KX0uLi5gKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgY29uc29sZS5sb2coYFNlIGVuY29udHJhcm9uICR7ZXNwYWNpb3NWYWNpb3MubGVuZ3RofSBlc3BhY2lvcyB2YWPDrW9zYCk7XG5cbiAgICAgICAgLy8gU2kgbm8gaGF5IGVzcGFjaW9zLCBubyBuZWNlc2l0YW1vcyBjb21wYWN0YXJcbiAgICAgICAgaWYgKGVzcGFjaW9zVmFjaW9zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIGNvbnNvbGUubG9nKFwiTm8gaGF5IGVzcGFjaW9zIHNpZ25pZmljYXRpdm9zIHBhcmEgY29tcGFjdGFyXCIpO1xuICAgICAgICAgIHJldHVybiB0cnVlOyAvLyBEZXZvbHZlbW9zIHRydWUgcG9ycXVlIHTDqWNuaWNhbWVudGUgZXN0w6EgY29tcGFjdGFkb1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gT3JkZW5hciBlc3BhY2lvcyBwb3IgcG9zaWNpw7NuIChkZSBpenF1aWVyZGEgYSBkZXJlY2hhKVxuICAgICAgICBlc3BhY2lvc1ZhY2lvcy5zb3J0KChhLCBiKSA9PiBhLnN0YXJ0IC0gYi5zdGFydCk7XG5cbiAgICAgICAgLy8gQ2FsY3VsYXIgZWwgZXNwYWNpbyB0b3RhbCBhIGNvbXBhY3RhclxuICAgICAgICBsZXQgZXNwYWNpb1RvdGFsID0gMDtcbiAgICAgICAgZXNwYWNpb3NWYWNpb3MuZm9yRWFjaChlc3BhY2lvID0+IHtcbiAgICAgICAgICBlc3BhY2lvVG90YWwgKz0gZXNwYWNpby5zaXplO1xuICAgICAgICB9KTtcblxuICAgICAgICBjb25zb2xlLmxvZyhgRXNwYWNpbyB0b3RhbCBhIGNvbXBhY3RhcjogJHtlc3BhY2lvVG90YWx9bXMgKCR7ZXNwYWNpb1RvdGFsLzEwMDB9cylgKTtcbiAgICAgICAgY29uc29sZS5sb2coYFByZXBhcmFuZG8gYWN0dWFsaXphY2lvbmVzIHBhcmEgJHt0b2Rvc0VsZW1lbnRvcy5sZW5ndGh9IGVsZW1lbnRvcy4uLmApO1xuXG4gICAgICAgIC8vIFByZXBhcmFyIGFjdHVhbGl6YWNpb25lcyBwYXJhIGNhZGEgZWxlbWVudG9cbiAgICAgICAgY29uc3QgYWN0dWFsaXphY2lvbmVzID0ge307XG4gICAgICAgIGxldCBlbGVtZW50b3NBTW92ZXIgPSAwO1xuXG4gICAgICAgIC8vIFBhcmEgY2FkYSBlbGVtZW50bywgY2FsY3VsYW1vcyBlbCBkZXNwbGF6YW1pZW50byBiYXNhZG8gZW4gbG9zIGVzcGFjaW9zIGFudGVyaW9yZXNcbiAgICAgICAgdG9kb3NFbGVtZW50b3MuZm9yRWFjaChlbGVtZW50byA9PiB7XG4gICAgICAgICAgbGV0IGRlc3BsYXphbWllbnRvID0gMDtcblxuICAgICAgICAgIC8vIENhbGN1bGFyIGN1w6FudG8gZGViZSBtb3ZlcnNlIGJhc2FkbyBlbiBsb3MgZXNwYWNpb3MgdmFjw61vcyBhbnRlcmlvcmVzXG4gICAgICAgICAgZm9yIChjb25zdCBlc3BhY2lvIG9mIGVzcGFjaW9zVmFjaW9zKSB7XG4gICAgICAgICAgICAvLyBTaSBlbCBlbGVtZW50byBlc3TDoSBkZXNwdcOpcyBkZWwgZXNwYWNpbyB2YWPDrW8sIGRlYmUgbW92ZXJzZVxuICAgICAgICAgICAgaWYgKGVsZW1lbnRvLmZyb20gPiBlc3BhY2lvLmVuZCkge1xuICAgICAgICAgICAgICBkZXNwbGF6YW1pZW50byArPSBlc3BhY2lvLnNpemU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gU2kgaGF5IGRlc3BsYXphbWllbnRvLCBhw7FhZGlyIGEgbGFzIGFjdHVhbGl6YWNpb25lc1xuICAgICAgICAgIGlmIChkZXNwbGF6YW1pZW50byA+IDApIHtcbiAgICAgICAgICAgIGNvbnN0IG51ZXZvRnJvbSA9IGVsZW1lbnRvLmZyb20gLSBkZXNwbGF6YW1pZW50bztcbiAgICAgICAgICAgIGNvbnN0IG51ZXZvVG8gPSBlbGVtZW50by50byAtIGRlc3BsYXphbWllbnRvO1xuXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhgRWxlbWVudG8gJHtlbGVtZW50by5pZC5zdWJzdHJpbmcoMCw4KX0uLi4gc2UgbW92ZXLDoTogJHtlbGVtZW50by5mcm9tfW1zIC0+ICR7bnVldm9Gcm9tfW1zIChkZXNwbGF6YW1pZW50bzogJHtkZXNwbGF6YW1pZW50b31tcylgKTtcblxuICAgICAgICAgICAgYWN0dWFsaXphY2lvbmVzW2VsZW1lbnRvLmlkXSA9IHtcbiAgICAgICAgICAgICAgZGlzcGxheToge1xuICAgICAgICAgICAgICAgIGZyb206IG51ZXZvRnJvbSxcbiAgICAgICAgICAgICAgICB0bzogbnVldm9Ub1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZWxlbWVudG9zQU1vdmVyKys7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBjb25zb2xlLmxvZyhgRWxlbWVudG9zIGEgbW92ZXI6ICR7ZWxlbWVudG9zQU1vdmVyfSBkZSAke3RvZG9zRWxlbWVudG9zLmxlbmd0aH0gdG90YWxgKTtcblxuICAgICAgICAvLyBBcGxpY2FyIGxhcyBhY3R1YWxpemFjaW9uZXNcbiAgICAgICAgaWYgKGVsZW1lbnRvc0FNb3ZlciA+IDApIHtcbiAgICAgICAgICBjb25zb2xlLmxvZyhcIkFwbGljYW5kbyBhY3R1YWxpemFjaW9uZXMgcGFyYSBjb21wYWN0YXIgdGltZWxpbmUuLi5cIik7XG5cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgZGlzcGF0Y2goRURJVF9PQkpFQ1QsIHtcbiAgICAgICAgICAgICAgcGF5bG9hZDogYWN0dWFsaXphY2lvbmVzXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiQWN0dWFsaXphY2lvbmVzIGFwbGljYWRhcyBjb24gw6l4aXRvXCIpO1xuICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgYWwgYXBsaWNhciBhY3R1YWxpemFjaW9uZXM6XCIsIGVycm9yKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBSZWZyZXNjYXIgbGEgdmlzdGFcbiAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGNvbnN0IHsgc2NhbGUgfSA9IHN0YXRlTWFuYWdlci5nZXRTdGF0ZSgpO1xuICAgICAgICAgICAgICBpZiAoc2NhbGUpIHtcbiAgICAgICAgICAgICAgICAvLyBIYWNlciB1biBwZXF1ZcOxbyBjYW1iaW8gZW4gbGEgZXNjYWxhIHBhcmEgZm9yemFyIGxhIGFjdHVhbGl6YWNpw7NuXG4gICAgICAgICAgICAgICAgY29uc3QgdXBkYXRlZFNjYWxlID0geyAuLi5zY2FsZSB9O1xuXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB1cGRhdGVkU2NhbGUudW5pdCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICAgIHVwZGF0ZWRTY2FsZS51bml0ID0gKHVwZGF0ZWRTY2FsZS51bml0IHx8IDApICsgMTtcblxuICAgICAgICAgICAgICAgICAgZGlzcGF0Y2goVElNRUxJTkVfU0NBTEVfQ0hBTkdFRCwge1xuICAgICAgICAgICAgICAgICAgICBwYXlsb2FkOiB7IHNjYWxlOiB1cGRhdGVkU2NhbGUgfVxuICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgIC8vIFZvbHZlciBhIGxhIGVzY2FsYSBvcmlnaW5hbFxuICAgICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRTY2FsZSA9IHsgLi4uc3RhdGVNYW5hZ2VyLmdldFN0YXRlKCkuc2NhbGUgfTtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFNjYWxlLnVuaXQgPSAoY3VycmVudFNjYWxlLnVuaXQgfHwgMSkgLSAxO1xuICAgICAgICAgICAgICAgICAgICBkaXNwYXRjaChUSU1FTElORV9TQ0FMRV9DSEFOR0VELCB7XG4gICAgICAgICAgICAgICAgICAgICAgcGF5bG9hZDogeyBzY2FsZTogY3VycmVudFNjYWxlIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICB9LCAzMDApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIGFsIHJlZnJlc2NhciBsYSB2aXN0YTpcIiwgZXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sIDUwMCk7XG5cbiAgICAgICAgICBjb25zb2xlLmxvZyhcIkNvbXBhY3RhY2nDs24gY29tcGxldGFkYSBjb24gw6l4aXRvXCIpO1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnNvbGUubG9nKFwiTm8gaGF5IGVsZW1lbnRvcyBxdWUgbmVjZXNpdGVuIG1vdmVyc2VcIik7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBhbCBjb21wYWN0YXIgbGEgbMOtbmVhIGRlIHRpZW1wbzpcIiwgZXJyb3IpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfSxcblxuICAgIHNtYXJ0VHJpbTogYXN5bmMgKCkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc29sZS5sb2coXCI9PT0gSU5JQ0lBTkRPIFBST0NFU08gREUgUkVDT1JURSBJTlRFTElHRU5URSBERVNERSBJQSA9PT1cIik7XG5cbiAgICAgICAgLy8gMS4gUmVhbGl6YXIgbGEgbGxhbWFkYSBhbCBBUEkgcGFyYSBhbmFsaXphciBsYSB0cmFuc2NyaXBjacOzblxuICAgICAgICBjb25zb2xlLmxvZyhcIlNvbGljaXRhbmRvIGFuw6FsaXNpcyBkZSB0cmFuc2NyaXBjacOzbi4uLlwiKTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCgnL2FwaS9zbWFydC10cmltJyk7XG5cbiAgICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRXJyb3IgYWwgYW5hbGl6YXIgbGEgdHJhbnNjcmlwY2nDs246ICR7cmVzcG9uc2Uuc3RhdHVzfWApO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgY29uc29sZS5sb2coXCJBbsOhbGlzaXMgZGUgdHJhbnNjcmlwY2nDs24gY29tcGxldGFkbzpcIiwgZGF0YSk7XG5cbiAgICAgICAgaWYgKCFkYXRhLnJlbW92ZVNlZ21lbnRzIHx8ICFBcnJheS5pc0FycmF5KGRhdGEucmVtb3ZlU2VnbWVudHMpIHx8IGRhdGEucmVtb3ZlU2VnbWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgY29uc29sZS5sb2coXCJObyBzZSBlbmNvbnRyYXJvbiBzZWdtZW50b3MgcGFyYSBlbGltaW5hclwiKTtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICAvLyAyLiBDb252ZXJ0aXIgbG9zIHNlZ21lbnRvcyBhbCBmb3JtYXRvIHF1ZSBlc3BlcmEgcmVtb3ZlU2VnbWVudHNcbiAgICAgICAgY29uc3Qgc2VnbWVudHMgPSBkYXRhLnJlbW92ZVNlZ21lbnRzLm1hcChzZWdtZW50ID0+ICh7XG4gICAgICAgICAgc3RhcnRUaW1lOiBzZWdtZW50LnN0YXJ0VGltZSwgLy8gWWEgZXN0w6EgZW4gc2VndW5kb3NcbiAgICAgICAgICBlbmRUaW1lOiBzZWdtZW50LmVuZFRpbWUgICAgICAvLyBZYSBlc3TDoSBlbiBzZWd1bmRvc1xuICAgICAgICB9KSk7XG5cbiAgICAgICAgY29uc29sZS5sb2coYFNlIGVsaW1pbmFyw6FuICR7c2VnbWVudHMubGVuZ3RofSBzZWdtZW50b3M6YCxcbiAgICAgICAgICBzZWdtZW50cy5tYXAocyA9PiBgJHtzLnN0YXJ0VGltZX1zLSR7cy5lbmRUaW1lfXNgKS5qb2luKCcsICcpKTtcblxuICAgICAgICAvLyBBbG1hY2VuYXIgaW5mb3JtYWNpw7NuIGRlbCBlc3RhZG8gcHJldmlvIHBhcmEgaWRlbnRpZmljYXIgdHJhY2tzIHkgZWxlbWVudG9zXG4gICAgICAgIGNvbnNvbGUubG9nKFwiT2J0ZW5pZW5kbyBpbmZvcm1hY2nDs24gZGVsIGVzdGFkbyBhbnRlcyBkZSBlbGltaW5hciBzZWdtZW50b3MuLi5cIik7XG4gICAgICAgIGNvbnN0IGVzdGFkb1ByZXZpbyA9IHN0YXRlTWFuYWdlci5nZXRTdGF0ZSgpO1xuICAgICAgICBjb25zdCBlbGVtZW50b3NQcmV2aW9zID0gYXdhaXQgZXhlY3V0b3IuZ2V0QWxsVGltZWxpbmVFbGVtZW50cygpO1xuXG4gICAgICAgIC8vIERldGVybWluYXIgZWwgdHJhY2tJZCBwcmluY2lwYWwgYmFzYWRvIGVuIGxvcyBlbGVtZW50b3NcbiAgICAgICAgY29uc3QgY29udGFkb3JUcmFja3MgPSB7fTtcbiAgICAgICAgZWxlbWVudG9zUHJldmlvcy5mb3JFYWNoKGVsZW0gPT4ge1xuICAgICAgICAgIGlmIChlbGVtLnRyYWNrSWQpIHtcbiAgICAgICAgICAgIGNvbnRhZG9yVHJhY2tzW2VsZW0udHJhY2tJZF0gPSAoY29udGFkb3JUcmFja3NbZWxlbS50cmFja0lkXSB8fCAwKSArIDE7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICAvLyBFbmNvbnRyYXIgZWwgdHJhY2sgY29uIG3DoXMgZWxlbWVudG9zXG4gICAgICAgIGxldCB0cmFja0lkUHJpbmNpcGFsID0gXCJcIjtcbiAgICAgICAgaWYgKE9iamVjdC5rZXlzKGNvbnRhZG9yVHJhY2tzKS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgY29uc3QgdHJhY2tzUG9yVXNvID0gT2JqZWN0LmVudHJpZXMoY29udGFkb3JUcmFja3MpXG4gICAgICAgICAgICAuc29ydCgoYSwgYikgPT4gYlsxXSAtIGFbMV0pO1xuXG4gICAgICAgICAgaWYgKHRyYWNrc1BvclVzby5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB0cmFja0lkUHJpbmNpcGFsID0gdHJhY2tzUG9yVXNvWzBdWzBdO1xuICAgICAgICAgICAgY29uc29sZS5sb2coYFVzYW5kbyB0cmFja0lkIHByaW5jaXBhbDogJHt0cmFja0lkUHJpbmNpcGFsfWApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIDMuIEVsaW1pbmFyIGxvcyBzZWdtZW50b3NcbiAgICAgICAgY29uc29sZS5sb2coXCJFamVjdXRhbmRvIGVsaW1pbmFjacOzbiBkZSBzZWdtZW50b3MuLi5cIik7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGV4ZWN1dG9yLnJlbW92ZVNlZ21lbnRzKHNlZ21lbnRzKTtcblxuICAgICAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgICAgIGNvbnNvbGUubG9nKFwiRXJyb3IgYWwgZWxpbWluYXIgbG9zIHNlZ21lbnRvc1wiKTtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zb2xlLmxvZyhcIlNlZ21lbnRvcyBlbGltaW5hZG9zIGNvcnJlY3RhbWVudGVcIik7XG5cbiAgICAgICAgLy8gNC4gQ3JlYXIgcmVnaXN0cm8gZGUgbG9zIHNlZ21lbnRvcyBlbGltaW5hZG9zIHBhcmEgY29tcGFjdGFjacOzblxuICAgICAgICBjb25zdCBzZWdtZW50b3NFbGltaW5hZG9zID0gc2VnbWVudHMubWFwKHNlZ21lbnQgPT4gKHtcbiAgICAgICAgICBzdGFydDogc2VnbWVudC5zdGFydFRpbWUgKiAxMDAwLCAgLy8gQ29udmVydGlyIGEgbXNcbiAgICAgICAgICBlbmQ6IHNlZ21lbnQuZW5kVGltZSAqIDEwMDAsICAgICAgLy8gQ29udmVydGlyIGEgbXNcbiAgICAgICAgICB0cmFja0lkOiB0cmFja0lkUHJpbmNpcGFsLFxuICAgICAgICAgIHNpemU6IChzZWdtZW50LmVuZFRpbWUgLSBzZWdtZW50LnN0YXJ0VGltZSkgKiAxMDAwXG4gICAgICAgIH0pKTtcblxuICAgICAgICBjb25zb2xlLmxvZyhcIlNlZ21lbnRvcyByZWdpc3RyYWRvcyBwYXJhIGNvbXBhY3RhY2nDs246XCIsIHNlZ21lbnRvc0VsaW1pbmFkb3MpO1xuXG4gICAgICAgIC8vIDUuIEVzcGVyYXIgdW4gbW9tZW50byBwYXJhIHF1ZSBzZSBjb21wbGV0ZW4gbGFzIGFjdHVhbGl6YWNpb25lcyBkZWwgRE9NIHkgZWwgZXN0YWRvXG4gICAgICAgIGNvbnNvbGUubG9nKFwiRXNwZXJhbmRvIDUgc2VndW5kb3MgcGFyYSBhc2VndXJhciBxdWUgbG9zIGNhbWJpb3MgZW4gbGEgdGltZWxpbmUgZXN0w6luIGNvbXBsZXRvcyBhbnRlcyBkZSBjb21wYWN0YXIuLi5cIik7XG4gICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCA1MDAwKSk7XG5cbiAgICAgICAgLy8gNi4gQ29tcGFjdGFyIGVsIHRpbWVsaW5lIHVzYW5kbyBlbCBlbmZvcXVlIGRlIHNlZ21lbnRvcyByZWdpc3RyYWRvc1xuICAgICAgICBjb25zb2xlLmxvZyhcIkNvbXBhY3RhbmRvIHRpbWVsaW5lIGJhc2FkbyBlbiBzZWdtZW50b3MgZWxpbWluYWRvcy4uLlwiKTtcblxuICAgICAgICAvLyBPYnRlbmVyIGVsZW1lbnRvcyBhY3R1YWxlcyBkZXNwdcOpcyBkZSBsYSBlbGltaW5hY2nDs25cbiAgICAgICAgY29uc3QgZWxlbWVudG9zQWN0dWFsZXMgPSBhd2FpdCBleGVjdXRvci5nZXRBbGxUaW1lbGluZUVsZW1lbnRzKCk7XG4gICAgICAgIGNvbnNvbGUubG9nKGBTZSBlbmNvbnRyYXJvbiAke2VsZW1lbnRvc0FjdHVhbGVzLmxlbmd0aH0gZWxlbWVudG9zIGVuIGxhIHRpbWVsaW5lIGRlc3B1w6lzIGRlIGVsaW1pbmFyIHNlZ21lbnRvc2ApO1xuXG4gICAgICAgIC8vIENhbGN1bGFyIGVsIGVzcGFjaW8gdG90YWwgYSBjb21wYWN0YXJcbiAgICAgICAgbGV0IGVzcGFjaW9Ub3RhbCA9IDA7XG4gICAgICAgIHNlZ21lbnRvc0VsaW1pbmFkb3MuZm9yRWFjaChzZWdtZW50byA9PiB7XG4gICAgICAgICAgZXNwYWNpb1RvdGFsICs9IHNlZ21lbnRvLnNpemU7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNvbnNvbGUubG9nKGBFc3BhY2lvIHRvdGFsIGEgY29tcGFjdGFyOiAke2VzcGFjaW9Ub3RhbH1tcyAoJHtlc3BhY2lvVG90YWwvMTAwMH1zKWApO1xuXG4gICAgICAgIC8vIFByZXBhcmFyIGFjdHVhbGl6YWNpb25lcyBwYXJhIGNhZGEgZWxlbWVudG9cbiAgICAgICAgY29uc3QgYWN0dWFsaXphY2lvbmVzID0ge307XG4gICAgICAgIGxldCBlbGVtZW50b3NBTW92ZXIgPSAwO1xuXG4gICAgICAgIC8vIE9yZGVuYXIgc2VnbWVudG9zIHBvciBwb3NpY2nDs24gZGUgaW5pY2lvXG4gICAgICAgIGNvbnN0IHNlZ21lbnRvc09yZGVuYWRvcyA9IFsuLi5zZWdtZW50b3NFbGltaW5hZG9zXS5zb3J0KChhLCBiKSA9PiBhLnN0YXJ0IC0gYi5zdGFydCk7XG5cbiAgICAgICAgLy8gUGFyYSBjYWRhIGVsZW1lbnRvLCBjYWxjdWxhciBlbCBkZXNwbGF6YW1pZW50byBiYXNhZG8gZW4gbG9zIHNlZ21lbnRvcyBlbGltaW5hZG9zXG4gICAgICAgIGVsZW1lbnRvc0FjdHVhbGVzLmZvckVhY2goZWxlbWVudG8gPT4ge1xuICAgICAgICAgIGxldCBkZXNwbGF6YW1pZW50byA9IDA7XG5cbiAgICAgICAgICAvLyBDYWxjdWxhciBjdcOhbnRvIGRlYmUgbW92ZXJzZSBiYXNhZG8gZW4gbG9zIHNlZ21lbnRvcyBlbGltaW5hZG9zIGFudGVyaW9yZXNcbiAgICAgICAgICBmb3IgKGNvbnN0IHNlZ21lbnRvIG9mIHNlZ21lbnRvc09yZGVuYWRvcykge1xuICAgICAgICAgICAgaWYgKGVsZW1lbnRvLmZyb20gPiBzZWdtZW50by5zdGFydCkge1xuICAgICAgICAgICAgICBkZXNwbGF6YW1pZW50byArPSBzZWdtZW50by5zaXplO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIFNpIGhheSBkZXNwbGF6YW1pZW50bywgYcOxYWRpciBhIGxhcyBhY3R1YWxpemFjaW9uZXNcbiAgICAgICAgICBpZiAoZGVzcGxhemFtaWVudG8gPiAwKSB7XG4gICAgICAgICAgICBjb25zdCBudWV2b0Zyb20gPSBlbGVtZW50by5mcm9tIC0gZGVzcGxhemFtaWVudG87XG4gICAgICAgICAgICBjb25zdCBudWV2b1RvID0gZWxlbWVudG8udG8gLSBkZXNwbGF6YW1pZW50bztcblxuICAgICAgICAgICAgY29uc29sZS5sb2coYEVsZW1lbnRvICR7ZWxlbWVudG8uaWQuc3Vic3RyaW5nKDAsOCl9Li4uIHNlIG1vdmVyw6E6ICR7ZWxlbWVudG8uZnJvbX1tcyAtPiAke251ZXZvRnJvbX1tcyAoZGVzcGxhemFtaWVudG86ICR7ZGVzcGxhemFtaWVudG99bXMpYCk7XG5cbiAgICAgICAgICAgIGFjdHVhbGl6YWNpb25lc1tlbGVtZW50by5pZF0gPSB7XG4gICAgICAgICAgICAgIGRpc3BsYXk6IHtcbiAgICAgICAgICAgICAgICBmcm9tOiBudWV2b0Zyb20sXG4gICAgICAgICAgICAgICAgdG86IG51ZXZvVG9cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGVsZW1lbnRvc0FNb3ZlcisrO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgY29uc29sZS5sb2coYEVsZW1lbnRvcyBhIG1vdmVyOiAke2VsZW1lbnRvc0FNb3Zlcn0gZGUgJHtlbGVtZW50b3NBY3R1YWxlcy5sZW5ndGh9IHRvdGFsYCk7XG5cbiAgICAgICAgLy8gQXBsaWNhciBsYXMgYWN0dWFsaXphY2lvbmVzXG4gICAgICAgIGlmIChlbGVtZW50b3NBTW92ZXIgPiAwKSB7XG4gICAgICAgICAgY29uc29sZS5sb2coXCJBcGxpY2FuZG8gYWN0dWFsaXphY2lvbmVzIHBhcmEgY29tcGFjdGFyIHRpbWVsaW5lLi4uXCIpO1xuXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGRpc3BhdGNoKEVESVRfT0JKRUNULCB7XG4gICAgICAgICAgICAgIHBheWxvYWQ6IGFjdHVhbGl6YWNpb25lc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIkFjdHVhbGl6YWNpb25lcyBhcGxpY2FkYXMgY29uIMOpeGl0b1wiKTtcblxuICAgICAgICAgICAgLy8gUmVmcmVzY2FyIGxhIHZpc3RhXG4gICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IHNjYWxlIH0gPSBzdGF0ZU1hbmFnZXIuZ2V0U3RhdGUoKTtcbiAgICAgICAgICAgICAgICBpZiAoc2NhbGUpIHtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IHVwZGF0ZWRTY2FsZSA9IHsgLi4uc2NhbGUgfTtcbiAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdXBkYXRlZFNjYWxlLnVuaXQgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZWRTY2FsZS51bml0ID0gKHVwZGF0ZWRTY2FsZS51bml0IHx8IDApICsgMTtcblxuICAgICAgICAgICAgICAgICAgICBkaXNwYXRjaChUSU1FTElORV9TQ0FMRV9DSEFOR0VELCB7XG4gICAgICAgICAgICAgICAgICAgICAgcGF5bG9hZDogeyBzY2FsZTogdXBkYXRlZFNjYWxlIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gVm9sdmVyIGEgbGEgZXNjYWxhIG9yaWdpbmFsXG4gICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRTY2FsZSA9IHsgLi4uc3RhdGVNYW5hZ2VyLmdldFN0YXRlKCkuc2NhbGUgfTtcbiAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50U2NhbGUudW5pdCA9IChjdXJyZW50U2NhbGUudW5pdCB8fCAxKSAtIDE7XG4gICAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2goVElNRUxJTkVfU0NBTEVfQ0hBTkdFRCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGF5bG9hZDogeyBzY2FsZTogY3VycmVudFNjYWxlIH1cbiAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSwgMzAwKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIGFsIHJlZnJlc2NhciBsYSB2aXN0YTpcIiwgZXJyb3IpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCA1MDApO1xuXG4gICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBhbCBhcGxpY2FyIGFjdHVhbGl6YWNpb25lczpcIiwgZXJyb3IpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zb2xlLmxvZyhcIk5vIHNlIGVuY29udHJhcm9uIGVsZW1lbnRvcyBxdWUgbmVjZXNpdGVuIG1vdmVyc2VcIik7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zb2xlLmxvZyhcIlRpbWVsaW5lIGNvbXBhY3RhZG8gY29ycmVjdGFtZW50ZVwiKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgYWwgcmVhbGl6YXIgZWwgcmVjb3J0ZSBpbnRlbGlnZW50ZTpcIiwgZXJyb3IpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfSxcblxuICAgIGFkZE11c2ljOiAobXVzaWNQYXRoOiBzdHJpbmcsIG9wdGlvbnM/OiBNdXNpY09wdGlvbnMpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIC8vIFZhbG9yZXMgcHJlZGV0ZXJtaW5hZG9zXG4gICAgICAgIGNvbnN0IHN0YXJ0VGltZSA9IG9wdGlvbnM/LnN0YXJ0VGltZSAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5zdGFydFRpbWUgOiAwO1xuICAgICAgICBjb25zdCBlbmRUaW1lID0gb3B0aW9ucz8uZW5kVGltZSAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5lbmRUaW1lIDogKHN0YXJ0VGltZSArIDMwKTsgLy8gRHVyYWNpw7NuIHByZWRldGVybWluYWRhIG3DoXMgbGFyZ2EgcGFyYSBtw7pzaWNhXG4gICAgICAgIGNvbnN0IHZvbHVtZSA9IG9wdGlvbnM/LnZvbHVtZSAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy52b2x1bWUgOiA4MDsgLy8gVm9sdW1lbiBwcmVkZXRlcm1pbmFkbyBhbCA4MCVcbiAgICAgICAgY29uc3QgcmVzcGVjdE5hdGl2ZUR1cmF0aW9uID0gb3B0aW9ucz8ucmVzcGVjdE5hdGl2ZUR1cmF0aW9uICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLnJlc3BlY3ROYXRpdmVEdXJhdGlvbiA6IHRydWU7IC8vIFBvciBkZWZlY3RvLCByZXNwZXRhciBkdXJhY2nDs24gbmF0aXZhXG5cbiAgICAgICAgY29uc29sZS5sb2coYEHDsWFkaWVuZG8gbcO6c2ljYSBkZXNkZSAke211c2ljUGF0aH1gKTtcbiAgICAgICAgY29uc29sZS5sb2coYFRpZW1wb3M6ICR7c3RhcnRUaW1lfXMgYSAke2VuZFRpbWV9cywgdm9sdW1lbjogJHt2b2x1bWV9LCByZXNwZWN0TmF0aXZlRHVyYXRpb246ICR7cmVzcGVjdE5hdGl2ZUR1cmF0aW9ufWApO1xuXG4gICAgICAgIC8vIENyZWFyIHBheWxvYWQgcGFyYSBsYSBtw7pzaWNhXG4gICAgICAgIGNvbnN0IGF1ZGlvUGF5bG9hZCA9IHtcbiAgICAgICAgICBpZDogZ2VuZXJhdGVJZCgpLFxuICAgICAgICAgIGRpc3BsYXk6IHtcbiAgICAgICAgICAgIGZyb206IHN0YXJ0VGltZSAqIDEwMDAsIC8vIENvbnZlcnRpciBhIG1pbGlzZWd1bmRvc1xuICAgICAgICAgICAgdG86IGVuZFRpbWUgKiAxMDAwICAgICAvLyBDb252ZXJ0aXIgYSBtaWxpc2VndW5kb3NcbiAgICAgICAgICB9LFxuICAgICAgICAgIHR5cGU6ICdhdWRpbycsXG4gICAgICAgICAgZGV0YWlsczoge1xuICAgICAgICAgICAgc3JjOiBtdXNpY1BhdGgsXG4gICAgICAgICAgICB2b2x1bWU6IHZvbHVtZSxcbiAgICAgICAgICAgIGZhZGVJbjogb3B0aW9ucz8uZmFkZUluID09PSB0cnVlLFxuICAgICAgICAgICAgZmFkZU91dDogb3B0aW9ucz8uZmFkZU91dCA9PT0gdHJ1ZVxuICAgICAgICAgIH0sXG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gQWdyZWdhciBhdWRpbyBhbCB0aW1lbGluZSB1c2FuZG8gQUREX0FVRElPXG4gICAgICAgIGRpc3BhdGNoKEFERF9BVURJTywge1xuICAgICAgICAgIHBheWxvYWQ6IGF1ZGlvUGF5bG9hZCxcbiAgICAgICAgICBvcHRpb25zOiB7XG4gICAgICAgICAgICByZXNwZWN0TmF0aXZlRHVyYXRpb246IHJlc3BlY3ROYXRpdmVEdXJhdGlvblxuICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNvbnNvbGUubG9nKGBNw7pzaWNhIGFncmVnYWRhIGV4aXRvc2FtZW50ZSBjb24gSUQ6ICR7YXVkaW9QYXlsb2FkLmlkfWApO1xuICAgICAgICByZXR1cm4gYXVkaW9QYXlsb2FkLmlkO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIGFsIGFncmVnYXIgbcO6c2ljYTpcIiwgZXJyb3IpO1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLy8gTnVldm8gbcOpdG9kbyBwYXJhIG9idGVuZXIgZWwgSUQgZGVsIHRyYWNrIGRlIHN1YnTDrXR1bG9zXG4gICAgZ2V0U3VidGl0bGVzVHJhY2tJZDogYXN5bmMgKCk6IFByb21pc2U8c3RyaW5nIHwgbnVsbD4gPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc29sZS5sb2coXCJCdXNjYW5kbyB0cmFjayBkZSBzdWJ0w610dWxvcyBleGlzdGVudGUuLi5cIik7XG5cbiAgICAgICAgLy8gT2J0ZW5lciB0b2RvcyBsb3MgZWxlbWVudG9zIGRlbCB0aW1lbGluZVxuICAgICAgICBjb25zdCBhbGxFbGVtZW50cyA9IGF3YWl0IGV4ZWN1dG9yLmdldEFsbFRpbWVsaW5lRWxlbWVudHMoKTtcblxuICAgICAgICBpZiAoYWxsRWxlbWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgY29uc29sZS5sb2coXCJObyBoYXkgZWxlbWVudG9zIGVuIGxhIHRpbWVsaW5lXCIpO1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQWdydXBhciBlbGVtZW50b3MgcG9yIHRyYWNrSWRcbiAgICAgICAgY29uc3QgdHJhY2tHcm91cHMgPSB7fTtcbiAgICAgICAgYWxsRWxlbWVudHMuZm9yRWFjaChlbGVtZW50ID0+IHtcbiAgICAgICAgICBpZiAoZWxlbWVudC50cmFja0lkKSB7XG4gICAgICAgICAgICBpZiAoIXRyYWNrR3JvdXBzW2VsZW1lbnQudHJhY2tJZF0pIHtcbiAgICAgICAgICAgICAgdHJhY2tHcm91cHNbZWxlbWVudC50cmFja0lkXSA9IFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHJhY2tHcm91cHNbZWxlbWVudC50cmFja0lkXS5wdXNoKGVsZW1lbnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gQnVzY2FyIHByaW1lcm8gdHJhY2tzIGNvbiBJRCBxdWUgY29udGVuZ2EgXCJzdWJ0aXRsZXNcIlxuICAgICAgICBmb3IgKGNvbnN0IFt0cmFja0lkLCBlbGVtZW50c10gb2YgT2JqZWN0LmVudHJpZXModHJhY2tHcm91cHMpKSB7XG4gICAgICAgICAgaWYgKHRyYWNrSWQuaW5jbHVkZXMoXCJzdWJ0aXRsZXMtdHJhY2tcIikgJiYgZWxlbWVudHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coYEVuY29udHJhZG8gdHJhY2sgZGUgc3VidMOtdHVsb3MgcG9yIG5vbWJyZTogJHt0cmFja0lkfSAoJHtlbGVtZW50cy5sZW5ndGh9IGVsZW1lbnRvcylgKTtcbiAgICAgICAgICAgIHJldHVybiB0cmFja0lkO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFNpIG5vIHNlIGVuY3VlbnRyYSBwb3Igbm9tYnJlLCBidXNjYXIgdHJhY2tzIHF1ZSBzb2xvIGNvbnRlbmdhbiBlbGVtZW50b3MgZGUgdGV4dG9cbiAgICAgICAgZm9yIChjb25zdCBbdHJhY2tJZCwgZWxlbWVudHNdIG9mIE9iamVjdC5lbnRyaWVzKHRyYWNrR3JvdXBzKSkge1xuICAgICAgICAgIGNvbnN0IGFsbFRleHRFbGVtZW50cyA9IGVsZW1lbnRzLmV2ZXJ5KGVsZW0gPT4gZWxlbS50eXBlID09PSAndGV4dCcpO1xuICAgICAgICAgIGlmIChhbGxUZXh0RWxlbWVudHMgJiYgZWxlbWVudHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coYEVuY29udHJhZG8gdHJhY2sgY29uIHNvbG8gZWxlbWVudG9zIGRlIHRleHRvOiAke3RyYWNrSWR9ICgke2VsZW1lbnRzLmxlbmd0aH0gZWxlbWVudG9zKWApO1xuICAgICAgICAgICAgcmV0dXJuIHRyYWNrSWQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc29sZS5sb2coXCJObyBzZSBlbmNvbnRyw7MgbmluZ8O6biB0cmFjayBkZSBzdWJ0w610dWxvc1wiKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgYWwgYnVzY2FyIHRyYWNrIGRlIHN1YnTDrXR1bG9zOlwiLCBlcnJvcik7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICByZXR1cm4gZXhlY3V0b3I7XG59XG4iXSwibmFtZXMiOlsiZGlzcGF0Y2giLCJBRERfVEVYVCIsIkFERF9WSURFTyIsIkFERF9JTUFHRSIsIkFERF9BVURJTyIsIkFDVElWRV9TUExJVCIsIkxBWUVSX1NFTEVDVCIsIkxBWUVSX0RFTEVURSIsIlRJTUVMSU5FX1NDQUxFX0NIQU5HRUQiLCJFRElUX09CSkVDVCIsImdlbmVyYXRlSWQiLCJjcmVhdGVWaWRlb0NvbW1hbmRFeGVjdXRvciIsInN0YXRlTWFuYWdlciIsImV4ZWN1dG9yIiwiYWRkVGV4dCIsInRleHQiLCJvcHRpb25zIiwicG9zaXRpb24iLCJ4IiwieSIsImZvbnRTaXplIiwiZm9udEZhbWlseSIsImNvbG9yIiwic3RhcnRUaW1lIiwiZW5kVGltZSIsInRleHRQYXlsb2FkIiwiaWQiLCJkaXNwbGF5IiwiZnJvbSIsInRvIiwidHlwZSIsImRldGFpbHMiLCJ3aWR0aCIsIndvcmRXcmFwIiwidGV4dEFsaWduIiwiYm9yZGVyV2lkdGgiLCJib3JkZXJDb2xvciIsImJveFNoYWRvdyIsImJsdXIiLCJwYXlsb2FkIiwiY2hhbmdlQ29sb3IiLCJlbGVtZW50SWQiLCJjb25zb2xlIiwibG9nIiwiYWRkSW1hZ2UiLCJ1cmwiLCJlcnJvciIsIkVycm9yIiwiSlNPTiIsInN0cmluZ2lmeSIsImluY2x1ZGVzIiwiaGVpZ2h0IiwidW5kZWZpbmVkIiwiaXNFeHBsaWNpdGx5QW5pbWF0ZWQiLCJpc0FuaW1hdGVkIiwiaXNFeHBsaWNpdGx5U3RhdGljIiwiaXNTdGF0aWMiLCJpc0FQTkciLCJ0b0xvd2VyQ2FzZSIsImVuZHNXaXRoIiwiaXNHSUYiLCJzaG91bGRUcmVhdEFzQW5pbWF0ZWQiLCJsb2dVcmwiLCJzdGFydHNXaXRoIiwic3Vic3RyaW5nIiwic2NhbGVNb2RlIiwidXNlRnVsbFNjcmVlbiIsImNvbW1vblBheWxvYWRQcm9wcyIsImNvbW1vbkRldGFpbHNQcm9wcyIsInNyYyIsIm9wYWNpdHkiLCJsZWZ0IiwidG9wIiwib3JpZ2luWCIsIm9yaWdpblkiLCJpbWFnZUlkIiwiaW1hZ2VQYXlsb2FkIiwibGVuZ3RoIiwiZGlzcGF0Y2hPcHRpb25zIiwibWVzc2FnZSIsInN0YWNrIiwiYWRkVmlkZW8iLCJpc0FWSSIsImlzRXhwbGljaXRBUE5HIiwidHJlYXRBc0FQTkciLCJyZXNwZWN0TmF0aXZlRHVyYXRpb24iLCJmaW5hbEVuZFRpbWUiLCJzeW5jV2l0aFRpbWVsaW5lIiwiYXBuZ1ZpZGVvUGF5bG9hZCIsImFwbmdFcnJvciIsInZpZGVvUGF5bG9hZCIsImF1dG9QbGF5IiwibG9vcCIsInJlc291cmNlSWQiLCJwbGF5YmFja0JlaGF2aW9yIiwiY2hhbmdlRHVyYXRpb24iLCJkdXJhdGlvbiIsImNoYW5nZVRyYW5zaXRpb24iLCJ0cmFuc2l0aW9uIiwiYWRkU3VidGl0bGVzIiwicGFyc2VUaW1lVG9NcyIsInRpbWVTdHJpbmciLCJob3VycyIsIm1pbnV0ZXMiLCJzZWNvbmRzQW5kTXMiLCJzcGxpdCIsInNlY29uZHMiLCJtcyIsInBhcnNlSW50IiwicGFyc2VTUlQiLCJzcnRDb250ZW50Iiwic2VnbWVudHMiLCJibG9ja3MiLCJ0cmltIiwiZm9yRWFjaCIsImJsb2NrIiwibGluZXMiLCJ0aW1lUmFuZ2UiLCJzbGljZSIsImpvaW4iLCJwdXNoIiwic3BsaXRUZXh0SW50b0dyb3VwcyIsIndvcmRzUGVyR3JvdXAiLCJ3b3JkcyIsImdyb3VwcyIsImkiLCJncm91cCIsInByb2Nlc3NTZWdtZW50Iiwic2VnbWVudCIsInRleHRHcm91cHMiLCJ0b3RhbER1cmF0aW9uIiwiZ3JvdXBEdXJhdGlvbiIsIm1hcCIsImdyb3VwVGV4dCIsImluZGV4Iiwic3VidGl0bGVzVHJhY2tJZCIsInRyYWNrSWQiLCJnZXRTdWJ0aXRsZXNUcmFja0lkIiwiY3JlYXRlU3VidGl0bGVQYXlsb2FkIiwidG9VcHBlckNhc2UiLCJmb250VXJsIiwiYmFja2dyb3VuZENvbG9yIiwicGFkZGluZyIsImJvcmRlclJhZGl1cyIsInJlc3BvbnNlIiwiZmV0Y2giLCJvayIsInN0YXR1cyIsImZsYXRNYXAiLCJvcmlnaW5hbExlbmd0aCIsImZpbHRlciIsInBhc3Nlc1N0YXJ0RmlsdGVyIiwicGFzc2VzRW5kRmlsdGVyIiwic2V0VGltZW91dCIsImdldEFjdGl2ZUVsZW1lbnRzIiwic3RhdGUiLCJnZXRTdGF0ZSIsImFjdGl2ZUlkcyIsInRyYWNrSXRlbXNNYXAiLCJhY3RpdmVFbGVtZW50cyIsIml0ZW0iLCJnZXRBbGxUaW1lbGluZUVsZW1lbnRzIiwiT2JqZWN0Iiwia2V5cyIsImtleSIsIm9ialZhbHVlIiwic2FtcGxlIiwiZW50cmllcyIsIl8iLCJhbGxFbGVtZW50cyIsInNvcnQiLCJhIiwiYiIsInJlbW92ZVNlZ21lbnRzIiwidHJhY2tJdGVtcyIsImZpcnN0SXRlbUlkIiwiaWRzIiwiUHJvbWlzZSIsInJlc29sdmUiLCJjdXJyZW50U3RhdGUiLCJvcmlnaW5hbEl0ZW1JZCIsIm9yaWdpbmFsSXRlbSIsInRyYWNrVHlwZSIsImVuZE1zIiwidGltZSIsInN0YXRlQWZ0ZXJGaXJzdEN1dCIsImVsZW1lbnRzQWZ0ZXJGaXJzdEN1dCIsImlzTmFOIiwiZHVyYWNpw7NuIiwic3RhcnRNcyIsImxlZnRFbGVtZW50IiwiZmluZCIsImVsZW0iLCJzdGF0ZUFmdGVyU2Vjb25kQ3V0IiwiZWxlbWVudHNBZnRlclNlY29uZEN1dCIsIm1pZGRsZUVsZW1lbnRzIiwiTWF0aCIsImFicyIsIm1pZGRsZUVsZW1lbnQiLCJ2aXNpYmxlIiwic2NhbGUiLCJvcmlnaW5hbFVuaXQiLCJ1bml0IiwiY29tcGFjdFRpbWVsaW5lIiwiZXN0YWRvIiwidG9kb3NFbGVtZW50b3MiLCJlbGVtZW50b3NQb3JUcmFjayIsImlkeCIsImVzcGFjaW9zVmFjaW9zIiwiZWxlbWVudG9zIiwiZWxlbWVudG9BY3R1YWwiLCJlbGVtZW50b1NpZ3VpZW50ZSIsImVzcGFjaW8iLCJzdGFydCIsImVuZCIsInNpemUiLCJlbGVtZW50b0FudGVzIiwiZWxlbWVudG9EZXNwdWVzIiwiZXNwYWNpb1RvdGFsIiwiYWN0dWFsaXphY2lvbmVzIiwiZWxlbWVudG9zQU1vdmVyIiwiZWxlbWVudG8iLCJkZXNwbGF6YW1pZW50byIsIm51ZXZvRnJvbSIsIm51ZXZvVG8iLCJ1cGRhdGVkU2NhbGUiLCJjdXJyZW50U2NhbGUiLCJzbWFydFRyaW0iLCJkYXRhIiwianNvbiIsIkFycmF5IiwiaXNBcnJheSIsInMiLCJlc3RhZG9QcmV2aW8iLCJlbGVtZW50b3NQcmV2aW9zIiwiY29udGFkb3JUcmFja3MiLCJ0cmFja0lkUHJpbmNpcGFsIiwidHJhY2tzUG9yVXNvIiwicmVzdWx0Iiwic2VnbWVudG9zRWxpbWluYWRvcyIsImVsZW1lbnRvc0FjdHVhbGVzIiwic2VnbWVudG8iLCJzZWdtZW50b3NPcmRlbmFkb3MiLCJhZGRNdXNpYyIsIm11c2ljUGF0aCIsInZvbHVtZSIsImF1ZGlvUGF5bG9hZCIsImZhZGVJbiIsImZhZGVPdXQiLCJ0cmFja0dyb3VwcyIsImVsZW1lbnQiLCJlbGVtZW50cyIsImFsbFRleHRFbGVtZW50cyIsImV2ZXJ5Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./components/ai-chat/ai-video-commands.ts\n"));

/***/ })

});
"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./features/editor/hooks/use-selection-modal.ts":
/*!******************************************************!*\
  !*** ./features/editor/hooks/use-selection-modal.ts ***!
  \******************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useSelectionModal: function() { return /* binding */ useSelectionModal; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _designcombo_events__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @designcombo/events */ \"(app-pages-browser)/./node_modules/@designcombo/events/dist/index.es.js\");\n/* harmony import */ var _designcombo_state__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @designcombo/state */ \"(app-pages-browser)/./node_modules/@designcombo/state/dist/index.es.js\");\n/* harmony import */ var _store_use_store__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../store/use-store */ \"(app-pages-browser)/./features/editor/store/use-store.ts\");\n\n\n\n\nconst useSelectionModal = ()=>{\n    const [isModalOpen, setIsModalOpen] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const [selectedItems, setSelectedItems] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n    const { trackItemsMap, setState, activeIds } = (0,_store_use_store__WEBPACK_IMPORTED_MODULE_3__[\"default\"])();\n    // Variable para almacenar el último tiempo de selección\n    const [lastSelectionTime, setLastSelectionTime] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(0);\n    // Variable para almacenar los últimos IDs seleccionados\n    const [prevActiveIds, setPrevActiveIds] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n    // Variable para almacenar la cantidad de selecciones recientes (para detectar actividad de selección)\n    const [selectionCount, setSelectionCount] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(0);\n    // Función para detectar si una selección es por arrastre\n    const detectDragSelection = (currentIds, previousIds, currentTime, lastTime)=>{\n        // Detectar arrastre basado en varios criterios\n        const isMultipleSelection = currentIds.length > 1;\n        const isQuickSelection = currentTime - lastTime < 300; // 300ms\n        const hasSelectionActivity = selectionCount > 3; // Muchas selecciones en poco tiempo sugiere arrastre\n        const isDrag = isMultipleSelection || isQuickSelection && hasSelectionActivity;\n        console.log(\"[DEBUG Modal] Evaluando selecci\\xf3n como arrastre:\", {\n            isMultipleSelection,\n            isQuickSelection,\n            hasSelectionActivity,\n            selectionCount,\n            timeDiff: currentTime - lastTime,\n            currentIds,\n            previousIds,\n            isDrag\n        });\n        return isDrag;\n    };\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        // Suscribirse a eventos de selección\n        const selectionEvents = _designcombo_events__WEBPACK_IMPORTED_MODULE_1__.subject.pipe((0,_designcombo_events__WEBPACK_IMPORTED_MODULE_1__.filter)((param)=>{\n            let { key } = param;\n            return key.startsWith(_designcombo_state__WEBPACK_IMPORTED_MODULE_2__.LAYER_PREFIX);\n        }));\n        const selectionSubscription = selectionEvents.subscribe((obj)=>{\n            if (obj.key === _designcombo_state__WEBPACK_IMPORTED_MODULE_2__.LAYER_SELECTION) {\n                var _obj_value, _obj_value1;\n                const newActiveIds = ((_obj_value = obj.value) === null || _obj_value === void 0 ? void 0 : _obj_value.payload.activeIds) || [];\n                const now = Date.now();\n                console.log(\"[DEBUG Modal] Evento de selecci\\xf3n recibido:\", {\n                    activeIds: newActiveIds,\n                    time: now,\n                    timeDiff: now - lastSelectionTime,\n                    payloadInfo: (_obj_value1 = obj.value) === null || _obj_value1 === void 0 ? void 0 : _obj_value1.payload\n                });\n                // Actualizar estado global\n                setState({\n                    activeIds: newActiveIds\n                });\n                // Incrementar contador de selecciones (para detectar actividad)\n                setSelectionCount((prev)=>prev + 1);\n                // Reducir el contador de selecciones después de un tiempo\n                setTimeout(()=>{\n                    setSelectionCount((prev)=>Math.max(0, prev - 1));\n                }, 1000);\n                // Si hay elementos seleccionados\n                if (newActiveIds && newActiveIds.length > 0) {\n                    // Obtenemos los elementos seleccionados\n                    const items = newActiveIds.map((id)=>trackItemsMap[id]).filter(Boolean);\n                    // Actualizamos los elementos seleccionados\n                    setSelectedItems(items);\n                    // Detectar si es una selección por arrastre\n                    const isDragSelection = detectDragSelection(newActiveIds, prevActiveIds, now, lastSelectionTime);\n                    // Si parece ser una selección por arrastre, mostramos el modal\n                    if (isDragSelection) {\n                        console.log(\"[DEBUG Modal] Mostrando modal por selecci\\xf3n por arrastre\");\n                        setIsModalOpen(true);\n                    }\n                    // Actualizamos el tiempo de la última selección\n                    setLastSelectionTime(now);\n                    // Actualizamos los IDs previamente seleccionados\n                    setPrevActiveIds(newActiveIds);\n                } else {\n                    // Si no hay elementos seleccionados, cerramos el modal\n                    console.log(\"[DEBUG Modal] No hay elementos seleccionados, cerrando modal\");\n                    setIsModalOpen(false);\n                    setSelectedItems([]);\n                }\n            }\n        });\n        return ()=>{\n            selectionSubscription.unsubscribe();\n        };\n    }, [\n        trackItemsMap,\n        setState,\n        lastSelectionTime,\n        prevActiveIds,\n        selectionCount\n    ]);\n    // Si los activeIds cambian fuera de este hook, actualizamos los elementos seleccionados\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (activeIds && activeIds.length > 0) {\n            const items = activeIds.map((id)=>trackItemsMap[id]).filter(Boolean);\n            setSelectedItems(items);\n        }\n    }, [\n        activeIds,\n        trackItemsMap\n    ]);\n    // Escuchar el evento personalizado de arrastre completado\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        const handleDragComplete = (e)=>{\n            console.log(\"[DEBUG Modal] Evento de arrastre completado recibido\", e.detail);\n            // Si hay elementos seleccionados actualmente, mostrar el modal\n            if (activeIds && activeIds.length > 0) {\n                console.log(\"[DEBUG Modal] Hay elementos seleccionados despu\\xe9s del arrastre, mostrando modal\");\n                setIsModalOpen(true);\n            }\n        };\n        // Añadir listener para el evento personalizado\n        window.addEventListener(\"timeline-drag-complete\", handleDragComplete);\n        return ()=>{\n            window.removeEventListener(\"timeline-drag-complete\", handleDragComplete);\n        };\n    }, [\n        activeIds\n    ]);\n    const handleClose = ()=>{\n        console.log(\"[DEBUG Modal] Cerrando modal manualmente\");\n        setIsModalOpen(false);\n    };\n    const handleDelete = ()=>{\n        if (selectedItems.length > 0) {\n            const ids = selectedItems.map((item)=>item.id);\n            console.log(\"[DEBUG Modal] Eliminando elementos:\", ids);\n            (0,_designcombo_events__WEBPACK_IMPORTED_MODULE_1__.dispatch)(_designcombo_state__WEBPACK_IMPORTED_MODULE_2__.LAYER_DELETE, {\n                payload: {\n                    ids\n                }\n            });\n            setIsModalOpen(false);\n        }\n    };\n    const handleCopy = ()=>{\n        // Aquí iría la lógica para duplicar los elementos seleccionados\n        console.log(\"[DEBUG Modal] Duplicar elementos\", selectedItems);\n        setIsModalOpen(false);\n    };\n    const handleSplit = ()=>{\n        if (selectedItems.length === 1) {\n            console.log(\"[DEBUG Modal] Dividiendo elemento:\", selectedItems[0].id);\n            (0,_designcombo_events__WEBPACK_IMPORTED_MODULE_1__.dispatch)(_designcombo_state__WEBPACK_IMPORTED_MODULE_2__.ACTIVE_SPLIT, {\n                payload: {\n                    id: selectedItems[0].id\n                }\n            });\n            setIsModalOpen(false);\n        }\n    };\n    const handleTrim = ()=>{\n        if (selectedItems.length === 1) {\n            // Lógica para recortar el elemento seleccionado\n            console.log(\"[DEBUG Modal] Recortar elemento\", selectedItems[0]);\n            setIsModalOpen(false);\n        }\n    };\n    // Método para abrir el modal manualmente (útil para pruebas)\n    const openModal = ()=>{\n        console.log(\"[DEBUG Modal] Abriendo modal manualmente\");\n        setIsModalOpen(true);\n    };\n    return {\n        isModalOpen,\n        selectedItems,\n        handleClose,\n        handleDelete,\n        handleCopy,\n        handleSplit,\n        handleTrim,\n        openModal\n    };\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2ZlYXR1cmVzL2VkaXRvci9ob29rcy91c2Utc2VsZWN0aW9uLW1vZGFsLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUE0QztBQUNvQjtBQUM0QztBQUNsRTtBQUduQyxNQUFNVSxvQkFBb0I7SUFDL0IsTUFBTSxDQUFDQyxhQUFhQyxlQUFlLEdBQUdaLCtDQUFRQSxDQUFDO0lBQy9DLE1BQU0sQ0FBQ2EsZUFBZUMsaUJBQWlCLEdBQUdkLCtDQUFRQSxDQUFlLEVBQUU7SUFDbkUsTUFBTSxFQUFFZSxhQUFhLEVBQUVDLFFBQVEsRUFBRUMsU0FBUyxFQUFFLEdBQUdSLDREQUFRQTtJQUV2RCx3REFBd0Q7SUFDeEQsTUFBTSxDQUFDUyxtQkFBbUJDLHFCQUFxQixHQUFHbkIsK0NBQVFBLENBQUM7SUFDM0Qsd0RBQXdEO0lBQ3hELE1BQU0sQ0FBQ29CLGVBQWVDLGlCQUFpQixHQUFHckIsK0NBQVFBLENBQVcsRUFBRTtJQUMvRCxzR0FBc0c7SUFDdEcsTUFBTSxDQUFDc0IsZ0JBQWdCQyxrQkFBa0IsR0FBR3ZCLCtDQUFRQSxDQUFDO0lBRXJELHlEQUF5RDtJQUN6RCxNQUFNd0Isc0JBQXNCLENBQzFCQyxZQUNBQyxhQUNBQyxhQUNBQztRQUVBLCtDQUErQztRQUMvQyxNQUFNQyxzQkFBc0JKLFdBQVdLLE1BQU0sR0FBRztRQUNoRCxNQUFNQyxtQkFBbUJKLGNBQWNDLFdBQVcsS0FBSyxRQUFRO1FBQy9ELE1BQU1JLHVCQUF1QlYsaUJBQWlCLEdBQUcscURBQXFEO1FBRXRHLE1BQU1XLFNBQVNKLHVCQUF3QkUsb0JBQW9CQztRQUUzREUsUUFBUUMsR0FBRyxDQUFDLHVEQUFvRDtZQUM5RE47WUFDQUU7WUFDQUM7WUFDQVY7WUFDQWMsVUFBVVQsY0FBY0M7WUFDeEJIO1lBQ0FDO1lBQ0FPO1FBQ0Y7UUFFQSxPQUFPQTtJQUNUO0lBRUFoQyxnREFBU0EsQ0FBQztRQUNSLHFDQUFxQztRQUNyQyxNQUFNb0Msa0JBQWtCakMsd0RBQU9BLENBQUNrQyxJQUFJLENBQ2xDbkMsMkRBQU1BLENBQUM7Z0JBQUMsRUFBRW9DLEdBQUcsRUFBRTttQkFBS0EsSUFBSUMsVUFBVSxDQUFDbkMsNERBQVlBOztRQUdqRCxNQUFNb0Msd0JBQXdCSixnQkFBZ0JLLFNBQVMsQ0FBQyxDQUFDQztZQUN2RCxJQUFJQSxJQUFJSixHQUFHLEtBQUtqQywrREFBZUEsRUFBRTtvQkFDVnFDLFlBT05BO2dCQVBmLE1BQU1DLGVBQWVELEVBQUFBLGFBQUFBLElBQUlFLEtBQUssY0FBVEYsaUNBQUFBLFdBQVdHLE9BQU8sQ0FBQzdCLFNBQVMsS0FBSSxFQUFFO2dCQUN2RCxNQUFNOEIsTUFBTUMsS0FBS0QsR0FBRztnQkFFcEJiLFFBQVFDLEdBQUcsQ0FBQyxrREFBK0M7b0JBQ3pEbEIsV0FBVzJCO29CQUNYSyxNQUFNRjtvQkFDTlgsVUFBVVcsTUFBTTdCO29CQUNoQmdDLFdBQVcsR0FBRVAsY0FBQUEsSUFBSUUsS0FBSyxjQUFURixrQ0FBQUEsWUFBV0csT0FBTztnQkFDakM7Z0JBRUEsMkJBQTJCO2dCQUMzQjlCLFNBQVM7b0JBQ1BDLFdBQVcyQjtnQkFDYjtnQkFFQSxnRUFBZ0U7Z0JBQ2hFckIsa0JBQWtCNEIsQ0FBQUEsT0FBUUEsT0FBTztnQkFFakMsMERBQTBEO2dCQUMxREMsV0FBVztvQkFDVDdCLGtCQUFrQjRCLENBQUFBLE9BQVFFLEtBQUtDLEdBQUcsQ0FBQyxHQUFHSCxPQUFPO2dCQUMvQyxHQUFHO2dCQUVILGlDQUFpQztnQkFDakMsSUFBSVAsZ0JBQWdCQSxhQUFhZCxNQUFNLEdBQUcsR0FBRztvQkFDM0Msd0NBQXdDO29CQUN4QyxNQUFNeUIsUUFBUVgsYUFDWFksR0FBRyxDQUFDQyxDQUFBQSxLQUFNMUMsYUFBYSxDQUFDMEMsR0FBRyxFQUMzQnRELE1BQU0sQ0FBQ3VEO29CQUVWLDJDQUEyQztvQkFDM0M1QyxpQkFBaUJ5QztvQkFFakIsNENBQTRDO29CQUM1QyxNQUFNSSxrQkFBa0JuQyxvQkFDdEJvQixjQUNBeEIsZUFDQTJCLEtBQ0E3QjtvQkFHRiwrREFBK0Q7b0JBQy9ELElBQUl5QyxpQkFBaUI7d0JBQ25CekIsUUFBUUMsR0FBRyxDQUFDO3dCQUNadkIsZUFBZTtvQkFDakI7b0JBRUEsZ0RBQWdEO29CQUNoRE8scUJBQXFCNEI7b0JBQ3JCLGlEQUFpRDtvQkFDakQxQixpQkFBaUJ1QjtnQkFDbkIsT0FBTztvQkFDTCx1REFBdUQ7b0JBQ3ZEVixRQUFRQyxHQUFHLENBQUM7b0JBQ1p2QixlQUFlO29CQUNmRSxpQkFBaUIsRUFBRTtnQkFDckI7WUFDRjtRQUNGO1FBRUEsT0FBTztZQUNMMkIsc0JBQXNCbUIsV0FBVztRQUNuQztJQUNGLEdBQUc7UUFBQzdDO1FBQWVDO1FBQVVFO1FBQW1CRTtRQUFlRTtLQUFlO0lBRTlFLHdGQUF3RjtJQUN4RnJCLGdEQUFTQSxDQUFDO1FBQ1IsSUFBSWdCLGFBQWFBLFVBQVVhLE1BQU0sR0FBRyxHQUFHO1lBQ3JDLE1BQU15QixRQUFRdEMsVUFDWHVDLEdBQUcsQ0FBQ0MsQ0FBQUEsS0FBTTFDLGFBQWEsQ0FBQzBDLEdBQUcsRUFDM0J0RCxNQUFNLENBQUN1RDtZQUVWNUMsaUJBQWlCeUM7UUFDbkI7SUFDRixHQUFHO1FBQUN0QztRQUFXRjtLQUFjO0lBRTdCLDBEQUEwRDtJQUMxRGQsZ0RBQVNBLENBQUM7UUFDUixNQUFNNEQscUJBQXFCLENBQUNDO1lBQzFCNUIsUUFBUUMsR0FBRyxDQUFDLHdEQUF3RDJCLEVBQUVDLE1BQU07WUFFNUUsK0RBQStEO1lBQy9ELElBQUk5QyxhQUFhQSxVQUFVYSxNQUFNLEdBQUcsR0FBRztnQkFDckNJLFFBQVFDLEdBQUcsQ0FBQztnQkFDWnZCLGVBQWU7WUFDakI7UUFDRjtRQUVBLCtDQUErQztRQUMvQ29ELE9BQU9DLGdCQUFnQixDQUFDLDBCQUEwQko7UUFFbEQsT0FBTztZQUNMRyxPQUFPRSxtQkFBbUIsQ0FBQywwQkFBMEJMO1FBQ3ZEO0lBQ0YsR0FBRztRQUFDNUM7S0FBVTtJQUVkLE1BQU1rRCxjQUFjO1FBQ2xCakMsUUFBUUMsR0FBRyxDQUFDO1FBQ1p2QixlQUFlO0lBQ2pCO0lBRUEsTUFBTXdELGVBQWU7UUFDbkIsSUFBSXZELGNBQWNpQixNQUFNLEdBQUcsR0FBRztZQUM1QixNQUFNdUMsTUFBTXhELGNBQWMyQyxHQUFHLENBQUNjLENBQUFBLE9BQVFBLEtBQUtiLEVBQUU7WUFDN0N2QixRQUFRQyxHQUFHLENBQUMsdUNBQXVDa0M7WUFDbkRuRSw2REFBUUEsQ0FBQ0ssNERBQVlBLEVBQUU7Z0JBQ3JCdUMsU0FBUztvQkFDUHVCO2dCQUNGO1lBQ0Y7WUFDQXpELGVBQWU7UUFDakI7SUFDRjtJQUVBLE1BQU0yRCxhQUFhO1FBQ2pCLGdFQUFnRTtRQUNoRXJDLFFBQVFDLEdBQUcsQ0FBQyxvQ0FBb0N0QjtRQUNoREQsZUFBZTtJQUNqQjtJQUVBLE1BQU00RCxjQUFjO1FBQ2xCLElBQUkzRCxjQUFjaUIsTUFBTSxLQUFLLEdBQUc7WUFDOUJJLFFBQVFDLEdBQUcsQ0FBQyxzQ0FBc0N0QixhQUFhLENBQUMsRUFBRSxDQUFDNEMsRUFBRTtZQUNyRXZELDZEQUFRQSxDQUFDTSw0REFBWUEsRUFBRTtnQkFDckJzQyxTQUFTO29CQUNQVyxJQUFJNUMsYUFBYSxDQUFDLEVBQUUsQ0FBQzRDLEVBQUU7Z0JBQ3pCO1lBQ0Y7WUFDQTdDLGVBQWU7UUFDakI7SUFDRjtJQUVBLE1BQU02RCxhQUFhO1FBQ2pCLElBQUk1RCxjQUFjaUIsTUFBTSxLQUFLLEdBQUc7WUFDOUIsZ0RBQWdEO1lBQ2hESSxRQUFRQyxHQUFHLENBQUMsbUNBQW1DdEIsYUFBYSxDQUFDLEVBQUU7WUFDL0RELGVBQWU7UUFDakI7SUFDRjtJQUVBLDZEQUE2RDtJQUM3RCxNQUFNOEQsWUFBWTtRQUNoQnhDLFFBQVFDLEdBQUcsQ0FBQztRQUNadkIsZUFBZTtJQUNqQjtJQUVBLE9BQU87UUFDTEQ7UUFDQUU7UUFDQXNEO1FBQ0FDO1FBQ0FHO1FBQ0FDO1FBQ0FDO1FBQ0FDO0lBQ0Y7QUFDRixFQUFFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL2ZlYXR1cmVzL2VkaXRvci9ob29rcy91c2Utc2VsZWN0aW9uLW1vZGFsLnRzP2QxMzIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgdXNlU3RhdGUsIHVzZUVmZmVjdCB9IGZyb20gJ3JlYWN0JztcclxuaW1wb3J0IHsgZGlzcGF0Y2gsIGZpbHRlciwgc3ViamVjdCB9IGZyb20gXCJAZGVzaWduY29tYm8vZXZlbnRzXCI7XHJcbmltcG9ydCB7IExBWUVSX1BSRUZJWCwgTEFZRVJfU0VMRUNUSU9OLCBMQVlFUl9ERUxFVEUsIEVESVRfT0JKRUNULCBBQ1RJVkVfU1BMSVQgfSBmcm9tIFwiQGRlc2lnbmNvbWJvL3N0YXRlXCI7XHJcbmltcG9ydCB1c2VTdG9yZSBmcm9tICcuLi9zdG9yZS91c2Utc3RvcmUnO1xyXG5pbXBvcnQgeyBJVHJhY2tJdGVtIH0gZnJvbSBcIkBkZXNpZ25jb21iby90eXBlc1wiO1xyXG5cclxuZXhwb3J0IGNvbnN0IHVzZVNlbGVjdGlvbk1vZGFsID0gKCkgPT4ge1xyXG4gIGNvbnN0IFtpc01vZGFsT3Blbiwgc2V0SXNNb2RhbE9wZW5dID0gdXNlU3RhdGUoZmFsc2UpO1xyXG4gIGNvbnN0IFtzZWxlY3RlZEl0ZW1zLCBzZXRTZWxlY3RlZEl0ZW1zXSA9IHVzZVN0YXRlPElUcmFja0l0ZW1bXT4oW10pO1xyXG4gIGNvbnN0IHsgdHJhY2tJdGVtc01hcCwgc2V0U3RhdGUsIGFjdGl2ZUlkcyB9ID0gdXNlU3RvcmUoKTtcclxuXHJcbiAgLy8gVmFyaWFibGUgcGFyYSBhbG1hY2VuYXIgZWwgw7psdGltbyB0aWVtcG8gZGUgc2VsZWNjacOzblxyXG4gIGNvbnN0IFtsYXN0U2VsZWN0aW9uVGltZSwgc2V0TGFzdFNlbGVjdGlvblRpbWVdID0gdXNlU3RhdGUoMCk7XHJcbiAgLy8gVmFyaWFibGUgcGFyYSBhbG1hY2VuYXIgbG9zIMO6bHRpbW9zIElEcyBzZWxlY2Npb25hZG9zXHJcbiAgY29uc3QgW3ByZXZBY3RpdmVJZHMsIHNldFByZXZBY3RpdmVJZHNdID0gdXNlU3RhdGU8c3RyaW5nW10+KFtdKTtcclxuICAvLyBWYXJpYWJsZSBwYXJhIGFsbWFjZW5hciBsYSBjYW50aWRhZCBkZSBzZWxlY2Npb25lcyByZWNpZW50ZXMgKHBhcmEgZGV0ZWN0YXIgYWN0aXZpZGFkIGRlIHNlbGVjY2nDs24pXHJcbiAgY29uc3QgW3NlbGVjdGlvbkNvdW50LCBzZXRTZWxlY3Rpb25Db3VudF0gPSB1c2VTdGF0ZSgwKTtcclxuXHJcbiAgLy8gRnVuY2nDs24gcGFyYSBkZXRlY3RhciBzaSB1bmEgc2VsZWNjacOzbiBlcyBwb3IgYXJyYXN0cmVcclxuICBjb25zdCBkZXRlY3REcmFnU2VsZWN0aW9uID0gKFxyXG4gICAgY3VycmVudElkczogc3RyaW5nW10sXHJcbiAgICBwcmV2aW91c0lkczogc3RyaW5nW10sXHJcbiAgICBjdXJyZW50VGltZTogbnVtYmVyLFxyXG4gICAgbGFzdFRpbWU6IG51bWJlclxyXG4gICkgPT4ge1xyXG4gICAgLy8gRGV0ZWN0YXIgYXJyYXN0cmUgYmFzYWRvIGVuIHZhcmlvcyBjcml0ZXJpb3NcclxuICAgIGNvbnN0IGlzTXVsdGlwbGVTZWxlY3Rpb24gPSBjdXJyZW50SWRzLmxlbmd0aCA+IDE7XHJcbiAgICBjb25zdCBpc1F1aWNrU2VsZWN0aW9uID0gY3VycmVudFRpbWUgLSBsYXN0VGltZSA8IDMwMDsgLy8gMzAwbXNcclxuICAgIGNvbnN0IGhhc1NlbGVjdGlvbkFjdGl2aXR5ID0gc2VsZWN0aW9uQ291bnQgPiAzOyAvLyBNdWNoYXMgc2VsZWNjaW9uZXMgZW4gcG9jbyB0aWVtcG8gc3VnaWVyZSBhcnJhc3RyZVxyXG5cclxuICAgIGNvbnN0IGlzRHJhZyA9IGlzTXVsdGlwbGVTZWxlY3Rpb24gfHwgKGlzUXVpY2tTZWxlY3Rpb24gJiYgaGFzU2VsZWN0aW9uQWN0aXZpdHkpO1xyXG5cclxuICAgIGNvbnNvbGUubG9nKFwiW0RFQlVHIE1vZGFsXSBFdmFsdWFuZG8gc2VsZWNjacOzbiBjb21vIGFycmFzdHJlOlwiLCB7XHJcbiAgICAgIGlzTXVsdGlwbGVTZWxlY3Rpb24sXHJcbiAgICAgIGlzUXVpY2tTZWxlY3Rpb24sXHJcbiAgICAgIGhhc1NlbGVjdGlvbkFjdGl2aXR5LFxyXG4gICAgICBzZWxlY3Rpb25Db3VudCxcclxuICAgICAgdGltZURpZmY6IGN1cnJlbnRUaW1lIC0gbGFzdFRpbWUsXHJcbiAgICAgIGN1cnJlbnRJZHMsXHJcbiAgICAgIHByZXZpb3VzSWRzLFxyXG4gICAgICBpc0RyYWdcclxuICAgIH0pO1xyXG5cclxuICAgIHJldHVybiBpc0RyYWc7XHJcbiAgfTtcclxuXHJcbiAgdXNlRWZmZWN0KCgpID0+IHtcclxuICAgIC8vIFN1c2NyaWJpcnNlIGEgZXZlbnRvcyBkZSBzZWxlY2Npw7NuXHJcbiAgICBjb25zdCBzZWxlY3Rpb25FdmVudHMgPSBzdWJqZWN0LnBpcGUoXHJcbiAgICAgIGZpbHRlcigoeyBrZXkgfSkgPT4ga2V5LnN0YXJ0c1dpdGgoTEFZRVJfUFJFRklYKSksXHJcbiAgICApO1xyXG5cclxuICAgIGNvbnN0IHNlbGVjdGlvblN1YnNjcmlwdGlvbiA9IHNlbGVjdGlvbkV2ZW50cy5zdWJzY3JpYmUoKG9iaikgPT4ge1xyXG4gICAgICBpZiAob2JqLmtleSA9PT0gTEFZRVJfU0VMRUNUSU9OKSB7XHJcbiAgICAgICAgY29uc3QgbmV3QWN0aXZlSWRzID0gb2JqLnZhbHVlPy5wYXlsb2FkLmFjdGl2ZUlkcyB8fCBbXTtcclxuICAgICAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xyXG5cclxuICAgICAgICBjb25zb2xlLmxvZyhcIltERUJVRyBNb2RhbF0gRXZlbnRvIGRlIHNlbGVjY2nDs24gcmVjaWJpZG86XCIsIHtcclxuICAgICAgICAgIGFjdGl2ZUlkczogbmV3QWN0aXZlSWRzLFxyXG4gICAgICAgICAgdGltZTogbm93LFxyXG4gICAgICAgICAgdGltZURpZmY6IG5vdyAtIGxhc3RTZWxlY3Rpb25UaW1lLFxyXG4gICAgICAgICAgcGF5bG9hZEluZm86IG9iai52YWx1ZT8ucGF5bG9hZFxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICAvLyBBY3R1YWxpemFyIGVzdGFkbyBnbG9iYWxcclxuICAgICAgICBzZXRTdGF0ZSh7XHJcbiAgICAgICAgICBhY3RpdmVJZHM6IG5ld0FjdGl2ZUlkcyxcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgLy8gSW5jcmVtZW50YXIgY29udGFkb3IgZGUgc2VsZWNjaW9uZXMgKHBhcmEgZGV0ZWN0YXIgYWN0aXZpZGFkKVxyXG4gICAgICAgIHNldFNlbGVjdGlvbkNvdW50KHByZXYgPT4gcHJldiArIDEpO1xyXG5cclxuICAgICAgICAvLyBSZWR1Y2lyIGVsIGNvbnRhZG9yIGRlIHNlbGVjY2lvbmVzIGRlc3B1w6lzIGRlIHVuIHRpZW1wb1xyXG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICAgICAgc2V0U2VsZWN0aW9uQ291bnQocHJldiA9PiBNYXRoLm1heCgwLCBwcmV2IC0gMSkpO1xyXG4gICAgICAgIH0sIDEwMDApO1xyXG5cclxuICAgICAgICAvLyBTaSBoYXkgZWxlbWVudG9zIHNlbGVjY2lvbmFkb3NcclxuICAgICAgICBpZiAobmV3QWN0aXZlSWRzICYmIG5ld0FjdGl2ZUlkcy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAvLyBPYnRlbmVtb3MgbG9zIGVsZW1lbnRvcyBzZWxlY2Npb25hZG9zXHJcbiAgICAgICAgICBjb25zdCBpdGVtcyA9IG5ld0FjdGl2ZUlkc1xyXG4gICAgICAgICAgICAubWFwKGlkID0+IHRyYWNrSXRlbXNNYXBbaWRdKVxyXG4gICAgICAgICAgICAuZmlsdGVyKEJvb2xlYW4pO1xyXG5cclxuICAgICAgICAgIC8vIEFjdHVhbGl6YW1vcyBsb3MgZWxlbWVudG9zIHNlbGVjY2lvbmFkb3NcclxuICAgICAgICAgIHNldFNlbGVjdGVkSXRlbXMoaXRlbXMpO1xyXG5cclxuICAgICAgICAgIC8vIERldGVjdGFyIHNpIGVzIHVuYSBzZWxlY2Npw7NuIHBvciBhcnJhc3RyZVxyXG4gICAgICAgICAgY29uc3QgaXNEcmFnU2VsZWN0aW9uID0gZGV0ZWN0RHJhZ1NlbGVjdGlvbihcclxuICAgICAgICAgICAgbmV3QWN0aXZlSWRzLFxyXG4gICAgICAgICAgICBwcmV2QWN0aXZlSWRzLFxyXG4gICAgICAgICAgICBub3csXHJcbiAgICAgICAgICAgIGxhc3RTZWxlY3Rpb25UaW1lXHJcbiAgICAgICAgICApO1xyXG5cclxuICAgICAgICAgIC8vIFNpIHBhcmVjZSBzZXIgdW5hIHNlbGVjY2nDs24gcG9yIGFycmFzdHJlLCBtb3N0cmFtb3MgZWwgbW9kYWxcclxuICAgICAgICAgIGlmIChpc0RyYWdTZWxlY3Rpb24pIHtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coXCJbREVCVUcgTW9kYWxdIE1vc3RyYW5kbyBtb2RhbCBwb3Igc2VsZWNjacOzbiBwb3IgYXJyYXN0cmVcIik7XHJcbiAgICAgICAgICAgIHNldElzTW9kYWxPcGVuKHRydWUpO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIC8vIEFjdHVhbGl6YW1vcyBlbCB0aWVtcG8gZGUgbGEgw7psdGltYSBzZWxlY2Npw7NuXHJcbiAgICAgICAgICBzZXRMYXN0U2VsZWN0aW9uVGltZShub3cpO1xyXG4gICAgICAgICAgLy8gQWN0dWFsaXphbW9zIGxvcyBJRHMgcHJldmlhbWVudGUgc2VsZWNjaW9uYWRvc1xyXG4gICAgICAgICAgc2V0UHJldkFjdGl2ZUlkcyhuZXdBY3RpdmVJZHMpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAvLyBTaSBubyBoYXkgZWxlbWVudG9zIHNlbGVjY2lvbmFkb3MsIGNlcnJhbW9zIGVsIG1vZGFsXHJcbiAgICAgICAgICBjb25zb2xlLmxvZyhcIltERUJVRyBNb2RhbF0gTm8gaGF5IGVsZW1lbnRvcyBzZWxlY2Npb25hZG9zLCBjZXJyYW5kbyBtb2RhbFwiKTtcclxuICAgICAgICAgIHNldElzTW9kYWxPcGVuKGZhbHNlKTtcclxuICAgICAgICAgIHNldFNlbGVjdGVkSXRlbXMoW10pO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgcmV0dXJuICgpID0+IHtcclxuICAgICAgc2VsZWN0aW9uU3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XHJcbiAgICB9O1xyXG4gIH0sIFt0cmFja0l0ZW1zTWFwLCBzZXRTdGF0ZSwgbGFzdFNlbGVjdGlvblRpbWUsIHByZXZBY3RpdmVJZHMsIHNlbGVjdGlvbkNvdW50XSk7XHJcblxyXG4gIC8vIFNpIGxvcyBhY3RpdmVJZHMgY2FtYmlhbiBmdWVyYSBkZSBlc3RlIGhvb2ssIGFjdHVhbGl6YW1vcyBsb3MgZWxlbWVudG9zIHNlbGVjY2lvbmFkb3NcclxuICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgaWYgKGFjdGl2ZUlkcyAmJiBhY3RpdmVJZHMubGVuZ3RoID4gMCkge1xyXG4gICAgICBjb25zdCBpdGVtcyA9IGFjdGl2ZUlkc1xyXG4gICAgICAgIC5tYXAoaWQgPT4gdHJhY2tJdGVtc01hcFtpZF0pXHJcbiAgICAgICAgLmZpbHRlcihCb29sZWFuKTtcclxuXHJcbiAgICAgIHNldFNlbGVjdGVkSXRlbXMoaXRlbXMpO1xyXG4gICAgfVxyXG4gIH0sIFthY3RpdmVJZHMsIHRyYWNrSXRlbXNNYXBdKTtcclxuXHJcbiAgLy8gRXNjdWNoYXIgZWwgZXZlbnRvIHBlcnNvbmFsaXphZG8gZGUgYXJyYXN0cmUgY29tcGxldGFkb1xyXG4gIHVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICBjb25zdCBoYW5kbGVEcmFnQ29tcGxldGUgPSAoZTogQ3VzdG9tRXZlbnQpID0+IHtcclxuICAgICAgY29uc29sZS5sb2coXCJbREVCVUcgTW9kYWxdIEV2ZW50byBkZSBhcnJhc3RyZSBjb21wbGV0YWRvIHJlY2liaWRvXCIsIGUuZGV0YWlsKTtcclxuXHJcbiAgICAgIC8vIFNpIGhheSBlbGVtZW50b3Mgc2VsZWNjaW9uYWRvcyBhY3R1YWxtZW50ZSwgbW9zdHJhciBlbCBtb2RhbFxyXG4gICAgICBpZiAoYWN0aXZlSWRzICYmIGFjdGl2ZUlkcy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgY29uc29sZS5sb2coXCJbREVCVUcgTW9kYWxdIEhheSBlbGVtZW50b3Mgc2VsZWNjaW9uYWRvcyBkZXNwdcOpcyBkZWwgYXJyYXN0cmUsIG1vc3RyYW5kbyBtb2RhbFwiKTtcclxuICAgICAgICBzZXRJc01vZGFsT3Blbih0cnVlKTtcclxuICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICAvLyBBw7FhZGlyIGxpc3RlbmVyIHBhcmEgZWwgZXZlbnRvIHBlcnNvbmFsaXphZG9cclxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCd0aW1lbGluZS1kcmFnLWNvbXBsZXRlJywgaGFuZGxlRHJhZ0NvbXBsZXRlIGFzIEV2ZW50TGlzdGVuZXIpO1xyXG5cclxuICAgIHJldHVybiAoKSA9PiB7XHJcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCd0aW1lbGluZS1kcmFnLWNvbXBsZXRlJywgaGFuZGxlRHJhZ0NvbXBsZXRlIGFzIEV2ZW50TGlzdGVuZXIpO1xyXG4gICAgfTtcclxuICB9LCBbYWN0aXZlSWRzXSk7XHJcblxyXG4gIGNvbnN0IGhhbmRsZUNsb3NlID0gKCkgPT4ge1xyXG4gICAgY29uc29sZS5sb2coXCJbREVCVUcgTW9kYWxdIENlcnJhbmRvIG1vZGFsIG1hbnVhbG1lbnRlXCIpO1xyXG4gICAgc2V0SXNNb2RhbE9wZW4oZmFsc2UpO1xyXG4gIH07XHJcblxyXG4gIGNvbnN0IGhhbmRsZURlbGV0ZSA9ICgpID0+IHtcclxuICAgIGlmIChzZWxlY3RlZEl0ZW1zLmxlbmd0aCA+IDApIHtcclxuICAgICAgY29uc3QgaWRzID0gc2VsZWN0ZWRJdGVtcy5tYXAoaXRlbSA9PiBpdGVtLmlkKTtcclxuICAgICAgY29uc29sZS5sb2coXCJbREVCVUcgTW9kYWxdIEVsaW1pbmFuZG8gZWxlbWVudG9zOlwiLCBpZHMpO1xyXG4gICAgICBkaXNwYXRjaChMQVlFUl9ERUxFVEUsIHtcclxuICAgICAgICBwYXlsb2FkOiB7XHJcbiAgICAgICAgICBpZHNcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG4gICAgICBzZXRJc01vZGFsT3BlbihmYWxzZSk7XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgY29uc3QgaGFuZGxlQ29weSA9ICgpID0+IHtcclxuICAgIC8vIEFxdcOtIGlyw61hIGxhIGzDs2dpY2EgcGFyYSBkdXBsaWNhciBsb3MgZWxlbWVudG9zIHNlbGVjY2lvbmFkb3NcclxuICAgIGNvbnNvbGUubG9nKCdbREVCVUcgTW9kYWxdIER1cGxpY2FyIGVsZW1lbnRvcycsIHNlbGVjdGVkSXRlbXMpO1xyXG4gICAgc2V0SXNNb2RhbE9wZW4oZmFsc2UpO1xyXG4gIH07XHJcblxyXG4gIGNvbnN0IGhhbmRsZVNwbGl0ID0gKCkgPT4ge1xyXG4gICAgaWYgKHNlbGVjdGVkSXRlbXMubGVuZ3RoID09PSAxKSB7XHJcbiAgICAgIGNvbnNvbGUubG9nKCdbREVCVUcgTW9kYWxdIERpdmlkaWVuZG8gZWxlbWVudG86Jywgc2VsZWN0ZWRJdGVtc1swXS5pZCk7XHJcbiAgICAgIGRpc3BhdGNoKEFDVElWRV9TUExJVCwge1xyXG4gICAgICAgIHBheWxvYWQ6IHtcclxuICAgICAgICAgIGlkOiBzZWxlY3RlZEl0ZW1zWzBdLmlkLFxyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgICAgIHNldElzTW9kYWxPcGVuKGZhbHNlKTtcclxuICAgIH1cclxuICB9O1xyXG5cclxuICBjb25zdCBoYW5kbGVUcmltID0gKCkgPT4ge1xyXG4gICAgaWYgKHNlbGVjdGVkSXRlbXMubGVuZ3RoID09PSAxKSB7XHJcbiAgICAgIC8vIEzDs2dpY2EgcGFyYSByZWNvcnRhciBlbCBlbGVtZW50byBzZWxlY2Npb25hZG9cclxuICAgICAgY29uc29sZS5sb2coJ1tERUJVRyBNb2RhbF0gUmVjb3J0YXIgZWxlbWVudG8nLCBzZWxlY3RlZEl0ZW1zWzBdKTtcclxuICAgICAgc2V0SXNNb2RhbE9wZW4oZmFsc2UpO1xyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIC8vIE3DqXRvZG8gcGFyYSBhYnJpciBlbCBtb2RhbCBtYW51YWxtZW50ZSAow7p0aWwgcGFyYSBwcnVlYmFzKVxyXG4gIGNvbnN0IG9wZW5Nb2RhbCA9ICgpID0+IHtcclxuICAgIGNvbnNvbGUubG9nKFwiW0RFQlVHIE1vZGFsXSBBYnJpZW5kbyBtb2RhbCBtYW51YWxtZW50ZVwiKTtcclxuICAgIHNldElzTW9kYWxPcGVuKHRydWUpO1xyXG4gIH07XHJcblxyXG4gIHJldHVybiB7XHJcbiAgICBpc01vZGFsT3BlbixcclxuICAgIHNlbGVjdGVkSXRlbXMsXHJcbiAgICBoYW5kbGVDbG9zZSxcclxuICAgIGhhbmRsZURlbGV0ZSxcclxuICAgIGhhbmRsZUNvcHksXHJcbiAgICBoYW5kbGVTcGxpdCxcclxuICAgIGhhbmRsZVRyaW0sXHJcbiAgICBvcGVuTW9kYWwgLy8gTnVldm8gbcOpdG9kbyBwYXJhIGFicmlyIGVsIG1vZGFsIG1hbnVhbG1lbnRlXHJcbiAgfTtcclxufTtcclxuIl0sIm5hbWVzIjpbInVzZVN0YXRlIiwidXNlRWZmZWN0IiwiZGlzcGF0Y2giLCJmaWx0ZXIiLCJzdWJqZWN0IiwiTEFZRVJfUFJFRklYIiwiTEFZRVJfU0VMRUNUSU9OIiwiTEFZRVJfREVMRVRFIiwiQUNUSVZFX1NQTElUIiwidXNlU3RvcmUiLCJ1c2VTZWxlY3Rpb25Nb2RhbCIsImlzTW9kYWxPcGVuIiwic2V0SXNNb2RhbE9wZW4iLCJzZWxlY3RlZEl0ZW1zIiwic2V0U2VsZWN0ZWRJdGVtcyIsInRyYWNrSXRlbXNNYXAiLCJzZXRTdGF0ZSIsImFjdGl2ZUlkcyIsImxhc3RTZWxlY3Rpb25UaW1lIiwic2V0TGFzdFNlbGVjdGlvblRpbWUiLCJwcmV2QWN0aXZlSWRzIiwic2V0UHJldkFjdGl2ZUlkcyIsInNlbGVjdGlvbkNvdW50Iiwic2V0U2VsZWN0aW9uQ291bnQiLCJkZXRlY3REcmFnU2VsZWN0aW9uIiwiY3VycmVudElkcyIsInByZXZpb3VzSWRzIiwiY3VycmVudFRpbWUiLCJsYXN0VGltZSIsImlzTXVsdGlwbGVTZWxlY3Rpb24iLCJsZW5ndGgiLCJpc1F1aWNrU2VsZWN0aW9uIiwiaGFzU2VsZWN0aW9uQWN0aXZpdHkiLCJpc0RyYWciLCJjb25zb2xlIiwibG9nIiwidGltZURpZmYiLCJzZWxlY3Rpb25FdmVudHMiLCJwaXBlIiwia2V5Iiwic3RhcnRzV2l0aCIsInNlbGVjdGlvblN1YnNjcmlwdGlvbiIsInN1YnNjcmliZSIsIm9iaiIsIm5ld0FjdGl2ZUlkcyIsInZhbHVlIiwicGF5bG9hZCIsIm5vdyIsIkRhdGUiLCJ0aW1lIiwicGF5bG9hZEluZm8iLCJwcmV2Iiwic2V0VGltZW91dCIsIk1hdGgiLCJtYXgiLCJpdGVtcyIsIm1hcCIsImlkIiwiQm9vbGVhbiIsImlzRHJhZ1NlbGVjdGlvbiIsInVuc3Vic2NyaWJlIiwiaGFuZGxlRHJhZ0NvbXBsZXRlIiwiZSIsImRldGFpbCIsIndpbmRvdyIsImFkZEV2ZW50TGlzdGVuZXIiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiaGFuZGxlQ2xvc2UiLCJoYW5kbGVEZWxldGUiLCJpZHMiLCJpdGVtIiwiaGFuZGxlQ29weSIsImhhbmRsZVNwbGl0IiwiaGFuZGxlVHJpbSIsIm9wZW5Nb2RhbCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./features/editor/hooks/use-selection-modal.ts\n"));

/***/ })

});
"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./features/editor/scene/interactions.tsx":
/*!************************************************!*\
  !*** ./features/editor/scene/interactions.tsx ***!
  \************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SceneInteractions: function() { return /* binding */ SceneInteractions; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _interactify_selection__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @interactify/selection */ \"(app-pages-browser)/./node_modules/@interactify/selection/dist/selecto.esm.js\");\n/* harmony import */ var _interactify_moveable__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @interactify/moveable */ \"(app-pages-browser)/./node_modules/@interactify/moveable/dist/index.es.js\");\n/* harmony import */ var _utils_scene__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/scene */ \"(app-pages-browser)/./features/editor/utils/scene.ts\");\n/* harmony import */ var _designcombo_events__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @designcombo/events */ \"(app-pages-browser)/./node_modules/@designcombo/events/dist/index.es.js\");\n/* harmony import */ var _designcombo_state__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @designcombo/state */ \"(app-pages-browser)/./node_modules/@designcombo/state/dist/index.es.js\");\n/* harmony import */ var _utils_target__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../utils/target */ \"(app-pages-browser)/./features/editor/utils/target.ts\");\n/* harmony import */ var _store_use_store__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../store/use-store */ \"(app-pages-browser)/./features/editor/store/use-store.ts\");\n/* harmony import */ var _utils_time__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../utils/time */ \"(app-pages-browser)/./features/editor/utils/time.ts\");\n/* harmony import */ var _store_use_layout_store__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../store/use-layout-store */ \"(app-pages-browser)/./features/editor/store/use-layout-store.ts\");\n/* __next_internal_client_entry_do_not_use__ SceneInteractions auto */ \nvar _s = $RefreshSig$();\n\n\n\n\n\n\n\n\n\n\nlet holdGroupPosition = null;\nlet dragStartEnd = false;\nfunction SceneInteractions(param) {\n    let { stateManager, viewerRef, zoom, size } = param;\n    _s();\n    const [targets, setTargets] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]);\n    const [selection, setSelection] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)();\n    const { activeIds, setState, trackItemDetailsMap, trackItemsMap, playerRef, setSceneMoveableRef } = (0,_store_use_store__WEBPACK_IMPORTED_MODULE_7__[\"default\"])();\n    const { setActiveMenuItem, setShowMenuItem } = (0,_store_use_layout_store__WEBPACK_IMPORTED_MODULE_9__[\"default\"])();\n    const moveableRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const [selectionInfo, setSelectionInfo] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(_utils_target__WEBPACK_IMPORTED_MODULE_6__.emptySelection);\n    // Constantes para el snap\n    const SNAP_THRESHOLD = 15; // Distancia en píxeles para activar el snap\n    const SNAP_EDGE_THRESHOLD = 5; // Umbral para considerar que un elemento está en el borde\n    // Función para aplicar snap a coordenadas\n    const applySnap = function(value, snapPoints) {\n        let threshold = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : SNAP_THRESHOLD;\n        for (const point of snapPoints){\n            if (Math.abs(value - point) <= threshold) {\n                return point;\n            }\n        }\n        return value;\n    };\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        var _playerRef_current;\n        const updateTargets = (time)=>{\n            const currentTime = time || (0,_utils_time__WEBPACK_IMPORTED_MODULE_8__.getCurrentTime)();\n            const { trackItemsMap } = _store_use_store__WEBPACK_IMPORTED_MODULE_7__[\"default\"].getState();\n            const targetIds = activeIds.filter((id)=>{\n                var _trackItemsMap_id, _trackItemsMap_id1;\n                return ((_trackItemsMap_id = trackItemsMap[id]) === null || _trackItemsMap_id === void 0 ? void 0 : _trackItemsMap_id.display.from) <= currentTime && ((_trackItemsMap_id1 = trackItemsMap[id]) === null || _trackItemsMap_id1 === void 0 ? void 0 : _trackItemsMap_id1.display.to) >= currentTime;\n            });\n            const targets = targetIds.map((id)=>(0,_utils_target__WEBPACK_IMPORTED_MODULE_6__.getTargetById)(id));\n            selection === null || selection === void 0 ? void 0 : selection.setSelectedTargets(targets);\n            const selInfo = (0,_utils_target__WEBPACK_IMPORTED_MODULE_6__.getSelectionByIds)(targetIds);\n            setSelectionInfo(selInfo);\n            setTargets(selInfo.targets);\n        };\n        const timer = setTimeout(()=>{\n            updateTargets();\n        });\n        const onSeeked = (v)=>{\n            setTimeout(()=>{\n                const { fps } = _store_use_store__WEBPACK_IMPORTED_MODULE_7__[\"default\"].getState();\n                const seekedTime = v.detail.frame / fps * 1000;\n                updateTargets(seekedTime);\n            });\n        };\n        playerRef === null || playerRef === void 0 ? void 0 : (_playerRef_current = playerRef.current) === null || _playerRef_current === void 0 ? void 0 : _playerRef_current.addEventListener(\"seeked\", onSeeked);\n        return ()=>{\n            var _playerRef_current;\n            playerRef === null || playerRef === void 0 ? void 0 : (_playerRef_current = playerRef.current) === null || _playerRef_current === void 0 ? void 0 : _playerRef_current.removeEventListener(\"seeked\", onSeeked);\n            clearTimeout(timer);\n        };\n    }, [\n        activeIds,\n        playerRef,\n        trackItemsMap\n    ]);\n    // Función para manejar la selección de elementos\n    const handleSelection = (ids)=>{\n        console.log(\"[DEBUG Interactions] Selecci\\xf3n de elementos:\", ids);\n        // Actualizar el estado de activeIds\n        stateManager.updateState({\n            activeIds: ids\n        }, {\n            updateHistory: false,\n            kind: \"layer:selection\"\n        });\n        // Si se ha seleccionado un solo elemento, cambiar inmediatamente al panel de atributos\n        if (ids && ids.length === 1) {\n            console.log(\"[DEBUG Interactions] Cambiando a panel de atributos directamente desde interactions\");\n            // FORZAR cambio directo al panel de atributos\n            setActiveMenuItem(\"attributes\");\n            setShowMenuItem(true);\n            // Forzar el evento de selección para asegurar que todos los componentes se actualicen\n            (0,_designcombo_events__WEBPACK_IMPORTED_MODULE_4__.dispatch)(_designcombo_state__WEBPACK_IMPORTED_MODULE_5__.LAYER_SELECTION, {\n                payload: {\n                    activeIds: ids\n                }\n            });\n            // Verificar el cambio\n            setTimeout(()=>{\n                const currentMenuItem = _store_use_layout_store__WEBPACK_IMPORTED_MODULE_9__[\"default\"].getState().activeMenuItem;\n                console.log(\"[DEBUG Interactions] Panel despu\\xe9s del cambio:\", currentMenuItem);\n            }, 100);\n        }\n    };\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        var _viewerRef_current;\n        const selection = new _interactify_selection__WEBPACK_IMPORTED_MODULE_10__[\"default\"]({\n            container: (_viewerRef_current = viewerRef.current) === null || _viewerRef_current === void 0 ? void 0 : _viewerRef_current.infiniteViewer.getContainer(),\n            boundContainer: true,\n            hitRate: 0,\n            selectableTargets: [\n                \".designcombo-scene-item\"\n            ],\n            selectFromInside: false,\n            selectByClick: true,\n            toggleContinueSelect: \"shift\"\n        }).on(\"select\", (e)=>{\n            const ids = e.selected.map((el)=>(0,_utils_scene__WEBPACK_IMPORTED_MODULE_3__.getIdFromClassName)(el.className));\n            setTargets(e.selected);\n            // Usar la función handleSelection\n            handleSelection(ids);\n        }).on(\"dragStart\", (e)=>{\n            var _moveableRef_current;\n            const target = e.inputEvent.target;\n            dragStartEnd = false;\n            if (targets.includes(target)) {\n                e.stop();\n            }\n            if (target && (moveableRef === null || moveableRef === void 0 ? void 0 : (_moveableRef_current = moveableRef.current) === null || _moveableRef_current === void 0 ? void 0 : _moveableRef_current.moveable.isMoveableElement(target))) {\n                e.stop();\n            }\n        }).on(\"dragEnd\", ()=>{\n            dragStartEnd = true;\n        }).on(\"selectEnd\", (e)=>{\n            const moveable = moveableRef.current;\n            if (e.isDragStart) {\n                e.inputEvent.preventDefault();\n                setTimeout(()=>{\n                    if (!dragStartEnd) {\n                        moveable === null || moveable === void 0 ? void 0 : moveable.moveable.dragStart(e.inputEvent);\n                    }\n                });\n            } else {\n                const targets = e.selected;\n                const ids = targets.map((el)=>(0,_utils_scene__WEBPACK_IMPORTED_MODULE_3__.getIdFromClassName)(el.className));\n                // Usar la función handleSelection\n                handleSelection(ids);\n                setTargets(targets);\n            }\n        });\n        setSelection(selection);\n        return ()=>{\n            selection.destroy();\n        };\n    }, []);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        const activeSelectionSubscription = stateManager.subscribeToActiveIds((newState)=>{\n            setState(newState);\n            // Si hay un solo elemento seleccionado, asegurarse de que se muestre el panel de atributos\n            if (newState.activeIds && newState.activeIds.length === 1) {\n                setActiveMenuItem(\"attributes\");\n                setShowMenuItem(true);\n            }\n        });\n        return ()=>{\n            activeSelectionSubscription.unsubscribe();\n        };\n    }, []);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        moveableRef.current.moveable.updateRect();\n    }, [\n        trackItemsMap\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        setSceneMoveableRef(moveableRef);\n    }, [\n        moveableRef\n    ]);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_interactify_moveable__WEBPACK_IMPORTED_MODULE_2__[\"default\"], {\n        ref: moveableRef,\n        rotationPosition: \"bottom\",\n        renderDirections: selectionInfo.controls,\n        ...selectionInfo.ables,\n        origin: false,\n        target: targets,\n        zoom: 1 / zoom,\n        className: \"designcombo-scene-moveable\",\n        onDrag: (param)=>{\n            let { target, beforeTranslate, inputEvent } = param;\n            const targetId = (0,_utils_scene__WEBPACK_IMPORTED_MODULE_3__.getIdFromClassName)(target.className);\n            const trackItem = trackItemDetailsMap[targetId];\n            // Obtener dimensiones del elemento\n            const targetWidth = target.offsetWidth;\n            const targetHeight = target.offsetHeight;\n            // Calcular la posición propuesta\n            let left = parseFloat(trackItem === null || trackItem === void 0 ? void 0 : trackItem.details.left) + beforeTranslate[0];\n            let top = parseFloat(trackItem === null || trackItem === void 0 ? void 0 : trackItem.details.top) + beforeTranslate[1];\n            // Puntos de snap para el eje X (izquierda, centro, derecha)\n            const snapPointsX = [\n                0,\n                size.width / 2 - targetWidth / 2,\n                size.width - targetWidth // Borde derecho\n            ];\n            // Puntos de snap para el eje Y (arriba, centro, abajo)\n            const snapPointsY = [\n                0,\n                size.height / 2 - targetHeight / 2,\n                size.height - targetHeight // Borde inferior\n            ];\n            // Aplicar snap con umbral normal\n            left = applySnap(left, snapPointsX);\n            top = applySnap(top, snapPointsY);\n            // Feedback visual para indicar el snap (opcional)\n            if (snapPointsX.some((point)=>Math.abs(left - point) <= SNAP_EDGE_THRESHOLD) || snapPointsY.some((point)=>Math.abs(top - point) <= SNAP_EDGE_THRESHOLD)) {\n                // Se podría añadir una clase CSS para indicar visualmente el snap\n                target.classList.add(\"snapped-element\");\n                // Añadir pequeña vibración como feedback táctil (opcional)\n                if (inputEvent instanceof MouseEvent && \"vibrate\" in navigator) {\n                    navigator.vibrate(10); // Vibración sutil de 10ms\n                }\n            } else {\n                target.classList.remove(\"snapped-element\");\n            }\n            // Actualizar posición\n            target.style.top = top + \"px\";\n            target.style.left = left + \"px\";\n        },\n        onDragEnd: (param)=>{\n            let { target, isDrag } = param;\n            if (!isDrag) return;\n            const targetId = (0,_utils_scene__WEBPACK_IMPORTED_MODULE_3__.getIdFromClassName)(target.className);\n            // Eliminar la clase de snap al finalizar\n            target.classList.remove(\"snapped-element\");\n            (0,_designcombo_events__WEBPACK_IMPORTED_MODULE_4__.dispatch)(_designcombo_state__WEBPACK_IMPORTED_MODULE_5__.EDIT_OBJECT, {\n                payload: {\n                    [targetId]: {\n                        details: {\n                            left: target.style.left,\n                            top: target.style.top\n                        }\n                    }\n                }\n            });\n        },\n        onScale: (param)=>{\n            let { target, transform, direction } = param;\n            const [xControl, yControl] = direction;\n            const scaleRegex = /scale\\(([^)]+)\\)/;\n            const match = target.style.transform.match(scaleRegex);\n            //get current scale\n            const [scaleX, scaleY] = match[1].split(\",\").map((value)=>parseFloat(value.trim()));\n            //get new Scale\n            const match2 = transform.match(scaleRegex);\n            const [newScaleX, newScaleY] = match2[1].split(\",\").map((value)=>parseFloat(value.trim()));\n            const currentWidth = target.clientWidth * scaleX;\n            const currentHeight = target.clientHeight * scaleY;\n            const newWidth = target.clientWidth * newScaleX;\n            const newHeight = target.clientHeight * newScaleY;\n            target.style.transform = transform;\n            //Move element to initial Left position\n            const diffX = currentWidth - newWidth;\n            let newLeft = parseFloat(target.style.left) - diffX / 2;\n            const diffY = currentHeight - newHeight;\n            let newTop = parseFloat(target.style.top) - diffY / 2;\n            if (xControl === -1) {\n                newLeft += diffX;\n            }\n            if (yControl === -1) {\n                newTop += diffY;\n            }\n            target.style.left = newLeft + \"px\";\n            target.style.top = newTop + \"px\";\n        },\n        onScaleEnd: (param)=>{\n            let { target } = param;\n            if (!target.style.transform) return;\n            const targetId = (0,_utils_scene__WEBPACK_IMPORTED_MODULE_3__.getIdFromClassName)(target.className);\n            (0,_designcombo_events__WEBPACK_IMPORTED_MODULE_4__.dispatch)(_designcombo_state__WEBPACK_IMPORTED_MODULE_5__.EDIT_OBJECT, {\n                payload: {\n                    [targetId]: {\n                        details: {\n                            transform: target.style.transform,\n                            left: parseFloat(target.style.left),\n                            top: parseFloat(target.style.top)\n                        }\n                    }\n                }\n            });\n        },\n        onRotate: (param)=>{\n            let { target, transform } = param;\n            target.style.transform = transform;\n        },\n        onRotateEnd: (param)=>{\n            let { target } = param;\n            if (!target.style.transform) return;\n            const targetId = (0,_utils_scene__WEBPACK_IMPORTED_MODULE_3__.getIdFromClassName)(target.className);\n            (0,_designcombo_events__WEBPACK_IMPORTED_MODULE_4__.dispatch)(_designcombo_state__WEBPACK_IMPORTED_MODULE_5__.EDIT_OBJECT, {\n                payload: {\n                    [targetId]: {\n                        details: {\n                            transform: target.style.transform\n                        }\n                    }\n                }\n            });\n        },\n        onDragGroup: (param)=>{\n            let { events } = param;\n            holdGroupPosition = {};\n            // Obtener el rectángulo que contiene todo el grupo\n            let groupLeft = Infinity;\n            let groupTop = Infinity;\n            let groupRight = -Infinity;\n            let groupBottom = -Infinity;\n            // Primer paso: calcular dimensiones del grupo\n            for(let i = 0; i < events.length; i++){\n                const event = events[i];\n                const id = (0,_utils_scene__WEBPACK_IMPORTED_MODULE_3__.getIdFromClassName)(event.target.className);\n                const trackItem = trackItemDetailsMap[id];\n                const left = parseFloat(trackItem === null || trackItem === void 0 ? void 0 : trackItem.details.left);\n                const top = parseFloat(trackItem === null || trackItem === void 0 ? void 0 : trackItem.details.top);\n                const width = event.target.offsetWidth;\n                const height = event.target.offsetHeight;\n                groupLeft = Math.min(groupLeft, left);\n                groupTop = Math.min(groupTop, top);\n                groupRight = Math.max(groupRight, left + width);\n                groupBottom = Math.max(groupBottom, top + height);\n            }\n            const groupWidth = groupRight - groupLeft;\n            const groupHeight = groupBottom - groupTop;\n            // Calcular el desplazamiento base del grupo (desde el primer elemento)\n            const baseTranslate = events[0].beforeTranslate;\n            // Calcular nueva posición del grupo con posible snap\n            let newGroupLeft = groupLeft + baseTranslate[0];\n            let newGroupTop = groupTop + baseTranslate[1];\n            // Puntos de snap para el grupo\n            const snapPointsX = [\n                0,\n                size.width / 2 - groupWidth / 2,\n                size.width - groupWidth // Borde derecho\n            ];\n            const snapPointsY = [\n                0,\n                size.height / 2 - groupHeight / 2,\n                size.height - groupHeight // Borde inferior\n            ];\n            // Aplicar snap al grupo\n            const snappedGroupLeft = applySnap(newGroupLeft, snapPointsX);\n            const snappedGroupTop = applySnap(newGroupTop, snapPointsY);\n            // Calcular el ajuste necesario después del snap\n            const adjustX = snappedGroupLeft - newGroupLeft;\n            const adjustY = snappedGroupTop - newGroupTop;\n            // Feedback visual para el snap de grupo\n            const isGroupSnapped = Math.abs(adjustX) <= SNAP_EDGE_THRESHOLD || Math.abs(adjustY) <= SNAP_EDGE_THRESHOLD;\n            // Aplicar el movimiento ajustado a cada elemento del grupo\n            for(let i = 0; i < events.length; i++){\n                const event = events[i];\n                const id = (0,_utils_scene__WEBPACK_IMPORTED_MODULE_3__.getIdFromClassName)(event.target.className);\n                const trackItem = trackItemDetailsMap[id];\n                const left = parseFloat(trackItem === null || trackItem === void 0 ? void 0 : trackItem.details.left) + event.beforeTranslate[0] + adjustX;\n                const top = parseFloat(trackItem === null || trackItem === void 0 ? void 0 : trackItem.details.top) + event.beforeTranslate[1] + adjustY;\n                event.target.style.left = \"\".concat(left, \"px\");\n                event.target.style.top = \"\".concat(top, \"px\");\n                // Aplicar clase visual si hay snap\n                if (isGroupSnapped) {\n                    event.target.classList.add(\"snapped-element\");\n                } else {\n                    event.target.classList.remove(\"snapped-element\");\n                }\n                holdGroupPosition[id] = {\n                    left: left,\n                    top: top\n                };\n            }\n            // Feedback táctil si hay snap\n            if (isGroupSnapped && \"vibrate\" in navigator) {\n                navigator.vibrate(10);\n            }\n        },\n        onResize: (param)=>{\n            let { target, width: nextWidth, height: nextHeight, direction } = param;\n            if (direction[1] === 1) {\n                var _target_firstElementChild;\n                const currentWidth = target.clientWidth;\n                const currentHeight = target.clientHeight;\n                // Get new width and height\n                const scaleY = nextHeight / currentHeight;\n                const scale = scaleY;\n                // Update target dimensions\n                target.style.width = \"\".concat(currentWidth * scale, \"px\");\n                target.style.height = \"\".concat(currentHeight * scale, \"px\");\n                // Safely access nested elements\n                const animationDiv = (_target_firstElementChild = target.firstElementChild) === null || _target_firstElementChild === void 0 ? void 0 : _target_firstElementChild.firstElementChild;\n                if (animationDiv) {\n                    animationDiv.style.width = \"\".concat(currentWidth * scale, \"px\");\n                    animationDiv.style.height = \"\".concat(currentHeight * scale, \"px\");\n                    const textDiv = animationDiv.firstElementChild;\n                    if (textDiv) {\n                        const fontSize = parseFloat(getComputedStyle(textDiv).fontSize);\n                        textDiv.style.fontSize = \"\".concat(fontSize * scale, \"px\");\n                        textDiv.style.width = \"\".concat(currentWidth * scale, \"px\");\n                        textDiv.style.height = \"\".concat(currentHeight * scale, \"px\");\n                    }\n                }\n            } else {\n                var _target_firstElementChild1;\n                target.style.width = nextWidth + \"px\";\n                target.style.height = nextHeight + \"px\";\n                // Safely access nested elements\n                const animationDiv = (_target_firstElementChild1 = target.firstElementChild) === null || _target_firstElementChild1 === void 0 ? void 0 : _target_firstElementChild1.firstElementChild;\n                if (animationDiv) {\n                    animationDiv.style.width = \"\".concat(nextWidth, \"px\");\n                    animationDiv.style.height = \"\".concat(nextHeight, \"px\");\n                    const textDiv = animationDiv.firstElementChild;\n                    if (textDiv) {\n                        textDiv.style.width = \"\".concat(nextWidth, \"px\");\n                        textDiv.style.height = \"\".concat(nextHeight, \"px\");\n                    }\n                }\n            }\n        },\n        onResizeEnd: (param)=>{\n            let { target } = param;\n            var _target_firstElementChild_firstElementChild, _target_firstElementChild;\n            const targetId = (0,_utils_scene__WEBPACK_IMPORTED_MODULE_3__.getIdFromClassName)(target.className);\n            const textDiv = (_target_firstElementChild = target.firstElementChild) === null || _target_firstElementChild === void 0 ? void 0 : (_target_firstElementChild_firstElementChild = _target_firstElementChild.firstElementChild) === null || _target_firstElementChild_firstElementChild === void 0 ? void 0 : _target_firstElementChild_firstElementChild.firstElementChild;\n            (0,_designcombo_events__WEBPACK_IMPORTED_MODULE_4__.dispatch)(_designcombo_state__WEBPACK_IMPORTED_MODULE_5__.EDIT_OBJECT, {\n                payload: {\n                    [targetId]: {\n                        details: {\n                            width: parseFloat(target.style.width),\n                            height: parseFloat(target.style.height),\n                            fontSize: parseFloat(textDiv.style.fontSize)\n                        }\n                    }\n                }\n            });\n        },\n        onDragGroupEnd: ()=>{\n            if (holdGroupPosition) {\n                const payload = {};\n                Object.keys(holdGroupPosition).forEach((id)=>{\n                    const left = holdGroupPosition[id].left;\n                    const top = holdGroupPosition[id].top;\n                    // Eliminar la clase de snap\n                    const element = document.querySelector(\".id-\".concat(id));\n                    if (element) {\n                        element.classList.remove(\"snapped-element\");\n                    }\n                    payload[id] = {\n                        details: {\n                            top: \"\".concat(top, \"px\"),\n                            left: \"\".concat(left, \"px\")\n                        }\n                    };\n                });\n                (0,_designcombo_events__WEBPACK_IMPORTED_MODULE_4__.dispatch)(_designcombo_state__WEBPACK_IMPORTED_MODULE_5__.EDIT_OBJECT, {\n                    payload: payload\n                });\n                holdGroupPosition = null;\n            }\n        }\n    }, void 0, false, {\n        fileName: \"C:\\\\Users\\\\david\\\\Desktop\\\\ai-video-agent\\\\react-video-editor\\\\features\\\\editor\\\\scene\\\\interactions.tsx\",\n        lineNumber: 225,\n        columnNumber: 5\n    }, this);\n}\n_s(SceneInteractions, \"lrX3Qn1bDg1Z1txtD65ffnnzOtA=\", false, function() {\n    return [\n        _store_use_store__WEBPACK_IMPORTED_MODULE_7__[\"default\"],\n        _store_use_layout_store__WEBPACK_IMPORTED_MODULE_9__[\"default\"]\n    ];\n});\n_c = SceneInteractions;\nvar _c;\n$RefreshReg$(_c, \"SceneInteractions\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2ZlYXR1cmVzL2VkaXRvci9zY2VuZS9pbnRlcmFjdGlvbnMudHN4IiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUVvRDtBQUNMO0FBQ0Y7QUFDTztBQUNMO0FBQ21CO0FBTXpDO0FBQ2lCO0FBRUs7QUFDUTtBQUV2RCxJQUFJZSxvQkFBZ0Q7QUFDcEQsSUFBSUMsZUFBZTtBQVNaLFNBQVNDLGtCQUFrQixLQUtUO1FBTFMsRUFDaENDLFlBQVksRUFDWkMsU0FBUyxFQUNUQyxJQUFJLEVBQ0pDLElBQUksRUFDbUIsR0FMUzs7SUFNaEMsTUFBTSxDQUFDQyxTQUFTQyxXQUFXLEdBQUdyQiwrQ0FBUUEsQ0FBbUIsRUFBRTtJQUMzRCxNQUFNLENBQUNzQixXQUFXQyxhQUFhLEdBQUd2QiwrQ0FBUUE7SUFDMUMsTUFBTSxFQUNKd0IsU0FBUyxFQUNUQyxRQUFRLEVBQ1JDLG1CQUFtQixFQUNuQkMsYUFBYSxFQUNiQyxTQUFTLEVBQ1RDLG1CQUFtQixFQUNwQixHQUFHbkIsNERBQVFBO0lBQ1osTUFBTSxFQUFFb0IsaUJBQWlCLEVBQUVDLGVBQWUsRUFBRSxHQUFHbkIsbUVBQWNBO0lBQzdELE1BQU1vQixjQUFjakMsNkNBQU1BLENBQVc7SUFDckMsTUFBTSxDQUFDa0MsZUFBZUMsaUJBQWlCLEdBQ3JDbEMsK0NBQVFBLENBQWdCTyx5REFBY0E7SUFFeEMsMEJBQTBCO0lBQzFCLE1BQU00QixpQkFBaUIsSUFBSSw0Q0FBNEM7SUFDdkUsTUFBTUMsc0JBQXNCLEdBQUcsMERBQTBEO0lBRXpGLDBDQUEwQztJQUMxQyxNQUFNQyxZQUFZLFNBQUNDLE9BQWVDO1lBQXNCQyw2RUFBb0JMO1FBQzFFLEtBQUssTUFBTU0sU0FBU0YsV0FBWTtZQUM5QixJQUFJRyxLQUFLQyxHQUFHLENBQUNMLFFBQVFHLFVBQVVELFdBQVc7Z0JBQ3hDLE9BQU9DO1lBQ1Q7UUFDRjtRQUNBLE9BQU9IO0lBQ1Q7SUFFQXhDLGdEQUFTQSxDQUFDO1lBOEJSOEI7UUE3QkEsTUFBTWdCLGdCQUFnQixDQUFDQztZQUNyQixNQUFNQyxjQUFjRCxRQUFRbEMsMkRBQWNBO1lBQzFDLE1BQU0sRUFBRWdCLGFBQWEsRUFBRSxHQUFHakIsd0RBQVFBLENBQUNxQyxRQUFRO1lBQzNDLE1BQU1DLFlBQVl4QixVQUFVeUIsTUFBTSxDQUFDLENBQUNDO29CQUVoQ3ZCLG1CQUNBQTtnQkFGRixPQUNFQSxFQUFBQSxvQkFBQUEsYUFBYSxDQUFDdUIsR0FBRyxjQUFqQnZCLHdDQUFBQSxrQkFBbUJ3QixPQUFPLENBQUNDLElBQUksS0FBSU4sZUFDbkNuQixFQUFBQSxxQkFBQUEsYUFBYSxDQUFDdUIsR0FBRyxjQUFqQnZCLHlDQUFBQSxtQkFBbUJ3QixPQUFPLENBQUNFLEVBQUUsS0FBSVA7WUFFckM7WUFDQSxNQUFNMUIsVUFBVTRCLFVBQVVNLEdBQUcsQ0FDM0IsQ0FBQ0osS0FBT3pDLDREQUFhQSxDQUFDeUM7WUFFeEI1QixzQkFBQUEsZ0NBQUFBLFVBQVdpQyxrQkFBa0IsQ0FBQ25DO1lBQzlCLE1BQU1vQyxVQUFVaEQsZ0VBQWlCQSxDQUFDd0M7WUFFbENkLGlCQUFpQnNCO1lBQ2pCbkMsV0FBV21DLFFBQVFwQyxPQUFPO1FBQzVCO1FBQ0EsTUFBTXFDLFFBQVFDLFdBQVc7WUFDdkJkO1FBQ0Y7UUFFQSxNQUFNZSxXQUFXLENBQUNDO1lBQ2hCRixXQUFXO2dCQUNULE1BQU0sRUFBRUcsR0FBRyxFQUFFLEdBQUduRCx3REFBUUEsQ0FBQ3FDLFFBQVE7Z0JBQ2pDLE1BQU1lLGFBQWEsRUFBR0MsTUFBTSxDQUFDQyxLQUFLLEdBQUdILE1BQU87Z0JBQzVDakIsY0FBY2tCO1lBQ2hCO1FBQ0Y7UUFDQWxDLHNCQUFBQSxpQ0FBQUEscUJBQUFBLFVBQVdxQyxPQUFPLGNBQWxCckMseUNBQUFBLG1CQUFvQnNDLGdCQUFnQixDQUFDLFVBQVVQO1FBRS9DLE9BQU87Z0JBQ0wvQjtZQUFBQSxzQkFBQUEsaUNBQUFBLHFCQUFBQSxVQUFXcUMsT0FBTyxjQUFsQnJDLHlDQUFBQSxtQkFBb0J1QyxtQkFBbUIsQ0FBQyxVQUFVUjtZQUNsRFMsYUFBYVg7UUFDZjtJQUNGLEdBQUc7UUFBQ2pDO1FBQVdJO1FBQVdEO0tBQWM7SUFFeEMsaURBQWlEO0lBQ2pELE1BQU0wQyxrQkFBa0IsQ0FBQ0M7UUFDdkJDLFFBQVFDLEdBQUcsQ0FBQyxtREFBZ0RGO1FBRTVELG9DQUFvQztRQUNwQ3RELGFBQWF5RCxXQUFXLENBQ3RCO1lBQ0VqRCxXQUFXOEM7UUFDYixHQUNBO1lBQ0VJLGVBQWU7WUFDZkMsTUFBTTtRQUNSO1FBR0YsdUZBQXVGO1FBQ3ZGLElBQUlMLE9BQU9BLElBQUlNLE1BQU0sS0FBSyxHQUFHO1lBQzNCTCxRQUFRQyxHQUFHLENBQUM7WUFFWiw4Q0FBOEM7WUFDOUMxQyxrQkFBa0I7WUFDbEJDLGdCQUFnQjtZQUVoQixzRkFBc0Y7WUFDdEYzQiw2REFBUUEsQ0FBQ0UsK0RBQWVBLEVBQUU7Z0JBQ3hCdUUsU0FBUztvQkFDUHJELFdBQVc4QztnQkFDYjtZQUNGO1lBRUEsc0JBQXNCO1lBQ3RCWixXQUFXO2dCQUNULE1BQU1vQixrQkFBa0JsRSwrREFBY0EsQ0FBQ21DLFFBQVEsR0FBR2dDLGNBQWM7Z0JBQ2hFUixRQUFRQyxHQUFHLENBQUMscURBQWtETTtZQUNoRSxHQUFHO1FBQ0w7SUFDRjtJQUVBaEYsZ0RBQVNBLENBQUM7WUFFS21CO1FBRGIsTUFBTUssWUFBWSxJQUFJckIsK0RBQVNBLENBQUM7WUFDOUIrRSxTQUFTLEdBQUUvRCxxQkFBQUEsVUFBVWdELE9BQU8sY0FBakJoRCx5Q0FBQUEsbUJBQW1CZ0UsY0FBYyxDQUFDQyxZQUFZO1lBQ3pEQyxnQkFBZ0I7WUFDaEJDLFNBQVM7WUFDVEMsbUJBQW1CO2dCQUFDO2FBQTBCO1lBQzlDQyxrQkFBa0I7WUFDbEJDLGVBQWU7WUFDZkMsc0JBQXNCO1FBQ3hCLEdBQ0dDLEVBQUUsQ0FBQyxVQUFVLENBQUNDO1lBQ2IsTUFBTXBCLE1BQU1vQixFQUFFQyxRQUFRLENBQUNyQyxHQUFHLENBQUMsQ0FBQ3NDLEtBQU96RixnRUFBa0JBLENBQUN5RixHQUFHQyxTQUFTO1lBQ2xFeEUsV0FBV3FFLEVBQUVDLFFBQVE7WUFFckIsa0NBQWtDO1lBQ2xDdEIsZ0JBQWdCQztRQUNsQixHQUNDbUIsRUFBRSxDQUFDLGFBQWEsQ0FBQ0M7Z0JBU2QxRDtZQVJGLE1BQU04RCxTQUFTSixFQUFFSyxVQUFVLENBQUNELE1BQU07WUFDbENoRixlQUFlO1lBRWYsSUFBSU0sUUFBUTRFLFFBQVEsQ0FBQ0YsU0FBUztnQkFDNUJKLEVBQUVPLElBQUk7WUFDUjtZQUNBLElBQ0VILFdBQ0E5RCx3QkFBQUEsbUNBQUFBLHVCQUFBQSxZQUFhaUMsT0FBTyxjQUFwQmpDLDJDQUFBQSxxQkFBc0JrRSxRQUFRLENBQUNDLGlCQUFpQixDQUFDTCxVQUNqRDtnQkFDQUosRUFBRU8sSUFBSTtZQUNSO1FBQ0YsR0FDQ1IsRUFBRSxDQUFDLFdBQVc7WUFDYjNFLGVBQWU7UUFDakIsR0FDQzJFLEVBQUUsQ0FBQyxhQUFhLENBQUNDO1lBQ2hCLE1BQU1RLFdBQVdsRSxZQUFZaUMsT0FBTztZQUNwQyxJQUFJeUIsRUFBRVUsV0FBVyxFQUFFO2dCQUNqQlYsRUFBRUssVUFBVSxDQUFDTSxjQUFjO2dCQUMzQjNDLFdBQVc7b0JBQ1QsSUFBSSxDQUFDNUMsY0FBYzt3QkFDakJvRixxQkFBQUEsK0JBQUFBLFNBQVVBLFFBQVEsQ0FBQ0ksU0FBUyxDQUFDWixFQUFFSyxVQUFVO29CQUMzQztnQkFDRjtZQUNGLE9BQU87Z0JBQ0wsTUFBTTNFLFVBQVVzRSxFQUFFQyxRQUFRO2dCQUMxQixNQUFNckIsTUFBTWxELFFBQVFrQyxHQUFHLENBQUMsQ0FBQ3NDLEtBQU96RixnRUFBa0JBLENBQUN5RixHQUFHQyxTQUFTO2dCQUUvRCxrQ0FBa0M7Z0JBQ2xDeEIsZ0JBQWdCQztnQkFDaEJqRCxXQUFXRDtZQUNiO1FBQ0Y7UUFDRkcsYUFBYUQ7UUFDYixPQUFPO1lBQ0xBLFVBQVVpRixPQUFPO1FBQ25CO0lBQ0YsR0FBRyxFQUFFO0lBRUx6RyxnREFBU0EsQ0FBQztRQUNSLE1BQU0wRyw4QkFBOEJ4RixhQUFheUYsb0JBQW9CLENBQ25FLENBQUNDO1lBQ0NqRixTQUFTaUY7WUFFVCwyRkFBMkY7WUFDM0YsSUFBSUEsU0FBU2xGLFNBQVMsSUFBSWtGLFNBQVNsRixTQUFTLENBQUNvRCxNQUFNLEtBQUssR0FBRztnQkFDekQ5QyxrQkFBa0I7Z0JBQ2xCQyxnQkFBZ0I7WUFDbEI7UUFDRjtRQUdGLE9BQU87WUFDTHlFLDRCQUE0QkcsV0FBVztRQUN6QztJQUNGLEdBQUcsRUFBRTtJQUVMN0csZ0RBQVNBLENBQUM7UUFDUmtDLFlBQVlpQyxPQUFPLENBQUVpQyxRQUFRLENBQUNVLFVBQVU7SUFDMUMsR0FBRztRQUFDakY7S0FBYztJQUVsQjdCLGdEQUFTQSxDQUFDO1FBQ1IrQixvQkFBb0JHO0lBQ3RCLEdBQUc7UUFBQ0E7S0FBWTtJQUNoQixxQkFDRSw4REFBQzlCLDZEQUFRQTtRQUNQMkcsS0FBSzdFO1FBQ0w4RSxrQkFBa0I7UUFDbEJDLGtCQUFrQjlFLGNBQWMrRSxRQUFRO1FBQ3ZDLEdBQUcvRSxjQUFjZ0YsS0FBSztRQUN2QkMsUUFBUTtRQUNScEIsUUFBUTFFO1FBQ1JGLE1BQU0sSUFBSUE7UUFDVjJFLFdBQVU7UUFDVnNCLFFBQVE7Z0JBQUMsRUFBRXJCLE1BQU0sRUFBRXNCLGVBQWUsRUFBRXJCLFVBQVUsRUFBRTtZQUM5QyxNQUFNc0IsV0FBV2xILGdFQUFrQkEsQ0FBQzJGLE9BQU9ELFNBQVM7WUFDcEQsTUFBTXlCLFlBQVk1RixtQkFBbUIsQ0FBQzJGLFNBQVM7WUFFL0MsbUNBQW1DO1lBQ25DLE1BQU1FLGNBQWN6QixPQUFPMEIsV0FBVztZQUN0QyxNQUFNQyxlQUFlM0IsT0FBTzRCLFlBQVk7WUFFeEMsaUNBQWlDO1lBQ2pDLElBQUlDLE9BQU9DLFdBQVdOLHNCQUFBQSxnQ0FBQUEsVUFBV08sT0FBTyxDQUFDRixJQUFJLElBQWNQLGVBQWUsQ0FBQyxFQUFFO1lBQzdFLElBQUlVLE1BQU1GLFdBQVdOLHNCQUFBQSxnQ0FBQUEsVUFBV08sT0FBTyxDQUFDQyxHQUFHLElBQWNWLGVBQWUsQ0FBQyxFQUFFO1lBRTNFLDREQUE0RDtZQUM1RCxNQUFNVyxjQUFjO2dCQUNsQjtnQkFDQTVHLEtBQUs2RyxLQUFLLEdBQUcsSUFBSVQsY0FBYztnQkFDL0JwRyxLQUFLNkcsS0FBSyxHQUFHVCxZQUFZLGdCQUFnQjthQUMxQztZQUVELHVEQUF1RDtZQUN2RCxNQUFNVSxjQUFjO2dCQUNsQjtnQkFDQTlHLEtBQUsrRyxNQUFNLEdBQUcsSUFBSVQsZUFBZTtnQkFDakN0RyxLQUFLK0csTUFBTSxHQUFHVCxhQUFhLGlCQUFpQjthQUM3QztZQUVELGlDQUFpQztZQUNqQ0UsT0FBT3RGLFVBQVVzRixNQUFNSTtZQUN2QkQsTUFBTXpGLFVBQVV5RixLQUFLRztZQUVyQixrREFBa0Q7WUFDbEQsSUFBSUYsWUFBWUksSUFBSSxDQUFDMUYsQ0FBQUEsUUFBU0MsS0FBS0MsR0FBRyxDQUFDZ0YsT0FBT2xGLFVBQVVMLHdCQUNwRDZGLFlBQVlFLElBQUksQ0FBQzFGLENBQUFBLFFBQVNDLEtBQUtDLEdBQUcsQ0FBQ21GLE1BQU1yRixVQUFVTCxzQkFBc0I7Z0JBQzNFLGtFQUFrRTtnQkFDbEUwRCxPQUFPc0MsU0FBUyxDQUFDQyxHQUFHLENBQUM7Z0JBRXJCLDJEQUEyRDtnQkFDM0QsSUFBSXRDLHNCQUFzQnVDLGNBQWMsYUFBYUMsV0FBVztvQkFDOURBLFVBQVVDLE9BQU8sQ0FBQyxLQUFLLDBCQUEwQjtnQkFDbkQ7WUFDRixPQUFPO2dCQUNMMUMsT0FBT3NDLFNBQVMsQ0FBQ0ssTUFBTSxDQUFDO1lBQzFCO1lBRUEsc0JBQXNCO1lBQ3RCM0MsT0FBTzRDLEtBQUssQ0FBQ1osR0FBRyxHQUFHQSxNQUFNO1lBQ3pCaEMsT0FBTzRDLEtBQUssQ0FBQ2YsSUFBSSxHQUFHQSxPQUFPO1FBQzdCO1FBQ0FnQixXQUFXO2dCQUFDLEVBQUU3QyxNQUFNLEVBQUU4QyxNQUFNLEVBQUU7WUFDNUIsSUFBSSxDQUFDQSxRQUFRO1lBQ2IsTUFBTXZCLFdBQVdsSCxnRUFBa0JBLENBQUMyRixPQUFPRCxTQUFTO1lBRXBELHlDQUF5QztZQUN6Q0MsT0FBT3NDLFNBQVMsQ0FBQ0ssTUFBTSxDQUFDO1lBRXhCckksNkRBQVFBLENBQUNDLDJEQUFXQSxFQUFFO2dCQUNwQndFLFNBQVM7b0JBQ1AsQ0FBQ3dDLFNBQVMsRUFBRTt3QkFDVlEsU0FBUzs0QkFDUEYsTUFBTTdCLE9BQU80QyxLQUFLLENBQUNmLElBQUk7NEJBQ3ZCRyxLQUFLaEMsT0FBTzRDLEtBQUssQ0FBQ1osR0FBRzt3QkFDdkI7b0JBQ0Y7Z0JBQ0Y7WUFDRjtRQUNGO1FBQ0FlLFNBQVM7Z0JBQUMsRUFBRS9DLE1BQU0sRUFBRWdELFNBQVMsRUFBRUMsU0FBUyxFQUFFO1lBQ3hDLE1BQU0sQ0FBQ0MsVUFBVUMsU0FBUyxHQUFHRjtZQUU3QixNQUFNRyxhQUFhO1lBQ25CLE1BQU1DLFFBQVFyRCxPQUFPNEMsS0FBSyxDQUFDSSxTQUFTLENBQUNLLEtBQUssQ0FBQ0Q7WUFFM0MsbUJBQW1CO1lBQ25CLE1BQU0sQ0FBQ0UsUUFBUUMsT0FBTyxHQUFHRixLQUFLLENBQUMsRUFBRSxDQUM5QkcsS0FBSyxDQUFDLEtBQ05oRyxHQUFHLENBQUMsQ0FBQ2hCLFFBQVVzRixXQUFXdEYsTUFBTWlILElBQUk7WUFFdkMsZUFBZTtZQUNmLE1BQU1DLFNBQVNWLFVBQVVLLEtBQUssQ0FBQ0Q7WUFDL0IsTUFBTSxDQUFDTyxXQUFXQyxVQUFVLEdBQUdGLE1BQU0sQ0FBQyxFQUFFLENBQ3JDRixLQUFLLENBQUMsS0FDTmhHLEdBQUcsQ0FBQyxDQUFDaEIsUUFBVXNGLFdBQVd0RixNQUFNaUgsSUFBSTtZQUV2QyxNQUFNSSxlQUFlN0QsT0FBTzhELFdBQVcsR0FBR1I7WUFDMUMsTUFBTVMsZ0JBQWdCL0QsT0FBT2dFLFlBQVksR0FBR1Q7WUFFNUMsTUFBTVUsV0FBV2pFLE9BQU84RCxXQUFXLEdBQUdIO1lBQ3RDLE1BQU1PLFlBQVlsRSxPQUFPZ0UsWUFBWSxHQUFHSjtZQUV4QzVELE9BQU80QyxLQUFLLENBQUNJLFNBQVMsR0FBR0E7WUFFekIsdUNBQXVDO1lBQ3ZDLE1BQU1tQixRQUFRTixlQUFlSTtZQUM3QixJQUFJRyxVQUFVdEMsV0FBVzlCLE9BQU80QyxLQUFLLENBQUNmLElBQUksSUFBSXNDLFFBQVE7WUFFdEQsTUFBTUUsUUFBUU4sZ0JBQWdCRztZQUM5QixJQUFJSSxTQUFTeEMsV0FBVzlCLE9BQU80QyxLQUFLLENBQUNaLEdBQUcsSUFBSXFDLFFBQVE7WUFFcEQsSUFBSW5CLGFBQWEsQ0FBQyxHQUFHO2dCQUNuQmtCLFdBQVdEO1lBQ2I7WUFDQSxJQUFJaEIsYUFBYSxDQUFDLEdBQUc7Z0JBQ25CbUIsVUFBVUQ7WUFDWjtZQUNBckUsT0FBTzRDLEtBQUssQ0FBQ2YsSUFBSSxHQUFHdUMsVUFBVTtZQUM5QnBFLE9BQU80QyxLQUFLLENBQUNaLEdBQUcsR0FBR3NDLFNBQVM7UUFDOUI7UUFDQUMsWUFBWTtnQkFBQyxFQUFFdkUsTUFBTSxFQUFFO1lBQ3JCLElBQUksQ0FBQ0EsT0FBTzRDLEtBQUssQ0FBQ0ksU0FBUyxFQUFFO1lBQzdCLE1BQU16QixXQUFXbEgsZ0VBQWtCQSxDQUFDMkYsT0FBT0QsU0FBUztZQUVwRHpGLDZEQUFRQSxDQUFDQywyREFBV0EsRUFBRTtnQkFDcEJ3RSxTQUFTO29CQUNQLENBQUN3QyxTQUFTLEVBQUU7d0JBQ1ZRLFNBQVM7NEJBQ1BpQixXQUFXaEQsT0FBTzRDLEtBQUssQ0FBQ0ksU0FBUzs0QkFDakNuQixNQUFNQyxXQUFXOUIsT0FBTzRDLEtBQUssQ0FBQ2YsSUFBSTs0QkFDbENHLEtBQUtGLFdBQVc5QixPQUFPNEMsS0FBSyxDQUFDWixHQUFHO3dCQUNsQztvQkFDRjtnQkFDRjtZQUNGO1FBQ0Y7UUFDQXdDLFVBQVU7Z0JBQUMsRUFBRXhFLE1BQU0sRUFBRWdELFNBQVMsRUFBRTtZQUM5QmhELE9BQU80QyxLQUFLLENBQUNJLFNBQVMsR0FBR0E7UUFDM0I7UUFDQXlCLGFBQWE7Z0JBQUMsRUFBRXpFLE1BQU0sRUFBRTtZQUN0QixJQUFJLENBQUNBLE9BQU80QyxLQUFLLENBQUNJLFNBQVMsRUFBRTtZQUM3QixNQUFNekIsV0FBV2xILGdFQUFrQkEsQ0FBQzJGLE9BQU9ELFNBQVM7WUFDcER6Riw2REFBUUEsQ0FBQ0MsMkRBQVdBLEVBQUU7Z0JBQ3BCd0UsU0FBUztvQkFDUCxDQUFDd0MsU0FBUyxFQUFFO3dCQUNWUSxTQUFTOzRCQUNQaUIsV0FBV2hELE9BQU80QyxLQUFLLENBQUNJLFNBQVM7d0JBQ25DO29CQUNGO2dCQUNGO1lBQ0Y7UUFDRjtRQUNBMEIsYUFBYTtnQkFBQyxFQUFFQyxNQUFNLEVBQUU7WUFDdEI1SixvQkFBb0IsQ0FBQztZQUVyQixtREFBbUQ7WUFDbkQsSUFBSTZKLFlBQVlDO1lBQ2hCLElBQUlDLFdBQVdEO1lBQ2YsSUFBSUUsYUFBYSxDQUFDRjtZQUNsQixJQUFJRyxjQUFjLENBQUNIO1lBRW5CLDhDQUE4QztZQUM5QyxJQUFLLElBQUlJLElBQUksR0FBR0EsSUFBSU4sT0FBTzdGLE1BQU0sRUFBRW1HLElBQUs7Z0JBQ3RDLE1BQU1DLFFBQVFQLE1BQU0sQ0FBQ00sRUFBRTtnQkFDdkIsTUFBTTdILEtBQUsvQyxnRUFBa0JBLENBQUM2SyxNQUFNbEYsTUFBTSxDQUFDRCxTQUFTO2dCQUNwRCxNQUFNeUIsWUFBWTVGLG1CQUFtQixDQUFDd0IsR0FBRztnQkFFekMsTUFBTXlFLE9BQU9DLFdBQVdOLHNCQUFBQSxnQ0FBQUEsVUFBV08sT0FBTyxDQUFDRixJQUFJO2dCQUMvQyxNQUFNRyxNQUFNRixXQUFXTixzQkFBQUEsZ0NBQUFBLFVBQVdPLE9BQU8sQ0FBQ0MsR0FBRztnQkFDN0MsTUFBTUUsUUFBUWdELE1BQU1sRixNQUFNLENBQUMwQixXQUFXO2dCQUN0QyxNQUFNVSxTQUFTOEMsTUFBTWxGLE1BQU0sQ0FBQzRCLFlBQVk7Z0JBRXhDZ0QsWUFBWWhJLEtBQUt1SSxHQUFHLENBQUNQLFdBQVcvQztnQkFDaENpRCxXQUFXbEksS0FBS3VJLEdBQUcsQ0FBQ0wsVUFBVTlDO2dCQUM5QitDLGFBQWFuSSxLQUFLd0ksR0FBRyxDQUFDTCxZQUFZbEQsT0FBT0s7Z0JBQ3pDOEMsY0FBY3BJLEtBQUt3SSxHQUFHLENBQUNKLGFBQWFoRCxNQUFNSTtZQUM1QztZQUVBLE1BQU1pRCxhQUFhTixhQUFhSDtZQUNoQyxNQUFNVSxjQUFjTixjQUFjRjtZQUVsQyx1RUFBdUU7WUFDdkUsTUFBTVMsZ0JBQWdCWixNQUFNLENBQUMsRUFBRSxDQUFDckQsZUFBZTtZQUUvQyxxREFBcUQ7WUFDckQsSUFBSWtFLGVBQWVaLFlBQVlXLGFBQWEsQ0FBQyxFQUFFO1lBQy9DLElBQUlFLGNBQWNYLFdBQVdTLGFBQWEsQ0FBQyxFQUFFO1lBRTdDLCtCQUErQjtZQUMvQixNQUFNdEQsY0FBYztnQkFDbEI7Z0JBQ0E1RyxLQUFLNkcsS0FBSyxHQUFHLElBQUltRCxhQUFhO2dCQUM5QmhLLEtBQUs2RyxLQUFLLEdBQUdtRCxXQUFXLGdCQUFnQjthQUN6QztZQUVELE1BQU1sRCxjQUFjO2dCQUNsQjtnQkFDQTlHLEtBQUsrRyxNQUFNLEdBQUcsSUFBSWtELGNBQWM7Z0JBQ2hDakssS0FBSytHLE1BQU0sR0FBR2tELFlBQVksaUJBQWlCO2FBQzVDO1lBRUQsd0JBQXdCO1lBQ3hCLE1BQU1JLG1CQUFtQm5KLFVBQVVpSixjQUFjdkQ7WUFDakQsTUFBTTBELGtCQUFrQnBKLFVBQVVrSixhQUFhdEQ7WUFFL0MsZ0RBQWdEO1lBQ2hELE1BQU15RCxVQUFVRixtQkFBbUJGO1lBQ25DLE1BQU1LLFVBQVVGLGtCQUFrQkY7WUFFbEMsd0NBQXdDO1lBQ3hDLE1BQU1LLGlCQUNKbEosS0FBS0MsR0FBRyxDQUFDK0ksWUFBWXRKLHVCQUNyQk0sS0FBS0MsR0FBRyxDQUFDZ0osWUFBWXZKO1lBRXZCLDJEQUEyRDtZQUMzRCxJQUFLLElBQUkySSxJQUFJLEdBQUdBLElBQUlOLE9BQU83RixNQUFNLEVBQUVtRyxJQUFLO2dCQUN0QyxNQUFNQyxRQUFRUCxNQUFNLENBQUNNLEVBQUU7Z0JBQ3ZCLE1BQU03SCxLQUFLL0MsZ0VBQWtCQSxDQUFDNkssTUFBTWxGLE1BQU0sQ0FBQ0QsU0FBUztnQkFDcEQsTUFBTXlCLFlBQVk1RixtQkFBbUIsQ0FBQ3dCLEdBQUc7Z0JBRXpDLE1BQU15RSxPQUFPQyxXQUFXTixzQkFBQUEsZ0NBQUFBLFVBQVdPLE9BQU8sQ0FBQ0YsSUFBSSxJQUM3Q3FELE1BQU01RCxlQUFlLENBQUMsRUFBRSxHQUFHc0U7Z0JBQzdCLE1BQU01RCxNQUFNRixXQUFXTixzQkFBQUEsZ0NBQUFBLFVBQVdPLE9BQU8sQ0FBQ0MsR0FBRyxJQUMzQ2tELE1BQU01RCxlQUFlLENBQUMsRUFBRSxHQUFHdUU7Z0JBRTdCWCxNQUFNbEYsTUFBTSxDQUFDNEMsS0FBSyxDQUFDZixJQUFJLEdBQUcsR0FBUSxPQUFMQSxNQUFLO2dCQUNsQ3FELE1BQU1sRixNQUFNLENBQUM0QyxLQUFLLENBQUNaLEdBQUcsR0FBRyxHQUFPLE9BQUpBLEtBQUk7Z0JBRWhDLG1DQUFtQztnQkFDbkMsSUFBSThELGdCQUFnQjtvQkFDbEJaLE1BQU1sRixNQUFNLENBQUNzQyxTQUFTLENBQUNDLEdBQUcsQ0FBQztnQkFDN0IsT0FBTztvQkFDTDJDLE1BQU1sRixNQUFNLENBQUNzQyxTQUFTLENBQUNLLE1BQU0sQ0FBQztnQkFDaEM7Z0JBRUE1SCxpQkFBaUIsQ0FBQ3FDLEdBQUcsR0FBRztvQkFDdEJ5RSxNQUFNQTtvQkFDTkcsS0FBS0E7Z0JBQ1A7WUFDRjtZQUVBLDhCQUE4QjtZQUM5QixJQUFJOEQsa0JBQWtCLGFBQWFyRCxXQUFXO2dCQUM1Q0EsVUFBVUMsT0FBTyxDQUFDO1lBQ3BCO1FBQ0Y7UUFDQXFELFVBQVU7Z0JBQUMsRUFDVC9GLE1BQU0sRUFDTmtDLE9BQU84RCxTQUFTLEVBQ2hCNUQsUUFBUTZELFVBQVUsRUFDbEJoRCxTQUFTLEVBQ1Y7WUFDQyxJQUFJQSxTQUFTLENBQUMsRUFBRSxLQUFLLEdBQUc7b0JBYURqRDtnQkFackIsTUFBTTZELGVBQWU3RCxPQUFPOEQsV0FBVztnQkFDdkMsTUFBTUMsZ0JBQWdCL0QsT0FBT2dFLFlBQVk7Z0JBRXpDLDJCQUEyQjtnQkFDM0IsTUFBTVQsU0FBUzBDLGFBQWFsQztnQkFDNUIsTUFBTW1DLFFBQVEzQztnQkFFZCwyQkFBMkI7Z0JBQzNCdkQsT0FBTzRDLEtBQUssQ0FBQ1YsS0FBSyxHQUFHLEdBQXdCLE9BQXJCMkIsZUFBZXFDLE9BQU07Z0JBQzdDbEcsT0FBTzRDLEtBQUssQ0FBQ1IsTUFBTSxHQUFHLEdBQXlCLE9BQXRCMkIsZ0JBQWdCbUMsT0FBTTtnQkFFL0MsZ0NBQWdDO2dCQUNoQyxNQUFNQyxnQkFBZW5HLDRCQUFBQSxPQUFPb0csaUJBQWlCLGNBQXhCcEcsZ0RBQUFBLDBCQUNqQm9HLGlCQUFpQjtnQkFDckIsSUFBSUQsY0FBYztvQkFDaEJBLGFBQWF2RCxLQUFLLENBQUNWLEtBQUssR0FBRyxHQUF3QixPQUFyQjJCLGVBQWVxQyxPQUFNO29CQUNuREMsYUFBYXZELEtBQUssQ0FBQ1IsTUFBTSxHQUFHLEdBQXlCLE9BQXRCMkIsZ0JBQWdCbUMsT0FBTTtvQkFFckQsTUFBTUcsVUFDSkYsYUFBYUMsaUJBQWlCO29CQUNoQyxJQUFJQyxTQUFTO3dCQUNYLE1BQU1DLFdBQVd4RSxXQUFXeUUsaUJBQWlCRixTQUFTQyxRQUFRO3dCQUM5REQsUUFBUXpELEtBQUssQ0FBQzBELFFBQVEsR0FBRyxHQUFvQixPQUFqQkEsV0FBV0osT0FBTTt3QkFDN0NHLFFBQVF6RCxLQUFLLENBQUNWLEtBQUssR0FBRyxHQUF3QixPQUFyQjJCLGVBQWVxQyxPQUFNO3dCQUM5Q0csUUFBUXpELEtBQUssQ0FBQ1IsTUFBTSxHQUFHLEdBQXlCLE9BQXRCMkIsZ0JBQWdCbUMsT0FBTTtvQkFDbEQ7Z0JBQ0Y7WUFDRixPQUFPO29CQUtnQmxHO2dCQUpyQkEsT0FBTzRDLEtBQUssQ0FBQ1YsS0FBSyxHQUFHOEQsWUFBWTtnQkFDakNoRyxPQUFPNEMsS0FBSyxDQUFDUixNQUFNLEdBQUc2RCxhQUFhO2dCQUVuQyxnQ0FBZ0M7Z0JBQ2hDLE1BQU1FLGdCQUFlbkcsNkJBQUFBLE9BQU9vRyxpQkFBaUIsY0FBeEJwRyxpREFBQUEsMkJBQ2pCb0csaUJBQWlCO2dCQUNyQixJQUFJRCxjQUFjO29CQUNoQkEsYUFBYXZELEtBQUssQ0FBQ1YsS0FBSyxHQUFHLEdBQWEsT0FBVjhELFdBQVU7b0JBQ3hDRyxhQUFhdkQsS0FBSyxDQUFDUixNQUFNLEdBQUcsR0FBYyxPQUFYNkQsWUFBVztvQkFFMUMsTUFBTUksVUFDSkYsYUFBYUMsaUJBQWlCO29CQUNoQyxJQUFJQyxTQUFTO3dCQUNYQSxRQUFRekQsS0FBSyxDQUFDVixLQUFLLEdBQUcsR0FBYSxPQUFWOEQsV0FBVTt3QkFDbkNLLFFBQVF6RCxLQUFLLENBQUNSLE1BQU0sR0FBRyxHQUFjLE9BQVg2RCxZQUFXO29CQUN2QztnQkFDRjtZQUNGO1FBQ0Y7UUFDQU8sYUFBYTtnQkFBQyxFQUFFeEcsTUFBTSxFQUFFO2dCQUVOQSw2Q0FBQUE7WUFEaEIsTUFBTXVCLFdBQVdsSCxnRUFBa0JBLENBQUMyRixPQUFPRCxTQUFTO1lBQ3BELE1BQU1zRyxXQUFVckcsNEJBQUFBLE9BQU9vRyxpQkFBaUIsY0FBeEJwRyxpREFBQUEsOENBQUFBLDBCQUEwQm9HLGlCQUFpQixjQUEzQ3BHLGtFQUFBQSw0Q0FDWm9HLGlCQUFpQjtZQUNyQjlMLDZEQUFRQSxDQUFDQywyREFBV0EsRUFBRTtnQkFDcEJ3RSxTQUFTO29CQUNQLENBQUN3QyxTQUFTLEVBQUU7d0JBQ1ZRLFNBQVM7NEJBQ1BHLE9BQU9KLFdBQVc5QixPQUFPNEMsS0FBSyxDQUFDVixLQUFLOzRCQUNwQ0UsUUFBUU4sV0FBVzlCLE9BQU80QyxLQUFLLENBQUNSLE1BQU07NEJBQ3RDa0UsVUFBVXhFLFdBQVd1RSxRQUFRekQsS0FBSyxDQUFDMEQsUUFBUTt3QkFDN0M7b0JBQ0Y7Z0JBQ0Y7WUFDRjtRQUNGO1FBQ0FHLGdCQUFnQjtZQUNkLElBQUkxTCxtQkFBbUI7Z0JBQ3JCLE1BQU1nRSxVQUF3QyxDQUFDO2dCQUMvQzJILE9BQU9DLElBQUksQ0FBQzVMLG1CQUFtQjZMLE9BQU8sQ0FBQyxDQUFDeEo7b0JBQ3RDLE1BQU15RSxPQUFPOUcsaUJBQWtCLENBQUNxQyxHQUFHLENBQUN5RSxJQUFJO29CQUN4QyxNQUFNRyxNQUFNakgsaUJBQWtCLENBQUNxQyxHQUFHLENBQUM0RSxHQUFHO29CQUV0Qyw0QkFBNEI7b0JBQzVCLE1BQU02RSxVQUFVQyxTQUFTQyxhQUFhLENBQUMsT0FBVSxPQUFIM0o7b0JBQzlDLElBQUl5SixTQUFTO3dCQUNYQSxRQUFRdkUsU0FBUyxDQUFDSyxNQUFNLENBQUM7b0JBQzNCO29CQUVBNUQsT0FBTyxDQUFDM0IsR0FBRyxHQUFHO3dCQUNaMkUsU0FBUzs0QkFDUEMsS0FBSyxHQUFPLE9BQUpBLEtBQUk7NEJBQ1pILE1BQU0sR0FBUSxPQUFMQSxNQUFLO3dCQUNoQjtvQkFDRjtnQkFDRjtnQkFDQXZILDZEQUFRQSxDQUFDQywyREFBV0EsRUFBRTtvQkFDcEJ3RSxTQUFTQTtnQkFDWDtnQkFDQWhFLG9CQUFvQjtZQUN0QjtRQUNGOzs7Ozs7QUFHTjtHQXZoQmdCRTs7UUFlVkwsd0RBQVFBO1FBQ21DRSwrREFBY0E7OztLQWhCL0NHIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL2ZlYXR1cmVzL2VkaXRvci9zY2VuZS9pbnRlcmFjdGlvbnMudHN4PzJhZWMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2UgY2xpZW50XCI7XG5cbmltcG9ydCB7IHVzZUVmZmVjdCwgdXNlUmVmLCB1c2VTdGF0ZSB9IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IFNlbGVjdGlvbiBmcm9tIFwiQGludGVyYWN0aWZ5L3NlbGVjdGlvblwiO1xuaW1wb3J0IE1vdmVhYmxlIGZyb20gXCJAaW50ZXJhY3RpZnkvbW92ZWFibGVcIjtcbmltcG9ydCB7IGdldElkRnJvbUNsYXNzTmFtZSB9IGZyb20gXCIuLi91dGlscy9zY2VuZVwiO1xuaW1wb3J0IHsgZGlzcGF0Y2ggfSBmcm9tIFwiQGRlc2lnbmNvbWJvL2V2ZW50c1wiO1xuaW1wb3J0IHsgRURJVF9PQkpFQ1QsIExBWUVSX1NFTEVDVElPTiB9IGZyb20gXCJAZGVzaWduY29tYm8vc3RhdGVcIjtcbmltcG9ydCB7XG4gIFNlbGVjdGlvbkluZm8sXG4gIGVtcHR5U2VsZWN0aW9uLFxuICBnZXRTZWxlY3Rpb25CeUlkcyxcbiAgZ2V0VGFyZ2V0QnlJZCxcbn0gZnJvbSBcIi4uL3V0aWxzL3RhcmdldFwiO1xuaW1wb3J0IHVzZVN0b3JlIGZyb20gXCIuLi9zdG9yZS91c2Utc3RvcmVcIjtcbmltcG9ydCBTdGF0ZU1hbmFnZXIgZnJvbSBcIkBkZXNpZ25jb21iby9zdGF0ZVwiO1xuaW1wb3J0IHsgZ2V0Q3VycmVudFRpbWUgfSBmcm9tIFwiLi4vdXRpbHMvdGltZVwiO1xuaW1wb3J0IHVzZUxheW91dFN0b3JlIGZyb20gXCIuLi9zdG9yZS91c2UtbGF5b3V0LXN0b3JlXCI7XG5cbmxldCBob2xkR3JvdXBQb3NpdGlvbjogUmVjb3JkPHN0cmluZywgYW55PiB8IG51bGwgPSBudWxsO1xubGV0IGRyYWdTdGFydEVuZCA9IGZhbHNlO1xuXG5pbnRlcmZhY2UgU2NlbmVJbnRlcmFjdGlvbnNQcm9wcyB7XG4gIHN0YXRlTWFuYWdlcjogU3RhdGVNYW5hZ2VyO1xuICB2aWV3ZXJSZWY6IFJlYWN0LlJlZk9iamVjdDxhbnk+O1xuICBjb250YWluZXJSZWY6IFJlYWN0LlJlZk9iamVjdDxIVE1MRGl2RWxlbWVudD47XG4gIHpvb206IG51bWJlcjtcbiAgc2l6ZTogeyB3aWR0aDogbnVtYmVyOyBoZWlnaHQ6IG51bWJlciB9O1xufVxuZXhwb3J0IGZ1bmN0aW9uIFNjZW5lSW50ZXJhY3Rpb25zKHtcbiAgc3RhdGVNYW5hZ2VyLFxuICB2aWV3ZXJSZWYsXG4gIHpvb20sXG4gIHNpemUsXG59OiBTY2VuZUludGVyYWN0aW9uc1Byb3BzKSB7XG4gIGNvbnN0IFt0YXJnZXRzLCBzZXRUYXJnZXRzXSA9IHVzZVN0YXRlPEhUTUxEaXZFbGVtZW50W10+KFtdKTtcbiAgY29uc3QgW3NlbGVjdGlvbiwgc2V0U2VsZWN0aW9uXSA9IHVzZVN0YXRlPFNlbGVjdGlvbj4oKTtcbiAgY29uc3Qge1xuICAgIGFjdGl2ZUlkcyxcbiAgICBzZXRTdGF0ZSxcbiAgICB0cmFja0l0ZW1EZXRhaWxzTWFwLFxuICAgIHRyYWNrSXRlbXNNYXAsXG4gICAgcGxheWVyUmVmLFxuICAgIHNldFNjZW5lTW92ZWFibGVSZWYsXG4gIH0gPSB1c2VTdG9yZSgpO1xuICBjb25zdCB7IHNldEFjdGl2ZU1lbnVJdGVtLCBzZXRTaG93TWVudUl0ZW0gfSA9IHVzZUxheW91dFN0b3JlKCk7XG4gIGNvbnN0IG1vdmVhYmxlUmVmID0gdXNlUmVmPE1vdmVhYmxlPihudWxsKTtcbiAgY29uc3QgW3NlbGVjdGlvbkluZm8sIHNldFNlbGVjdGlvbkluZm9dID1cbiAgICB1c2VTdGF0ZTxTZWxlY3Rpb25JbmZvPihlbXB0eVNlbGVjdGlvbik7XG5cbiAgLy8gQ29uc3RhbnRlcyBwYXJhIGVsIHNuYXBcbiAgY29uc3QgU05BUF9USFJFU0hPTEQgPSAxNTsgLy8gRGlzdGFuY2lhIGVuIHDDrXhlbGVzIHBhcmEgYWN0aXZhciBlbCBzbmFwXG4gIGNvbnN0IFNOQVBfRURHRV9USFJFU0hPTEQgPSA1OyAvLyBVbWJyYWwgcGFyYSBjb25zaWRlcmFyIHF1ZSB1biBlbGVtZW50byBlc3TDoSBlbiBlbCBib3JkZVxuXG4gIC8vIEZ1bmNpw7NuIHBhcmEgYXBsaWNhciBzbmFwIGEgY29vcmRlbmFkYXNcbiAgY29uc3QgYXBwbHlTbmFwID0gKHZhbHVlOiBudW1iZXIsIHNuYXBQb2ludHM6IG51bWJlcltdLCB0aHJlc2hvbGQ6IG51bWJlciA9IFNOQVBfVEhSRVNIT0xEKTogbnVtYmVyID0+IHtcbiAgICBmb3IgKGNvbnN0IHBvaW50IG9mIHNuYXBQb2ludHMpIHtcbiAgICAgIGlmIChNYXRoLmFicyh2YWx1ZSAtIHBvaW50KSA8PSB0aHJlc2hvbGQpIHtcbiAgICAgICAgcmV0dXJuIHBvaW50O1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG4gIH07XG5cbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCB1cGRhdGVUYXJnZXRzID0gKHRpbWU/OiBudW1iZXIpID0+IHtcbiAgICAgIGNvbnN0IGN1cnJlbnRUaW1lID0gdGltZSB8fCBnZXRDdXJyZW50VGltZSgpO1xuICAgICAgY29uc3QgeyB0cmFja0l0ZW1zTWFwIH0gPSB1c2VTdG9yZS5nZXRTdGF0ZSgpO1xuICAgICAgY29uc3QgdGFyZ2V0SWRzID0gYWN0aXZlSWRzLmZpbHRlcigoaWQpID0+IHtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICB0cmFja0l0ZW1zTWFwW2lkXT8uZGlzcGxheS5mcm9tIDw9IGN1cnJlbnRUaW1lICYmXG4gICAgICAgICAgdHJhY2tJdGVtc01hcFtpZF0/LmRpc3BsYXkudG8gPj0gY3VycmVudFRpbWVcbiAgICAgICAgKTtcbiAgICAgIH0pO1xuICAgICAgY29uc3QgdGFyZ2V0cyA9IHRhcmdldElkcy5tYXAoXG4gICAgICAgIChpZCkgPT4gZ2V0VGFyZ2V0QnlJZChpZCkgYXMgSFRNTERpdkVsZW1lbnQsXG4gICAgICApO1xuICAgICAgc2VsZWN0aW9uPy5zZXRTZWxlY3RlZFRhcmdldHModGFyZ2V0cyk7XG4gICAgICBjb25zdCBzZWxJbmZvID0gZ2V0U2VsZWN0aW9uQnlJZHModGFyZ2V0SWRzKTtcblxuICAgICAgc2V0U2VsZWN0aW9uSW5mbyhzZWxJbmZvKTtcbiAgICAgIHNldFRhcmdldHMoc2VsSW5mby50YXJnZXRzIGFzIEhUTUxEaXZFbGVtZW50W10pO1xuICAgIH07XG4gICAgY29uc3QgdGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHVwZGF0ZVRhcmdldHMoKTtcbiAgICB9KTtcblxuICAgIGNvbnN0IG9uU2Vla2VkID0gKHY6IGFueSkgPT4ge1xuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgZnBzIH0gPSB1c2VTdG9yZS5nZXRTdGF0ZSgpO1xuICAgICAgICBjb25zdCBzZWVrZWRUaW1lID0gKHYuZGV0YWlsLmZyYW1lIC8gZnBzKSAqIDEwMDA7XG4gICAgICAgIHVwZGF0ZVRhcmdldHMoc2Vla2VkVGltZSk7XG4gICAgICB9KTtcbiAgICB9O1xuICAgIHBsYXllclJlZj8uY3VycmVudD8uYWRkRXZlbnRMaXN0ZW5lcihcInNlZWtlZFwiLCBvblNlZWtlZCk7XG5cbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgcGxheWVyUmVmPy5jdXJyZW50Py5yZW1vdmVFdmVudExpc3RlbmVyKFwic2Vla2VkXCIsIG9uU2Vla2VkKTtcbiAgICAgIGNsZWFyVGltZW91dCh0aW1lcik7XG4gICAgfTtcbiAgfSwgW2FjdGl2ZUlkcywgcGxheWVyUmVmLCB0cmFja0l0ZW1zTWFwXSk7XG5cbiAgLy8gRnVuY2nDs24gcGFyYSBtYW5lamFyIGxhIHNlbGVjY2nDs24gZGUgZWxlbWVudG9zXG4gIGNvbnN0IGhhbmRsZVNlbGVjdGlvbiA9IChpZHM6IHN0cmluZ1tdKSA9PiB7XG4gICAgY29uc29sZS5sb2coXCJbREVCVUcgSW50ZXJhY3Rpb25zXSBTZWxlY2Npw7NuIGRlIGVsZW1lbnRvczpcIiwgaWRzKTtcblxuICAgIC8vIEFjdHVhbGl6YXIgZWwgZXN0YWRvIGRlIGFjdGl2ZUlkc1xuICAgIHN0YXRlTWFuYWdlci51cGRhdGVTdGF0ZShcbiAgICAgIHtcbiAgICAgICAgYWN0aXZlSWRzOiBpZHMsXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICB1cGRhdGVIaXN0b3J5OiBmYWxzZSxcbiAgICAgICAga2luZDogXCJsYXllcjpzZWxlY3Rpb25cIixcbiAgICAgIH0sXG4gICAgKTtcblxuICAgIC8vIFNpIHNlIGhhIHNlbGVjY2lvbmFkbyB1biBzb2xvIGVsZW1lbnRvLCBjYW1iaWFyIGlubWVkaWF0YW1lbnRlIGFsIHBhbmVsIGRlIGF0cmlidXRvc1xuICAgIGlmIChpZHMgJiYgaWRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgY29uc29sZS5sb2coXCJbREVCVUcgSW50ZXJhY3Rpb25zXSBDYW1iaWFuZG8gYSBwYW5lbCBkZSBhdHJpYnV0b3MgZGlyZWN0YW1lbnRlIGRlc2RlIGludGVyYWN0aW9uc1wiKTtcblxuICAgICAgLy8gRk9SWkFSIGNhbWJpbyBkaXJlY3RvIGFsIHBhbmVsIGRlIGF0cmlidXRvc1xuICAgICAgc2V0QWN0aXZlTWVudUl0ZW0oXCJhdHRyaWJ1dGVzXCIpO1xuICAgICAgc2V0U2hvd01lbnVJdGVtKHRydWUpO1xuXG4gICAgICAvLyBGb3J6YXIgZWwgZXZlbnRvIGRlIHNlbGVjY2nDs24gcGFyYSBhc2VndXJhciBxdWUgdG9kb3MgbG9zIGNvbXBvbmVudGVzIHNlIGFjdHVhbGljZW5cbiAgICAgIGRpc3BhdGNoKExBWUVSX1NFTEVDVElPTiwge1xuICAgICAgICBwYXlsb2FkOiB7XG4gICAgICAgICAgYWN0aXZlSWRzOiBpZHNcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIC8vIFZlcmlmaWNhciBlbCBjYW1iaW9cbiAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBjb25zdCBjdXJyZW50TWVudUl0ZW0gPSB1c2VMYXlvdXRTdG9yZS5nZXRTdGF0ZSgpLmFjdGl2ZU1lbnVJdGVtO1xuICAgICAgICBjb25zb2xlLmxvZyhcIltERUJVRyBJbnRlcmFjdGlvbnNdIFBhbmVsIGRlc3B1w6lzIGRlbCBjYW1iaW86XCIsIGN1cnJlbnRNZW51SXRlbSk7XG4gICAgICB9LCAxMDApO1xuICAgIH1cbiAgfTtcblxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGNvbnN0IHNlbGVjdGlvbiA9IG5ldyBTZWxlY3Rpb24oe1xuICAgICAgY29udGFpbmVyOiB2aWV3ZXJSZWYuY3VycmVudD8uaW5maW5pdGVWaWV3ZXIuZ2V0Q29udGFpbmVyKCksXG4gICAgICBib3VuZENvbnRhaW5lcjogdHJ1ZSxcbiAgICAgIGhpdFJhdGU6IDAsXG4gICAgICBzZWxlY3RhYmxlVGFyZ2V0czogW1wiLmRlc2lnbmNvbWJvLXNjZW5lLWl0ZW1cIl0sXG4gICAgICBzZWxlY3RGcm9tSW5zaWRlOiBmYWxzZSxcbiAgICAgIHNlbGVjdEJ5Q2xpY2s6IHRydWUsXG4gICAgICB0b2dnbGVDb250aW51ZVNlbGVjdDogXCJzaGlmdFwiLFxuICAgIH0pXG4gICAgICAub24oXCJzZWxlY3RcIiwgKGUpID0+IHtcbiAgICAgICAgY29uc3QgaWRzID0gZS5zZWxlY3RlZC5tYXAoKGVsKSA9PiBnZXRJZEZyb21DbGFzc05hbWUoZWwuY2xhc3NOYW1lKSk7XG4gICAgICAgIHNldFRhcmdldHMoZS5zZWxlY3RlZCBhcyBIVE1MRGl2RWxlbWVudFtdKTtcblxuICAgICAgICAvLyBVc2FyIGxhIGZ1bmNpw7NuIGhhbmRsZVNlbGVjdGlvblxuICAgICAgICBoYW5kbGVTZWxlY3Rpb24oaWRzKTtcbiAgICAgIH0pXG4gICAgICAub24oXCJkcmFnU3RhcnRcIiwgKGUpID0+IHtcbiAgICAgICAgY29uc3QgdGFyZ2V0ID0gZS5pbnB1dEV2ZW50LnRhcmdldCBhcyBIVE1MRGl2RWxlbWVudDtcbiAgICAgICAgZHJhZ1N0YXJ0RW5kID0gZmFsc2U7XG5cbiAgICAgICAgaWYgKHRhcmdldHMuaW5jbHVkZXModGFyZ2V0KSkge1xuICAgICAgICAgIGUuc3RvcCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChcbiAgICAgICAgICB0YXJnZXQgJiZcbiAgICAgICAgICBtb3ZlYWJsZVJlZj8uY3VycmVudD8ubW92ZWFibGUuaXNNb3ZlYWJsZUVsZW1lbnQodGFyZ2V0KVxuICAgICAgICApIHtcbiAgICAgICAgICBlLnN0b3AoKTtcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICAgIC5vbihcImRyYWdFbmRcIiwgKCkgPT4ge1xuICAgICAgICBkcmFnU3RhcnRFbmQgPSB0cnVlO1xuICAgICAgfSlcbiAgICAgIC5vbihcInNlbGVjdEVuZFwiLCAoZSkgPT4ge1xuICAgICAgICBjb25zdCBtb3ZlYWJsZSA9IG1vdmVhYmxlUmVmLmN1cnJlbnQ7XG4gICAgICAgIGlmIChlLmlzRHJhZ1N0YXJ0KSB7XG4gICAgICAgICAgZS5pbnB1dEV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICBpZiAoIWRyYWdTdGFydEVuZCkge1xuICAgICAgICAgICAgICBtb3ZlYWJsZT8ubW92ZWFibGUuZHJhZ1N0YXJ0KGUuaW5wdXRFdmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc3QgdGFyZ2V0cyA9IGUuc2VsZWN0ZWQgYXMgSFRNTERpdkVsZW1lbnRbXTtcbiAgICAgICAgICBjb25zdCBpZHMgPSB0YXJnZXRzLm1hcCgoZWwpID0+IGdldElkRnJvbUNsYXNzTmFtZShlbC5jbGFzc05hbWUpKTtcblxuICAgICAgICAgIC8vIFVzYXIgbGEgZnVuY2nDs24gaGFuZGxlU2VsZWN0aW9uXG4gICAgICAgICAgaGFuZGxlU2VsZWN0aW9uKGlkcyk7XG4gICAgICAgICAgc2V0VGFyZ2V0cyh0YXJnZXRzKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgc2V0U2VsZWN0aW9uKHNlbGVjdGlvbik7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHNlbGVjdGlvbi5kZXN0cm95KCk7XG4gICAgfTtcbiAgfSwgW10pO1xuXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgY29uc3QgYWN0aXZlU2VsZWN0aW9uU3Vic2NyaXB0aW9uID0gc3RhdGVNYW5hZ2VyLnN1YnNjcmliZVRvQWN0aXZlSWRzKFxuICAgICAgKG5ld1N0YXRlKSA9PiB7XG4gICAgICAgIHNldFN0YXRlKG5ld1N0YXRlKTtcblxuICAgICAgICAvLyBTaSBoYXkgdW4gc29sbyBlbGVtZW50byBzZWxlY2Npb25hZG8sIGFzZWd1cmFyc2UgZGUgcXVlIHNlIG11ZXN0cmUgZWwgcGFuZWwgZGUgYXRyaWJ1dG9zXG4gICAgICAgIGlmIChuZXdTdGF0ZS5hY3RpdmVJZHMgJiYgbmV3U3RhdGUuYWN0aXZlSWRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgIHNldEFjdGl2ZU1lbnVJdGVtKFwiYXR0cmlidXRlc1wiKTtcbiAgICAgICAgICBzZXRTaG93TWVudUl0ZW0odHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgKTtcblxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBhY3RpdmVTZWxlY3Rpb25TdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICB9O1xuICB9LCBbXSk7XG5cbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBtb3ZlYWJsZVJlZi5jdXJyZW50IS5tb3ZlYWJsZS51cGRhdGVSZWN0KCk7XG4gIH0sIFt0cmFja0l0ZW1zTWFwXSk7XG5cbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBzZXRTY2VuZU1vdmVhYmxlUmVmKG1vdmVhYmxlUmVmKTtcbiAgfSwgW21vdmVhYmxlUmVmXSk7XG4gIHJldHVybiAoXG4gICAgPE1vdmVhYmxlXG4gICAgICByZWY9e21vdmVhYmxlUmVmfVxuICAgICAgcm90YXRpb25Qb3NpdGlvbj17XCJib3R0b21cIn1cbiAgICAgIHJlbmRlckRpcmVjdGlvbnM9e3NlbGVjdGlvbkluZm8uY29udHJvbHN9XG4gICAgICB7Li4uc2VsZWN0aW9uSW5mby5hYmxlc31cbiAgICAgIG9yaWdpbj17ZmFsc2V9XG4gICAgICB0YXJnZXQ9e3RhcmdldHN9XG4gICAgICB6b29tPXsxIC8gem9vbX1cbiAgICAgIGNsYXNzTmFtZT1cImRlc2lnbmNvbWJvLXNjZW5lLW1vdmVhYmxlXCJcbiAgICAgIG9uRHJhZz17KHsgdGFyZ2V0LCBiZWZvcmVUcmFuc2xhdGUsIGlucHV0RXZlbnQgfSkgPT4ge1xuICAgICAgICBjb25zdCB0YXJnZXRJZCA9IGdldElkRnJvbUNsYXNzTmFtZSh0YXJnZXQuY2xhc3NOYW1lKSBhcyBzdHJpbmc7XG4gICAgICAgIGNvbnN0IHRyYWNrSXRlbSA9IHRyYWNrSXRlbURldGFpbHNNYXBbdGFyZ2V0SWRdO1xuXG4gICAgICAgIC8vIE9idGVuZXIgZGltZW5zaW9uZXMgZGVsIGVsZW1lbnRvXG4gICAgICAgIGNvbnN0IHRhcmdldFdpZHRoID0gdGFyZ2V0Lm9mZnNldFdpZHRoO1xuICAgICAgICBjb25zdCB0YXJnZXRIZWlnaHQgPSB0YXJnZXQub2Zmc2V0SGVpZ2h0O1xuXG4gICAgICAgIC8vIENhbGN1bGFyIGxhIHBvc2ljacOzbiBwcm9wdWVzdGFcbiAgICAgICAgbGV0IGxlZnQgPSBwYXJzZUZsb2F0KHRyYWNrSXRlbT8uZGV0YWlscy5sZWZ0IGFzIHN0cmluZykgKyBiZWZvcmVUcmFuc2xhdGVbMF07XG4gICAgICAgIGxldCB0b3AgPSBwYXJzZUZsb2F0KHRyYWNrSXRlbT8uZGV0YWlscy50b3AgYXMgc3RyaW5nKSArIGJlZm9yZVRyYW5zbGF0ZVsxXTtcblxuICAgICAgICAvLyBQdW50b3MgZGUgc25hcCBwYXJhIGVsIGVqZSBYIChpenF1aWVyZGEsIGNlbnRybywgZGVyZWNoYSlcbiAgICAgICAgY29uc3Qgc25hcFBvaW50c1ggPSBbXG4gICAgICAgICAgMCwgLy8gQm9yZGUgaXpxdWllcmRvXG4gICAgICAgICAgc2l6ZS53aWR0aCAvIDIgLSB0YXJnZXRXaWR0aCAvIDIsIC8vIENlbnRybyBob3Jpem9udGFsXG4gICAgICAgICAgc2l6ZS53aWR0aCAtIHRhcmdldFdpZHRoIC8vIEJvcmRlIGRlcmVjaG9cbiAgICAgICAgXTtcblxuICAgICAgICAvLyBQdW50b3MgZGUgc25hcCBwYXJhIGVsIGVqZSBZIChhcnJpYmEsIGNlbnRybywgYWJham8pXG4gICAgICAgIGNvbnN0IHNuYXBQb2ludHNZID0gW1xuICAgICAgICAgIDAsIC8vIEJvcmRlIHN1cGVyaW9yXG4gICAgICAgICAgc2l6ZS5oZWlnaHQgLyAyIC0gdGFyZ2V0SGVpZ2h0IC8gMiwgLy8gQ2VudHJvIHZlcnRpY2FsXG4gICAgICAgICAgc2l6ZS5oZWlnaHQgLSB0YXJnZXRIZWlnaHQgLy8gQm9yZGUgaW5mZXJpb3JcbiAgICAgICAgXTtcblxuICAgICAgICAvLyBBcGxpY2FyIHNuYXAgY29uIHVtYnJhbCBub3JtYWxcbiAgICAgICAgbGVmdCA9IGFwcGx5U25hcChsZWZ0LCBzbmFwUG9pbnRzWCk7XG4gICAgICAgIHRvcCA9IGFwcGx5U25hcCh0b3AsIHNuYXBQb2ludHNZKTtcblxuICAgICAgICAvLyBGZWVkYmFjayB2aXN1YWwgcGFyYSBpbmRpY2FyIGVsIHNuYXAgKG9wY2lvbmFsKVxuICAgICAgICBpZiAoc25hcFBvaW50c1guc29tZShwb2ludCA9PiBNYXRoLmFicyhsZWZ0IC0gcG9pbnQpIDw9IFNOQVBfRURHRV9USFJFU0hPTEQpIHx8XG4gICAgICAgICAgICBzbmFwUG9pbnRzWS5zb21lKHBvaW50ID0+IE1hdGguYWJzKHRvcCAtIHBvaW50KSA8PSBTTkFQX0VER0VfVEhSRVNIT0xEKSkge1xuICAgICAgICAgIC8vIFNlIHBvZHLDrWEgYcOxYWRpciB1bmEgY2xhc2UgQ1NTIHBhcmEgaW5kaWNhciB2aXN1YWxtZW50ZSBlbCBzbmFwXG4gICAgICAgICAgdGFyZ2V0LmNsYXNzTGlzdC5hZGQoJ3NuYXBwZWQtZWxlbWVudCcpO1xuXG4gICAgICAgICAgLy8gQcOxYWRpciBwZXF1ZcOxYSB2aWJyYWNpw7NuIGNvbW8gZmVlZGJhY2sgdMOhY3RpbCAob3BjaW9uYWwpXG4gICAgICAgICAgaWYgKGlucHV0RXZlbnQgaW5zdGFuY2VvZiBNb3VzZUV2ZW50ICYmICd2aWJyYXRlJyBpbiBuYXZpZ2F0b3IpIHtcbiAgICAgICAgICAgIG5hdmlnYXRvci52aWJyYXRlKDEwKTsgLy8gVmlicmFjacOzbiBzdXRpbCBkZSAxMG1zXG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRhcmdldC5jbGFzc0xpc3QucmVtb3ZlKCdzbmFwcGVkLWVsZW1lbnQnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEFjdHVhbGl6YXIgcG9zaWNpw7NuXG4gICAgICAgIHRhcmdldC5zdHlsZS50b3AgPSB0b3AgKyBcInB4XCI7XG4gICAgICAgIHRhcmdldC5zdHlsZS5sZWZ0ID0gbGVmdCArIFwicHhcIjtcbiAgICAgIH19XG4gICAgICBvbkRyYWdFbmQ9eyh7IHRhcmdldCwgaXNEcmFnIH0pID0+IHtcbiAgICAgICAgaWYgKCFpc0RyYWcpIHJldHVybjtcbiAgICAgICAgY29uc3QgdGFyZ2V0SWQgPSBnZXRJZEZyb21DbGFzc05hbWUodGFyZ2V0LmNsYXNzTmFtZSkgYXMgc3RyaW5nO1xuXG4gICAgICAgIC8vIEVsaW1pbmFyIGxhIGNsYXNlIGRlIHNuYXAgYWwgZmluYWxpemFyXG4gICAgICAgIHRhcmdldC5jbGFzc0xpc3QucmVtb3ZlKCdzbmFwcGVkLWVsZW1lbnQnKTtcblxuICAgICAgICBkaXNwYXRjaChFRElUX09CSkVDVCwge1xuICAgICAgICAgIHBheWxvYWQ6IHtcbiAgICAgICAgICAgIFt0YXJnZXRJZF06IHtcbiAgICAgICAgICAgICAgZGV0YWlsczoge1xuICAgICAgICAgICAgICAgIGxlZnQ6IHRhcmdldC5zdHlsZS5sZWZ0LFxuICAgICAgICAgICAgICAgIHRvcDogdGFyZ2V0LnN0eWxlLnRvcCxcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgICB9fVxuICAgICAgb25TY2FsZT17KHsgdGFyZ2V0LCB0cmFuc2Zvcm0sIGRpcmVjdGlvbiB9KSA9PiB7XG4gICAgICAgIGNvbnN0IFt4Q29udHJvbCwgeUNvbnRyb2xdID0gZGlyZWN0aW9uO1xuXG4gICAgICAgIGNvbnN0IHNjYWxlUmVnZXggPSAvc2NhbGVcXCgoW14pXSspXFwpLztcbiAgICAgICAgY29uc3QgbWF0Y2ggPSB0YXJnZXQuc3R5bGUudHJhbnNmb3JtLm1hdGNoKHNjYWxlUmVnZXgpITtcblxuICAgICAgICAvL2dldCBjdXJyZW50IHNjYWxlXG4gICAgICAgIGNvbnN0IFtzY2FsZVgsIHNjYWxlWV0gPSBtYXRjaFsxXVxuICAgICAgICAgIC5zcGxpdChcIixcIilcbiAgICAgICAgICAubWFwKCh2YWx1ZSkgPT4gcGFyc2VGbG9hdCh2YWx1ZS50cmltKCkpKTtcblxuICAgICAgICAvL2dldCBuZXcgU2NhbGVcbiAgICAgICAgY29uc3QgbWF0Y2gyID0gdHJhbnNmb3JtLm1hdGNoKHNjYWxlUmVnZXgpITtcbiAgICAgICAgY29uc3QgW25ld1NjYWxlWCwgbmV3U2NhbGVZXSA9IG1hdGNoMlsxXVxuICAgICAgICAgIC5zcGxpdChcIixcIilcbiAgICAgICAgICAubWFwKCh2YWx1ZSkgPT4gcGFyc2VGbG9hdCh2YWx1ZS50cmltKCkpKTtcblxuICAgICAgICBjb25zdCBjdXJyZW50V2lkdGggPSB0YXJnZXQuY2xpZW50V2lkdGggKiBzY2FsZVg7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRIZWlnaHQgPSB0YXJnZXQuY2xpZW50SGVpZ2h0ICogc2NhbGVZO1xuXG4gICAgICAgIGNvbnN0IG5ld1dpZHRoID0gdGFyZ2V0LmNsaWVudFdpZHRoICogbmV3U2NhbGVYO1xuICAgICAgICBjb25zdCBuZXdIZWlnaHQgPSB0YXJnZXQuY2xpZW50SGVpZ2h0ICogbmV3U2NhbGVZO1xuXG4gICAgICAgIHRhcmdldC5zdHlsZS50cmFuc2Zvcm0gPSB0cmFuc2Zvcm07XG5cbiAgICAgICAgLy9Nb3ZlIGVsZW1lbnQgdG8gaW5pdGlhbCBMZWZ0IHBvc2l0aW9uXG4gICAgICAgIGNvbnN0IGRpZmZYID0gY3VycmVudFdpZHRoIC0gbmV3V2lkdGg7XG4gICAgICAgIGxldCBuZXdMZWZ0ID0gcGFyc2VGbG9hdCh0YXJnZXQuc3R5bGUubGVmdCkgLSBkaWZmWCAvIDI7XG5cbiAgICAgICAgY29uc3QgZGlmZlkgPSBjdXJyZW50SGVpZ2h0IC0gbmV3SGVpZ2h0O1xuICAgICAgICBsZXQgbmV3VG9wID0gcGFyc2VGbG9hdCh0YXJnZXQuc3R5bGUudG9wKSAtIGRpZmZZIC8gMjtcblxuICAgICAgICBpZiAoeENvbnRyb2wgPT09IC0xKSB7XG4gICAgICAgICAgbmV3TGVmdCArPSBkaWZmWDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoeUNvbnRyb2wgPT09IC0xKSB7XG4gICAgICAgICAgbmV3VG9wICs9IGRpZmZZO1xuICAgICAgICB9XG4gICAgICAgIHRhcmdldC5zdHlsZS5sZWZ0ID0gbmV3TGVmdCArIFwicHhcIjtcbiAgICAgICAgdGFyZ2V0LnN0eWxlLnRvcCA9IG5ld1RvcCArIFwicHhcIjtcbiAgICAgIH19XG4gICAgICBvblNjYWxlRW5kPXsoeyB0YXJnZXQgfSkgPT4ge1xuICAgICAgICBpZiAoIXRhcmdldC5zdHlsZS50cmFuc2Zvcm0pIHJldHVybjtcbiAgICAgICAgY29uc3QgdGFyZ2V0SWQgPSBnZXRJZEZyb21DbGFzc05hbWUodGFyZ2V0LmNsYXNzTmFtZSkgYXMgc3RyaW5nO1xuXG4gICAgICAgIGRpc3BhdGNoKEVESVRfT0JKRUNULCB7XG4gICAgICAgICAgcGF5bG9hZDoge1xuICAgICAgICAgICAgW3RhcmdldElkXToge1xuICAgICAgICAgICAgICBkZXRhaWxzOiB7XG4gICAgICAgICAgICAgICAgdHJhbnNmb3JtOiB0YXJnZXQuc3R5bGUudHJhbnNmb3JtLFxuICAgICAgICAgICAgICAgIGxlZnQ6IHBhcnNlRmxvYXQodGFyZ2V0LnN0eWxlLmxlZnQpLFxuICAgICAgICAgICAgICAgIHRvcDogcGFyc2VGbG9hdCh0YXJnZXQuc3R5bGUudG9wKSxcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgICB9fVxuICAgICAgb25Sb3RhdGU9eyh7IHRhcmdldCwgdHJhbnNmb3JtIH0pID0+IHtcbiAgICAgICAgdGFyZ2V0LnN0eWxlLnRyYW5zZm9ybSA9IHRyYW5zZm9ybTtcbiAgICAgIH19XG4gICAgICBvblJvdGF0ZUVuZD17KHsgdGFyZ2V0IH0pID0+IHtcbiAgICAgICAgaWYgKCF0YXJnZXQuc3R5bGUudHJhbnNmb3JtKSByZXR1cm47XG4gICAgICAgIGNvbnN0IHRhcmdldElkID0gZ2V0SWRGcm9tQ2xhc3NOYW1lKHRhcmdldC5jbGFzc05hbWUpIGFzIHN0cmluZztcbiAgICAgICAgZGlzcGF0Y2goRURJVF9PQkpFQ1QsIHtcbiAgICAgICAgICBwYXlsb2FkOiB7XG4gICAgICAgICAgICBbdGFyZ2V0SWRdOiB7XG4gICAgICAgICAgICAgIGRldGFpbHM6IHtcbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm06IHRhcmdldC5zdHlsZS50cmFuc2Zvcm0sXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgICAgfX1cbiAgICAgIG9uRHJhZ0dyb3VwPXsoeyBldmVudHMgfSkgPT4ge1xuICAgICAgICBob2xkR3JvdXBQb3NpdGlvbiA9IHt9O1xuXG4gICAgICAgIC8vIE9idGVuZXIgZWwgcmVjdMOhbmd1bG8gcXVlIGNvbnRpZW5lIHRvZG8gZWwgZ3J1cG9cbiAgICAgICAgbGV0IGdyb3VwTGVmdCA9IEluZmluaXR5O1xuICAgICAgICBsZXQgZ3JvdXBUb3AgPSBJbmZpbml0eTtcbiAgICAgICAgbGV0IGdyb3VwUmlnaHQgPSAtSW5maW5pdHk7XG4gICAgICAgIGxldCBncm91cEJvdHRvbSA9IC1JbmZpbml0eTtcblxuICAgICAgICAvLyBQcmltZXIgcGFzbzogY2FsY3VsYXIgZGltZW5zaW9uZXMgZGVsIGdydXBvXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZXZlbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgY29uc3QgZXZlbnQgPSBldmVudHNbaV07XG4gICAgICAgICAgY29uc3QgaWQgPSBnZXRJZEZyb21DbGFzc05hbWUoZXZlbnQudGFyZ2V0LmNsYXNzTmFtZSk7XG4gICAgICAgICAgY29uc3QgdHJhY2tJdGVtID0gdHJhY2tJdGVtRGV0YWlsc01hcFtpZF07XG5cbiAgICAgICAgICBjb25zdCBsZWZ0ID0gcGFyc2VGbG9hdCh0cmFja0l0ZW0/LmRldGFpbHMubGVmdCBhcyBzdHJpbmcpO1xuICAgICAgICAgIGNvbnN0IHRvcCA9IHBhcnNlRmxvYXQodHJhY2tJdGVtPy5kZXRhaWxzLnRvcCBhcyBzdHJpbmcpO1xuICAgICAgICAgIGNvbnN0IHdpZHRoID0gZXZlbnQudGFyZ2V0Lm9mZnNldFdpZHRoO1xuICAgICAgICAgIGNvbnN0IGhlaWdodCA9IGV2ZW50LnRhcmdldC5vZmZzZXRIZWlnaHQ7XG5cbiAgICAgICAgICBncm91cExlZnQgPSBNYXRoLm1pbihncm91cExlZnQsIGxlZnQpO1xuICAgICAgICAgIGdyb3VwVG9wID0gTWF0aC5taW4oZ3JvdXBUb3AsIHRvcCk7XG4gICAgICAgICAgZ3JvdXBSaWdodCA9IE1hdGgubWF4KGdyb3VwUmlnaHQsIGxlZnQgKyB3aWR0aCk7XG4gICAgICAgICAgZ3JvdXBCb3R0b20gPSBNYXRoLm1heChncm91cEJvdHRvbSwgdG9wICsgaGVpZ2h0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGdyb3VwV2lkdGggPSBncm91cFJpZ2h0IC0gZ3JvdXBMZWZ0O1xuICAgICAgICBjb25zdCBncm91cEhlaWdodCA9IGdyb3VwQm90dG9tIC0gZ3JvdXBUb3A7XG5cbiAgICAgICAgLy8gQ2FsY3VsYXIgZWwgZGVzcGxhemFtaWVudG8gYmFzZSBkZWwgZ3J1cG8gKGRlc2RlIGVsIHByaW1lciBlbGVtZW50bylcbiAgICAgICAgY29uc3QgYmFzZVRyYW5zbGF0ZSA9IGV2ZW50c1swXS5iZWZvcmVUcmFuc2xhdGU7XG5cbiAgICAgICAgLy8gQ2FsY3VsYXIgbnVldmEgcG9zaWNpw7NuIGRlbCBncnVwbyBjb24gcG9zaWJsZSBzbmFwXG4gICAgICAgIGxldCBuZXdHcm91cExlZnQgPSBncm91cExlZnQgKyBiYXNlVHJhbnNsYXRlWzBdO1xuICAgICAgICBsZXQgbmV3R3JvdXBUb3AgPSBncm91cFRvcCArIGJhc2VUcmFuc2xhdGVbMV07XG5cbiAgICAgICAgLy8gUHVudG9zIGRlIHNuYXAgcGFyYSBlbCBncnVwb1xuICAgICAgICBjb25zdCBzbmFwUG9pbnRzWCA9IFtcbiAgICAgICAgICAwLCAvLyBCb3JkZSBpenF1aWVyZG9cbiAgICAgICAgICBzaXplLndpZHRoIC8gMiAtIGdyb3VwV2lkdGggLyAyLCAvLyBDZW50cm8gaG9yaXpvbnRhbFxuICAgICAgICAgIHNpemUud2lkdGggLSBncm91cFdpZHRoIC8vIEJvcmRlIGRlcmVjaG9cbiAgICAgICAgXTtcblxuICAgICAgICBjb25zdCBzbmFwUG9pbnRzWSA9IFtcbiAgICAgICAgICAwLCAvLyBCb3JkZSBzdXBlcmlvclxuICAgICAgICAgIHNpemUuaGVpZ2h0IC8gMiAtIGdyb3VwSGVpZ2h0IC8gMiwgLy8gQ2VudHJvIHZlcnRpY2FsXG4gICAgICAgICAgc2l6ZS5oZWlnaHQgLSBncm91cEhlaWdodCAvLyBCb3JkZSBpbmZlcmlvclxuICAgICAgICBdO1xuXG4gICAgICAgIC8vIEFwbGljYXIgc25hcCBhbCBncnVwb1xuICAgICAgICBjb25zdCBzbmFwcGVkR3JvdXBMZWZ0ID0gYXBwbHlTbmFwKG5ld0dyb3VwTGVmdCwgc25hcFBvaW50c1gpO1xuICAgICAgICBjb25zdCBzbmFwcGVkR3JvdXBUb3AgPSBhcHBseVNuYXAobmV3R3JvdXBUb3AsIHNuYXBQb2ludHNZKTtcblxuICAgICAgICAvLyBDYWxjdWxhciBlbCBhanVzdGUgbmVjZXNhcmlvIGRlc3B1w6lzIGRlbCBzbmFwXG4gICAgICAgIGNvbnN0IGFkanVzdFggPSBzbmFwcGVkR3JvdXBMZWZ0IC0gbmV3R3JvdXBMZWZ0O1xuICAgICAgICBjb25zdCBhZGp1c3RZID0gc25hcHBlZEdyb3VwVG9wIC0gbmV3R3JvdXBUb3A7XG5cbiAgICAgICAgLy8gRmVlZGJhY2sgdmlzdWFsIHBhcmEgZWwgc25hcCBkZSBncnVwb1xuICAgICAgICBjb25zdCBpc0dyb3VwU25hcHBlZCA9XG4gICAgICAgICAgTWF0aC5hYnMoYWRqdXN0WCkgPD0gU05BUF9FREdFX1RIUkVTSE9MRCB8fFxuICAgICAgICAgIE1hdGguYWJzKGFkanVzdFkpIDw9IFNOQVBfRURHRV9USFJFU0hPTEQ7XG5cbiAgICAgICAgLy8gQXBsaWNhciBlbCBtb3ZpbWllbnRvIGFqdXN0YWRvIGEgY2FkYSBlbGVtZW50byBkZWwgZ3J1cG9cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBldmVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBjb25zdCBldmVudCA9IGV2ZW50c1tpXTtcbiAgICAgICAgICBjb25zdCBpZCA9IGdldElkRnJvbUNsYXNzTmFtZShldmVudC50YXJnZXQuY2xhc3NOYW1lKTtcbiAgICAgICAgICBjb25zdCB0cmFja0l0ZW0gPSB0cmFja0l0ZW1EZXRhaWxzTWFwW2lkXTtcblxuICAgICAgICAgIGNvbnN0IGxlZnQgPSBwYXJzZUZsb2F0KHRyYWNrSXRlbT8uZGV0YWlscy5sZWZ0IGFzIHN0cmluZykgK1xuICAgICAgICAgICAgZXZlbnQuYmVmb3JlVHJhbnNsYXRlWzBdICsgYWRqdXN0WDtcbiAgICAgICAgICBjb25zdCB0b3AgPSBwYXJzZUZsb2F0KHRyYWNrSXRlbT8uZGV0YWlscy50b3AgYXMgc3RyaW5nKSArXG4gICAgICAgICAgICBldmVudC5iZWZvcmVUcmFuc2xhdGVbMV0gKyBhZGp1c3RZO1xuXG4gICAgICAgICAgZXZlbnQudGFyZ2V0LnN0eWxlLmxlZnQgPSBgJHtsZWZ0fXB4YDtcbiAgICAgICAgICBldmVudC50YXJnZXQuc3R5bGUudG9wID0gYCR7dG9wfXB4YDtcblxuICAgICAgICAgIC8vIEFwbGljYXIgY2xhc2UgdmlzdWFsIHNpIGhheSBzbmFwXG4gICAgICAgICAgaWYgKGlzR3JvdXBTbmFwcGVkKSB7XG4gICAgICAgICAgICBldmVudC50YXJnZXQuY2xhc3NMaXN0LmFkZCgnc25hcHBlZC1lbGVtZW50Jyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGV2ZW50LnRhcmdldC5jbGFzc0xpc3QucmVtb3ZlKCdzbmFwcGVkLWVsZW1lbnQnKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBob2xkR3JvdXBQb3NpdGlvbltpZF0gPSB7XG4gICAgICAgICAgICBsZWZ0OiBsZWZ0LFxuICAgICAgICAgICAgdG9wOiB0b3AsXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEZlZWRiYWNrIHTDoWN0aWwgc2kgaGF5IHNuYXBcbiAgICAgICAgaWYgKGlzR3JvdXBTbmFwcGVkICYmICd2aWJyYXRlJyBpbiBuYXZpZ2F0b3IpIHtcbiAgICAgICAgICBuYXZpZ2F0b3IudmlicmF0ZSgxMCk7XG4gICAgICAgIH1cbiAgICAgIH19XG4gICAgICBvblJlc2l6ZT17KHtcbiAgICAgICAgdGFyZ2V0LFxuICAgICAgICB3aWR0aDogbmV4dFdpZHRoLFxuICAgICAgICBoZWlnaHQ6IG5leHRIZWlnaHQsXG4gICAgICAgIGRpcmVjdGlvbixcbiAgICAgIH0pID0+IHtcbiAgICAgICAgaWYgKGRpcmVjdGlvblsxXSA9PT0gMSkge1xuICAgICAgICAgIGNvbnN0IGN1cnJlbnRXaWR0aCA9IHRhcmdldC5jbGllbnRXaWR0aDtcbiAgICAgICAgICBjb25zdCBjdXJyZW50SGVpZ2h0ID0gdGFyZ2V0LmNsaWVudEhlaWdodDtcblxuICAgICAgICAgIC8vIEdldCBuZXcgd2lkdGggYW5kIGhlaWdodFxuICAgICAgICAgIGNvbnN0IHNjYWxlWSA9IG5leHRIZWlnaHQgLyBjdXJyZW50SGVpZ2h0O1xuICAgICAgICAgIGNvbnN0IHNjYWxlID0gc2NhbGVZO1xuXG4gICAgICAgICAgLy8gVXBkYXRlIHRhcmdldCBkaW1lbnNpb25zXG4gICAgICAgICAgdGFyZ2V0LnN0eWxlLndpZHRoID0gYCR7Y3VycmVudFdpZHRoICogc2NhbGV9cHhgO1xuICAgICAgICAgIHRhcmdldC5zdHlsZS5oZWlnaHQgPSBgJHtjdXJyZW50SGVpZ2h0ICogc2NhbGV9cHhgO1xuXG4gICAgICAgICAgLy8gU2FmZWx5IGFjY2VzcyBuZXN0ZWQgZWxlbWVudHNcbiAgICAgICAgICBjb25zdCBhbmltYXRpb25EaXYgPSB0YXJnZXQuZmlyc3RFbGVtZW50Q2hpbGRcbiAgICAgICAgICAgID8uZmlyc3RFbGVtZW50Q2hpbGQgYXMgSFRNTERpdkVsZW1lbnQgfCBudWxsO1xuICAgICAgICAgIGlmIChhbmltYXRpb25EaXYpIHtcbiAgICAgICAgICAgIGFuaW1hdGlvbkRpdi5zdHlsZS53aWR0aCA9IGAke2N1cnJlbnRXaWR0aCAqIHNjYWxlfXB4YDtcbiAgICAgICAgICAgIGFuaW1hdGlvbkRpdi5zdHlsZS5oZWlnaHQgPSBgJHtjdXJyZW50SGVpZ2h0ICogc2NhbGV9cHhgO1xuXG4gICAgICAgICAgICBjb25zdCB0ZXh0RGl2ID1cbiAgICAgICAgICAgICAgYW5pbWF0aW9uRGl2LmZpcnN0RWxlbWVudENoaWxkIGFzIEhUTUxEaXZFbGVtZW50IHwgbnVsbDtcbiAgICAgICAgICAgIGlmICh0ZXh0RGl2KSB7XG4gICAgICAgICAgICAgIGNvbnN0IGZvbnRTaXplID0gcGFyc2VGbG9hdChnZXRDb21wdXRlZFN0eWxlKHRleHREaXYpLmZvbnRTaXplKTtcbiAgICAgICAgICAgICAgdGV4dERpdi5zdHlsZS5mb250U2l6ZSA9IGAke2ZvbnRTaXplICogc2NhbGV9cHhgO1xuICAgICAgICAgICAgICB0ZXh0RGl2LnN0eWxlLndpZHRoID0gYCR7Y3VycmVudFdpZHRoICogc2NhbGV9cHhgO1xuICAgICAgICAgICAgICB0ZXh0RGl2LnN0eWxlLmhlaWdodCA9IGAke2N1cnJlbnRIZWlnaHQgKiBzY2FsZX1weGA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRhcmdldC5zdHlsZS53aWR0aCA9IG5leHRXaWR0aCArIFwicHhcIjtcbiAgICAgICAgICB0YXJnZXQuc3R5bGUuaGVpZ2h0ID0gbmV4dEhlaWdodCArIFwicHhcIjtcblxuICAgICAgICAgIC8vIFNhZmVseSBhY2Nlc3MgbmVzdGVkIGVsZW1lbnRzXG4gICAgICAgICAgY29uc3QgYW5pbWF0aW9uRGl2ID0gdGFyZ2V0LmZpcnN0RWxlbWVudENoaWxkXG4gICAgICAgICAgICA/LmZpcnN0RWxlbWVudENoaWxkIGFzIEhUTUxEaXZFbGVtZW50IHwgbnVsbDtcbiAgICAgICAgICBpZiAoYW5pbWF0aW9uRGl2KSB7XG4gICAgICAgICAgICBhbmltYXRpb25EaXYuc3R5bGUud2lkdGggPSBgJHtuZXh0V2lkdGh9cHhgO1xuICAgICAgICAgICAgYW5pbWF0aW9uRGl2LnN0eWxlLmhlaWdodCA9IGAke25leHRIZWlnaHR9cHhgO1xuXG4gICAgICAgICAgICBjb25zdCB0ZXh0RGl2ID1cbiAgICAgICAgICAgICAgYW5pbWF0aW9uRGl2LmZpcnN0RWxlbWVudENoaWxkIGFzIEhUTUxEaXZFbGVtZW50IHwgbnVsbDtcbiAgICAgICAgICAgIGlmICh0ZXh0RGl2KSB7XG4gICAgICAgICAgICAgIHRleHREaXYuc3R5bGUud2lkdGggPSBgJHtuZXh0V2lkdGh9cHhgO1xuICAgICAgICAgICAgICB0ZXh0RGl2LnN0eWxlLmhlaWdodCA9IGAke25leHRIZWlnaHR9cHhgO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfX1cbiAgICAgIG9uUmVzaXplRW5kPXsoeyB0YXJnZXQgfSkgPT4ge1xuICAgICAgICBjb25zdCB0YXJnZXRJZCA9IGdldElkRnJvbUNsYXNzTmFtZSh0YXJnZXQuY2xhc3NOYW1lKSBhcyBzdHJpbmc7XG4gICAgICAgIGNvbnN0IHRleHREaXYgPSB0YXJnZXQuZmlyc3RFbGVtZW50Q2hpbGQ/LmZpcnN0RWxlbWVudENoaWxkXG4gICAgICAgICAgPy5maXJzdEVsZW1lbnRDaGlsZCBhcyBIVE1MRGl2RWxlbWVudDtcbiAgICAgICAgZGlzcGF0Y2goRURJVF9PQkpFQ1QsIHtcbiAgICAgICAgICBwYXlsb2FkOiB7XG4gICAgICAgICAgICBbdGFyZ2V0SWRdOiB7XG4gICAgICAgICAgICAgIGRldGFpbHM6IHtcbiAgICAgICAgICAgICAgICB3aWR0aDogcGFyc2VGbG9hdCh0YXJnZXQuc3R5bGUud2lkdGgpLFxuICAgICAgICAgICAgICAgIGhlaWdodDogcGFyc2VGbG9hdCh0YXJnZXQuc3R5bGUuaGVpZ2h0KSxcbiAgICAgICAgICAgICAgICBmb250U2l6ZTogcGFyc2VGbG9hdCh0ZXh0RGl2LnN0eWxlLmZvbnRTaXplKSxcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgICB9fVxuICAgICAgb25EcmFnR3JvdXBFbmQ9eygpID0+IHtcbiAgICAgICAgaWYgKGhvbGRHcm91cFBvc2l0aW9uKSB7XG4gICAgICAgICAgY29uc3QgcGF5bG9hZDogUmVjb3JkPHN0cmluZywgUGFydGlhbDxhbnk+PiA9IHt9O1xuICAgICAgICAgIE9iamVjdC5rZXlzKGhvbGRHcm91cFBvc2l0aW9uKS5mb3JFYWNoKChpZCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgbGVmdCA9IGhvbGRHcm91cFBvc2l0aW9uIVtpZF0ubGVmdDtcbiAgICAgICAgICAgIGNvbnN0IHRvcCA9IGhvbGRHcm91cFBvc2l0aW9uIVtpZF0udG9wO1xuXG4gICAgICAgICAgICAvLyBFbGltaW5hciBsYSBjbGFzZSBkZSBzbmFwXG4gICAgICAgICAgICBjb25zdCBlbGVtZW50ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihgLmlkLSR7aWR9YCk7XG4gICAgICAgICAgICBpZiAoZWxlbWVudCkge1xuICAgICAgICAgICAgICBlbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoJ3NuYXBwZWQtZWxlbWVudCcpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBwYXlsb2FkW2lkXSA9IHtcbiAgICAgICAgICAgICAgZGV0YWlsczoge1xuICAgICAgICAgICAgICAgIHRvcDogYCR7dG9wfXB4YCxcbiAgICAgICAgICAgICAgICBsZWZ0OiBgJHtsZWZ0fXB4YCxcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgZGlzcGF0Y2goRURJVF9PQkpFQ1QsIHtcbiAgICAgICAgICAgIHBheWxvYWQ6IHBheWxvYWQsXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgaG9sZEdyb3VwUG9zaXRpb24gPSBudWxsO1xuICAgICAgICB9XG4gICAgICB9fVxuICAgIC8+XG4gICk7XG59XG5cbiJdLCJuYW1lcyI6WyJ1c2VFZmZlY3QiLCJ1c2VSZWYiLCJ1c2VTdGF0ZSIsIlNlbGVjdGlvbiIsIk1vdmVhYmxlIiwiZ2V0SWRGcm9tQ2xhc3NOYW1lIiwiZGlzcGF0Y2giLCJFRElUX09CSkVDVCIsIkxBWUVSX1NFTEVDVElPTiIsImVtcHR5U2VsZWN0aW9uIiwiZ2V0U2VsZWN0aW9uQnlJZHMiLCJnZXRUYXJnZXRCeUlkIiwidXNlU3RvcmUiLCJnZXRDdXJyZW50VGltZSIsInVzZUxheW91dFN0b3JlIiwiaG9sZEdyb3VwUG9zaXRpb24iLCJkcmFnU3RhcnRFbmQiLCJTY2VuZUludGVyYWN0aW9ucyIsInN0YXRlTWFuYWdlciIsInZpZXdlclJlZiIsInpvb20iLCJzaXplIiwidGFyZ2V0cyIsInNldFRhcmdldHMiLCJzZWxlY3Rpb24iLCJzZXRTZWxlY3Rpb24iLCJhY3RpdmVJZHMiLCJzZXRTdGF0ZSIsInRyYWNrSXRlbURldGFpbHNNYXAiLCJ0cmFja0l0ZW1zTWFwIiwicGxheWVyUmVmIiwic2V0U2NlbmVNb3ZlYWJsZVJlZiIsInNldEFjdGl2ZU1lbnVJdGVtIiwic2V0U2hvd01lbnVJdGVtIiwibW92ZWFibGVSZWYiLCJzZWxlY3Rpb25JbmZvIiwic2V0U2VsZWN0aW9uSW5mbyIsIlNOQVBfVEhSRVNIT0xEIiwiU05BUF9FREdFX1RIUkVTSE9MRCIsImFwcGx5U25hcCIsInZhbHVlIiwic25hcFBvaW50cyIsInRocmVzaG9sZCIsInBvaW50IiwiTWF0aCIsImFicyIsInVwZGF0ZVRhcmdldHMiLCJ0aW1lIiwiY3VycmVudFRpbWUiLCJnZXRTdGF0ZSIsInRhcmdldElkcyIsImZpbHRlciIsImlkIiwiZGlzcGxheSIsImZyb20iLCJ0byIsIm1hcCIsInNldFNlbGVjdGVkVGFyZ2V0cyIsInNlbEluZm8iLCJ0aW1lciIsInNldFRpbWVvdXQiLCJvblNlZWtlZCIsInYiLCJmcHMiLCJzZWVrZWRUaW1lIiwiZGV0YWlsIiwiZnJhbWUiLCJjdXJyZW50IiwiYWRkRXZlbnRMaXN0ZW5lciIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJjbGVhclRpbWVvdXQiLCJoYW5kbGVTZWxlY3Rpb24iLCJpZHMiLCJjb25zb2xlIiwibG9nIiwidXBkYXRlU3RhdGUiLCJ1cGRhdGVIaXN0b3J5Iiwia2luZCIsImxlbmd0aCIsInBheWxvYWQiLCJjdXJyZW50TWVudUl0ZW0iLCJhY3RpdmVNZW51SXRlbSIsImNvbnRhaW5lciIsImluZmluaXRlVmlld2VyIiwiZ2V0Q29udGFpbmVyIiwiYm91bmRDb250YWluZXIiLCJoaXRSYXRlIiwic2VsZWN0YWJsZVRhcmdldHMiLCJzZWxlY3RGcm9tSW5zaWRlIiwic2VsZWN0QnlDbGljayIsInRvZ2dsZUNvbnRpbnVlU2VsZWN0Iiwib24iLCJlIiwic2VsZWN0ZWQiLCJlbCIsImNsYXNzTmFtZSIsInRhcmdldCIsImlucHV0RXZlbnQiLCJpbmNsdWRlcyIsInN0b3AiLCJtb3ZlYWJsZSIsImlzTW92ZWFibGVFbGVtZW50IiwiaXNEcmFnU3RhcnQiLCJwcmV2ZW50RGVmYXVsdCIsImRyYWdTdGFydCIsImRlc3Ryb3kiLCJhY3RpdmVTZWxlY3Rpb25TdWJzY3JpcHRpb24iLCJzdWJzY3JpYmVUb0FjdGl2ZUlkcyIsIm5ld1N0YXRlIiwidW5zdWJzY3JpYmUiLCJ1cGRhdGVSZWN0IiwicmVmIiwicm90YXRpb25Qb3NpdGlvbiIsInJlbmRlckRpcmVjdGlvbnMiLCJjb250cm9scyIsImFibGVzIiwib3JpZ2luIiwib25EcmFnIiwiYmVmb3JlVHJhbnNsYXRlIiwidGFyZ2V0SWQiLCJ0cmFja0l0ZW0iLCJ0YXJnZXRXaWR0aCIsIm9mZnNldFdpZHRoIiwidGFyZ2V0SGVpZ2h0Iiwib2Zmc2V0SGVpZ2h0IiwibGVmdCIsInBhcnNlRmxvYXQiLCJkZXRhaWxzIiwidG9wIiwic25hcFBvaW50c1giLCJ3aWR0aCIsInNuYXBQb2ludHNZIiwiaGVpZ2h0Iiwic29tZSIsImNsYXNzTGlzdCIsImFkZCIsIk1vdXNlRXZlbnQiLCJuYXZpZ2F0b3IiLCJ2aWJyYXRlIiwicmVtb3ZlIiwic3R5bGUiLCJvbkRyYWdFbmQiLCJpc0RyYWciLCJvblNjYWxlIiwidHJhbnNmb3JtIiwiZGlyZWN0aW9uIiwieENvbnRyb2wiLCJ5Q29udHJvbCIsInNjYWxlUmVnZXgiLCJtYXRjaCIsInNjYWxlWCIsInNjYWxlWSIsInNwbGl0IiwidHJpbSIsIm1hdGNoMiIsIm5ld1NjYWxlWCIsIm5ld1NjYWxlWSIsImN1cnJlbnRXaWR0aCIsImNsaWVudFdpZHRoIiwiY3VycmVudEhlaWdodCIsImNsaWVudEhlaWdodCIsIm5ld1dpZHRoIiwibmV3SGVpZ2h0IiwiZGlmZlgiLCJuZXdMZWZ0IiwiZGlmZlkiLCJuZXdUb3AiLCJvblNjYWxlRW5kIiwib25Sb3RhdGUiLCJvblJvdGF0ZUVuZCIsIm9uRHJhZ0dyb3VwIiwiZXZlbnRzIiwiZ3JvdXBMZWZ0IiwiSW5maW5pdHkiLCJncm91cFRvcCIsImdyb3VwUmlnaHQiLCJncm91cEJvdHRvbSIsImkiLCJldmVudCIsIm1pbiIsIm1heCIsImdyb3VwV2lkdGgiLCJncm91cEhlaWdodCIsImJhc2VUcmFuc2xhdGUiLCJuZXdHcm91cExlZnQiLCJuZXdHcm91cFRvcCIsInNuYXBwZWRHcm91cExlZnQiLCJzbmFwcGVkR3JvdXBUb3AiLCJhZGp1c3RYIiwiYWRqdXN0WSIsImlzR3JvdXBTbmFwcGVkIiwib25SZXNpemUiLCJuZXh0V2lkdGgiLCJuZXh0SGVpZ2h0Iiwic2NhbGUiLCJhbmltYXRpb25EaXYiLCJmaXJzdEVsZW1lbnRDaGlsZCIsInRleHREaXYiLCJmb250U2l6ZSIsImdldENvbXB1dGVkU3R5bGUiLCJvblJlc2l6ZUVuZCIsIm9uRHJhZ0dyb3VwRW5kIiwiT2JqZWN0Iiwia2V5cyIsImZvckVhY2giLCJlbGVtZW50IiwiZG9jdW1lbnQiLCJxdWVyeVNlbGVjdG9yIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./features/editor/scene/interactions.tsx\n"));

/***/ })

});
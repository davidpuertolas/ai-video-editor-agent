"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/remotion";
exports.ids = ["vendor-chunks/remotion"];
exports.modules = {

/***/ "(ssr)/./node_modules/remotion/dist/esm/index.mjs":
/*!**************************************************!*\
  !*** ./node_modules/remotion/dist/esm/index.mjs ***!
  \**************************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AbsoluteFill: () => (/* binding */ AbsoluteFill),\n/* harmony export */   Artifact: () => (/* binding */ Artifact),\n/* harmony export */   Audio: () => (/* binding */ Audio),\n/* harmony export */   Composition: () => (/* binding */ Composition),\n/* harmony export */   Config: () => (/* binding */ Config),\n/* harmony export */   Easing: () => (/* binding */ Easing),\n/* harmony export */   Experimental: () => (/* binding */ Experimental),\n/* harmony export */   Folder: () => (/* binding */ Folder),\n/* harmony export */   FolderContext: () => (/* binding */ FolderContext),\n/* harmony export */   Freeze: () => (/* binding */ Freeze),\n/* harmony export */   IFrame: () => (/* binding */ IFrame),\n/* harmony export */   Img: () => (/* binding */ Img),\n/* harmony export */   Internals: () => (/* binding */ Internals),\n/* harmony export */   Loop: () => (/* binding */ Loop),\n/* harmony export */   OffthreadVideo: () => (/* binding */ OffthreadVideo),\n/* harmony export */   Sequence: () => (/* binding */ Sequence),\n/* harmony export */   Series: () => (/* binding */ Series),\n/* harmony export */   Still: () => (/* binding */ Still),\n/* harmony export */   VERSION: () => (/* binding */ VERSION),\n/* harmony export */   Video: () => (/* binding */ Video),\n/* harmony export */   cancelRender: () => (/* binding */ cancelRender),\n/* harmony export */   continueRender: () => (/* binding */ continueRender),\n/* harmony export */   delayRender: () => (/* binding */ delayRender),\n/* harmony export */   getInputProps: () => (/* binding */ getInputProps),\n/* harmony export */   getRemotionEnvironment: () => (/* binding */ getRemotionEnvironment),\n/* harmony export */   getStaticFiles: () => (/* binding */ getStaticFiles),\n/* harmony export */   interpolate: () => (/* binding */ interpolate),\n/* harmony export */   interpolateColors: () => (/* binding */ interpolateColors),\n/* harmony export */   measureSpring: () => (/* binding */ measureSpring),\n/* harmony export */   prefetch: () => (/* binding */ prefetch),\n/* harmony export */   random: () => (/* binding */ random),\n/* harmony export */   registerRoot: () => (/* binding */ registerRoot),\n/* harmony export */   spring: () => (/* binding */ spring),\n/* harmony export */   staticFile: () => (/* binding */ staticFile),\n/* harmony export */   useBufferState: () => (/* binding */ useBufferState),\n/* harmony export */   useCurrentFrame: () => (/* binding */ useCurrentFrame),\n/* harmony export */   useCurrentScale: () => (/* binding */ useCurrentScale),\n/* harmony export */   useVideoConfig: () => (/* binding */ useVideoConfig),\n/* harmony export */   watchStaticFile: () => (/* binding */ watchStaticFile)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react/jsx-runtime */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react-jsx-runtime.js\");\n/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react-dom */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react-dom.js\");\nvar __defProp = Object.defineProperty;\nvar __export = (target, all)=>{\n    for(var name in all)__defProp(target, name, {\n        get: all[name],\n        enumerable: true,\n        configurable: true,\n        set: (newValue)=>all[name] = ()=>newValue\n    });\n};\n// src/_check-rsc.ts\n\nif (typeof react__WEBPACK_IMPORTED_MODULE_0__.createContext !== \"function\") {\n    const err = [\n        'Remotion requires React.createContext, but it is \"undefined\".',\n        'If you are in a React Server Component, turn it into a client component by adding \"use client\" at the top of the file.',\n        \"\",\n        \"Before:\",\n        '  import {useCurrentFrame} from \"remotion\";',\n        \"\",\n        \"After:\",\n        '  \"use client\";',\n        '  import {useCurrentFrame} from \"remotion\";'\n    ];\n    throw new Error(err.join(\"\\n\"));\n}\n// src/Clipper.tsx\n\n// src/NativeLayers.tsx\n\n\nvar NativeLayersContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)({\n    setClipRegion: ()=>{\n        throw new Error(\"NativeLayers not set\");\n    },\n    clipRegion: null\n});\nvar NativeLayersProvider = ({ children })=>{\n    const [clipRegion, setClipRegion] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const context = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        return {\n            setClipRegion,\n            clipRegion\n        };\n    }, [\n        clipRegion,\n        setClipRegion\n    ]);\n    if (false) {}\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(NativeLayersContext.Provider, {\n        value: context,\n        children\n    });\n};\n// src/Clipper.tsx\nvar Clipper = ({ height, width, x, y })=>{\n    const { setClipRegion } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(NativeLayersContext);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        setClipRegion((c)=>{\n            if (c === \"hide\") {\n                throw new Error(\"Cannot render <Clipper>, because another <Null> is already rendered\");\n            }\n            if (c === null) {\n                return {\n                    height,\n                    width,\n                    x,\n                    y\n                };\n            }\n            throw new Error(\"Cannot render <Clipper>, because another component clipping the region was already rendered (most likely <Clipper>)\");\n        });\n        return ()=>{\n            setClipRegion(null);\n        };\n    }, [\n        height,\n        setClipRegion,\n        width,\n        x,\n        y\n    ]);\n    return null;\n};\n// src/enable-sequence-stack-traces.ts\n\n// src/get-remotion-environment.ts\nfunction getNodeEnvString() {\n    return [\n        \"NOD\",\n        \"E_EN\",\n        \"V\"\n    ].join(\"\");\n}\nvar getEnvString = ()=>{\n    return [\n        \"e\",\n        \"nv\"\n    ].join(\"\");\n};\nvar getRemotionEnvironment = ()=>{\n    const isPlayer =  false && 0;\n    const isRendering =  false && (0);\n    const isStudio =  false && 0;\n    return {\n        isStudio,\n        isRendering,\n        isPlayer\n    };\n};\n// src/enable-sequence-stack-traces.ts\nvar originalCreateElement = react__WEBPACK_IMPORTED_MODULE_0__.createElement;\nvar componentsToAddStacksTo = [];\nvar enableSequenceStackTraces = ()=>{\n    if (!getRemotionEnvironment().isStudio) {\n        return;\n    }\n    const proxy = new Proxy(originalCreateElement, {\n        apply (target, thisArg, argArray) {\n            if (componentsToAddStacksTo.includes(argArray[0])) {\n                const [first, props, ...rest] = argArray;\n                const newProps = {\n                    ...props ?? {},\n                    stack: new Error().stack\n                };\n                return Reflect.apply(target, thisArg, [\n                    first,\n                    newProps,\n                    ...rest\n                ]);\n            }\n            return Reflect.apply(target, thisArg, argArray);\n        }\n    });\n    react__WEBPACK_IMPORTED_MODULE_0__.createElement = proxy;\n};\nvar addSequenceStackTraces = (component)=>{\n    componentsToAddStacksTo.push(component);\n    enableSequenceStackTraces();\n};\n// src/is-player.tsx\n\n\nvar IsPlayerContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)(false);\nvar IsPlayerContextProvider = ({ children })=>{\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(IsPlayerContext.Provider, {\n        value: true,\n        children\n    });\n};\nvar useIsPlayer = ()=>{\n    return (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(IsPlayerContext);\n};\n// src/truthy.ts\nfunction truthy(value) {\n    return Boolean(value);\n}\n// src/version.ts\nvar VERSION = \"4.0.221\";\n// src/multiple-versions-warning.ts\nvar checkMultipleRemotionVersions = ()=>{\n    if (typeof globalThis === \"undefined\") {\n        return;\n    }\n    const alreadyImported = globalThis.remotion_imported ||  false && 0;\n    if (alreadyImported) {\n        if (alreadyImported === VERSION) {\n            return;\n        }\n        throw new TypeError(`\\uD83D\\uDEA8 Multiple versions of Remotion detected: ${[\n            VERSION,\n            typeof alreadyImported === \"string\" ? alreadyImported : \"an older version\"\n        ].filter(truthy).join(\" and \")}. This will cause things to break in an unexpected way.\\nCheck that all your Remotion packages are on the same version. If your dependencies depend on Remotion, make them peer dependencies. You can also run \\`npx remotion versions\\` from your terminal to see which versions are mismatching.`);\n    }\n    globalThis.remotion_imported = VERSION;\n    if (false) {}\n};\n// src/Null.tsx\n\nvar Null = ()=>{\n    const { setClipRegion } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(NativeLayersContext);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        setClipRegion((c)=>{\n            if (c === null) {\n                return \"hide\";\n            }\n            if (c === \"hide\") {\n                return \"hide\";\n            }\n            throw new Error(\"Cannot render <Null>, because another component clipping the region was already rendered (most likely <Clipper>)\");\n        });\n        return ()=>{\n            setClipRegion(null);\n        };\n    }, [\n        setClipRegion\n    ]);\n    return null;\n};\n// src/Sequence.tsx\n\n// src/AbsoluteFill.tsx\n\n\nvar AbsoluteFillRefForwarding = (props, ref)=>{\n    const { style, ...other } = props;\n    const actualStyle = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        return {\n            position: \"absolute\",\n            top: 0,\n            left: 0,\n            right: 0,\n            bottom: 0,\n            width: \"100%\",\n            height: \"100%\",\n            display: \"flex\",\n            flexDirection: \"column\",\n            ...style\n        };\n    }, [\n        style\n    ]);\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"div\", {\n        ref,\n        style: actualStyle,\n        ...other\n    });\n};\nvar AbsoluteFill = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(AbsoluteFillRefForwarding);\n// src/SequenceContext.tsx\n\nvar SequenceContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)(null);\n// src/SequenceManager.tsx\n\n\nvar SequenceManager = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createContext({\n    registerSequence: ()=>{\n        throw new Error(\"SequenceManagerContext not initialized\");\n    },\n    unregisterSequence: ()=>{\n        throw new Error(\"SequenceManagerContext not initialized\");\n    },\n    sequences: []\n});\nvar SequenceVisibilityToggleContext = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createContext({\n    hidden: {},\n    setHidden: ()=>{\n        throw new Error(\"SequenceVisibilityToggle not initialized\");\n    }\n});\nvar SequenceManagerProvider = ({ children })=>{\n    const [sequences, setSequences] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n    const [hidden, setHidden] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)({});\n    const registerSequence = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((seq)=>{\n        setSequences((seqs)=>{\n            return [\n                ...seqs,\n                seq\n            ];\n        });\n    }, []);\n    const unregisterSequence = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((seq)=>{\n        setSequences((seqs)=>seqs.filter((s)=>s.id !== seq));\n    }, []);\n    const sequenceContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        return {\n            registerSequence,\n            sequences,\n            unregisterSequence\n        };\n    }, [\n        registerSequence,\n        sequences,\n        unregisterSequence\n    ]);\n    const hiddenContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        return {\n            hidden,\n            setHidden\n        };\n    }, [\n        hidden\n    ]);\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(SequenceManager.Provider, {\n        value: sequenceContext,\n        children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(SequenceVisibilityToggleContext.Provider, {\n            value: hiddenContext,\n            children\n        })\n    });\n};\n// src/nonce.ts\n\nvar NonceContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)({\n    getNonce: ()=>0,\n    fastRefreshes: 0\n});\nvar useNonce = ()=>{\n    const context = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(NonceContext);\n    const [nonce, setNonce] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(()=>context.getNonce());\n    const lastContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(context);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (lastContext.current === context) {\n            return;\n        }\n        lastContext.current = context;\n        setNonce(context.getNonce);\n    }, [\n        context\n    ]);\n    return nonce;\n};\n// src/timeline-position-state.ts\nvar exports_timeline_position_state = {};\n__export(exports_timeline_position_state, {\n    useTimelineSetFrame: ()=>useTimelineSetFrame,\n    useTimelinePosition: ()=>useTimelinePosition,\n    usePlayingState: ()=>usePlayingState,\n    persistCurrentFrame: ()=>persistCurrentFrame,\n    getInitialFrameState: ()=>getInitialFrameState,\n    getFrameForComposition: ()=>getFrameForComposition,\n    TimelineContext: ()=>TimelineContext,\n    SetTimelineContext: ()=>SetTimelineContext\n});\n\n// src/use-video.ts\n\n// src/CompositionManagerContext.tsx\n\nvar CompositionManager = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)({\n    compositions: [],\n    registerComposition: ()=>{\n        return;\n    },\n    unregisterComposition: ()=>{\n        return;\n    },\n    registerFolder: ()=>{\n        return;\n    },\n    unregisterFolder: ()=>{\n        return;\n    },\n    setCurrentCompositionMetadata: ()=>{\n        return;\n    },\n    updateCompositionDefaultProps: ()=>{\n        return;\n    },\n    folders: [],\n    currentCompositionMetadata: null,\n    canvasContent: null,\n    setCanvasContent: ()=>{\n        return;\n    }\n});\n// src/ResolveCompositionConfig.tsx\n\n// src/EditorProps.tsx\n\n\nvar EditorPropsContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)({\n    props: {},\n    updateProps: ()=>{\n        throw new Error(\"Not implemented\");\n    },\n    resetUnsaved: ()=>{\n        throw new Error(\"Not implemented\");\n    }\n});\nvar editorPropsProviderRef = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createRef();\nvar EditorPropsProvider = ({ children })=>{\n    const [props, setProps] = react__WEBPACK_IMPORTED_MODULE_0__.useState({});\n    const updateProps = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(({ defaultProps, id, newProps })=>{\n        setProps((prev)=>{\n            return {\n                ...prev,\n                [id]: typeof newProps === \"function\" ? newProps(prev[id] ?? defaultProps) : newProps\n            };\n        });\n    }, []);\n    const resetUnsaved = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        setProps({});\n    }, []);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useImperativeHandle)(editorPropsProviderRef, ()=>{\n        return {\n            getProps: ()=>props,\n            setProps\n        };\n    }, [\n        props\n    ]);\n    const ctx = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        return {\n            props,\n            updateProps,\n            resetUnsaved\n        };\n    }, [\n        props,\n        resetUnsaved,\n        updateProps\n    ]);\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(EditorPropsContext.Provider, {\n        value: ctx,\n        children\n    });\n};\n// src/static-file.ts\nvar problematicCharacters = {\n    \"%3A\": \":\",\n    \"%2F\": \"/\",\n    \"%3F\": \"?\",\n    \"%23\": \"#\",\n    \"%5B\": \"[\",\n    \"%5D\": \"]\",\n    \"%40\": \"@\",\n    \"%21\": \"!\",\n    \"%24\": \"$\",\n    \"%26\": \"&\",\n    \"%27\": \"'\",\n    \"%28\": \"(\",\n    \"%29\": \")\",\n    \"%2A\": \"*\",\n    \"%2B\": \"+\",\n    \"%2C\": \",\",\n    \"%3B\": \";\"\n};\nvar didWarn = {};\nvar warnOnce = (message)=>{\n    if (didWarn[message]) {\n        return;\n    }\n    console.warn(message);\n    didWarn[message] = true;\n};\nvar includesHexOfUnsafeChar = (path)=>{\n    for (const key of Object.keys(problematicCharacters)){\n        if (path.includes(key)) {\n            return {\n                containsHex: true,\n                hexCode: key\n            };\n        }\n    }\n    return {\n        containsHex: false\n    };\n};\nvar trimLeadingSlash = (path)=>{\n    if (path.startsWith(\"/\")) {\n        return trimLeadingSlash(path.substring(1));\n    }\n    return path;\n};\nvar inner = (path)=>{\n    if (false) {}\n    return `/${trimLeadingSlash(path)}`;\n};\nvar encodeBySplitting = (path)=>{\n    const splitBySlash = path.split(\"/\");\n    const encodedArray = splitBySlash.map((element)=>{\n        return encodeURIComponent(element);\n    });\n    const merged = encodedArray.join(\"/\");\n    return merged;\n};\nvar staticFile = (path)=>{\n    if (path.startsWith(\"http://\") || path.startsWith(\"https://\")) {\n        throw new TypeError(`staticFile() does not support remote URLs - got \"${path}\". Instead, pass the URL without wrapping it in staticFile(). See: https://remotion.dev/docs/staticfile-remote-urls`);\n    }\n    if (path.startsWith(\"..\") || path.startsWith(\"./\")) {\n        throw new TypeError(`staticFile() does not support relative paths - got \"${path}\". Instead, pass the name of a file that is inside the public/ folder. See: https://remotion.dev/docs/staticfile-relative-paths`);\n    }\n    if (path.startsWith(\"/Users\") || path.startsWith(\"/home\") || path.startsWith(\"/tmp\") || path.startsWith(\"/etc\") || path.startsWith(\"/opt\") || path.startsWith(\"/var\") || path.startsWith(\"C:\") || path.startsWith(\"D:\") || path.startsWith(\"E:\")) {\n        throw new TypeError(`staticFile() does not support absolute paths - got \"${path}\". Instead, pass the name of a file that is inside the public/ folder. See: https://remotion.dev/docs/staticfile-relative-paths`);\n    }\n    if (path.startsWith(\"public/\")) {\n        throw new TypeError(`Do not include the public/ prefix when using staticFile() - got \"${path}\". See: https://remotion.dev/docs/staticfile-relative-paths`);\n    }\n    const includesHex = includesHexOfUnsafeChar(path);\n    if (includesHex.containsHex) {\n        warnOnce(`WARNING: You seem to pass an already encoded path (path contains ${includesHex.hexCode}). Since Remotion 4.0, the encoding is done by staticFile() itself. You may want to remove a encodeURIComponent() wrapping.`);\n    }\n    const preprocessed = encodeBySplitting(path);\n    const preparsed = inner(preprocessed);\n    if (!preparsed.startsWith(\"/\")) {\n        return `/${preparsed}`;\n    }\n    return preparsed;\n};\n// src/input-props-serialization.ts\nvar DATE_TOKEN = \"remotion-date:\";\nvar FILE_TOKEN = \"remotion-file:\";\nvar serializeJSONWithDate = ({ data, indent, staticBase })=>{\n    let customDateUsed = false;\n    let customFileUsed = false;\n    let mapUsed = false;\n    let setUsed = false;\n    try {\n        const serializedString = JSON.stringify(data, function(key, value) {\n            const item = this[key];\n            if (item instanceof Date) {\n                customDateUsed = true;\n                return `${DATE_TOKEN}${item.toISOString()}`;\n            }\n            if (item instanceof Map) {\n                mapUsed = true;\n                return value;\n            }\n            if (item instanceof Set) {\n                setUsed = true;\n                return value;\n            }\n            if (typeof item === \"string\" && staticBase !== null && item.startsWith(staticBase)) {\n                customFileUsed = true;\n                return `${FILE_TOKEN}${item.replace(staticBase + \"/\", \"\")}`;\n            }\n            return value;\n        }, indent);\n        return {\n            serializedString,\n            customDateUsed,\n            customFileUsed,\n            mapUsed,\n            setUsed\n        };\n    } catch (err) {\n        throw new Error(\"Could not serialize the passed input props to JSON: \" + err.message);\n    }\n};\nvar deserializeJSONWithCustomFields = (data)=>{\n    return JSON.parse(data, (_, value)=>{\n        if (typeof value === \"string\" && value.startsWith(DATE_TOKEN)) {\n            return new Date(value.replace(DATE_TOKEN, \"\"));\n        }\n        if (typeof value === \"string\" && value.startsWith(FILE_TOKEN)) {\n            return staticFile(value.replace(FILE_TOKEN, \"\"));\n        }\n        return value;\n    });\n};\nvar serializeThenDeserializeInStudio = (props)=>{\n    if (getRemotionEnvironment().isStudio) {\n        return deserializeJSONWithCustomFields(serializeJSONWithDate({\n            data: props,\n            indent: 2,\n            staticBase: window.remotion_staticBase\n        }).serializedString);\n    }\n    return props;\n};\n// src/config/input-props.ts\nvar didWarnSSRImport = false;\nvar warnOnceSSRImport = ()=>{\n    if (didWarnSSRImport) {\n        return;\n    }\n    didWarnSSRImport = true;\n    console.warn(\"Called `getInputProps()` on the server. This function is not available server-side and has returned an empty object.\");\n    console.warn(\"To hide this warning, don't call this function on the server:\");\n    console.warn(\"  typeof window === 'undefined' ? {} : getInputProps()\");\n};\nvar getInputProps = ()=>{\n    if (true) {\n        warnOnceSSRImport();\n        return {};\n    }\n    if (getRemotionEnvironment().isPlayer) {\n        throw new Error(\"You cannot call `getInputProps()` from a <Player>. Instead, the props are available as React props from component that you passed as `component` prop.\");\n    }\n    const param = window.remotion_inputProps;\n    if (!param) {\n        return {};\n    }\n    const parsed = deserializeJSONWithCustomFields(param);\n    return parsed;\n};\n// src/codec.ts\nvar validCodecs = [\n    \"h264\",\n    \"h265\",\n    \"vp8\",\n    \"vp9\",\n    \"mp3\",\n    \"aac\",\n    \"wav\",\n    \"prores\",\n    \"h264-mkv\",\n    \"h264-ts\",\n    \"gif\"\n];\n// src/validation/validate-default-codec.ts\nfunction validateDefaultCodec(defaultCodec, location) {\n    if (typeof defaultCodec === \"undefined\") {\n        return;\n    }\n    if (typeof defaultCodec !== \"string\") {\n        throw new TypeError(`The \"defaultCodec\" prop ${location} must be a string, but you passed a value of type ${typeof defaultCodec}.`);\n    }\n    if (!validCodecs.includes(defaultCodec)) {\n        throw new Error(`The \"defaultCodec\" prop ${location} must be one of ${validCodecs.join(\", \")}, but you passed ${defaultCodec}.`);\n    }\n}\n// src/validation/validate-dimensions.ts\nfunction validateDimension(amount, nameOfProp, location) {\n    if (typeof amount !== \"number\") {\n        throw new Error(`The \"${nameOfProp}\" prop ${location} must be a number, but you passed a value of type ${typeof amount}`);\n    }\n    if (isNaN(amount)) {\n        throw new TypeError(`The \"${nameOfProp}\" prop ${location} must not be NaN, but is NaN.`);\n    }\n    if (!Number.isFinite(amount)) {\n        throw new TypeError(`The \"${nameOfProp}\" prop ${location} must be finite, but is ${amount}.`);\n    }\n    if (amount % 1 !== 0) {\n        throw new TypeError(`The \"${nameOfProp}\" prop ${location} must be an integer, but is ${amount}.`);\n    }\n    if (amount <= 0) {\n        throw new TypeError(`The \"${nameOfProp}\" prop ${location} must be positive, but got ${amount}.`);\n    }\n}\n// src/validation/validate-duration-in-frames.ts\nfunction validateDurationInFrames(durationInFrames, options) {\n    const { allowFloats, component } = options;\n    if (typeof durationInFrames === \"undefined\") {\n        throw new Error(`The \"durationInFrames\" prop ${component} is missing.`);\n    }\n    if (typeof durationInFrames !== \"number\") {\n        throw new Error(`The \"durationInFrames\" prop ${component} must be a number, but you passed a value of type ${typeof durationInFrames}`);\n    }\n    if (durationInFrames <= 0) {\n        throw new TypeError(`The \"durationInFrames\" prop ${component} must be positive, but got ${durationInFrames}.`);\n    }\n    if (!allowFloats && durationInFrames % 1 !== 0) {\n        throw new TypeError(`The \"durationInFrames\" prop ${component} must be an integer, but got ${durationInFrames}.`);\n    }\n    if (!Number.isFinite(durationInFrames)) {\n        throw new TypeError(`The \"durationInFrames\" prop ${component} must be finite, but got ${durationInFrames}.`);\n    }\n}\n// src/validation/validate-fps.ts\nfunction validateFps(fps, location, isGif) {\n    if (typeof fps !== \"number\") {\n        throw new Error(`\"fps\" must be a number, but you passed a value of type ${typeof fps} ${location}`);\n    }\n    if (!Number.isFinite(fps)) {\n        throw new Error(`\"fps\" must be a finite, but you passed ${fps} ${location}`);\n    }\n    if (isNaN(fps)) {\n        throw new Error(`\"fps\" must not be NaN, but got ${fps} ${location}`);\n    }\n    if (fps <= 0) {\n        throw new TypeError(`\"fps\" must be positive, but got ${fps} ${location}`);\n    }\n    if (isGif && fps > 50) {\n        throw new TypeError(`The FPS for a GIF cannot be higher than 50. Use the --every-nth-frame option to lower the FPS: https://remotion.dev/docs/render-as-gif`);\n    }\n}\n// src/resolve-video-config.ts\nvar validateCalculated = ({ calculated, compositionId, compositionFps, compositionHeight, compositionWidth, compositionDurationInFrames })=>{\n    const calculateMetadataErrorLocation = `calculated by calculateMetadata() for the composition \"${compositionId}\"`;\n    const defaultErrorLocation = `of the \"<Composition />\" component with the id \"${compositionId}\"`;\n    const width = calculated?.width ?? compositionWidth ?? undefined;\n    validateDimension(width, \"width\", calculated?.width ? calculateMetadataErrorLocation : defaultErrorLocation);\n    const height = calculated?.height ?? compositionHeight ?? undefined;\n    validateDimension(height, \"height\", calculated?.height ? calculateMetadataErrorLocation : defaultErrorLocation);\n    const fps = calculated?.fps ?? compositionFps ?? null;\n    validateFps(fps, calculated?.fps ? calculateMetadataErrorLocation : defaultErrorLocation, false);\n    const durationInFrames = calculated?.durationInFrames ?? compositionDurationInFrames ?? null;\n    validateDurationInFrames(durationInFrames, {\n        allowFloats: false,\n        component: `of the \"<Composition />\" component with the id \"${compositionId}\"`\n    });\n    const defaultCodec = calculated?.defaultCodec;\n    validateDefaultCodec(defaultCodec, calculateMetadataErrorLocation);\n    return {\n        width,\n        height,\n        fps,\n        durationInFrames,\n        defaultCodec\n    };\n};\nvar resolveVideoConfig = ({ calculateMetadata, signal, defaultProps, originalProps, compositionId, compositionDurationInFrames, compositionFps, compositionHeight, compositionWidth })=>{\n    const calculatedProm = calculateMetadata ? calculateMetadata({\n        defaultProps,\n        props: originalProps,\n        abortSignal: signal,\n        compositionId\n    }) : null;\n    if (calculatedProm !== null && typeof calculatedProm === \"object\" && \"then\" in calculatedProm) {\n        return calculatedProm.then((c)=>{\n            const { height, width, durationInFrames, fps, defaultCodec } = validateCalculated({\n                calculated: c,\n                compositionDurationInFrames,\n                compositionFps,\n                compositionHeight,\n                compositionWidth,\n                compositionId\n            });\n            return {\n                width,\n                height,\n                fps,\n                durationInFrames,\n                id: compositionId,\n                defaultProps: serializeThenDeserializeInStudio(defaultProps),\n                props: serializeThenDeserializeInStudio(c.props ?? originalProps),\n                defaultCodec: defaultCodec ?? null\n            };\n        });\n    }\n    const data = validateCalculated({\n        calculated: calculatedProm,\n        compositionDurationInFrames,\n        compositionFps,\n        compositionHeight,\n        compositionWidth,\n        compositionId\n    });\n    if (calculatedProm === null) {\n        return {\n            ...data,\n            id: compositionId,\n            defaultProps: serializeThenDeserializeInStudio(defaultProps ?? {}),\n            props: serializeThenDeserializeInStudio(originalProps),\n            defaultCodec: null\n        };\n    }\n    return {\n        ...data,\n        id: compositionId,\n        defaultProps: serializeThenDeserializeInStudio(defaultProps ?? {}),\n        props: serializeThenDeserializeInStudio(calculatedProm.props ?? originalProps),\n        defaultCodec: calculatedProm.defaultCodec ?? null\n    };\n};\nvar resolveVideoConfigOrCatch = (params)=>{\n    try {\n        const promiseOrReturnValue = resolveVideoConfig(params);\n        return {\n            type: \"success\",\n            result: promiseOrReturnValue\n        };\n    } catch (err) {\n        return {\n            type: \"error\",\n            error: err\n        };\n    }\n};\n// src/ResolveCompositionConfig.tsx\n\nvar ResolveCompositionContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)(null);\nvar resolveCompositionsRef = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createRef)();\nvar needsResolution = (composition)=>{\n    return Boolean(composition.calculateMetadata);\n};\nvar PROPS_UPDATED_EXTERNALLY = \"remotion.propsUpdatedExternally\";\nvar ResolveCompositionConfig = ({ children })=>{\n    const [currentRenderModalComposition, setCurrentRenderModalComposition] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const { compositions, canvasContent, currentCompositionMetadata } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(CompositionManager);\n    const { fastRefreshes } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(NonceContext);\n    const selectedComposition = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        return compositions.find((c)=>canvasContent && canvasContent.type === \"composition\" && canvasContent.compositionId === c.id);\n    }, [\n        canvasContent,\n        compositions\n    ]);\n    const renderModalComposition = compositions.find((c)=>c.id === currentRenderModalComposition);\n    const { props: allEditorProps } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(EditorPropsContext);\n    const inputProps = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        return  true ? {} : 0;\n    }, []);\n    const [resolvedConfigs, setResolvedConfigs] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)({});\n    const selectedEditorProps = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        return selectedComposition ? allEditorProps[selectedComposition.id] ?? {} : {};\n    }, [\n        allEditorProps,\n        selectedComposition\n    ]);\n    const renderModalProps = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        return renderModalComposition ? allEditorProps[renderModalComposition.id] ?? {} : {};\n    }, [\n        allEditorProps,\n        renderModalComposition\n    ]);\n    const hasResolution = Boolean(currentCompositionMetadata);\n    const doResolution = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(({ calculateMetadata, combinedProps, compositionDurationInFrames, compositionFps, compositionHeight, compositionId, compositionWidth, defaultProps })=>{\n        const controller = new AbortController;\n        if (hasResolution) {\n            return controller;\n        }\n        const { signal } = controller;\n        const result = resolveVideoConfigOrCatch({\n            compositionId,\n            calculateMetadata,\n            originalProps: combinedProps,\n            signal,\n            defaultProps,\n            compositionDurationInFrames,\n            compositionFps,\n            compositionHeight,\n            compositionWidth\n        });\n        if (result.type === \"error\") {\n            setResolvedConfigs((r)=>({\n                    ...r,\n                    [compositionId]: {\n                        type: \"error\",\n                        error: result.error\n                    }\n                }));\n            return controller;\n        }\n        const promOrNot = result.result;\n        if (typeof promOrNot === \"object\" && \"then\" in promOrNot) {\n            setResolvedConfigs((r)=>{\n                const prev = r[compositionId];\n                if (prev?.type === \"success\" || prev?.type === \"success-and-refreshing\") {\n                    return {\n                        ...r,\n                        [compositionId]: {\n                            type: \"success-and-refreshing\",\n                            result: prev.result\n                        }\n                    };\n                }\n                return {\n                    ...r,\n                    [compositionId]: {\n                        type: \"loading\"\n                    }\n                };\n            });\n            promOrNot.then((c)=>{\n                if (controller.signal.aborted) {\n                    return;\n                }\n                setResolvedConfigs((r)=>({\n                        ...r,\n                        [compositionId]: {\n                            type: \"success\",\n                            result: c\n                        }\n                    }));\n            }).catch((err)=>{\n                if (controller.signal.aborted) {\n                    return;\n                }\n                setResolvedConfigs((r)=>({\n                        ...r,\n                        [compositionId]: {\n                            type: \"error\",\n                            error: err\n                        }\n                    }));\n            });\n        } else {\n            setResolvedConfigs((r)=>({\n                    ...r,\n                    [compositionId]: {\n                        type: \"success\",\n                        result: promOrNot\n                    }\n                }));\n        }\n        return controller;\n    }, [\n        hasResolution\n    ]);\n    const currentComposition = canvasContent?.type === \"composition\" ? canvasContent.compositionId : null;\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useImperativeHandle)(resolveCompositionsRef, ()=>{\n        return {\n            setCurrentRenderModalComposition: (id)=>{\n                setCurrentRenderModalComposition(id);\n            },\n            reloadCurrentlySelectedComposition: ()=>{\n                if (!currentComposition) {\n                    return;\n                }\n                const composition = compositions.find((c)=>c.id === currentComposition);\n                if (!composition) {\n                    throw new Error(`Could not find composition with id ${currentComposition}`);\n                }\n                const editorProps = allEditorProps[currentComposition] ?? {};\n                const defaultProps = {\n                    ...composition.defaultProps ?? {},\n                    ...editorProps ?? {}\n                };\n                const props = {\n                    ...defaultProps,\n                    ...inputProps ?? {}\n                };\n                doResolution({\n                    defaultProps,\n                    calculateMetadata: composition.calculateMetadata,\n                    combinedProps: props,\n                    compositionDurationInFrames: composition.durationInFrames ?? null,\n                    compositionFps: composition.fps ?? null,\n                    compositionHeight: composition.height ?? null,\n                    compositionWidth: composition.width ?? null,\n                    compositionId: composition.id\n                });\n            }\n        };\n    }, [\n        allEditorProps,\n        compositions,\n        currentComposition,\n        doResolution,\n        inputProps\n    ]);\n    const isTheSame = selectedComposition?.id === renderModalComposition?.id;\n    const currentDefaultProps = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        return {\n            ...selectedComposition?.defaultProps ?? {},\n            ...selectedEditorProps ?? {}\n        };\n    }, [\n        selectedComposition?.defaultProps,\n        selectedEditorProps\n    ]);\n    const originalProps = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        return {\n            ...currentDefaultProps,\n            ...inputProps ?? {}\n        };\n    }, [\n        currentDefaultProps,\n        inputProps\n    ]);\n    const canResolve = selectedComposition && needsResolution(selectedComposition);\n    const shouldIgnoreUpdate =  false && 0;\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (shouldIgnoreUpdate) {\n            return;\n        }\n        if (canResolve) {\n            const controller = doResolution({\n                calculateMetadata: selectedComposition.calculateMetadata,\n                combinedProps: originalProps,\n                compositionDurationInFrames: selectedComposition.durationInFrames ?? null,\n                compositionFps: selectedComposition.fps ?? null,\n                compositionHeight: selectedComposition.height ?? null,\n                compositionWidth: selectedComposition.width ?? null,\n                defaultProps: currentDefaultProps,\n                compositionId: selectedComposition.id\n            });\n            return ()=>{\n                controller.abort();\n            };\n        }\n    }, [\n        canResolve,\n        currentDefaultProps,\n        doResolution,\n        originalProps,\n        selectedComposition?.calculateMetadata,\n        selectedComposition?.durationInFrames,\n        selectedComposition?.fps,\n        selectedComposition?.height,\n        selectedComposition?.id,\n        selectedComposition?.width,\n        shouldIgnoreUpdate\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (shouldIgnoreUpdate) {\n            return;\n        }\n        window.dispatchEvent(new CustomEvent(\"remotion.propsUpdatedExternally\"));\n    }, [\n        fastRefreshes\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (renderModalComposition && !isTheSame) {\n            const combinedProps = {\n                ...renderModalComposition.defaultProps ?? {},\n                ...renderModalProps ?? {},\n                ...inputProps ?? {}\n            };\n            const controller = doResolution({\n                calculateMetadata: renderModalComposition.calculateMetadata,\n                compositionDurationInFrames: renderModalComposition.durationInFrames ?? null,\n                compositionFps: renderModalComposition.fps ?? null,\n                compositionHeight: renderModalComposition.height ?? null,\n                compositionId: renderModalComposition.id,\n                compositionWidth: renderModalComposition.width ?? null,\n                defaultProps: currentDefaultProps,\n                combinedProps\n            });\n            return ()=>{\n                controller.abort();\n            };\n        }\n    }, [\n        currentDefaultProps,\n        doResolution,\n        inputProps,\n        isTheSame,\n        renderModalComposition,\n        renderModalProps\n    ]);\n    const resolvedConfigsIncludingStaticOnes = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        const staticComps = compositions.filter((c)=>{\n            return c.calculateMetadata === null;\n        });\n        return {\n            ...resolvedConfigs,\n            ...staticComps.reduce((acc, curr)=>{\n                return {\n                    ...acc,\n                    [curr.id]: {\n                        type: \"success\",\n                        result: {\n                            ...curr,\n                            defaultProps: curr.defaultProps ?? {}\n                        }\n                    }\n                };\n            }, {})\n        };\n    }, [\n        compositions,\n        resolvedConfigs\n    ]);\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(ResolveCompositionContext.Provider, {\n        value: resolvedConfigsIncludingStaticOnes,\n        children\n    });\n};\nvar useResolvedVideoConfig = (preferredCompositionId)=>{\n    const context = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(ResolveCompositionContext);\n    const { props: allEditorProps } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(EditorPropsContext);\n    const { compositions, canvasContent, currentCompositionMetadata } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(CompositionManager);\n    const currentComposition = canvasContent?.type === \"composition\" ? canvasContent.compositionId : null;\n    const compositionId = preferredCompositionId ?? currentComposition;\n    const composition = compositions.find((c)=>c.id === compositionId);\n    const selectedEditorProps = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        return composition ? allEditorProps[composition.id] ?? {} : {};\n    }, [\n        allEditorProps,\n        composition\n    ]);\n    return (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        if (!composition) {\n            return null;\n        }\n        if (currentCompositionMetadata) {\n            return {\n                type: \"success\",\n                result: {\n                    ...currentCompositionMetadata,\n                    id: composition.id,\n                    props: currentCompositionMetadata.props,\n                    defaultProps: composition.defaultProps ?? {},\n                    defaultCodec: currentCompositionMetadata.defaultCodec\n                }\n            };\n        }\n        if (!needsResolution(composition)) {\n            validateDurationInFrames(composition.durationInFrames, {\n                allowFloats: false,\n                component: `in <Composition id=\"${composition.id}\">`\n            });\n            validateFps(composition.fps, `in <Composition id=\"${composition.id}\">`, false);\n            validateDimension(composition.width, \"width\", `in <Composition id=\"${composition.id}\">`);\n            validateDimension(composition.height, \"height\", `in <Composition id=\"${composition.id}\">`);\n            return {\n                type: \"success\",\n                result: {\n                    width: composition.width,\n                    height: composition.height,\n                    fps: composition.fps,\n                    id: composition.id,\n                    durationInFrames: composition.durationInFrames,\n                    defaultProps: composition.defaultProps ?? {},\n                    props: {\n                        ...composition.defaultProps ?? {},\n                        ...selectedEditorProps ?? {},\n                        ... true ? {} : 0\n                    },\n                    defaultCodec: null\n                }\n            };\n        }\n        if (!context[composition.id]) {\n            return null;\n        }\n        return context[composition.id];\n    }, [\n        composition,\n        context,\n        currentCompositionMetadata,\n        selectedEditorProps\n    ]);\n};\n// src/use-video.ts\nvar useVideo = ()=>{\n    const { canvasContent, compositions, currentCompositionMetadata } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(CompositionManager);\n    const selected = compositions.find((c)=>{\n        return canvasContent?.type === \"composition\" && c.id === canvasContent.compositionId;\n    });\n    const resolved = useResolvedVideoConfig(selected?.id ?? null);\n    return (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        if (!resolved) {\n            return null;\n        }\n        if (resolved.type === \"error\") {\n            return null;\n        }\n        if (resolved.type === \"loading\") {\n            return null;\n        }\n        if (!selected) {\n            return null;\n        }\n        return {\n            ...resolved.result,\n            defaultProps: selected.defaultProps ?? {},\n            id: selected.id,\n            ...currentCompositionMetadata ?? {},\n            component: selected.component\n        };\n    }, [\n        currentCompositionMetadata,\n        resolved,\n        selected\n    ]);\n};\n// src/timeline-position-state.ts\nvar TimelineContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)({\n    frame: {},\n    playing: false,\n    playbackRate: 1,\n    rootId: \"\",\n    imperativePlaying: {\n        current: false\n    },\n    setPlaybackRate: ()=>{\n        throw new Error(\"default\");\n    },\n    audioAndVideoTags: {\n        current: []\n    }\n});\nvar SetTimelineContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)({\n    setFrame: ()=>{\n        throw new Error(\"default\");\n    },\n    setPlaying: ()=>{\n        throw new Error(\"default\");\n    }\n});\nvar makeKey = ()=>{\n    return `remotion.time-all`;\n};\nvar persistCurrentFrame = (time)=>{\n    localStorage.setItem(makeKey(), JSON.stringify(time));\n};\nvar getInitialFrameState = ()=>{\n    const item = localStorage.getItem(makeKey()) ?? \"{}\";\n    const obj = JSON.parse(item);\n    return obj;\n};\nvar getFrameForComposition = (composition)=>{\n    const item = localStorage.getItem(makeKey()) ?? \"{}\";\n    const obj = JSON.parse(item);\n    if (obj[composition] !== undefined) {\n        return Number(obj[composition]);\n    }\n    if (true) {\n        return 0;\n    }\n    return window.remotion_initialFrame ?? 0;\n};\nvar useTimelinePosition = ()=>{\n    const videoConfig = useVideo();\n    const state = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(TimelineContext);\n    if (!videoConfig) {\n        return  true ? 0 : 0;\n    }\n    const unclamped = state.frame[videoConfig.id] ?? (getRemotionEnvironment().isPlayer ? 0 : getFrameForComposition(videoConfig.id));\n    return Math.min(videoConfig.durationInFrames - 1, unclamped);\n};\nvar useTimelineSetFrame = ()=>{\n    const { setFrame } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(SetTimelineContext);\n    return setFrame;\n};\nvar usePlayingState = ()=>{\n    const { playing, imperativePlaying } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(TimelineContext);\n    const { setPlaying } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(SetTimelineContext);\n    return (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>[\n            playing,\n            setPlaying,\n            imperativePlaying\n        ], [\n        imperativePlaying,\n        playing,\n        setPlaying\n    ]);\n};\n// src/use-video-config.ts\n\n// src/CanUseRemotionHooks.tsx\n\n\nvar CanUseRemotionHooks = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)(false);\nvar CanUseRemotionHooksProvider = ({ children })=>{\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(CanUseRemotionHooks.Provider, {\n        value: true,\n        children\n    });\n};\n// src/use-unsafe-video-config.ts\n\nvar useUnsafeVideoConfig = ()=>{\n    const context = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(SequenceContext);\n    const ctxWidth = context?.width ?? null;\n    const ctxHeight = context?.height ?? null;\n    const ctxDuration = context?.durationInFrames ?? null;\n    const video = useVideo();\n    return (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        if (!video) {\n            return null;\n        }\n        const { id, durationInFrames, fps, height, width, defaultProps, props, defaultCodec } = video;\n        return {\n            id,\n            width: ctxWidth ?? width,\n            height: ctxHeight ?? height,\n            fps,\n            durationInFrames: ctxDuration ?? durationInFrames,\n            defaultProps,\n            props,\n            defaultCodec\n        };\n    }, [\n        ctxDuration,\n        ctxHeight,\n        ctxWidth,\n        video\n    ]);\n};\n// src/use-video-config.ts\nvar useVideoConfig = ()=>{\n    const videoConfig = useUnsafeVideoConfig();\n    const context = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(CanUseRemotionHooks);\n    const isPlayer = useIsPlayer();\n    if (!videoConfig) {\n        if ( false || isPlayer) {\n            throw new Error([\n                \"No video config found. Likely reasons:\",\n                \"- You are probably calling useVideoConfig() from outside the component passed to <Player />. See https://www.remotion.dev/docs/player/examples for how to set up the Player correctly.\",\n                \"- You have multiple versions of Remotion installed which causes the React context to get lost.\"\n            ].join(\"-\"));\n        }\n        throw new Error(\"No video config found. You are probably calling useVideoConfig() from a component which has not been registered as a <Composition />. See https://www.remotion.dev/docs/the-fundamentals#defining-compositions for more information.\");\n    }\n    if (!context) {\n        throw new Error(\"Called useVideoConfig() outside a Remotion composition.\");\n    }\n    return videoConfig;\n};\n// src/freeze.tsx\n\n// src/use-current-frame.ts\n\nvar useCurrentFrame = ()=>{\n    const canUseRemotionHooks = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(CanUseRemotionHooks);\n    if (!canUseRemotionHooks) {\n        if (getRemotionEnvironment().isPlayer) {\n            throw new Error(`useCurrentFrame can only be called inside a component that was passed to <Player>. See: https://www.remotion.dev/docs/player/examples`);\n        }\n        throw new Error(`useCurrentFrame() can only be called inside a component that was registered as a composition. See https://www.remotion.dev/docs/the-fundamentals#defining-compositions`);\n    }\n    const frame = useTimelinePosition();\n    const context = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(SequenceContext);\n    const contextOffset = context ? context.cumulatedFrom + context.relativeFrom : 0;\n    return frame - contextOffset;\n};\n// src/freeze.tsx\n\nvar Freeze = ({ frame: frameToFreeze, children, active = true })=>{\n    const frame = useCurrentFrame();\n    const videoConfig = useVideoConfig();\n    if (typeof frameToFreeze === \"undefined\") {\n        throw new Error(`The <Freeze /> component requires a 'frame' prop, but none was passed.`);\n    }\n    if (typeof frameToFreeze !== \"number\") {\n        throw new Error(`The 'frame' prop of <Freeze /> must be a number, but is of type ${typeof frameToFreeze}`);\n    }\n    if (Number.isNaN(frameToFreeze)) {\n        throw new Error(`The 'frame' prop of <Freeze /> must be a real number, but it is NaN.`);\n    }\n    if (!Number.isFinite(frameToFreeze)) {\n        throw new Error(`The 'frame' prop of <Freeze /> must be a finite number, but it is ${frameToFreeze}.`);\n    }\n    const isActive = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        if (typeof active === \"boolean\") {\n            return active;\n        }\n        if (typeof active === \"function\") {\n            return active(frame);\n        }\n    }, [\n        active,\n        frame\n    ]);\n    const timelineContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(TimelineContext);\n    const sequenceContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(SequenceContext);\n    const relativeFrom = sequenceContext?.relativeFrom ?? 0;\n    const timelineValue = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        if (!isActive) {\n            return timelineContext;\n        }\n        return {\n            ...timelineContext,\n            playing: false,\n            imperativePlaying: {\n                current: false\n            },\n            frame: {\n                [videoConfig.id]: frameToFreeze + relativeFrom\n            }\n        };\n    }, [\n        isActive,\n        timelineContext,\n        videoConfig.id,\n        frameToFreeze,\n        relativeFrom\n    ]);\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(TimelineContext.Provider, {\n        value: timelineValue,\n        children\n    });\n};\n// src/Sequence.tsx\n\nvar RegularSequenceRefForwardingFunction = ({ from = 0, durationInFrames = Infinity, children, name, height, width, showInTimeline = true, _remotionInternalLoopDisplay: loopDisplay, _remotionInternalStack: stack, _remotionInternalPremountDisplay: premountDisplay, ...other }, ref)=>{\n    const { layout = \"absolute-fill\" } = other;\n    const [id] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(()=>String(Math.random()));\n    const parentSequence = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(SequenceContext);\n    const { rootId } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(TimelineContext);\n    const cumulatedFrom = parentSequence ? parentSequence.cumulatedFrom + parentSequence.relativeFrom : 0;\n    const nonce = useNonce();\n    if (layout !== \"absolute-fill\" && layout !== \"none\") {\n        throw new TypeError(`The layout prop of <Sequence /> expects either \"absolute-fill\" or \"none\", but you passed: ${layout}`);\n    }\n    if (layout === \"none\" && typeof other.style !== \"undefined\") {\n        throw new TypeError('If layout=\"none\", you may not pass a style.');\n    }\n    if (typeof durationInFrames !== \"number\") {\n        throw new TypeError(`You passed to durationInFrames an argument of type ${typeof durationInFrames}, but it must be a number.`);\n    }\n    if (durationInFrames <= 0) {\n        throw new TypeError(`durationInFrames must be positive, but got ${durationInFrames}`);\n    }\n    if (typeof from !== \"number\") {\n        throw new TypeError(`You passed to the \"from\" props of your <Sequence> an argument of type ${typeof from}, but it must be a number.`);\n    }\n    if (!Number.isFinite(from)) {\n        throw new TypeError(`The \"from\" prop of a sequence must be finite, but got ${from}.`);\n    }\n    const absoluteFrame = useTimelinePosition();\n    const videoConfig = useVideoConfig();\n    const parentSequenceDuration = parentSequence ? Math.min(parentSequence.durationInFrames - from, durationInFrames) : durationInFrames;\n    const actualDurationInFrames = Math.max(0, Math.min(videoConfig.durationInFrames - from, parentSequenceDuration));\n    const { registerSequence, unregisterSequence } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(SequenceManager);\n    const { hidden } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(SequenceVisibilityToggleContext);\n    const premounting = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        return parentSequence?.premounting ?? Boolean(other._remotionInternalIsPremounting);\n    }, [\n        other._remotionInternalIsPremounting,\n        parentSequence?.premounting\n    ]);\n    const contextValue = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        return {\n            cumulatedFrom,\n            relativeFrom: from,\n            durationInFrames: actualDurationInFrames,\n            parentFrom: parentSequence?.relativeFrom ?? 0,\n            id,\n            height: height ?? parentSequence?.height ?? null,\n            width: width ?? parentSequence?.width ?? null,\n            premounting\n        };\n    }, [\n        cumulatedFrom,\n        from,\n        actualDurationInFrames,\n        parentSequence,\n        id,\n        height,\n        width,\n        premounting\n    ]);\n    const timelineClipName = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        return name ?? \"\";\n    }, [\n        name\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (!getRemotionEnvironment().isStudio) {\n            return;\n        }\n        registerSequence({\n            from,\n            duration: actualDurationInFrames,\n            id,\n            displayName: timelineClipName,\n            parent: parentSequence?.id ?? null,\n            type: \"sequence\",\n            rootId,\n            showInTimeline,\n            nonce,\n            loopDisplay,\n            stack: stack ?? null,\n            premountDisplay: premountDisplay ?? null\n        });\n        return ()=>{\n            unregisterSequence(id);\n        };\n    }, [\n        durationInFrames,\n        id,\n        name,\n        registerSequence,\n        timelineClipName,\n        unregisterSequence,\n        parentSequence?.id,\n        actualDurationInFrames,\n        rootId,\n        from,\n        showInTimeline,\n        nonce,\n        loopDisplay,\n        stack,\n        premountDisplay\n    ]);\n    const endThreshold = Math.ceil(cumulatedFrom + from + durationInFrames - 1);\n    const content = absoluteFrame < cumulatedFrom + from ? null : absoluteFrame > endThreshold ? null : children;\n    const styleIfThere = other.layout === \"none\" ? undefined : other.style;\n    const defaultStyle = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        return {\n            flexDirection: undefined,\n            ...width ? {\n                width\n            } : {},\n            ...height ? {\n                height\n            } : {},\n            ...styleIfThere ?? {}\n        };\n    }, [\n        height,\n        styleIfThere,\n        width\n    ]);\n    if (ref !== null && layout === \"none\") {\n        throw new TypeError('It is not supported to pass both a `ref` and `layout=\"none\"` to <Sequence />.');\n    }\n    const isSequenceHidden = hidden[id] ?? false;\n    if (isSequenceHidden) {\n        return null;\n    }\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(SequenceContext.Provider, {\n        value: contextValue,\n        children: content === null ? null : other.layout === \"none\" ? content : /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(AbsoluteFill, {\n            ref,\n            style: defaultStyle,\n            className: other.className,\n            children: content\n        })\n    });\n};\nvar RegularSequence = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(RegularSequenceRefForwardingFunction);\nvar PremountedSequenceRefForwardingFunction = (props, ref)=>{\n    const frame = useCurrentFrame();\n    if (props.layout === \"none\") {\n        throw new Error('`<Sequence>` with `premountFor` prop does not support layout=\"none\"');\n    }\n    const { style: passedStyle, from = 0, premountFor = 0, ...otherProps } = props;\n    const premountingActive = frame < from && frame >= from - premountFor;\n    const style = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        return {\n            ...passedStyle,\n            opacity: premountingActive ? 0 : 1,\n            pointerEvents: premountingActive ? \"none\" : passedStyle?.pointerEvents ?? undefined\n        };\n    }, [\n        premountingActive,\n        passedStyle\n    ]);\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(Freeze, {\n        frame: from,\n        active: premountingActive,\n        children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(Sequence, {\n            ref,\n            from,\n            style,\n            _remotionInternalPremountDisplay: premountFor,\n            _remotionInternalIsPremounting: premountingActive,\n            ...otherProps\n        })\n    });\n};\nvar PremountedSequence = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(PremountedSequenceRefForwardingFunction);\nvar SequenceRefForwardingFunction = (props, ref)=>{\n    if (props.layout !== \"none\" && props.premountFor && !getRemotionEnvironment().isRendering) {\n        return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(PremountedSequence, {\n            ...props,\n            ref\n        });\n    }\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(RegularSequence, {\n        ...props,\n        ref\n    });\n};\nvar Sequence = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(SequenceRefForwardingFunction);\n// src/Artifact.tsx\n\n// src/RenderAssetManager.tsx\n\n// src/validation/validate-artifact.ts\nvar validateArtifactFilename = (filename)=>{\n    if (typeof filename !== \"string\") {\n        throw new TypeError(`The \"filename\" must be a string, but you passed a value of type ${typeof filename}`);\n    }\n    if (filename.trim() === \"\") {\n        throw new Error(\"The `filename` must not be empty\");\n    }\n    if (!filename.match(/^([0-9a-zA-Z-!_.*'()/:&$@=;+,?]+)/g)) {\n        throw new Error('The `filename` must match \"/^([0-9a-zA-Z-!_.*\\'()/:&$@=;+,?]+)/g\". Use forward slashes only, even on Windows.');\n    }\n};\nvar validateContent = (content)=>{\n    if (typeof content !== \"string\" && !(content instanceof Uint8Array)) {\n        throw new TypeError(`The \"content\" must be a string or Uint8Array, but you passed a value of type ${typeof content}`);\n    }\n    if (typeof content === \"string\" && content.trim() === \"\") {\n        throw new Error(\"The `content` must not be empty\");\n    }\n};\nvar validateRenderAsset = (artifact)=>{\n    if (artifact.type !== \"artifact\") {\n        return;\n    }\n    validateArtifactFilename(artifact.filename);\n    validateContent(artifact.content);\n};\n// src/RenderAssetManager.tsx\n\nvar RenderAssetManager = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)({\n    registerRenderAsset: ()=>{\n        return;\n    },\n    unregisterRenderAsset: ()=>{\n        return;\n    },\n    renderAssets: []\n});\nvar RenderAssetManagerProvider = ({ children })=>{\n    const [renderAssets, setRenderAssets] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n    const registerRenderAsset = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((renderAsset)=>{\n        validateRenderAsset(renderAsset);\n        setRenderAssets((assets)=>{\n            return [\n                ...assets,\n                renderAsset\n            ];\n        });\n    }, []);\n    const unregisterRenderAsset = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((id)=>{\n        setRenderAssets((assts)=>{\n            return assts.filter((a)=>a.id !== id);\n        });\n    }, []);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect)(()=>{\n        if (false) {}\n    }, [\n        renderAssets\n    ]);\n    const contextValue = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        return {\n            registerRenderAsset,\n            unregisterRenderAsset,\n            renderAssets\n        };\n    }, [\n        renderAssets,\n        registerRenderAsset,\n        unregisterRenderAsset\n    ]);\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(RenderAssetManager.Provider, {\n        value: contextValue,\n        children\n    });\n};\n// src/Artifact.tsx\nvar Artifact = ({ filename, content })=>{\n    const { registerRenderAsset, unregisterRenderAsset } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(RenderAssetManager);\n    const [env] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(()=>getRemotionEnvironment());\n    const frame = useCurrentFrame();\n    const [id] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(()=>{\n        return String(Math.random());\n    });\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (!env.isRendering) {\n            return;\n        }\n        if (content instanceof Uint8Array) {\n            registerRenderAsset({\n                type: \"artifact\",\n                id,\n                content: btoa(new TextDecoder(\"utf8\").decode(content)),\n                filename,\n                frame,\n                binary: true\n            });\n        } else {\n            registerRenderAsset({\n                type: \"artifact\",\n                id,\n                content,\n                filename,\n                frame,\n                binary: false\n            });\n        }\n        return ()=>{\n            return unregisterRenderAsset(id);\n        };\n    }, [\n        content,\n        env.isRendering,\n        filename,\n        frame,\n        id,\n        registerRenderAsset,\n        unregisterRenderAsset\n    ]);\n    return null;\n};\n// src/audio/Audio.tsx\n\n// src/absolute-src.ts\nvar getAbsoluteSrc = (relativeSrc)=>{\n    if (true) {\n        return relativeSrc;\n    }\n    return new URL(relativeSrc, window.origin).href;\n};\n// src/calculate-loop.ts\nvar calculateLoopDuration = ({ endAt, mediaDuration, playbackRate, startFrom })=>{\n    let duration = mediaDuration;\n    if (typeof endAt !== \"undefined\") {\n        duration = endAt;\n    }\n    if (typeof startFrom !== \"undefined\") {\n        duration -= startFrom;\n    }\n    const actualDuration = duration / playbackRate;\n    return Math.floor(actualDuration);\n};\n// src/cancel-render.ts\nfunction cancelRender(err) {\n    let error;\n    if (isErrorLike(err)) {\n        error = err;\n        if (!error.stack) {\n            error.stack = new Error(error.message).stack;\n        }\n    } else if (typeof err === \"string\") {\n        error = Error(err);\n    } else {\n        error = Error(\"Rendering was cancelled\");\n    }\n    window.remotion_cancelledError = error.stack;\n    throw error;\n}\nvar isErrorLike = (err)=>{\n    if (err instanceof Error) {\n        return true;\n    }\n    if (err === null) {\n        return false;\n    }\n    if (typeof err !== \"object\") {\n        return false;\n    }\n    if (!(\"stack\" in err)) {\n        return false;\n    }\n    if (typeof err.stack !== \"string\") {\n        return false;\n    }\n    if (!(\"message\" in err)) {\n        return false;\n    }\n    if (typeof err.message !== \"string\") {\n        return false;\n    }\n    return true;\n};\n// src/loop/index.tsx\n\n\nvar LoopContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)(null);\nvar useLoop = ()=>{\n    return react__WEBPACK_IMPORTED_MODULE_0__.useContext(LoopContext);\n};\nvar Loop = ({ durationInFrames, times = Infinity, children, name, ...props })=>{\n    const currentFrame = useCurrentFrame();\n    const { durationInFrames: compDuration } = useVideoConfig();\n    validateDurationInFrames(durationInFrames, {\n        component: \"of the <Loop /> component\",\n        allowFloats: true\n    });\n    if (typeof times !== \"number\") {\n        throw new TypeError(`You passed to \"times\" an argument of type ${typeof times}, but it must be a number.`);\n    }\n    if (times !== Infinity && times % 1 !== 0) {\n        throw new TypeError(`The \"times\" prop of a loop must be an integer, but got ${times}.`);\n    }\n    if (times < 0) {\n        throw new TypeError(`The \"times\" prop of a loop must be at least 0, but got ${times}`);\n    }\n    const maxTimes = Math.ceil(compDuration / durationInFrames);\n    const actualTimes = Math.min(maxTimes, times);\n    const style = props.layout === \"none\" ? undefined : props.style;\n    const maxFrame = durationInFrames * (actualTimes - 1);\n    const iteration = Math.floor(currentFrame / durationInFrames);\n    const start = iteration * durationInFrames;\n    const from = Math.min(start, maxFrame);\n    const loopDisplay = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        return {\n            numberOfTimes: actualTimes,\n            startOffset: -from,\n            durationInFrames\n        };\n    }, [\n        actualTimes,\n        durationInFrames,\n        from\n    ]);\n    const loopContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        return {\n            iteration: Math.floor(currentFrame / durationInFrames),\n            durationInFrames\n        };\n    }, [\n        currentFrame,\n        durationInFrames\n    ]);\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(LoopContext.Provider, {\n        value: loopContext,\n        children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(Sequence, {\n            durationInFrames,\n            from,\n            name: name ?? \"<Loop>\",\n            _remotionInternalLoopDisplay: loopDisplay,\n            layout: props.layout,\n            style,\n            children\n        })\n    });\n};\nLoop.useLoop = useLoop;\n// src/prefetch.ts\n\n// src/prefetch-state.tsx\n\n\nvar PreloadContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)({});\nvar preloads = {};\nvar updaters = [];\nvar setPreloads = (updater)=>{\n    preloads = updater(preloads);\n    updaters.forEach((u)=>u());\n};\nvar PrefetchProvider = ({ children })=>{\n    const [_preloads, _setPreloads] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(()=>preloads);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        const updaterFunction = ()=>{\n            _setPreloads(preloads);\n        };\n        updaters.push(updaterFunction);\n        return ()=>{\n            updaters = updaters.filter((u)=>u !== updaterFunction);\n        };\n    }, []);\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(PreloadContext.Provider, {\n        value: _preloads,\n        children\n    });\n};\n// src/prefetch.ts\nvar usePreload = (src)=>{\n    const preloads2 = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(PreloadContext);\n    return preloads2[src] ?? src;\n};\nvar blobToBase64 = function(blob) {\n    const reader = new FileReader;\n    return new Promise((resolve, reject)=>{\n        reader.onload = function() {\n            const dataUrl = reader.result;\n            resolve(dataUrl);\n        };\n        reader.onerror = (err)=>{\n            return reject(err);\n        };\n        reader.readAsDataURL(blob);\n    });\n};\nvar getBlobFromReader = async ({ reader, contentType, contentLength, onProgress })=>{\n    let receivedLength = 0;\n    const chunks = [];\n    while(true){\n        const { done, value } = await reader.read();\n        if (done) {\n            break;\n        }\n        chunks.push(value);\n        receivedLength += value.length;\n        if (onProgress) {\n            onProgress({\n                loadedBytes: receivedLength,\n                totalBytes: contentLength\n            });\n        }\n    }\n    const chunksAll = new Uint8Array(receivedLength);\n    let position = 0;\n    for (const chunk of chunks){\n        chunksAll.set(chunk, position);\n        position += chunk.length;\n    }\n    return new Blob([\n        chunksAll\n    ], {\n        type: contentType ?? undefined\n    });\n};\nvar prefetch = (src, options)=>{\n    const method = options?.method ?? \"blob-url\";\n    if (getRemotionEnvironment().isRendering) {\n        return {\n            free: ()=>{\n                return;\n            },\n            waitUntilDone: ()=>Promise.resolve(src)\n        };\n    }\n    let canceled = false;\n    let objectUrl = null;\n    let resolve = ()=>{\n        return;\n    };\n    let reject = ()=>{\n        return;\n    };\n    const waitUntilDone = new Promise((res, rej)=>{\n        resolve = res;\n        reject = rej;\n    });\n    const controller = new AbortController;\n    let canBeAborted = true;\n    fetch(src, {\n        signal: controller.signal\n    }).then((res)=>{\n        canBeAborted = false;\n        if (canceled) {\n            return null;\n        }\n        if (!res.ok) {\n            throw new Error(`HTTP error, status = ${res.status}`);\n        }\n        const headerContentType = res.headers.get(\"Content-Type\");\n        const contentType = options?.contentType ?? headerContentType;\n        const hasProperContentType = contentType && (contentType.startsWith(\"video/\") || contentType.startsWith(\"audio/\") || contentType.startsWith(\"image/\"));\n        if (!hasProperContentType) {\n            console.warn(`Called prefetch() on ${src} which returned a \"Content-Type\" of ${headerContentType}. Prefetched content should have a proper content type (video/... or audio/...) or a contentType passed the options of prefetch(). Otherwise, prefetching will not work properly in all browsers.`);\n        }\n        if (!res.body) {\n            throw new Error(`HTTP response of ${src} has no body`);\n        }\n        const reader = res.body.getReader();\n        return getBlobFromReader({\n            reader,\n            contentType: options?.contentType ?? headerContentType ?? null,\n            contentLength: res.headers.get(\"Content-Length\") ? parseInt(res.headers.get(\"Content-Length\"), 10) : null,\n            onProgress: options?.onProgress\n        });\n    }).then((buf)=>{\n        if (!buf) {\n            return;\n        }\n        const actualBlob = options?.contentType ? new Blob([\n            buf\n        ], {\n            type: options.contentType\n        }) : buf;\n        if (method === \"base64\") {\n            return blobToBase64(actualBlob);\n        }\n        return URL.createObjectURL(actualBlob);\n    }).then((url)=>{\n        if (canceled) {\n            return;\n        }\n        objectUrl = url;\n        setPreloads((p)=>({\n                ...p,\n                [src]: objectUrl\n            }));\n        resolve(objectUrl);\n    }).catch((err)=>{\n        reject(err);\n    });\n    return {\n        free: ()=>{\n            if (objectUrl) {\n                if (method === \"blob-url\") {\n                    URL.revokeObjectURL(objectUrl);\n                }\n                setPreloads((p)=>{\n                    const copy = {\n                        ...p\n                    };\n                    delete copy[src];\n                    return copy;\n                });\n            } else {\n                canceled = true;\n                if (canBeAborted) {\n                    try {\n                        controller.abort(new Error(\"free() called\"));\n                    } catch (e) {}\n                }\n            }\n        },\n        waitUntilDone: ()=>{\n            return waitUntilDone;\n        }\n    };\n};\n// src/validate-media-props.ts\nvar validateMediaProps = (props, component)=>{\n    if (typeof props.volume !== \"number\" && typeof props.volume !== \"function\" && typeof props.volume !== \"undefined\") {\n        throw new TypeError(`You have passed a volume of type ${typeof props.volume} to your <${component} /> component. Volume must be a number or a function with the signature '(frame: number) => number' undefined.`);\n    }\n    if (typeof props.volume === \"number\" && props.volume < 0) {\n        throw new TypeError(`You have passed a volume below 0 to your <${component} /> component. Volume must be between 0 and 1`);\n    }\n    if (typeof props.playbackRate !== \"number\" && typeof props.playbackRate !== \"undefined\") {\n        throw new TypeError(`You have passed a playbackRate of type ${typeof props.playbackRate} to your <${component} /> component. Playback rate must a real number or undefined.`);\n    }\n    if (typeof props.playbackRate === \"number\" && (isNaN(props.playbackRate) || !Number.isFinite(props.playbackRate) || props.playbackRate <= 0)) {\n        throw new TypeError(`You have passed a playbackRate of ${props.playbackRate} to your <${component} /> component. Playback rate must be a real number above 0.`);\n    }\n};\n// src/validate-start-from-props.ts\nvar validateStartFromProps = (startFrom, endAt)=>{\n    if (typeof startFrom !== \"undefined\") {\n        if (typeof startFrom !== \"number\") {\n            throw new TypeError(`type of startFrom prop must be a number, instead got type ${typeof startFrom}.`);\n        }\n        if (isNaN(startFrom) || startFrom === Infinity) {\n            throw new TypeError(\"startFrom prop can not be NaN or Infinity.\");\n        }\n        if (startFrom < 0) {\n            throw new TypeError(`startFrom must be greater than equal to 0 instead got ${startFrom}.`);\n        }\n    }\n    if (typeof endAt !== \"undefined\") {\n        if (typeof endAt !== \"number\") {\n            throw new TypeError(`type of endAt prop must be a number, instead got type ${typeof endAt}.`);\n        }\n        if (isNaN(endAt)) {\n            throw new TypeError(\"endAt prop can not be NaN.\");\n        }\n        if (endAt <= 0) {\n            throw new TypeError(`endAt must be a positive number, instead got ${endAt}.`);\n        }\n    }\n    if (endAt < startFrom) {\n        throw new TypeError(\"endAt prop must be greater than startFrom prop.\");\n    }\n};\n// src/video/duration-state.tsx\n\n\nvar durationReducer = (state, action)=>{\n    switch(action.type){\n        case \"got-duration\":\n            {\n                const absoluteSrc = getAbsoluteSrc(action.src);\n                if (state[absoluteSrc] === action.durationInSeconds) {\n                    return state;\n                }\n                return {\n                    ...state,\n                    [absoluteSrc]: action.durationInSeconds\n                };\n            }\n        default:\n            return state;\n    }\n};\nvar DurationsContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)({\n    durations: {},\n    setDurations: ()=>{\n        throw new Error(\"context missing\");\n    }\n});\nvar DurationsContextProvider = ({ children })=>{\n    const [durations, setDurations] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useReducer)(durationReducer, {});\n    const value = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        return {\n            durations,\n            setDurations\n        };\n    }, [\n        durations\n    ]);\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(DurationsContext.Provider, {\n        value,\n        children\n    });\n};\n// src/audio/AudioForPreview.tsx\n\n// src/random.ts\nfunction mulberry32(a) {\n    let t = a + 1831565813;\n    t = Math.imul(t ^ t >>> 15, t | 1);\n    t ^= t + Math.imul(t ^ t >>> 7, t | 61);\n    return ((t ^ t >>> 14) >>> 0) / 4294967296;\n}\nfunction hashCode(str) {\n    let i = 0;\n    let chr = 0;\n    let hash = 0;\n    for(i = 0; i < str.length; i++){\n        chr = str.charCodeAt(i);\n        hash = (hash << 5) - hash + chr;\n        hash |= 0;\n    }\n    return hash;\n}\nvar random = (seed, dummy)=>{\n    if (dummy !== undefined) {\n        throw new TypeError(\"random() takes only one argument\");\n    }\n    if (seed === null) {\n        return Math.random();\n    }\n    if (typeof seed === \"string\") {\n        return mulberry32(hashCode(seed));\n    }\n    if (typeof seed === \"number\") {\n        return mulberry32(seed * 10000000000);\n    }\n    throw new Error(\"random() argument must be a number or a string\");\n};\n// src/use-media-in-timeline.ts\n\n// src/audio/use-audio-frame.ts\n\nvar useMediaStartsAt = ()=>{\n    const parentSequence = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(SequenceContext);\n    const startsAt = Math.min(0, parentSequence?.relativeFrom ?? 0);\n    return startsAt;\n};\nvar useFrameForVolumeProp = (behavior)=>{\n    const loop = Loop.useLoop();\n    const frame = useCurrentFrame();\n    const startsAt = useMediaStartsAt();\n    if (behavior === \"repeat\" || loop === null) {\n        return frame + startsAt;\n    }\n    return frame + startsAt + loop.durationInFrames * loop.iteration;\n};\n// src/get-asset-file-name.ts\nvar getAssetDisplayName = (filename)=>{\n    if (/data:|blob:/.test(filename.substring(0, 5))) {\n        return \"Data URL\";\n    }\n    const splitted = filename.split(\"/\").map((s)=>s.split(\"\\\\\")).flat(1);\n    return splitted[splitted.length - 1];\n};\n// src/play-and-handle-not-allowed-error.ts\nvar playAndHandleNotAllowedError = (mediaRef, mediaType, onAutoPlayError)=>{\n    const { current } = mediaRef;\n    if (!current) {\n        return;\n    }\n    const prom = current.play();\n    if (prom.catch) {\n        prom.catch((err)=>{\n            if (!current) {\n                return;\n            }\n            if (err.message.includes(\"request was interrupted by a call to pause\")) {\n                return;\n            }\n            if (err.message.includes(\"The operation was aborted.\")) {\n                return;\n            }\n            if (err.message.includes(\"The fetching process for the media resource was aborted by the user agent\")) {\n                return;\n            }\n            if (err.message.includes(\"request was interrupted by a new load request\")) {\n                return;\n            }\n            if (err.message.includes(\"because the media was removed from the document\")) {\n                return;\n            }\n            console.log(`Could not play ${mediaType} due to following error: `, err);\n            if (!current.muted) {\n                if (onAutoPlayError) {\n                    onAutoPlayError();\n                    return;\n                }\n                console.log(`The video will be muted and we'll retry playing it.`);\n                if (mediaType === \"video\" && getRemotionEnvironment().isPlayer) {\n                    console.log(\"Use onAutoPlayError() to handle this error yourself.\");\n                }\n                current.muted = true;\n                current.play();\n            }\n        });\n    }\n};\n// src/volume-prop.ts\nvar evaluateVolume = ({ frame, volume, mediaVolume = 1, allowAmplificationDuringRender })=>{\n    const maxVolume = allowAmplificationDuringRender ? Infinity : 1;\n    if (typeof volume === \"number\") {\n        return Math.min(maxVolume, volume * mediaVolume);\n    }\n    if (typeof volume === \"undefined\") {\n        return Number(mediaVolume);\n    }\n    const evaluated = volume(frame) * mediaVolume;\n    if (typeof evaluated !== \"number\") {\n        throw new TypeError(`You passed in a a function to the volume prop but it did not return a number but a value of type ${typeof evaluated} for frame ${frame}`);\n    }\n    if (Number.isNaN(evaluated)) {\n        throw new TypeError(`You passed in a function to the volume prop but it returned NaN for frame ${frame}.`);\n    }\n    if (!Number.isFinite(evaluated)) {\n        throw new TypeError(`You passed in a function to the volume prop but it returned a non-finite number for frame ${frame}.`);\n    }\n    return Math.max(0, Math.min(maxVolume, evaluated));\n};\n// src/use-media-in-timeline.ts\nvar didWarn2 = {};\nvar warnOnce2 = (message)=>{\n    if (didWarn2[message]) {\n        return;\n    }\n    console.warn(message);\n    didWarn2[message] = true;\n};\nvar useMediaInTimeline = ({ volume, mediaVolume, mediaRef, src, mediaType, playbackRate, displayName, id, stack, showInTimeline, premountDisplay, onAutoPlayError })=>{\n    const videoConfig = useVideoConfig();\n    const { rootId, audioAndVideoTags } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(TimelineContext);\n    const parentSequence = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(SequenceContext);\n    const actualFrom = parentSequence ? parentSequence.relativeFrom + parentSequence.cumulatedFrom : 0;\n    const [playing] = usePlayingState();\n    const startsAt = useMediaStartsAt();\n    const { registerSequence, unregisterSequence } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(SequenceManager);\n    const [initialVolume] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(()=>volume);\n    const nonce = useNonce();\n    const duration = parentSequence ? Math.min(parentSequence.durationInFrames, videoConfig.durationInFrames) : videoConfig.durationInFrames;\n    const doesVolumeChange = typeof volume === \"function\";\n    const volumes = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        if (typeof volume === \"number\") {\n            return volume;\n        }\n        return new Array(Math.floor(Math.max(0, duration + startsAt))).fill(true).map((_, i)=>{\n            return evaluateVolume({\n                frame: i + startsAt,\n                volume,\n                mediaVolume,\n                allowAmplificationDuringRender: false\n            });\n        }).join(\",\");\n    }, [\n        duration,\n        startsAt,\n        volume,\n        mediaVolume\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (typeof volume === \"number\" && volume !== initialVolume) {\n            warnOnce2(`Remotion: The ${mediaType} with src ${src} has changed it's volume. Prefer the callback syntax for setting volume to get better timeline display: https://www.remotion.dev/docs/using-audio/#controlling-volume`);\n        }\n    }, [\n        initialVolume,\n        mediaType,\n        src,\n        volume\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (!mediaRef.current) {\n            return;\n        }\n        if (!src) {\n            throw new Error(\"No src passed\");\n        }\n        if (!getRemotionEnvironment().isStudio && window.process?.env?.NODE_ENV !== \"test\") {\n            return;\n        }\n        if (!showInTimeline) {\n            return;\n        }\n        registerSequence({\n            type: mediaType,\n            src,\n            id,\n            duration,\n            from: 0,\n            parent: parentSequence?.id ?? null,\n            displayName: displayName ?? getAssetDisplayName(src),\n            rootId,\n            volume: volumes,\n            showInTimeline: true,\n            nonce,\n            startMediaFrom: 0 - startsAt,\n            doesVolumeChange,\n            loopDisplay: undefined,\n            playbackRate,\n            stack,\n            premountDisplay\n        });\n        return ()=>{\n            unregisterSequence(id);\n        };\n    }, [\n        actualFrom,\n        duration,\n        id,\n        parentSequence,\n        src,\n        registerSequence,\n        rootId,\n        unregisterSequence,\n        videoConfig,\n        volumes,\n        doesVolumeChange,\n        nonce,\n        mediaRef,\n        mediaType,\n        startsAt,\n        playbackRate,\n        displayName,\n        stack,\n        showInTimeline,\n        premountDisplay\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        const tag = {\n            id,\n            play: ()=>{\n                if (!playing) {\n                    return;\n                }\n                return playAndHandleNotAllowedError(mediaRef, mediaType, onAutoPlayError);\n            }\n        };\n        audioAndVideoTags.current.push(tag);\n        return ()=>{\n            audioAndVideoTags.current = audioAndVideoTags.current.filter((a)=>a.id !== id);\n        };\n    }, [\n        audioAndVideoTags,\n        id,\n        mediaRef,\n        mediaType,\n        onAutoPlayError,\n        playing\n    ]);\n};\n// src/use-media-playback.ts\n\n// src/buffer-until-first-frame.ts\n\n// src/use-buffer-state.ts\n\n// src/buffering.tsx\n\n\nvar useBufferManager = ()=>{\n    const [blocks, setBlocks] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n    const [onBufferingCallbacks, setOnBufferingCallbacks] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n    const [onResumeCallbacks, setOnResumeCallbacks] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n    const buffering = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\n    const addBlock = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((block)=>{\n        setBlocks((b)=>[\n                ...b,\n                block\n            ]);\n        return {\n            unblock: ()=>{\n                setBlocks((b)=>{\n                    const newArr = b.filter((bx)=>bx !== block);\n                    if (newArr.length === b.length) {\n                        return b;\n                    }\n                    return newArr;\n                });\n            }\n        };\n    }, []);\n    const listenForBuffering = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((callback)=>{\n        setOnBufferingCallbacks((c)=>[\n                ...c,\n                callback\n            ]);\n        return {\n            remove: ()=>{\n                setOnBufferingCallbacks((c)=>c.filter((cb)=>cb !== callback));\n            }\n        };\n    }, []);\n    const listenForResume = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((callback)=>{\n        setOnResumeCallbacks((c)=>[\n                ...c,\n                callback\n            ]);\n        return {\n            remove: ()=>{\n                setOnResumeCallbacks((c)=>c.filter((cb)=>cb !== callback));\n            }\n        };\n    }, []);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (blocks.length > 0) {\n            onBufferingCallbacks.forEach((c)=>c());\n        }\n    }, [\n        blocks\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (blocks.length === 0) {\n            onResumeCallbacks.forEach((c)=>c());\n        }\n    }, [\n        blocks\n    ]);\n    return (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        return {\n            addBlock,\n            listenForBuffering,\n            listenForResume,\n            buffering\n        };\n    }, [\n        addBlock,\n        buffering,\n        listenForBuffering,\n        listenForResume\n    ]);\n};\nvar BufferingContextReact = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);\nvar BufferingProvider = ({ children })=>{\n    const bufferManager = useBufferManager();\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(BufferingContextReact.Provider, {\n        value: bufferManager,\n        children\n    });\n};\nvar useIsPlayerBuffering = (bufferManager)=>{\n    const [isBuffering, setIsBuffering] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(bufferManager.buffering.current);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        const onBuffer = ()=>{\n            setIsBuffering(true);\n        };\n        const onResume = ()=>{\n            setIsBuffering(false);\n        };\n        bufferManager.listenForBuffering(onBuffer);\n        bufferManager.listenForResume(onResume);\n        return ()=>{\n            bufferManager.listenForBuffering(()=>{\n                return;\n            });\n            bufferManager.listenForResume(()=>{\n                return;\n            });\n        };\n    }, [\n        bufferManager\n    ]);\n    return isBuffering;\n};\n// src/use-buffer-state.ts\nvar useBufferState = ()=>{\n    const buffer = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(BufferingContextReact);\n    const addBlock = buffer ? buffer.addBlock : null;\n    return (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>({\n            delayPlayback: ()=>{\n                if (!addBlock) {\n                    throw new Error(\"Tried to enable the buffering state, but a Remotion context was not found. This API can only be called in a component that was passed to the Remotion Player or a <Composition>. Or you might have experienced a version mismatch - run `npx remotion versions` and ensure all packages have the same version. This error is thrown by the buffer state https://remotion.dev/docs/player/buffer-state\");\n                }\n                const { unblock } = addBlock({\n                    id: String(Math.random())\n                });\n                return {\n                    unblock\n                };\n            }\n        }), [\n        addBlock\n    ]);\n};\n// src/buffer-until-first-frame.ts\nvar useBufferUntilFirstFrame = ({ mediaRef, mediaType, onVariableFpsVideoDetected, pauseWhenBuffering })=>{\n    const bufferingRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\n    const { delayPlayback } = useBufferState();\n    const bufferUntilFirstFrame = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((requestedTime)=>{\n        if (mediaType !== \"video\") {\n            return;\n        }\n        if (!pauseWhenBuffering) {\n            return;\n        }\n        const current = mediaRef.current;\n        if (!current) {\n            return;\n        }\n        if (!current.requestVideoFrameCallback) {\n            return;\n        }\n        bufferingRef.current = true;\n        const playback = delayPlayback();\n        const unblock = ()=>{\n            playback.unblock();\n            current.removeEventListener(\"ended\", unblock, {\n                once: true\n            });\n            current.removeEventListener(\"pause\", unblock, {\n                once: true\n            });\n            bufferingRef.current = false;\n        };\n        const onEndedOrPauseOrCanPlay = ()=>{\n            unblock();\n        };\n        current.requestVideoFrameCallback((_, info)=>{\n            const differenceFromRequested = Math.abs(info.mediaTime - requestedTime);\n            if (differenceFromRequested > 0.5) {\n                onVariableFpsVideoDetected();\n            }\n            unblock();\n        });\n        current.addEventListener(\"ended\", onEndedOrPauseOrCanPlay, {\n            once: true\n        });\n        current.addEventListener(\"pause\", onEndedOrPauseOrCanPlay, {\n            once: true\n        });\n        current.addEventListener(\"canplay\", onEndedOrPauseOrCanPlay, {\n            once: true\n        });\n    }, [\n        delayPlayback,\n        mediaRef,\n        mediaType,\n        onVariableFpsVideoDetected,\n        pauseWhenBuffering\n    ]);\n    return (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        return {\n            isBuffering: ()=>bufferingRef.current,\n            bufferUntilFirstFrame\n        };\n    }, [\n        bufferUntilFirstFrame\n    ]);\n};\n// src/use-media-buffering.ts\n\nvar useMediaBuffering = ({ element, shouldBuffer, isPremounting })=>{\n    const buffer = useBufferState();\n    const [isBuffering, setIsBuffering] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        let cleanupFns = [];\n        const { current } = element;\n        if (!current) {\n            return;\n        }\n        if (!shouldBuffer) {\n            return;\n        }\n        if (isPremounting) {\n            return;\n        }\n        const cleanup = ()=>{\n            cleanupFns.forEach((fn)=>fn());\n            cleanupFns = [];\n            setIsBuffering(false);\n        };\n        const onWaiting = ()=>{\n            setIsBuffering(true);\n            const { unblock } = buffer.delayPlayback();\n            const onCanPlay = ()=>{\n                cleanup();\n                init();\n            };\n            const onError = ()=>{\n                cleanup();\n                init();\n            };\n            current.addEventListener(\"canplay\", onCanPlay, {\n                once: true\n            });\n            cleanupFns.push(()=>{\n                current.removeEventListener(\"canplay\", onCanPlay);\n            });\n            current.addEventListener(\"error\", onError, {\n                once: true\n            });\n            cleanupFns.push(()=>{\n                current.removeEventListener(\"error\", onError);\n            });\n            cleanupFns.push(()=>{\n                unblock();\n            });\n        };\n        const init = ()=>{\n            if (current.readyState < current.HAVE_FUTURE_DATA) {\n                onWaiting();\n                if (!navigator.userAgent.includes(\"Firefox/\")) {\n                    current.load();\n                }\n            } else {\n                current.addEventListener(\"waiting\", onWaiting);\n                cleanupFns.push(()=>{\n                    current.removeEventListener(\"waiting\", onWaiting);\n                });\n            }\n        };\n        init();\n        return ()=>{\n            cleanup();\n        };\n    }, [\n        buffer,\n        element,\n        isPremounting,\n        shouldBuffer\n    ]);\n    return isBuffering;\n};\n// src/use-request-video-callback-time.ts\n\nvar useRequestVideoCallbackTime = ({ mediaRef, mediaType, lastSeek, onVariableFpsVideoDetected })=>{\n    const currentTime = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        const { current } = mediaRef;\n        if (current) {\n            currentTime.current = current.currentTime;\n        } else {\n            currentTime.current = null;\n            return;\n        }\n        if (mediaType !== \"video\") {\n            currentTime.current = null;\n            return;\n        }\n        const videoTag = current;\n        if (!videoTag.requestVideoFrameCallback) {\n            return;\n        }\n        let cancel = ()=>{\n            return;\n        };\n        const request = ()=>{\n            if (!videoTag) {\n                return;\n            }\n            const cb = videoTag.requestVideoFrameCallback((_, info)=>{\n                if (currentTime.current !== null) {\n                    const difference = Math.abs(currentTime.current - info.mediaTime);\n                    const differenceToLastSeek = Math.abs(lastSeek.current === null ? Infinity : info.mediaTime - lastSeek.current);\n                    if (difference > 0.5 && differenceToLastSeek > 0.5 && info.mediaTime > currentTime.current) {\n                        onVariableFpsVideoDetected();\n                    }\n                }\n                currentTime.current = info.mediaTime;\n                request();\n            });\n            cancel = ()=>{\n                videoTag.cancelVideoFrameCallback(cb);\n                cancel = ()=>{\n                    return;\n                };\n            };\n        };\n        request();\n        return ()=>{\n            cancel();\n        };\n    }, [\n        lastSeek,\n        mediaRef,\n        mediaType,\n        onVariableFpsVideoDetected\n    ]);\n    return currentTime;\n};\n// src/interpolate.ts\nfunction interpolateFunction(input, inputRange, outputRange, options) {\n    const { extrapolateLeft, extrapolateRight, easing } = options;\n    let result = input;\n    const [inputMin, inputMax] = inputRange;\n    const [outputMin, outputMax] = outputRange;\n    if (result < inputMin) {\n        if (extrapolateLeft === \"identity\") {\n            return result;\n        }\n        if (extrapolateLeft === \"clamp\") {\n            result = inputMin;\n        } else if (extrapolateLeft === \"wrap\") {\n            const range = inputMax - inputMin;\n            result = ((result - inputMin) % range + range) % range + inputMin;\n        } else if (extrapolateLeft === \"extend\") {}\n    }\n    if (result > inputMax) {\n        if (extrapolateRight === \"identity\") {\n            return result;\n        }\n        if (extrapolateRight === \"clamp\") {\n            result = inputMax;\n        } else if (extrapolateRight === \"wrap\") {\n            const range = inputMax - inputMin;\n            result = ((result - inputMin) % range + range) % range + inputMin;\n        } else if (extrapolateRight === \"extend\") {}\n    }\n    if (outputMin === outputMax) {\n        return outputMin;\n    }\n    result = (result - inputMin) / (inputMax - inputMin);\n    result = easing(result);\n    result = result * (outputMax - outputMin) + outputMin;\n    return result;\n}\nfunction findRange(input, inputRange) {\n    let i;\n    for(i = 1; i < inputRange.length - 1; ++i){\n        if (inputRange[i] >= input) {\n            break;\n        }\n    }\n    return i - 1;\n}\nfunction checkValidInputRange(arr) {\n    for(let i = 1; i < arr.length; ++i){\n        if (!(arr[i] > arr[i - 1])) {\n            throw new Error(`inputRange must be strictly monotonically increasing but got [${arr.join(\",\")}]`);\n        }\n    }\n}\nfunction checkInfiniteRange(name, arr) {\n    if (arr.length < 2) {\n        throw new Error(name + \" must have at least 2 elements\");\n    }\n    for (const element of arr){\n        if (typeof element !== \"number\") {\n            throw new Error(`${name} must contain only numbers`);\n        }\n        if (!Number.isFinite(element)) {\n            throw new Error(`${name} must contain only finite numbers, but got [${arr.join(\",\")}]`);\n        }\n    }\n}\nfunction interpolate(input, inputRange, outputRange, options) {\n    if (typeof input === \"undefined\") {\n        throw new Error(\"input can not be undefined\");\n    }\n    if (typeof inputRange === \"undefined\") {\n        throw new Error(\"inputRange can not be undefined\");\n    }\n    if (typeof outputRange === \"undefined\") {\n        throw new Error(\"outputRange can not be undefined\");\n    }\n    if (inputRange.length !== outputRange.length) {\n        throw new Error(\"inputRange (\" + inputRange.length + \") and outputRange (\" + outputRange.length + \") must have the same length\");\n    }\n    checkInfiniteRange(\"inputRange\", inputRange);\n    checkInfiniteRange(\"outputRange\", outputRange);\n    checkValidInputRange(inputRange);\n    const easing = options?.easing ?? ((num)=>num);\n    let extrapolateLeft = \"extend\";\n    if (options?.extrapolateLeft !== undefined) {\n        extrapolateLeft = options.extrapolateLeft;\n    }\n    let extrapolateRight = \"extend\";\n    if (options?.extrapolateRight !== undefined) {\n        extrapolateRight = options.extrapolateRight;\n    }\n    if (typeof input !== \"number\") {\n        throw new TypeError(\"Cannot interpolate an input which is not a number\");\n    }\n    const range = findRange(input, inputRange);\n    return interpolateFunction(input, [\n        inputRange[range],\n        inputRange[range + 1]\n    ], [\n        outputRange[range],\n        outputRange[range + 1]\n    ], {\n        easing,\n        extrapolateLeft,\n        extrapolateRight\n    });\n}\n// src/video/get-current-time.ts\nvar getExpectedMediaFrameUncorrected = ({ frame, playbackRate, startFrom })=>{\n    return interpolate(frame, [\n        -1,\n        startFrom,\n        startFrom + 1\n    ], [\n        -1,\n        startFrom,\n        startFrom + playbackRate\n    ]);\n};\nvar getMediaTime = ({ fps, frame, playbackRate, startFrom })=>{\n    const expectedFrame = getExpectedMediaFrameUncorrected({\n        frame,\n        playbackRate,\n        startFrom\n    });\n    const msPerFrame = 1000 / fps;\n    return expectedFrame * msPerFrame / 1000;\n};\n// src/video/video-fragment.ts\n\nvar toSeconds = (time, fps)=>{\n    return Math.round(time / fps * 100) / 100;\n};\nvar isIosSafari = ()=>{\n    if (true) {\n        return false;\n    }\n    const isIpadIPodIPhone = /iP(ad|od|hone)/i.test(window.navigator.userAgent);\n    const isAppleWebKit = /AppleWebKit/.test(window.navigator.userAgent);\n    return isIpadIPodIPhone && isAppleWebKit;\n};\nvar isIOSSafariAndBlob = (actualSrc)=>{\n    return isIosSafari() && actualSrc.startsWith(\"blob:\");\n};\nvar getVideoFragmentStart = ({ actualFrom, fps })=>{\n    return toSeconds(Math.max(0, -actualFrom), fps);\n};\nvar getVideoFragmentEnd = ({ duration, fps })=>{\n    return toSeconds(duration, fps);\n};\nvar appendVideoFragment = ({ actualSrc, actualFrom, duration, fps })=>{\n    if (isIOSSafariAndBlob(actualSrc)) {\n        return actualSrc;\n    }\n    if (actualSrc.startsWith(\"data:\")) {\n        return actualSrc;\n    }\n    const existingHash = Boolean(new URL(actualSrc, ( null) ?? \"http://localhost:3000\").hash);\n    if (existingHash) {\n        return actualSrc;\n    }\n    if (!Number.isFinite(actualFrom)) {\n        return actualSrc;\n    }\n    const withStartHash = `${actualSrc}#t=${getVideoFragmentStart({\n        actualFrom,\n        fps\n    })}`;\n    if (!Number.isFinite(duration)) {\n        return withStartHash;\n    }\n    return `${withStartHash},${getVideoFragmentEnd({\n        duration,\n        fps\n    })}`;\n};\nvar isSubsetOfDuration = ({ prevStartFrom, newStartFrom, prevDuration, newDuration, fps })=>{\n    const previousFrom = getVideoFragmentStart({\n        actualFrom: prevStartFrom,\n        fps\n    });\n    const newFrom = getVideoFragmentStart({\n        actualFrom: newStartFrom,\n        fps\n    });\n    const previousEnd = getVideoFragmentEnd({\n        duration: prevDuration,\n        fps\n    });\n    const newEnd = getVideoFragmentEnd({\n        duration: newDuration,\n        fps\n    });\n    if (newFrom < previousFrom) {\n        return false;\n    }\n    if (newEnd > previousEnd) {\n        return false;\n    }\n    return true;\n};\nvar useAppendVideoFragment = ({ actualSrc: initialActualSrc, actualFrom: initialActualFrom, duration: initialDuration, fps })=>{\n    const actualFromRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(initialActualFrom);\n    const actualDuration = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(initialDuration);\n    const actualSrc = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(initialActualSrc);\n    if (!isSubsetOfDuration({\n        prevStartFrom: actualFromRef.current,\n        newStartFrom: initialActualFrom,\n        prevDuration: actualDuration.current,\n        newDuration: initialDuration,\n        fps\n    }) || initialActualSrc !== actualSrc.current) {\n        actualFromRef.current = initialActualFrom;\n        actualDuration.current = initialDuration;\n        actualSrc.current = initialActualSrc;\n    }\n    const appended = appendVideoFragment({\n        actualSrc: actualSrc.current,\n        actualFrom: actualFromRef.current,\n        duration: actualDuration.current,\n        fps\n    });\n    return appended;\n};\n// src/warn-about-non-seekable-media.ts\nvar alreadyWarned = {};\nvar warnAboutNonSeekableMedia = (ref, type)=>{\n    if (ref === null) {\n        return;\n    }\n    if (ref.seekable.length === 0) {\n        return;\n    }\n    if (ref.seekable.length > 1) {\n        return;\n    }\n    if (alreadyWarned[ref.src]) {\n        return;\n    }\n    const range = {\n        start: ref.seekable.start(0),\n        end: ref.seekable.end(0)\n    };\n    if (range.start === 0 && range.end === 0) {\n        const msg = [\n            `The media ${ref.src} cannot be seeked. This could be one of few reasons:`,\n            \"1) The media resource was replaced while the video is playing but it was not loaded yet.\",\n            \"2) The media does not support seeking.\",\n            \"3) The media was loaded with security headers prventing it from being included.\",\n            \"Please see https://remotion.dev/docs/non-seekable-media for assistance.\"\n        ].join(\"\\n\");\n        if (type === \"console-error\") {\n            console.error(msg);\n        } else if (type === \"console-warning\") {\n            console.warn(`The media ${ref.src} does not support seeking. The video will render fine, but may not play correctly in the Remotion Studio and in the <Player>. See https://remotion.dev/docs/non-seekable-media for an explanation.`);\n        } else {\n            throw new Error(msg);\n        }\n        alreadyWarned[ref.src] = true;\n    }\n};\n// src/use-media-playback.ts\nvar DEFAULT_ACCEPTABLE_TIMESHIFT = 0.45;\nvar seek = (mediaRef, time)=>{\n    if (!mediaRef.current) {\n        return;\n    }\n    const timeToSet = isIosSafari() ? Number(time.toFixed(1)) : time;\n    mediaRef.current.currentTime = timeToSet;\n};\nvar useMediaPlayback = ({ mediaRef, src, mediaType, playbackRate: localPlaybackRate, onlyWarnForMediaSeekingError, acceptableTimeshift, pauseWhenBuffering, isPremounting, debugSeeking, onAutoPlayError })=>{\n    const { playbackRate: globalPlaybackRate } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(TimelineContext);\n    const frame = useCurrentFrame();\n    const absoluteFrame = useTimelinePosition();\n    const [playing] = usePlayingState();\n    const buffering = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(BufferingContextReact);\n    const { fps } = useVideoConfig();\n    const mediaStartsAt = useMediaStartsAt();\n    const lastSeekDueToShift = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const lastSeek = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    if (!buffering) {\n        throw new Error(\"useMediaPlayback must be used inside a <BufferingContext>\");\n    }\n    const isVariableFpsVideoMap = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)({});\n    const onVariableFpsVideoDetected = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        if (!src) {\n            return;\n        }\n        if (debugSeeking) {\n            console.log(`Detected ${src} as a variable FPS video. Disabling buffering while seeking.`);\n        }\n        isVariableFpsVideoMap.current[src] = true;\n    }, [\n        debugSeeking,\n        src\n    ]);\n    const currentTime = useRequestVideoCallbackTime({\n        mediaRef,\n        mediaType,\n        lastSeek,\n        onVariableFpsVideoDetected\n    });\n    const desiredUnclampedTime = getMediaTime({\n        frame,\n        playbackRate: localPlaybackRate,\n        startFrom: -mediaStartsAt,\n        fps\n    });\n    const isMediaTagBuffering = useMediaBuffering({\n        element: mediaRef,\n        shouldBuffer: pauseWhenBuffering,\n        isPremounting\n    });\n    const { bufferUntilFirstFrame, isBuffering } = useBufferUntilFirstFrame({\n        mediaRef,\n        mediaType,\n        onVariableFpsVideoDetected,\n        pauseWhenBuffering\n    });\n    const playbackRate = localPlaybackRate * globalPlaybackRate;\n    const acceptableTimeShiftButLessThanDuration = (()=>{\n        if (mediaRef.current?.duration) {\n            return Math.min(mediaRef.current.duration, acceptableTimeshift ?? DEFAULT_ACCEPTABLE_TIMESHIFT);\n        }\n        return acceptableTimeshift;\n    })();\n    const isPlayerBuffering = useIsPlayerBuffering(buffering);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (!playing) {\n            mediaRef.current?.pause();\n            return;\n        }\n        const isMediaTagBufferingOrStalled = isMediaTagBuffering || isBuffering();\n        if (isPlayerBuffering && !isMediaTagBufferingOrStalled) {\n            mediaRef.current?.pause();\n        }\n    }, [\n        isBuffering,\n        isMediaTagBuffering,\n        isPlayerBuffering,\n        mediaRef,\n        playing\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        const tagName = mediaType === \"audio\" ? \"<Audio>\" : \"<Video>\";\n        if (!mediaRef.current) {\n            throw new Error(`No ${mediaType} ref found`);\n        }\n        if (!src) {\n            throw new Error(`No 'src' attribute was passed to the ${tagName} element.`);\n        }\n        const playbackRateToSet = Math.max(0, playbackRate);\n        if (mediaRef.current.playbackRate !== playbackRateToSet) {\n            mediaRef.current.playbackRate = playbackRateToSet;\n        }\n        const { duration } = mediaRef.current;\n        const shouldBeTime = !Number.isNaN(duration) && Number.isFinite(duration) ? Math.min(duration, desiredUnclampedTime) : desiredUnclampedTime;\n        const mediaTagTime = mediaRef.current.currentTime;\n        const rvcTime = currentTime.current ?? null;\n        const isVariableFpsVideo = isVariableFpsVideoMap.current[src];\n        const timeShiftMediaTag = Math.abs(shouldBeTime - mediaTagTime);\n        const timeShiftRvcTag = rvcTime ? Math.abs(shouldBeTime - rvcTime) : null;\n        const timeShift = timeShiftRvcTag && !isVariableFpsVideo ? timeShiftRvcTag : timeShiftMediaTag;\n        if (debugSeeking) {\n            console.log({\n                mediaTagTime,\n                rvcTime,\n                shouldBeTime,\n                state: mediaRef.current.readyState,\n                playing: !mediaRef.current.paused,\n                isVariableFpsVideo\n            });\n        }\n        if (timeShift > acceptableTimeShiftButLessThanDuration && lastSeekDueToShift.current !== shouldBeTime) {\n            if (debugSeeking) {\n                console.log(\"Seeking\", {\n                    shouldBeTime,\n                    isTime: mediaTagTime,\n                    rvcTime,\n                    timeShift,\n                    isVariableFpsVideo\n                });\n            }\n            seek(mediaRef, shouldBeTime);\n            lastSeek.current = shouldBeTime;\n            lastSeekDueToShift.current = shouldBeTime;\n            if (playing && !isVariableFpsVideo) {\n                if (playbackRate > 0) {\n                    bufferUntilFirstFrame(shouldBeTime);\n                }\n                if (mediaRef.current.paused) {\n                    playAndHandleNotAllowedError(mediaRef, mediaType, onAutoPlayError);\n                }\n            }\n            if (!onlyWarnForMediaSeekingError) {\n                warnAboutNonSeekableMedia(mediaRef.current, onlyWarnForMediaSeekingError ? \"console-warning\" : \"console-error\");\n            }\n            return;\n        }\n        const seekThreshold = playing ? 0.15 : 0.00001;\n        const makesSenseToSeek = Math.abs(mediaRef.current.currentTime - shouldBeTime) > seekThreshold;\n        const isMediaTagBufferingOrStalled = isMediaTagBuffering || isBuffering();\n        const isSomethingElseBuffering = buffering.buffering.current && !isMediaTagBufferingOrStalled;\n        if (!playing || isSomethingElseBuffering) {\n            if (makesSenseToSeek) {\n                seek(mediaRef, shouldBeTime);\n                lastSeek.current = shouldBeTime;\n            }\n            return;\n        }\n        if (mediaRef.current.paused && !mediaRef.current.ended || absoluteFrame === 0) {\n            if (makesSenseToSeek) {\n                seek(mediaRef, shouldBeTime);\n                lastSeek.current = shouldBeTime;\n            }\n            playAndHandleNotAllowedError(mediaRef, mediaType, onAutoPlayError);\n            if (!isVariableFpsVideo) {\n                if (playbackRate > 0) {\n                    bufferUntilFirstFrame(shouldBeTime);\n                }\n            }\n        }\n    }, [\n        absoluteFrame,\n        acceptableTimeShiftButLessThanDuration,\n        bufferUntilFirstFrame,\n        buffering.buffering,\n        currentTime,\n        debugSeeking,\n        desiredUnclampedTime,\n        isBuffering,\n        isMediaTagBuffering,\n        mediaRef,\n        mediaType,\n        onlyWarnForMediaSeekingError,\n        playbackRate,\n        playing,\n        src,\n        onAutoPlayError\n    ]);\n};\n// src/use-media-tag-volume.ts\n\nvar useMediaTagVolume = (mediaRef)=>{\n    const [actualVolume, setActualVolume] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(1);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        const ref = mediaRef.current;\n        if (!ref) {\n            return;\n        }\n        const onChange = ()=>{\n            setActualVolume(ref.volume);\n        };\n        ref.addEventListener(\"volumechange\", onChange);\n        return ()=>ref.removeEventListener(\"volumechange\", onChange);\n    }, [\n        mediaRef\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        const ref = mediaRef.current;\n        if (!ref) {\n            return;\n        }\n        if (ref.volume !== actualVolume) {\n            setActualVolume(ref.volume);\n        }\n    }, [\n        actualVolume,\n        mediaRef\n    ]);\n    return actualVolume;\n};\n// src/use-sync-volume-with-media-tag.ts\n\n// src/is-approximately-the-same.ts\nvar FLOATING_POINT_ERROR_THRESHOLD = 0.00001;\nvar isApproximatelyTheSame = (num1, num2)=>{\n    return Math.abs(num1 - num2) < FLOATING_POINT_ERROR_THRESHOLD;\n};\n// src/use-sync-volume-with-media-tag.ts\nvar useSyncVolumeWithMediaTag = ({ volumePropFrame, actualVolume, volume, mediaVolume, mediaRef })=>{\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        const userPreferredVolume = evaluateVolume({\n            frame: volumePropFrame,\n            volume,\n            mediaVolume,\n            allowAmplificationDuringRender: false\n        });\n        if (!isApproximatelyTheSame(userPreferredVolume, actualVolume) && mediaRef.current) {\n            mediaRef.current.volume = userPreferredVolume;\n        }\n    }, [\n        actualVolume,\n        volumePropFrame,\n        mediaRef,\n        volume,\n        mediaVolume\n    ]);\n};\n// src/volume-position-state.ts\n\nvar MediaVolumeContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)({\n    mediaMuted: false,\n    mediaVolume: 1\n});\nvar SetMediaVolumeContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)({\n    setMediaMuted: ()=>{\n        throw new Error(\"default\");\n    },\n    setMediaVolume: ()=>{\n        throw new Error(\"default\");\n    }\n});\nvar useMediaVolumeState = ()=>{\n    const { mediaVolume } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(MediaVolumeContext);\n    const { setMediaVolume } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(SetMediaVolumeContext);\n    return (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        return [\n            mediaVolume,\n            setMediaVolume\n        ];\n    }, [\n        mediaVolume,\n        setMediaVolume\n    ]);\n};\nvar useMediaMutedState = ()=>{\n    const { mediaMuted } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(MediaVolumeContext);\n    const { setMediaMuted } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(SetMediaVolumeContext);\n    return (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        return [\n            mediaMuted,\n            setMediaMuted\n        ];\n    }, [\n        mediaMuted,\n        setMediaMuted\n    ]);\n};\n// src/audio/shared-audio-tags.tsx\n\n\nvar EMPTY_AUDIO = \"data:audio/mp3;base64,/+MYxAAJcAV8AAgAABn//////+/gQ5BAMA+D4Pg+BAQBAEAwD4Pg+D4EBAEAQDAPg++hYBH///hUFQVBUFREDQNHmf///////+MYxBUGkAGIMAAAAP/29Xt6lUxBTUUzLjEwMFVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV/+MYxDUAAANIAAAAAFVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV\";\nvar compareProps = (obj1, obj2)=>{\n    const keysA = Object.keys(obj1).sort();\n    const keysB = Object.keys(obj2).sort();\n    if (keysA.length !== keysB.length) {\n        return false;\n    }\n    for(let i = 0; i < keysA.length; i++){\n        if (keysA[i] !== keysB[i]) {\n            return false;\n        }\n        if (obj1[keysA[i]] !== obj2[keysB[i]]) {\n            return false;\n        }\n    }\n    return true;\n};\nvar didPropChange = (key, newProp, prevProp)=>{\n    if (key === \"src\" && !prevProp.startsWith(\"data:\") && !newProp.startsWith(\"data:\")) {\n        return new URL(prevProp, window.origin).toString() !== new URL(newProp, window.origin).toString();\n    }\n    if (prevProp === newProp) {\n        return false;\n    }\n    return true;\n};\nvar SharedAudioContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)(null);\nvar SharedAudioContextProvider = ({ children, numberOfAudioTags, component })=>{\n    const audios = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)([]);\n    const [initialNumberOfAudioTags] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(numberOfAudioTags);\n    if (numberOfAudioTags !== initialNumberOfAudioTags) {\n        throw new Error(\"The number of shared audio tags has changed dynamically. Once you have set this property, you cannot change it afterwards.\");\n    }\n    const refs = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        return new Array(numberOfAudioTags).fill(true).map(()=>{\n            return {\n                id: Math.random(),\n                ref: /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createRef)()\n            };\n        });\n    }, [\n        numberOfAudioTags\n    ]);\n    const takenAudios = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(new Array(numberOfAudioTags).fill(false));\n    const rerenderAudios = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        refs.forEach(({ ref, id })=>{\n            const data = audios.current?.find((a)=>a.id === id);\n            const { current } = ref;\n            if (!current) {\n                return;\n            }\n            if (data === undefined) {\n                current.src = EMPTY_AUDIO;\n                return;\n            }\n            if (!data) {\n                throw new TypeError(\"Expected audio data to be there\");\n            }\n            Object.keys(data.props).forEach((key)=>{\n                if (didPropChange(key, data.props[key], current[key])) {\n                    current[key] = data.props[key];\n                }\n            });\n        });\n    }, [\n        refs\n    ]);\n    const registerAudio = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((aud, audioId)=>{\n        const found = audios.current?.find((a)=>a.audioId === audioId);\n        if (found) {\n            return found;\n        }\n        const firstFreeAudio = takenAudios.current.findIndex((a)=>a === false);\n        if (firstFreeAudio === -1) {\n            throw new Error(`Tried to simultaneously mount ${numberOfAudioTags + 1} <Audio /> tags at the same time. With the current settings, the maximum amount of <Audio /> tags is limited to ${numberOfAudioTags} at the same time. Remotion pre-mounts silent audio tags to help avoid browser autoplay restrictions. See https://remotion.dev/docs/player/autoplay#use-the-numberofsharedaudiotags-property for more information on how to increase this limit.`);\n        }\n        const { id, ref } = refs[firstFreeAudio];\n        const cloned = [\n            ...takenAudios.current\n        ];\n        cloned[firstFreeAudio] = id;\n        takenAudios.current = cloned;\n        const newElem = {\n            props: aud,\n            id,\n            el: ref,\n            audioId\n        };\n        audios.current?.push(newElem);\n        rerenderAudios();\n        return newElem;\n    }, [\n        numberOfAudioTags,\n        refs,\n        rerenderAudios\n    ]);\n    const unregisterAudio = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((id)=>{\n        const cloned = [\n            ...takenAudios.current\n        ];\n        const index = refs.findIndex((r)=>r.id === id);\n        if (index === -1) {\n            throw new TypeError(\"Error occured in \");\n        }\n        cloned[index] = false;\n        takenAudios.current = cloned;\n        audios.current = audios.current?.filter((a)=>a.id !== id);\n        rerenderAudios();\n    }, [\n        refs,\n        rerenderAudios\n    ]);\n    const updateAudio = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(({ aud, audioId, id })=>{\n        let changed = false;\n        audios.current = audios.current?.map((prevA)=>{\n            if (prevA.id === id) {\n                const isTheSame = compareProps(aud, prevA.props);\n                if (isTheSame) {\n                    return prevA;\n                }\n                changed = true;\n                return {\n                    ...prevA,\n                    props: aud,\n                    audioId\n                };\n            }\n            return prevA;\n        });\n        if (changed) {\n            rerenderAudios();\n        }\n    }, [\n        rerenderAudios\n    ]);\n    const playAllAudios = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        refs.forEach((ref)=>{\n            playAndHandleNotAllowedError(ref.ref, \"audio\", null);\n        });\n    }, [\n        refs\n    ]);\n    const value = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        return {\n            registerAudio,\n            unregisterAudio,\n            updateAudio,\n            playAllAudios,\n            numberOfAudioTags\n        };\n    }, [\n        numberOfAudioTags,\n        playAllAudios,\n        registerAudio,\n        unregisterAudio,\n        updateAudio\n    ]);\n    const resetAudio = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        takenAudios.current = new Array(numberOfAudioTags).fill(false);\n        audios.current = [];\n        rerenderAudios();\n    }, [\n        numberOfAudioTags,\n        rerenderAudios\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        return ()=>{\n            resetAudio();\n        };\n    }, [\n        component,\n        resetAudio\n    ]);\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxs)(SharedAudioContext.Provider, {\n        value,\n        children: [\n            refs.map(({ id, ref })=>{\n                return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"audio\", {\n                    ref,\n                    preload: \"metadata\",\n                    src: EMPTY_AUDIO\n                }, id);\n            }),\n            children\n        ]\n    });\n};\nvar useSharedAudio = (aud, audioId)=>{\n    const ctx = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(SharedAudioContext);\n    const [elem] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(()=>{\n        if (ctx && ctx.numberOfAudioTags > 0) {\n            return ctx.registerAudio(aud, audioId);\n        }\n        return {\n            el: /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createRef(),\n            id: Math.random(),\n            props: aud,\n            audioId\n        };\n    });\n    const effectToUse = react__WEBPACK_IMPORTED_MODULE_0__.useInsertionEffect ?? react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect;\n    if (typeof document !== \"undefined\") {\n        effectToUse(()=>{\n            if (ctx && ctx.numberOfAudioTags > 0) {\n                ctx.updateAudio({\n                    id: elem.id,\n                    aud,\n                    audioId\n                });\n            }\n        }, [\n            aud,\n            ctx,\n            elem.id,\n            audioId\n        ]);\n        effectToUse(()=>{\n            return ()=>{\n                if (ctx && ctx.numberOfAudioTags > 0) {\n                    ctx.unregisterAudio(elem.id);\n                }\n            };\n        }, [\n            ctx,\n            elem.id\n        ]);\n    }\n    return elem;\n};\n// src/audio/AudioForPreview.tsx\n\nvar AudioForDevelopmentForwardRefFunction = (props, ref)=>{\n    const [initialShouldPreMountAudioElements] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(props.shouldPreMountAudioTags);\n    if (props.shouldPreMountAudioTags !== initialShouldPreMountAudioElements) {\n        throw new Error(\"Cannot change the behavior for pre-mounting audio tags dynamically.\");\n    }\n    const { volume, muted, playbackRate, shouldPreMountAudioTags, src, onDuration, acceptableTimeShiftInSeconds, _remotionInternalNeedsDurationCalculation, _remotionInternalNativeLoopPassed, _remotionInternalStack, _remotionDebugSeeking, allowAmplificationDuringRender, name, pauseWhenBuffering, showInTimeline, loopVolumeCurveBehavior, stack, ...nativeProps } = props;\n    const [mediaVolume] = useMediaVolumeState();\n    const [mediaMuted] = useMediaMutedState();\n    const volumePropFrame = useFrameForVolumeProp(loopVolumeCurveBehavior ?? \"repeat\");\n    const { hidden } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(SequenceVisibilityToggleContext);\n    if (!src) {\n        throw new TypeError(\"No 'src' was passed to <Audio>.\");\n    }\n    const preloadedSrc = usePreload(src);\n    const sequenceContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(SequenceContext);\n    const [timelineId] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(()=>String(Math.random()));\n    const isSequenceHidden = hidden[timelineId] ?? false;\n    const userPreferredVolume = evaluateVolume({\n        frame: volumePropFrame,\n        volume,\n        mediaVolume,\n        allowAmplificationDuringRender: false\n    });\n    const propsToPass = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        return {\n            muted: muted || mediaMuted || isSequenceHidden || userPreferredVolume <= 0,\n            src: preloadedSrc,\n            loop: _remotionInternalNativeLoopPassed,\n            ...nativeProps\n        };\n    }, [\n        _remotionInternalNativeLoopPassed,\n        isSequenceHidden,\n        mediaMuted,\n        muted,\n        nativeProps,\n        preloadedSrc,\n        userPreferredVolume\n    ]);\n    const id = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>`audio-${random(src ?? \"\")}-${sequenceContext?.relativeFrom}-${sequenceContext?.cumulatedFrom}-${sequenceContext?.durationInFrames}-muted:${props.muted}-loop:${props.loop}`, [\n        src,\n        sequenceContext?.relativeFrom,\n        sequenceContext?.cumulatedFrom,\n        sequenceContext?.durationInFrames,\n        props.muted,\n        props.loop\n    ]);\n    const audioRef = useSharedAudio(propsToPass, id).el;\n    const actualVolume = useMediaTagVolume(audioRef);\n    useSyncVolumeWithMediaTag({\n        volumePropFrame,\n        actualVolume,\n        volume,\n        mediaVolume,\n        mediaRef: audioRef\n    });\n    useMediaInTimeline({\n        volume,\n        mediaVolume,\n        mediaRef: audioRef,\n        src,\n        mediaType: \"audio\",\n        playbackRate: playbackRate ?? 1,\n        displayName: name ?? null,\n        id: timelineId,\n        stack: _remotionInternalStack,\n        showInTimeline,\n        premountDisplay: null,\n        onAutoPlayError: null\n    });\n    useMediaPlayback({\n        mediaRef: audioRef,\n        src,\n        mediaType: \"audio\",\n        playbackRate: playbackRate ?? 1,\n        onlyWarnForMediaSeekingError: false,\n        acceptableTimeshift: acceptableTimeShiftInSeconds ?? DEFAULT_ACCEPTABLE_TIMESHIFT,\n        isPremounting: Boolean(sequenceContext?.premounting),\n        pauseWhenBuffering,\n        debugSeeking: _remotionDebugSeeking,\n        onAutoPlayError: null\n    });\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useImperativeHandle)(ref, ()=>{\n        return audioRef.current;\n    }, [\n        audioRef\n    ]);\n    const currentOnDurationCallback = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)();\n    currentOnDurationCallback.current = onDuration;\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        const { current } = audioRef;\n        if (!current) {\n            return;\n        }\n        if (current.duration) {\n            currentOnDurationCallback.current?.(current.src, current.duration);\n            return;\n        }\n        const onLoadedMetadata = ()=>{\n            currentOnDurationCallback.current?.(current.src, current.duration);\n        };\n        current.addEventListener(\"loadedmetadata\", onLoadedMetadata);\n        return ()=>{\n            current.removeEventListener(\"loadedmetadata\", onLoadedMetadata);\n        };\n    }, [\n        audioRef,\n        src\n    ]);\n    if (initialShouldPreMountAudioElements) {\n        return null;\n    }\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"audio\", {\n        ref: audioRef,\n        preload: \"metadata\",\n        ...propsToPass\n    });\n};\nvar AudioForPreview = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(AudioForDevelopmentForwardRefFunction);\n// src/audio/AudioForRendering.tsx\n\n// src/delay-render.ts\nif (false) {}\nvar handles = [];\nif (false) {}\nvar DELAY_RENDER_CALLSTACK_TOKEN = \"The delayRender was called:\";\nvar DELAY_RENDER_RETRIES_LEFT = \"Retries left: \";\nvar DELAY_RENDER_RETRY_TOKEN = \"- Rendering the frame will be retried.\";\nvar defaultTimeout = 30000;\nvar delayRender = (label, options)=>{\n    if (typeof label !== \"string\" && typeof label !== \"undefined\") {\n        throw new Error(\"The label parameter of delayRender() must be a string or undefined, got: \" + JSON.stringify(label));\n    }\n    const handle = Math.random();\n    handles.push(handle);\n    const called = Error().stack?.replace(/^Error/g, \"\") ?? \"\";\n    if (getRemotionEnvironment().isRendering) {\n        const timeoutToUse = (options?.timeoutInMilliseconds ?? ( true ? defaultTimeout : 0)) - 2000;\n        if (false) {}\n    }\n    if (false) {}\n    return handle;\n};\nvar continueRender = (handle)=>{\n    if (typeof handle === \"undefined\") {\n        throw new TypeError(\"The continueRender() method must be called with a parameter that is the return value of delayRender(). No value was passed.\");\n    }\n    if (typeof handle !== \"number\") {\n        throw new TypeError(\"The parameter passed into continueRender() must be the return value of delayRender() which is a number. Got: \" + JSON.stringify(handle));\n    }\n    handles = handles.filter((h)=>{\n        if (h === handle) {\n            if (getRemotionEnvironment().isRendering) {\n                clearTimeout(window.remotion_delayRenderTimeouts[handle].timeout);\n                delete window.remotion_delayRenderTimeouts[handle];\n            }\n            return false;\n        }\n        return true;\n    });\n    if (handles.length === 0 && \"undefined\" !== \"undefined\") {}\n};\n// src/audio/AudioForRendering.tsx\n\nvar AudioForRenderingRefForwardingFunction = (props, ref)=>{\n    const audioRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const { volume: volumeProp, playbackRate, allowAmplificationDuringRender, onDuration, toneFrequency, _remotionInternalNeedsDurationCalculation, _remotionInternalNativeLoopPassed, acceptableTimeShiftInSeconds, name, onError, delayRenderRetries, delayRenderTimeoutInMilliseconds, loopVolumeCurveBehavior, pauseWhenBuffering, ...nativeProps } = props;\n    const absoluteFrame = useTimelinePosition();\n    const volumePropFrame = useFrameForVolumeProp(loopVolumeCurveBehavior ?? \"repeat\");\n    const frame = useCurrentFrame();\n    const sequenceContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(SequenceContext);\n    const { registerRenderAsset, unregisterRenderAsset } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(RenderAssetManager);\n    const id = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>`audio-${random(props.src ?? \"\")}-${sequenceContext?.relativeFrom}-${sequenceContext?.cumulatedFrom}-${sequenceContext?.durationInFrames}`, [\n        props.src,\n        sequenceContext?.relativeFrom,\n        sequenceContext?.cumulatedFrom,\n        sequenceContext?.durationInFrames\n    ]);\n    const volume = evaluateVolume({\n        volume: volumeProp,\n        frame: volumePropFrame,\n        mediaVolume: 1,\n        allowAmplificationDuringRender: allowAmplificationDuringRender ?? false\n    });\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useImperativeHandle)(ref, ()=>{\n        return audioRef.current;\n    }, []);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (!props.src) {\n            throw new Error(\"No src passed\");\n        }\n        if (!window.remotion_audioEnabled) {\n            return;\n        }\n        if (props.muted) {\n            return;\n        }\n        if (volume <= 0) {\n            return;\n        }\n        registerRenderAsset({\n            type: \"audio\",\n            src: getAbsoluteSrc(props.src),\n            id,\n            frame: absoluteFrame,\n            volume,\n            mediaFrame: frame,\n            playbackRate: props.playbackRate ?? 1,\n            allowAmplificationDuringRender: allowAmplificationDuringRender ?? false,\n            toneFrequency: toneFrequency ?? null,\n            audioStartFrame: Math.max(0, -(sequenceContext?.relativeFrom ?? 0))\n        });\n        return ()=>unregisterRenderAsset(id);\n    }, [\n        props.muted,\n        props.src,\n        registerRenderAsset,\n        absoluteFrame,\n        id,\n        unregisterRenderAsset,\n        volume,\n        volumePropFrame,\n        frame,\n        playbackRate,\n        props.playbackRate,\n        allowAmplificationDuringRender,\n        toneFrequency,\n        sequenceContext?.relativeFrom\n    ]);\n    const { src } = props;\n    const needsToRenderAudioTag = ref || _remotionInternalNeedsDurationCalculation;\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect)(()=>{\n        if (window.process?.env?.NODE_ENV === \"test\") {\n            return;\n        }\n        if (!needsToRenderAudioTag) {\n            return;\n        }\n        const newHandle = delayRender(\"Loading <Audio> duration with src=\" + src, {\n            retries: delayRenderRetries ?? undefined,\n            timeoutInMilliseconds: delayRenderTimeoutInMilliseconds ?? undefined\n        });\n        const { current } = audioRef;\n        const didLoad = ()=>{\n            if (current?.duration) {\n                onDuration(current.src, current.duration);\n            }\n            continueRender(newHandle);\n        };\n        if (current?.duration) {\n            onDuration(current.src, current.duration);\n            continueRender(newHandle);\n        } else {\n            current?.addEventListener(\"loadedmetadata\", didLoad, {\n                once: true\n            });\n        }\n        return ()=>{\n            current?.removeEventListener(\"loadedmetadata\", didLoad);\n            continueRender(newHandle);\n        };\n    }, [\n        src,\n        onDuration,\n        needsToRenderAudioTag,\n        delayRenderRetries,\n        delayRenderTimeoutInMilliseconds\n    ]);\n    if (!needsToRenderAudioTag) {\n        return null;\n    }\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"audio\", {\n        ref: audioRef,\n        ...nativeProps\n    });\n};\nvar AudioForRendering = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(AudioForRenderingRefForwardingFunction);\n// src/audio/Audio.tsx\n\nvar AudioRefForwardingFunction = (props, ref)=>{\n    const audioContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(SharedAudioContext);\n    const { startFrom, endAt, name, stack, pauseWhenBuffering, showInTimeline, _remotionDebugSeeking, ...otherProps } = props;\n    const { loop, ...propsOtherThanLoop } = props;\n    const { fps } = useVideoConfig();\n    const environment = getRemotionEnvironment();\n    const { durations, setDurations } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(DurationsContext);\n    if (typeof props.src !== \"string\") {\n        throw new TypeError(`The \\`<Audio>\\` tag requires a string for \\`src\\`, but got ${JSON.stringify(props.src)} instead.`);\n    }\n    const preloadedSrc = usePreload(props.src);\n    const onError = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((e)=>{\n        console.log(e.currentTarget.error);\n        const errMessage = `Could not play audio with src ${preloadedSrc}: ${e.currentTarget.error}. See https://remotion.dev/docs/media-playback-error for help.`;\n        if (loop) {\n            cancelRender(new Error(errMessage));\n        } else {\n            console.warn(errMessage);\n        }\n    }, [\n        loop,\n        preloadedSrc\n    ]);\n    const onDuration = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((src, durationInSeconds)=>{\n        setDurations({\n            type: \"got-duration\",\n            durationInSeconds,\n            src\n        });\n    }, [\n        setDurations\n    ]);\n    const durationFetched = durations[getAbsoluteSrc(preloadedSrc)] ?? durations[getAbsoluteSrc(props.src)];\n    if (loop && durationFetched !== undefined) {\n        const duration = durationFetched * fps;\n        return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(Loop, {\n            layout: \"none\",\n            durationInFrames: calculateLoopDuration({\n                endAt,\n                mediaDuration: duration,\n                playbackRate: props.playbackRate ?? 1,\n                startFrom\n            }),\n            children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(Audio, {\n                ...propsOtherThanLoop,\n                ref,\n                _remotionInternalNativeLoopPassed: true\n            })\n        });\n    }\n    if (typeof startFrom !== \"undefined\" || typeof endAt !== \"undefined\") {\n        validateStartFromProps(startFrom, endAt);\n        const startFromFrameNo = startFrom ?? 0;\n        const endAtFrameNo = endAt ?? Infinity;\n        return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(Sequence, {\n            layout: \"none\",\n            from: 0 - startFromFrameNo,\n            showInTimeline: false,\n            durationInFrames: endAtFrameNo,\n            name,\n            children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(Audio, {\n                _remotionInternalNeedsDurationCalculation: Boolean(loop),\n                pauseWhenBuffering: pauseWhenBuffering ?? false,\n                ...otherProps,\n                ref\n            })\n        });\n    }\n    validateMediaProps(props, \"Audio\");\n    if (environment.isRendering) {\n        return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(AudioForRendering, {\n            onDuration,\n            ...props,\n            ref,\n            onError,\n            _remotionInternalNeedsDurationCalculation: Boolean(loop)\n        });\n    }\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(AudioForPreview, {\n        _remotionInternalNativeLoopPassed: props._remotionInternalNativeLoopPassed ?? false,\n        _remotionDebugSeeking: _remotionDebugSeeking ?? false,\n        _remotionInternalStack: stack ?? null,\n        shouldPreMountAudioTags: audioContext !== null && audioContext.numberOfAudioTags > 0,\n        ...props,\n        ref,\n        onError,\n        onDuration,\n        pauseWhenBuffering: pauseWhenBuffering ?? false,\n        _remotionInternalNeedsDurationCalculation: Boolean(loop),\n        showInTimeline: showInTimeline ?? true\n    });\n};\nvar Audio = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(AudioRefForwardingFunction);\naddSequenceStackTraces(Audio);\n// src/Composition.tsx\n\n\n// src/Folder.tsx\n\n// src/validation/validate-folder-name.ts\nvar getRegex = ()=>/^([a-zA-Z0-9-\\u4E00-\\u9FFF])+$/g;\nvar isFolderNameValid = (name)=>name.match(getRegex());\nvar validateFolderName = (name)=>{\n    if (name === undefined || name === null) {\n        throw new TypeError(\"You must pass a name to a <Folder />.\");\n    }\n    if (typeof name !== \"string\") {\n        throw new TypeError(`The \"name\" you pass into <Folder /> must be a string. Got: ${typeof name}`);\n    }\n    if (!isFolderNameValid(name)) {\n        throw new Error(`Folder name can only contain a-z, A-Z, 0-9 and -. You passed ${name}`);\n    }\n};\nvar invalidFolderNameErrorMessage = `Folder name must match ${String(getRegex())}`;\n// src/Folder.tsx\n\nvar FolderContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)({\n    folderName: null,\n    parentName: null\n});\nvar Folder = ({ name, children })=>{\n    const parent = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(FolderContext);\n    const { registerFolder, unregisterFolder } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(CompositionManager);\n    validateFolderName(name);\n    const parentNameArr = [\n        parent.parentName,\n        parent.folderName\n    ].filter(truthy);\n    const parentName = parentNameArr.length === 0 ? null : parentNameArr.join(\"/\");\n    const value = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        return {\n            folderName: name,\n            parentName\n        };\n    }, [\n        name,\n        parentName\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        registerFolder(name, parentName);\n        return ()=>{\n            unregisterFolder(name, parentName);\n        };\n    }, [\n        name,\n        parent.folderName,\n        parentName,\n        registerFolder,\n        unregisterFolder\n    ]);\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(FolderContext.Provider, {\n        value,\n        children\n    });\n};\n// src/loading-indicator.tsx\n\nvar rotate = {\n    transform: `rotate(90deg)`\n};\nvar ICON_SIZE = 40;\nvar label = {\n    color: \"white\",\n    fontSize: 14,\n    fontFamily: \"sans-serif\"\n};\nvar container = {\n    justifyContent: \"center\",\n    alignItems: \"center\"\n};\nvar Loading = ()=>{\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxs)(AbsoluteFill, {\n        style: container,\n        id: \"remotion-comp-loading\",\n        children: [\n            /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"style\", {\n                type: \"text/css\",\n                children: `\n\t\t\t\t@keyframes anim {\n\t\t\t\t\tfrom {\n\t\t\t\t\t\topacity: 0\n\t\t\t\t\t}\n\t\t\t\t\tto {\n\t\t\t\t\t\topacity: 1\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t#remotion-comp-loading {\n\t\t\t\t\tanimation: anim 2s;\n\t\t\t\t\tanimation-fill-mode: forwards;\n\t\t\t\t}\n\t\t\t`\n            }),\n            /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"svg\", {\n                width: ICON_SIZE,\n                height: ICON_SIZE,\n                viewBox: \"-100 -100 400 400\",\n                style: rotate,\n                children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"path\", {\n                    fill: \"#555\",\n                    stroke: \"#555\",\n                    strokeWidth: \"100\",\n                    strokeLinejoin: \"round\",\n                    d: \"M 2 172 a 196 100 0 0 0 195 5 A 196 240 0 0 0 100 2.259 A 196 240 0 0 0 2 172 z\"\n                })\n            }),\n            /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxs)(\"p\", {\n                style: label,\n                children: [\n                    \"Resolving \",\n                    \"<Suspense>\",\n                    \"...\"\n                ]\n            })\n        ]\n    });\n};\n// src/portal-node.ts\nvar _portalNode = null;\nvar portalNode = ()=>{\n    if (!_portalNode) {\n        if (typeof document === \"undefined\") {\n            throw new Error(\"Tried to call an API that only works in the browser from outside the browser\");\n        }\n        _portalNode = document.createElement(\"div\");\n        _portalNode.style.position = \"absolute\";\n        _portalNode.style.top = \"0px\";\n        _portalNode.style.left = \"0px\";\n        _portalNode.style.right = \"0px\";\n        _portalNode.style.bottom = \"0px\";\n        _portalNode.style.width = \"100%\";\n        _portalNode.style.height = \"100%\";\n        _portalNode.style.display = \"flex\";\n        _portalNode.style.flexDirection = \"column\";\n        const containerNode = document.createElement(\"div\");\n        containerNode.style.position = \"fixed\";\n        containerNode.style.top = -999999 + \"px\";\n        containerNode.appendChild(_portalNode);\n        document.body.appendChild(containerNode);\n    }\n    return _portalNode;\n};\n// src/use-lazy-component.ts\n\nvar useLazyComponent = (compProps)=>{\n    const lazy = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        if (\"lazyComponent\" in compProps && typeof compProps.lazyComponent !== \"undefined\") {\n            return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.lazy(compProps.lazyComponent);\n        }\n        if (\"component\" in compProps) {\n            if (typeof document === \"undefined\") {\n                return compProps.component;\n            }\n            return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.lazy(()=>Promise.resolve({\n                    default: compProps.component\n                }));\n        }\n        throw new Error(\"You must pass either 'component' or 'lazyComponent'\");\n    }, [\n        compProps.component,\n        compProps.lazyComponent\n    ]);\n    return lazy;\n};\n// src/validation/validate-composition-id.ts\nvar getRegex2 = ()=>/^([a-zA-Z0-9-\\u4E00-\\u9FFF])+$/g;\nvar isCompositionIdValid = (id)=>id.match(getRegex2());\nvar validateCompositionId = (id)=>{\n    if (!isCompositionIdValid(id)) {\n        throw new Error(`Composition id can only contain a-z, A-Z, 0-9, CJK characters and -. You passed ${id}`);\n    }\n};\nvar invalidCompositionErrorMessage = `Composition ID must match ${String(getRegex2())}`;\n// src/validation/validate-default-props.ts\nvar validateDefaultAndInputProps = (defaultProps, name, compositionId)=>{\n    if (!defaultProps) {\n        return;\n    }\n    if (typeof defaultProps !== \"object\") {\n        throw new Error(`\"${name}\" must be an object, but you passed a value of type ${typeof defaultProps}`);\n    }\n    if (Array.isArray(defaultProps)) {\n        throw new Error(`\"${name}\" must be an object, an array was passed ${compositionId ? `for composition \"${compositionId}\"` : \"\"}`);\n    }\n};\n// src/Composition.tsx\n\nvar ClipComposition = ({ children })=>{\n    const { clipRegion } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(NativeLayersContext);\n    const style = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        return {\n            display: \"flex\",\n            flexDirection: \"row\",\n            opacity: clipRegion === \"hide\" ? 0 : 1,\n            clipPath: clipRegion && clipRegion !== \"hide\" ? `polygon(${clipRegion.x}px ${clipRegion.y}px, ${clipRegion.x}px ${clipRegion.height + clipRegion.y}px, ${clipRegion.width + clipRegion.x}px ${clipRegion.height + clipRegion.y}px, ${clipRegion.width + clipRegion.x}px ${clipRegion.y}px)` : undefined\n        };\n    }, [\n        clipRegion\n    ]);\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(AbsoluteFill, {\n        style,\n        children\n    });\n};\nvar Fallback = ()=>{\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        const fallback = delayRender(\"Waiting for Root component to unsuspend\");\n        return ()=>continueRender(fallback);\n    }, []);\n    return null;\n};\nvar Composition = ({ width, height, fps, durationInFrames, id, defaultProps, schema, ...compProps })=>{\n    const { registerComposition, unregisterComposition } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(CompositionManager);\n    const video = useVideo();\n    const lazy = useLazyComponent(compProps);\n    const nonce = useNonce();\n    const isPlayer = useIsPlayer();\n    const environment = getRemotionEnvironment();\n    const canUseComposition = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(CanUseRemotionHooks);\n    if (canUseComposition) {\n        if (isPlayer) {\n            throw new Error(\"<Composition> was mounted inside the `component` that was passed to the <Player>. See https://remotion.dev/docs/wrong-composition-mount for help.\");\n        }\n        throw new Error(\"<Composition> mounted inside another composition. See https://remotion.dev/docs/wrong-composition-mount for help.\");\n    }\n    const { folderName, parentName } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(FolderContext);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (!id) {\n            throw new Error(\"No id for composition passed.\");\n        }\n        validateCompositionId(id);\n        validateDefaultAndInputProps(defaultProps, \"defaultProps\", id);\n        registerComposition({\n            durationInFrames: durationInFrames ?? undefined,\n            fps: fps ?? undefined,\n            height: height ?? undefined,\n            width: width ?? undefined,\n            id,\n            folderName,\n            component: lazy,\n            defaultProps: serializeThenDeserializeInStudio(defaultProps ?? {}),\n            nonce,\n            parentFolderName: parentName,\n            schema: schema ?? null,\n            calculateMetadata: compProps.calculateMetadata ?? null\n        });\n        return ()=>{\n            unregisterComposition(id);\n        };\n    }, [\n        durationInFrames,\n        fps,\n        height,\n        lazy,\n        id,\n        folderName,\n        defaultProps,\n        registerComposition,\n        unregisterComposition,\n        width,\n        nonce,\n        parentName,\n        schema,\n        compProps.calculateMetadata\n    ]);\n    const resolved = useResolvedVideoConfig(id);\n    if (environment.isStudio && video && video.component === lazy) {\n        const Comp = lazy;\n        if (resolved === null || resolved.type !== \"success\") {\n            return null;\n        }\n        return /*#__PURE__*/ (0,react_dom__WEBPACK_IMPORTED_MODULE_2__.createPortal)(/* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(ClipComposition, {\n            children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(CanUseRemotionHooksProvider, {\n                children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(react__WEBPACK_IMPORTED_MODULE_0__.Suspense, {\n                    fallback: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(Loading, {}),\n                    children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(Comp, {\n                        ...resolved.result.props ?? {}\n                    })\n                })\n            })\n        }), portalNode());\n    }\n    if (environment.isRendering && video && video.component === lazy) {\n        const Comp = lazy;\n        if (resolved === null || resolved.type !== \"success\") {\n            return null;\n        }\n        return /*#__PURE__*/ (0,react_dom__WEBPACK_IMPORTED_MODULE_2__.createPortal)(/* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(CanUseRemotionHooksProvider, {\n            children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(react__WEBPACK_IMPORTED_MODULE_0__.Suspense, {\n                fallback: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(Fallback, {}),\n                children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(Comp, {\n                    ...resolved.result.props ?? {}\n                })\n            })\n        }), portalNode());\n    }\n    return null;\n};\n// src/CompositionManager.tsx\n\n\nvar compositionsRef = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createRef();\nvar CompositionManagerProvider = ({ children, numberOfAudioTags })=>{\n    const [compositions, setCompositions] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n    const currentcompositionsRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(compositions);\n    const [folders, setFolders] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n    const [canvasContent, setCanvasContent] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const [currentCompositionMetadata, setCurrentCompositionMetadata] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const updateCompositions = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((updateComps)=>{\n        setCompositions((comps)=>{\n            const updated = updateComps(comps);\n            currentcompositionsRef.current = updated;\n            return updated;\n        });\n    }, []);\n    const registerComposition = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((comp)=>{\n        updateCompositions((comps)=>{\n            if (comps.find((c)=>c.id === comp.id)) {\n                throw new Error(`Multiple composition with id ${comp.id} are registered.`);\n            }\n            const value = [\n                ...comps,\n                comp\n            ].slice().sort((a, b)=>a.nonce - b.nonce);\n            return value;\n        });\n    }, [\n        updateCompositions\n    ]);\n    const unregisterComposition = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((id)=>{\n        setCompositions((comps)=>{\n            return comps.filter((c)=>c.id !== id);\n        });\n    }, []);\n    const registerFolder = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((name, parent)=>{\n        setFolders((prevFolders)=>{\n            return [\n                ...prevFolders,\n                {\n                    name,\n                    parent\n                }\n            ];\n        });\n    }, []);\n    const unregisterFolder = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((name, parent)=>{\n        setFolders((prevFolders)=>{\n            return prevFolders.filter((p)=>!(p.name === name && p.parent === parent));\n        });\n    }, []);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useImperativeHandle)(compositionsRef, ()=>{\n        return {\n            getCompositions: ()=>currentcompositionsRef.current\n        };\n    }, []);\n    const composition = compositions.find((c)=>canvasContent?.type === \"composition\" ? c.id === canvasContent.compositionId : null);\n    const updateCompositionDefaultProps = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((id, newDefaultProps)=>{\n        setCompositions((comps)=>{\n            const updated = comps.map((c)=>{\n                if (c.id === id) {\n                    return {\n                        ...c,\n                        defaultProps: newDefaultProps\n                    };\n                }\n                return c;\n            });\n            return updated;\n        });\n    }, []);\n    const contextValue = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        return {\n            compositions,\n            registerComposition,\n            unregisterComposition,\n            folders,\n            registerFolder,\n            unregisterFolder,\n            currentCompositionMetadata,\n            setCurrentCompositionMetadata,\n            canvasContent,\n            setCanvasContent,\n            updateCompositionDefaultProps\n        };\n    }, [\n        compositions,\n        registerComposition,\n        unregisterComposition,\n        folders,\n        registerFolder,\n        unregisterFolder,\n        currentCompositionMetadata,\n        canvasContent,\n        updateCompositionDefaultProps\n    ]);\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(CompositionManager.Provider, {\n        value: contextValue,\n        children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(SequenceManagerProvider, {\n            children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(RenderAssetManagerProvider, {\n                children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(ResolveCompositionConfig, {\n                    children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(SharedAudioContextProvider, {\n                        numberOfAudioTags,\n                        component: composition?.component ?? null,\n                        children\n                    })\n                })\n            })\n        })\n    });\n};\n// src/bezier.ts\nfunction a(aA1, aA2) {\n    return 1 - 3 * aA2 + 3 * aA1;\n}\nfunction b(aA1, aA2) {\n    return 3 * aA2 - 6 * aA1;\n}\nfunction c(aA1) {\n    return 3 * aA1;\n}\nfunction calcBezier(aT, aA1, aA2) {\n    return ((a(aA1, aA2) * aT + b(aA1, aA2)) * aT + c(aA1)) * aT;\n}\nfunction getSlope(aT, aA1, aA2) {\n    return 3 * a(aA1, aA2) * aT * aT + 2 * b(aA1, aA2) * aT + c(aA1);\n}\nfunction binarySubdivide({ aX, _aA, _aB, mX1, mX2 }) {\n    let currentX;\n    let currentT;\n    let i = 0;\n    let aA = _aA;\n    let aB = _aB;\n    do {\n        currentT = aA + (aB - aA) / 2;\n        currentX = calcBezier(currentT, mX1, mX2) - aX;\n        if (currentX > 0) {\n            aB = currentT;\n        } else {\n            aA = currentT;\n        }\n    }while (Math.abs(currentX) > SUBDIVISION_PRECISION && ++i < SUBDIVISION_MAX_ITERATIONS);\n    return currentT;\n}\nfunction newtonRaphsonIterate(aX, _aGuessT, mX1, mX2) {\n    let aGuessT = _aGuessT;\n    for(let i = 0; i < NEWTON_ITERATIONS; ++i){\n        const currentSlope = getSlope(aGuessT, mX1, mX2);\n        if (currentSlope === 0) {\n            return aGuessT;\n        }\n        const currentX = calcBezier(aGuessT, mX1, mX2) - aX;\n        aGuessT -= currentX / currentSlope;\n    }\n    return aGuessT;\n}\nfunction bezier(mX1, mY1, mX2, mY2) {\n    if (!(mX1 >= 0 && mX1 <= 1 && mX2 >= 0 && mX2 <= 1)) {\n        throw new Error(\"bezier x values must be in [0, 1] range\");\n    }\n    const sampleValues = float32ArraySupported ? new Float32Array(kSplineTableSize) : new Array(kSplineTableSize);\n    if (mX1 !== mY1 || mX2 !== mY2) {\n        for(let i = 0; i < kSplineTableSize; ++i){\n            sampleValues[i] = calcBezier(i * kSampleStepSize, mX1, mX2);\n        }\n    }\n    function getTForX(aX) {\n        let intervalStart = 0;\n        let currentSample = 1;\n        const lastSample = kSplineTableSize - 1;\n        for(; currentSample !== lastSample && sampleValues[currentSample] <= aX; ++currentSample){\n            intervalStart += kSampleStepSize;\n        }\n        --currentSample;\n        const dist = (aX - sampleValues[currentSample]) / (sampleValues[currentSample + 1] - sampleValues[currentSample]);\n        const guessForT = intervalStart + dist * kSampleStepSize;\n        const initialSlope = getSlope(guessForT, mX1, mX2);\n        if (initialSlope >= NEWTON_MIN_SLOPE) {\n            return newtonRaphsonIterate(aX, guessForT, mX1, mX2);\n        }\n        if (initialSlope === 0) {\n            return guessForT;\n        }\n        return binarySubdivide({\n            aX,\n            _aA: intervalStart,\n            _aB: intervalStart + kSampleStepSize,\n            mX1,\n            mX2\n        });\n    }\n    return function(x) {\n        if (mX1 === mY1 && mX2 === mY2) {\n            return x;\n        }\n        if (x === 0) {\n            return 0;\n        }\n        if (x === 1) {\n            return 1;\n        }\n        return calcBezier(getTForX(x), mY1, mY2);\n    };\n}\nvar NEWTON_ITERATIONS = 4;\nvar NEWTON_MIN_SLOPE = 0.001;\nvar SUBDIVISION_PRECISION = 0.0000001;\nvar SUBDIVISION_MAX_ITERATIONS = 10;\nvar kSplineTableSize = 11;\nvar kSampleStepSize = 1 / (kSplineTableSize - 1);\nvar float32ArraySupported = typeof Float32Array === \"function\";\n// src/easing.ts\nclass Easing {\n    static step0(n) {\n        return n > 0 ? 1 : 0;\n    }\n    static step1(n) {\n        return n >= 1 ? 1 : 0;\n    }\n    static linear(t) {\n        return t;\n    }\n    static ease(t) {\n        return Easing.bezier(0.42, 0, 1, 1)(t);\n    }\n    static quad(t) {\n        return t * t;\n    }\n    static cubic(t) {\n        return t * t * t;\n    }\n    static poly(n) {\n        return (t)=>t ** n;\n    }\n    static sin(t) {\n        return 1 - Math.cos(t * Math.PI / 2);\n    }\n    static circle(t) {\n        return 1 - Math.sqrt(1 - t * t);\n    }\n    static exp(t) {\n        return 2 ** (10 * (t - 1));\n    }\n    static elastic(bounciness = 1) {\n        const p = bounciness * Math.PI;\n        return (t)=>1 - Math.cos(t * Math.PI / 2) ** 3 * Math.cos(t * p);\n    }\n    static back(s = 1.70158) {\n        return (t)=>t * t * ((s + 1) * t - s);\n    }\n    static bounce(t) {\n        if (t < 1 / 2.75) {\n            return 7.5625 * t * t;\n        }\n        if (t < 2 / 2.75) {\n            const t2_ = t - 1.5 / 2.75;\n            return 7.5625 * t2_ * t2_ + 0.75;\n        }\n        if (t < 2.5 / 2.75) {\n            const t2_ = t - 2.25 / 2.75;\n            return 7.5625 * t2_ * t2_ + 0.9375;\n        }\n        const t2 = t - 2.625 / 2.75;\n        return 7.5625 * t2 * t2 + 0.984375;\n    }\n    static bezier(x1, y1, x2, y2) {\n        return bezier(x1, y1, x2, y2);\n    }\n    static in(easing) {\n        return easing;\n    }\n    static out(easing) {\n        return (t)=>1 - easing(1 - t);\n    }\n    static inOut(easing) {\n        return (t)=>{\n            if (t < 0.5) {\n                return easing(t * 2) / 2;\n            }\n            return 1 - easing((1 - t) * 2) / 2;\n        };\n    }\n}\n// src/v5-flag.ts\nvar ENABLE_V5_BREAKING_CHANGES = false;\n// src/get-static-files.ts\nvar warnedServer = false;\nvar warnedPlayer = false;\nvar warnServerOnce = ()=>{\n    if (warnedServer) {\n        return;\n    }\n    warnedServer = true;\n    console.warn(\"Called getStaticFiles() on the server. The API is only available in the browser. An empty array was returned.\");\n};\nvar warnPlayerOnce = ()=>{\n    if (warnedPlayer) {\n        return;\n    }\n    warnedPlayer = true;\n    console.warn(\"Called getStaticFiles() while using the Remotion Player. The API is only available while using the Remotion Studio. An empty array was returned.\");\n};\nvar getStaticFiles = ()=>{\n    if (ENABLE_V5_BREAKING_CHANGES) {\n        throw new Error(\"getStaticFiles() has moved into the `@remotion/studio` package. Update your imports.\");\n    }\n    if (typeof document === \"undefined\") {\n        warnServerOnce();\n        return [];\n    }\n    if (window.remotion_isPlayer) {\n        warnPlayerOnce();\n        return [];\n    }\n    return window.remotion_staticFiles;\n};\n// src/IFrame.tsx\n\n\nvar IFrameRefForwarding = ({ onLoad, onError, delayRenderRetries, delayRenderTimeoutInMilliseconds, ...props2 }, ref)=>{\n    const [handle] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(()=>delayRender(`Loading <IFrame> with source ${props2.src}`, {\n            retries: delayRenderRetries ?? undefined,\n            timeoutInMilliseconds: delayRenderTimeoutInMilliseconds ?? undefined\n        }));\n    const didLoad = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((e)=>{\n        continueRender(handle);\n        onLoad?.(e);\n    }, [\n        handle,\n        onLoad\n    ]);\n    const didGetError = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((e)=>{\n        continueRender(handle);\n        if (onError) {\n            onError(e);\n        } else {\n            console.error(\"Error loading iframe:\", e, \"Handle the event using the onError() prop to make this message disappear.\");\n        }\n    }, [\n        handle,\n        onError\n    ]);\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"iframe\", {\n        ...props2,\n        ref,\n        onError: didGetError,\n        onLoad: didLoad\n    });\n};\nvar IFrame = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(IFrameRefForwarding);\n// src/Img.tsx\n\nfunction exponentialBackoff(errorCount) {\n    return 1000 * 2 ** (errorCount - 1);\n}\n\nvar ImgRefForwarding = ({ onError, maxRetries = 2, src, pauseWhenLoading, delayRenderRetries, delayRenderTimeoutInMilliseconds, onImageFrame, ...props2 }, ref)=>{\n    const imageRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const errors = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)({});\n    const { delayPlayback } = useBufferState();\n    const sequenceContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(SequenceContext);\n    if (!src) {\n        throw new Error('No \"src\" prop was passed to <Img>.');\n    }\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useImperativeHandle)(ref, ()=>{\n        return imageRef.current;\n    }, []);\n    const actualSrc = usePreload(src);\n    const retryIn = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((timeout)=>{\n        if (!imageRef.current) {\n            return;\n        }\n        const currentSrc = imageRef.current.src;\n        setTimeout(()=>{\n            if (!imageRef.current) {\n                return;\n            }\n            const newSrc = imageRef.current?.src;\n            if (newSrc !== currentSrc) {\n                return;\n            }\n            imageRef.current.removeAttribute(\"src\");\n            imageRef.current.setAttribute(\"src\", newSrc);\n        }, timeout);\n    }, []);\n    const didGetError = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((e)=>{\n        if (!errors.current) {\n            return;\n        }\n        errors.current[imageRef.current?.src] = (errors.current[imageRef.current?.src] ?? 0) + 1;\n        if (onError && (errors.current[imageRef.current?.src] ?? 0) > maxRetries) {\n            onError(e);\n            return;\n        }\n        if ((errors.current[imageRef.current?.src] ?? 0) <= maxRetries) {\n            const backoff = exponentialBackoff(errors.current[imageRef.current?.src] ?? 0);\n            console.warn(`Could not load image with source ${imageRef.current?.src}, retrying again in ${backoff}ms`);\n            retryIn(backoff);\n            return;\n        }\n        cancelRender(\"Error loading image with src: \" + imageRef.current?.src);\n    }, [\n        maxRetries,\n        onError,\n        retryIn\n    ]);\n    if (false) {}\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"img\", {\n        ...props2,\n        ref: imageRef,\n        onError: didGetError\n    });\n};\nvar Img = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(ImgRefForwarding);\n// src/default-css.ts\nvar exports_default_css = {};\n__export(exports_default_css, {\n    makeDefaultPreviewCSS: ()=>makeDefaultPreviewCSS,\n    injectCSS: ()=>injectCSS,\n    OFFTHREAD_VIDEO_CLASS_NAME: ()=>OFFTHREAD_VIDEO_CLASS_NAME\n});\nvar injected = {};\nvar injectCSS = (css)=>{\n    if (typeof document === \"undefined\") {\n        return;\n    }\n    if (injected[css]) {\n        return;\n    }\n    const head = document.head || document.getElementsByTagName(\"head\")[0];\n    const style = document.createElement(\"style\");\n    style.appendChild(document.createTextNode(css));\n    head.prepend(style);\n    injected[css] = true;\n};\nvar OFFTHREAD_VIDEO_CLASS_NAME = \"__remotion_offthreadvideo\";\nvar makeDefaultPreviewCSS = (scope, backgroundColor)=>{\n    if (!scope) {\n        return `\n    * {\n      box-sizing: border-box;\n    }\n    body {\n      margin: 0;\n\t    background-color: ${backgroundColor};\n    }\n    .${OFFTHREAD_VIDEO_CLASS_NAME} {\n      object-fit: contain;\n    }\n    `;\n    }\n    return `\n    ${scope} * {\n      box-sizing: border-box;\n    }\n    ${scope} *:-webkit-full-screen {\n      width: 100%;\n      height: 100%;\n    }\n    ${scope} .${OFFTHREAD_VIDEO_CLASS_NAME} {\n      object-fit: contain;\n    }\n  `;\n};\n// src/get-preview-dom-element.ts\nvar REMOTION_STUDIO_CONTAINER_ELEMENT = \"__remotion-studio-container\";\nvar getPreviewDomElement = ()=>{\n    return document.getElementById(REMOTION_STUDIO_CONTAINER_ELEMENT);\n};\n// src/register-root.ts\nvar Root = null;\nvar listeners = [];\nvar registerRoot = (comp)=>{\n    if (!comp) {\n        throw new Error(`You must pass a React component to registerRoot(), but ${JSON.stringify(comp)} was passed.`);\n    }\n    if (Root) {\n        throw new Error(\"registerRoot() was called more than once.\");\n    }\n    Root = comp;\n    listeners.forEach((l)=>{\n        l(comp);\n    });\n};\nvar getRoot = ()=>{\n    return Root;\n};\nvar waitForRoot = (fn)=>{\n    if (Root) {\n        fn(Root);\n        return ()=>{\n            return;\n        };\n    }\n    listeners.push(fn);\n    return ()=>{\n        listeners = listeners.filter((l)=>l !== fn);\n    };\n};\n// src/RemotionRoot.tsx\n\n\nvar RemotionRoot = ({ children, numberOfAudioTags })=>{\n    const [remotionRootId] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(()=>String(random(null)));\n    const [frame, setFrame] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(()=>getInitialFrameState());\n    const [playing, setPlaying] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const imperativePlaying = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\n    const [fastRefreshes, setFastRefreshes] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(0);\n    const [playbackRate, setPlaybackRate] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(1);\n    const audioAndVideoTags = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)([]);\n    if (false) {}\n    const timelineContextValue = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        return {\n            frame,\n            playing,\n            imperativePlaying,\n            rootId: remotionRootId,\n            playbackRate,\n            setPlaybackRate,\n            audioAndVideoTags\n        };\n    }, [\n        frame,\n        playbackRate,\n        playing,\n        remotionRootId\n    ]);\n    const setTimelineContextValue = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        return {\n            setFrame,\n            setPlaying\n        };\n    }, []);\n    const nonceContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        let counter = 0;\n        return {\n            getNonce: ()=>counter++,\n            fastRefreshes\n        };\n    }, [\n        fastRefreshes\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (true) {\n            if (__webpack_module__.hot) {\n                __webpack_module__.hot.addStatusHandler((status)=>{\n                    if (status === \"idle\") {\n                        setFastRefreshes((i)=>i + 1);\n                    }\n                });\n            }\n        }\n    }, []);\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(NonceContext.Provider, {\n        value: nonceContext,\n        children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(TimelineContext.Provider, {\n            value: timelineContextValue,\n            children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(SetTimelineContext.Provider, {\n                value: setTimelineContextValue,\n                children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(EditorPropsProvider, {\n                    children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(PrefetchProvider, {\n                        children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(NativeLayersProvider, {\n                            children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(CompositionManagerProvider, {\n                                numberOfAudioTags,\n                                children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(DurationsContextProvider, {\n                                    children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(BufferingProvider, {\n                                        children\n                                    })\n                                })\n                            })\n                        })\n                    })\n                })\n            })\n        })\n    });\n};\n// src/setup-env-variables.ts\nvar getEnvVariables = ()=>{\n    if (getRemotionEnvironment().isRendering) {\n        const param = window.remotion_envVariables;\n        if (!param) {\n            return {};\n        }\n        return {\n            ...JSON.parse(param),\n            NODE_ENV: \"production\"\n        };\n    }\n    if (false) {}\n    return {\n        NODE_ENV: \"production\"\n    };\n};\nvar setupEnvVariables = ()=>{\n    const env = getEnvVariables();\n    if (!window.process) {\n        window.process = {};\n    }\n    if (!window.process.env) {\n        window.process.env = {};\n    }\n    Object.keys(env).forEach((key)=>{\n        window.process.env[key] = env[key];\n    });\n};\n// src/use-current-scale.ts\n\nvar CurrentScaleContext = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);\nvar PreviewSizeContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)({\n    setSize: ()=>{\n        return;\n    },\n    size: {\n        size: \"auto\",\n        translation: {\n            x: 0,\n            y: 0\n        }\n    }\n});\nvar calculateScale = ({ canvasSize, compositionHeight, compositionWidth, previewSize })=>{\n    const heightRatio = canvasSize.height / compositionHeight;\n    const widthRatio = canvasSize.width / compositionWidth;\n    const ratio = Math.min(heightRatio, widthRatio);\n    return previewSize === \"auto\" ? ratio : Number(previewSize);\n};\nvar useCurrentScale = (options)=>{\n    const hasContext = react__WEBPACK_IMPORTED_MODULE_0__.useContext(CurrentScaleContext);\n    const zoomContext = react__WEBPACK_IMPORTED_MODULE_0__.useContext(PreviewSizeContext);\n    const config = useUnsafeVideoConfig();\n    if (hasContext === null || config === null || zoomContext === null) {\n        if (options?.dontThrowIfOutsideOfRemotion) {\n            return 1;\n        }\n        if (getRemotionEnvironment().isRendering) {\n            return 1;\n        }\n        throw new Error([\n            \"useCurrentScale() was called outside of a Remotion context.\",\n            \"This hook can only be called in a component that is being rendered by Remotion.\",\n            \"If you want to this hook to return 1 outside of Remotion, pass {dontThrowIfOutsideOfRemotion: true} as an option.\",\n            \"If you think you called this hook in a Remotion component, make sure all versions of Remotion are aligned.\"\n        ].join(\"\\n\"));\n    }\n    if (hasContext.type === \"scale\") {\n        return hasContext.scale;\n    }\n    return calculateScale({\n        canvasSize: hasContext.canvasSize,\n        compositionHeight: config.height,\n        compositionWidth: config.width,\n        previewSize: zoomContext.size.size\n    });\n};\n// src/watch-static-file.ts\nvar WATCH_REMOTION_STATIC_FILES = \"remotion_staticFilesChanged\";\nvar watchStaticFile = (fileName, callback)=>{\n    if (ENABLE_V5_BREAKING_CHANGES) {\n        throw new Error(\"watchStaticFile() has moved into the `@remotion/studio` package. Update your imports.\");\n    }\n    if (!getRemotionEnvironment().isStudio) {\n        console.warn(\"The API is only available while using the Remotion Studio.\");\n        return {\n            cancel: ()=>{\n                return;\n            }\n        };\n    }\n    const withoutStaticBase = fileName.startsWith(window.remotion_staticBase) ? fileName.replace(window.remotion_staticBase, \"\") : fileName;\n    const withoutLeadingSlash = withoutStaticBase.startsWith(\"/\") ? withoutStaticBase.slice(1) : withoutStaticBase;\n    let prevFileData = window.remotion_staticFiles.find((file)=>file.name === withoutLeadingSlash);\n    const checkFile = (event)=>{\n        const staticFiles = event.detail.files;\n        const newFileData = staticFiles.find((file)=>file.name === withoutLeadingSlash);\n        if (!newFileData) {\n            if (prevFileData !== undefined) {\n                callback(null);\n            }\n            prevFileData = undefined;\n            return;\n        }\n        if (prevFileData === undefined || prevFileData.lastModified !== newFileData.lastModified) {\n            callback(newFileData);\n            prevFileData = newFileData;\n        }\n    };\n    window.addEventListener(WATCH_REMOTION_STATIC_FILES, checkFile);\n    const cancel = ()=>{\n        return window.removeEventListener(WATCH_REMOTION_STATIC_FILES, checkFile);\n    };\n    return {\n        cancel\n    };\n};\n// src/wrap-remotion-context.tsx\n\nfunction useRemotionContexts() {\n    const compositionManagerCtx = react__WEBPACK_IMPORTED_MODULE_0__.useContext(CompositionManager);\n    const timelineContext = react__WEBPACK_IMPORTED_MODULE_0__.useContext(TimelineContext);\n    const setTimelineContext = react__WEBPACK_IMPORTED_MODULE_0__.useContext(SetTimelineContext);\n    const sequenceContext = react__WEBPACK_IMPORTED_MODULE_0__.useContext(SequenceContext);\n    const nonceContext = react__WEBPACK_IMPORTED_MODULE_0__.useContext(NonceContext);\n    const canUseRemotionHooksContext = react__WEBPACK_IMPORTED_MODULE_0__.useContext(CanUseRemotionHooks);\n    const nativeLayersContext = react__WEBPACK_IMPORTED_MODULE_0__.useContext(NativeLayersContext);\n    const preloadContext = react__WEBPACK_IMPORTED_MODULE_0__.useContext(PreloadContext);\n    const resolveCompositionContext = react__WEBPACK_IMPORTED_MODULE_0__.useContext(ResolveCompositionContext);\n    const renderAssetManagerContext = react__WEBPACK_IMPORTED_MODULE_0__.useContext(RenderAssetManager);\n    const sequenceManagerContext = react__WEBPACK_IMPORTED_MODULE_0__.useContext(SequenceManager);\n    const bufferManagerContext = react__WEBPACK_IMPORTED_MODULE_0__.useContext(BufferingContextReact);\n    return (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>({\n            compositionManagerCtx,\n            timelineContext,\n            setTimelineContext,\n            sequenceContext,\n            nonceContext,\n            canUseRemotionHooksContext,\n            nativeLayersContext,\n            preloadContext,\n            resolveCompositionContext,\n            renderAssetManagerContext,\n            sequenceManagerContext,\n            bufferManagerContext\n        }), [\n        compositionManagerCtx,\n        nonceContext,\n        sequenceContext,\n        setTimelineContext,\n        timelineContext,\n        canUseRemotionHooksContext,\n        nativeLayersContext,\n        preloadContext,\n        resolveCompositionContext,\n        renderAssetManagerContext,\n        sequenceManagerContext,\n        bufferManagerContext\n    ]);\n}\n\nvar RemotionContextProvider = (props2)=>{\n    const { children, contexts } = props2;\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(CanUseRemotionHooks.Provider, {\n        value: contexts.canUseRemotionHooksContext,\n        children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(NonceContext.Provider, {\n            value: contexts.nonceContext,\n            children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(NativeLayersContext.Provider, {\n                value: contexts.nativeLayersContext,\n                children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(PreloadContext.Provider, {\n                    value: contexts.preloadContext,\n                    children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(CompositionManager.Provider, {\n                        value: contexts.compositionManagerCtx,\n                        children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(SequenceManager.Provider, {\n                            value: contexts.sequenceManagerContext,\n                            children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(RenderAssetManager.Provider, {\n                                value: contexts.renderAssetManagerContext,\n                                children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(ResolveCompositionContext.Provider, {\n                                    value: contexts.resolveCompositionContext,\n                                    children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(TimelineContext.Provider, {\n                                        value: contexts.timelineContext,\n                                        children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(SetTimelineContext.Provider, {\n                                            value: contexts.setTimelineContext,\n                                            children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(SequenceContext.Provider, {\n                                                value: contexts.sequenceContext,\n                                                children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(BufferingContextReact.Provider, {\n                                                    value: contexts.bufferManagerContext,\n                                                    children\n                                                })\n                                            })\n                                        })\n                                    })\n                                })\n                            })\n                        })\n                    })\n                })\n            })\n        })\n    });\n};\n// src/internals.ts\nvar Internals = {\n    useUnsafeVideoConfig,\n    Timeline: exports_timeline_position_state,\n    CompositionManager,\n    SequenceManager,\n    SequenceVisibilityToggleContext,\n    RemotionRoot,\n    useVideo,\n    getRoot,\n    useMediaVolumeState,\n    useMediaMutedState,\n    useLazyComponent,\n    truthy,\n    SequenceContext,\n    useRemotionContexts,\n    RemotionContextProvider,\n    CSSUtils: exports_default_css,\n    setupEnvVariables,\n    MediaVolumeContext,\n    SetMediaVolumeContext,\n    getRemotionEnvironment,\n    SharedAudioContext,\n    SharedAudioContextProvider,\n    invalidCompositionErrorMessage,\n    isCompositionIdValid,\n    getPreviewDomElement,\n    compositionsRef,\n    portalNode,\n    waitForRoot,\n    CanUseRemotionHooksProvider,\n    CanUseRemotionHooks,\n    PrefetchProvider,\n    DurationsContextProvider,\n    IsPlayerContextProvider,\n    useIsPlayer,\n    EditorPropsProvider,\n    EditorPropsContext,\n    usePreload,\n    NonceContext,\n    resolveVideoConfig,\n    useResolvedVideoConfig,\n    resolveCompositionsRef,\n    ResolveCompositionConfig,\n    REMOTION_STUDIO_CONTAINER_ELEMENT,\n    RenderAssetManager,\n    persistCurrentFrame,\n    useTimelineSetFrame,\n    NativeLayersProvider,\n    ClipComposition,\n    isIosSafari,\n    WATCH_REMOTION_STATIC_FILES,\n    addSequenceStackTraces,\n    useMediaStartsAt,\n    BufferingProvider,\n    BufferingContextReact,\n    enableSequenceStackTraces,\n    CurrentScaleContext,\n    PreviewSizeContext,\n    calculateScale,\n    editorPropsProviderRef,\n    PROPS_UPDATED_EXTERNALLY,\n    validateRenderAsset\n};\n// src/interpolate-colors.ts\nfunction call(...args) {\n    return \"\\\\(\\\\s*(\" + args.join(\")\\\\s*,\\\\s*(\") + \")\\\\s*\\\\)\";\n}\nfunction getMatchers() {\n    const cachedMatchers = {\n        rgb: undefined,\n        rgba: undefined,\n        hsl: undefined,\n        hsla: undefined,\n        hex3: undefined,\n        hex4: undefined,\n        hex5: undefined,\n        hex6: undefined,\n        hex8: undefined\n    };\n    if (cachedMatchers.rgb === undefined) {\n        cachedMatchers.rgb = new RegExp(\"rgb\" + call(NUMBER, NUMBER, NUMBER));\n        cachedMatchers.rgba = new RegExp(\"rgba\" + call(NUMBER, NUMBER, NUMBER, NUMBER));\n        cachedMatchers.hsl = new RegExp(\"hsl\" + call(NUMBER, PERCENTAGE, PERCENTAGE));\n        cachedMatchers.hsla = new RegExp(\"hsla\" + call(NUMBER, PERCENTAGE, PERCENTAGE, NUMBER));\n        cachedMatchers.hex3 = /^#([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/;\n        cachedMatchers.hex4 = /^#([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/;\n        cachedMatchers.hex6 = /^#([0-9a-fA-F]{6})$/;\n        cachedMatchers.hex8 = /^#([0-9a-fA-F]{8})$/;\n    }\n    return cachedMatchers;\n}\nfunction hue2rgb(p, q, t) {\n    if (t < 0) {\n        t += 1;\n    }\n    if (t > 1) {\n        t -= 1;\n    }\n    if (t < 1 / 6) {\n        return p + (q - p) * 6 * t;\n    }\n    if (t < 1 / 2) {\n        return q;\n    }\n    if (t < 2 / 3) {\n        return p + (q - p) * (2 / 3 - t) * 6;\n    }\n    return p;\n}\nfunction hslToRgb(h, s, l) {\n    const q = l < 0.5 ? l * (1 + s) : l + s - l * s;\n    const p = 2 * l - q;\n    const r = hue2rgb(p, q, h + 1 / 3);\n    const g = hue2rgb(p, q, h);\n    const b2 = hue2rgb(p, q, h - 1 / 3);\n    return Math.round(r * 255) << 24 | Math.round(g * 255) << 16 | Math.round(b2 * 255) << 8;\n}\nfunction parse255(str) {\n    const int = Number.parseInt(str, 10);\n    if (int < 0) {\n        return 0;\n    }\n    if (int > 255) {\n        return 255;\n    }\n    return int;\n}\nfunction parse360(str) {\n    const int = Number.parseFloat(str);\n    return (int % 360 + 360) % 360 / 360;\n}\nfunction parse1(str) {\n    const num = Number.parseFloat(str);\n    if (num < 0) {\n        return 0;\n    }\n    if (num > 1) {\n        return 255;\n    }\n    return Math.round(num * 255);\n}\nfunction parsePercentage(str) {\n    const int = Number.parseFloat(str);\n    if (int < 0) {\n        return 0;\n    }\n    if (int > 100) {\n        return 1;\n    }\n    return int / 100;\n}\nfunction normalizeColor(color) {\n    const matchers = getMatchers();\n    let match;\n    if (matchers.hex6) {\n        if (match = matchers.hex6.exec(color)) {\n            return Number.parseInt(match[1] + \"ff\", 16) >>> 0;\n        }\n    }\n    if (colorNames[color] !== undefined) {\n        return colorNames[color];\n    }\n    if (matchers.rgb) {\n        if (match = matchers.rgb.exec(color)) {\n            return (parse255(match[1]) << 24 | parse255(match[2]) << 16 | parse255(match[3]) << 8 | 255) >>> 0;\n        }\n    }\n    if (matchers.rgba) {\n        if (match = matchers.rgba.exec(color)) {\n            return (parse255(match[1]) << 24 | parse255(match[2]) << 16 | parse255(match[3]) << 8 | parse1(match[4])) >>> 0;\n        }\n    }\n    if (matchers.hex3) {\n        if (match = matchers.hex3.exec(color)) {\n            return Number.parseInt(match[1] + match[1] + match[2] + match[2] + match[3] + match[3] + \"ff\", 16) >>> 0;\n        }\n    }\n    if (matchers.hex8) {\n        if (match = matchers.hex8.exec(color)) {\n            return Number.parseInt(match[1], 16) >>> 0;\n        }\n    }\n    if (matchers.hex4) {\n        if (match = matchers.hex4.exec(color)) {\n            return Number.parseInt(match[1] + match[1] + match[2] + match[2] + match[3] + match[3] + match[4] + match[4], 16) >>> 0;\n        }\n    }\n    if (matchers.hsl) {\n        if (match = matchers.hsl.exec(color)) {\n            return (hslToRgb(parse360(match[1]), parsePercentage(match[2]), parsePercentage(match[3])) | 255) >>> 0;\n        }\n    }\n    if (matchers.hsla) {\n        if (match = matchers.hsla.exec(color)) {\n            return (hslToRgb(parse360(match[1]), parsePercentage(match[2]), parsePercentage(match[3])) | parse1(match[4])) >>> 0;\n        }\n    }\n    throw new Error(`invalid color string ${color} provided`);\n}\nfunction processColor(color) {\n    const normalizedColor = normalizeColor(color);\n    return (normalizedColor << 24 | normalizedColor >>> 8) >>> 0;\n}\nvar NUMBER = \"[-+]?\\\\d*\\\\.?\\\\d+\";\nvar PERCENTAGE = NUMBER + \"%\";\nvar colorNames = {\n    transparent: 0,\n    aliceblue: 4042850303,\n    antiquewhite: 4209760255,\n    aqua: 16777215,\n    aquamarine: 2147472639,\n    azure: 4043309055,\n    beige: 4126530815,\n    bisque: 4293182719,\n    black: 255,\n    blanchedalmond: 4293643775,\n    blue: 65535,\n    blueviolet: 2318131967,\n    brown: 2771004159,\n    burlywood: 3736635391,\n    burntsienna: 3934150143,\n    cadetblue: 1604231423,\n    chartreuse: 2147418367,\n    chocolate: 3530104575,\n    coral: 4286533887,\n    cornflowerblue: 1687547391,\n    cornsilk: 4294499583,\n    crimson: 3692313855,\n    cyan: 16777215,\n    darkblue: 35839,\n    darkcyan: 9145343,\n    darkgoldenrod: 3095792639,\n    darkgray: 2846468607,\n    darkgreen: 6553855,\n    darkgrey: 2846468607,\n    darkkhaki: 3182914559,\n    darkmagenta: 2332068863,\n    darkolivegreen: 1433087999,\n    darkorange: 4287365375,\n    darkorchid: 2570243327,\n    darkred: 2332033279,\n    darksalmon: 3918953215,\n    darkseagreen: 2411499519,\n    darkslateblue: 1211993087,\n    darkslategray: 793726975,\n    darkslategrey: 793726975,\n    darkturquoise: 13554175,\n    darkviolet: 2483082239,\n    deeppink: 4279538687,\n    deepskyblue: 12582911,\n    dimgray: 1768516095,\n    dimgrey: 1768516095,\n    dodgerblue: 512819199,\n    firebrick: 2988581631,\n    floralwhite: 4294635775,\n    forestgreen: 579543807,\n    fuchsia: 4278255615,\n    gainsboro: 3705462015,\n    ghostwhite: 4177068031,\n    gold: 4292280575,\n    goldenrod: 3668254975,\n    gray: 2155905279,\n    green: 8388863,\n    greenyellow: 2919182335,\n    grey: 2155905279,\n    honeydew: 4043305215,\n    hotpink: 4285117695,\n    indianred: 3445382399,\n    indigo: 1258324735,\n    ivory: 4294963455,\n    khaki: 4041641215,\n    lavender: 3873897215,\n    lavenderblush: 4293981695,\n    lawngreen: 2096890111,\n    lemonchiffon: 4294626815,\n    lightblue: 2916673279,\n    lightcoral: 4034953471,\n    lightcyan: 3774873599,\n    lightgoldenrodyellow: 4210742015,\n    lightgray: 3553874943,\n    lightgreen: 2431553791,\n    lightgrey: 3553874943,\n    lightpink: 4290167295,\n    lightsalmon: 4288707327,\n    lightseagreen: 548580095,\n    lightskyblue: 2278488831,\n    lightslategray: 2005441023,\n    lightslategrey: 2005441023,\n    lightsteelblue: 2965692159,\n    lightyellow: 4294959359,\n    lime: 16711935,\n    limegreen: 852308735,\n    linen: 4210091775,\n    magenta: 4278255615,\n    maroon: 2147483903,\n    mediumaquamarine: 1724754687,\n    mediumblue: 52735,\n    mediumorchid: 3126187007,\n    mediumpurple: 2473647103,\n    mediumseagreen: 1018393087,\n    mediumslateblue: 2070474495,\n    mediumspringgreen: 16423679,\n    mediumturquoise: 1221709055,\n    mediumvioletred: 3340076543,\n    midnightblue: 421097727,\n    mintcream: 4127193855,\n    mistyrose: 4293190143,\n    moccasin: 4293178879,\n    navajowhite: 4292783615,\n    navy: 33023,\n    oldlace: 4260751103,\n    olive: 2155872511,\n    olivedrab: 1804477439,\n    orange: 4289003775,\n    orangered: 4282712319,\n    orchid: 3664828159,\n    palegoldenrod: 4008225535,\n    palegreen: 2566625535,\n    paleturquoise: 2951671551,\n    palevioletred: 3681588223,\n    papayawhip: 4293907967,\n    peachpuff: 4292524543,\n    peru: 3448061951,\n    pink: 4290825215,\n    plum: 3718307327,\n    powderblue: 2967529215,\n    purple: 2147516671,\n    rebeccapurple: 1714657791,\n    red: 4278190335,\n    rosybrown: 3163525119,\n    royalblue: 1097458175,\n    saddlebrown: 2336560127,\n    salmon: 4202722047,\n    sandybrown: 4104413439,\n    seagreen: 780883967,\n    seashell: 4294307583,\n    sienna: 2689740287,\n    silver: 3233857791,\n    skyblue: 2278484991,\n    slateblue: 1784335871,\n    slategray: 1887473919,\n    slategrey: 1887473919,\n    snow: 4294638335,\n    springgreen: 16744447,\n    steelblue: 1182971135,\n    tan: 3535047935,\n    teal: 8421631,\n    thistle: 3636451583,\n    tomato: 4284696575,\n    turquoise: 1088475391,\n    violet: 4001558271,\n    wheat: 4125012991,\n    white: 4294967295,\n    whitesmoke: 4126537215,\n    yellow: 4294902015,\n    yellowgreen: 2597139199\n};\nvar opacity = (c2)=>{\n    return (c2 >> 24 & 255) / 255;\n};\nvar red = (c2)=>{\n    return c2 >> 16 & 255;\n};\nvar green = (c2)=>{\n    return c2 >> 8 & 255;\n};\nvar blue = (c2)=>{\n    return c2 & 255;\n};\nvar rgbaColor = (r, g, b2, alpha)=>{\n    return `rgba(${r}, ${g}, ${b2}, ${alpha})`;\n};\nvar interpolateColorsRGB = (value, inputRange, colors)=>{\n    const [r, g, b2, a2] = [\n        red,\n        green,\n        blue,\n        opacity\n    ].map((f)=>{\n        const unrounded = interpolate(value, inputRange, colors.map((c2)=>f(c2)), {\n            extrapolateLeft: \"clamp\",\n            extrapolateRight: \"clamp\"\n        });\n        if (f === opacity) {\n            return Number(unrounded.toFixed(3));\n        }\n        return Math.round(unrounded);\n    });\n    return rgbaColor(r, g, b2, a2);\n};\nvar interpolateColors = (input, inputRange, outputRange)=>{\n    if (typeof input === \"undefined\") {\n        throw new TypeError(\"input can not be undefined\");\n    }\n    if (typeof inputRange === \"undefined\") {\n        throw new TypeError(\"inputRange can not be undefined\");\n    }\n    if (typeof outputRange === \"undefined\") {\n        throw new TypeError(\"outputRange can not be undefined\");\n    }\n    if (inputRange.length !== outputRange.length) {\n        throw new TypeError(\"inputRange (\" + inputRange.length + \" values provided) and outputRange (\" + outputRange.length + \" values provided) must have the same length\");\n    }\n    const processedOutputRange = outputRange.map((c2)=>processColor(c2));\n    return interpolateColorsRGB(input, inputRange, processedOutputRange);\n};\n// src/validate-frame.ts\nvar validateFrame = ({ allowFloats, durationInFrames, frame })=>{\n    if (typeof frame === \"undefined\") {\n        throw new TypeError(`Argument missing for parameter \"frame\"`);\n    }\n    if (typeof frame !== \"number\") {\n        throw new TypeError(`Argument passed for \"frame\" is not a number: ${frame}`);\n    }\n    if (!Number.isFinite(frame)) {\n        throw new RangeError(`Frame ${frame} is not finite`);\n    }\n    if (frame % 1 !== 0 && !allowFloats) {\n        throw new RangeError(`Argument for frame must be an integer, but got ${frame}`);\n    }\n    if (frame < 0 && frame < -durationInFrames) {\n        throw new RangeError(`Cannot use frame ${frame}: Duration of composition is ${durationInFrames}, therefore the lowest frame that can be rendered is ${-durationInFrames}`);\n    }\n    if (frame > durationInFrames - 1) {\n        throw new RangeError(`Cannot use frame ${frame}: Duration of composition is ${durationInFrames}, therefore the highest frame that can be rendered is ${durationInFrames - 1}`);\n    }\n};\n// src/video/offthread-video-source.ts\nvar getOffthreadVideoSource = ({ src, transparent, currentTime, toneMapped })=>{\n    return `http://localhost:${window.remotion_proxyPort}/proxy?src=${encodeURIComponent(getAbsoluteSrc(src))}&time=${encodeURIComponent(currentTime)}&transparent=${String(transparent)}&toneMapped=${String(toneMapped)}`;\n};\n// src/series/index.tsx\n\n// src/series/flatten-children.tsx\n\nvar flattenChildren = (children)=>{\n    const childrenArray = react__WEBPACK_IMPORTED_MODULE_0__.Children.toArray(children);\n    return childrenArray.reduce((flatChildren, child)=>{\n        if (child.type === react__WEBPACK_IMPORTED_MODULE_0__.Fragment) {\n            return flatChildren.concat(flattenChildren(child.props.children));\n        }\n        flatChildren.push(child);\n        return flatChildren;\n    }, []);\n};\n// src/series/is-inside-series.tsx\n\n\nvar IsInsideSeriesContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)(false);\nvar IsInsideSeriesContainer = ({ children })=>{\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(IsInsideSeriesContext.Provider, {\n        value: true,\n        children\n    });\n};\nvar IsNotInsideSeriesProvider = ({ children })=>{\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(IsInsideSeriesContext.Provider, {\n        value: false,\n        children\n    });\n};\nvar useRequireToBeInsideSeries = ()=>{\n    const isInsideSeries = react__WEBPACK_IMPORTED_MODULE_0__.useContext(IsInsideSeriesContext);\n    if (!isInsideSeries) {\n        throw new Error(\"This component must be inside a <Series /> component.\");\n    }\n};\n// src/series/index.tsx\n\nvar SeriesSequenceRefForwardingFunction = ({ children }, _ref)=>{\n    useRequireToBeInsideSeries();\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(IsNotInsideSeriesProvider, {\n        children\n    });\n};\nvar SeriesSequence = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(SeriesSequenceRefForwardingFunction);\nvar Series = (props2)=>{\n    const childrenValue = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        let startFrame = 0;\n        const flattenedChildren = flattenChildren(props2.children);\n        return react__WEBPACK_IMPORTED_MODULE_0__.Children.map(flattenedChildren, (child, i)=>{\n            const castedChild = child;\n            if (typeof castedChild === \"string\") {\n                if (castedChild.trim() === \"\") {\n                    return null;\n                }\n                throw new TypeError(`The <Series /> component only accepts a list of <Series.Sequence /> components as its children, but you passed a string \"${castedChild}\"`);\n            }\n            if (castedChild.type !== SeriesSequence) {\n                throw new TypeError(`The <Series /> component only accepts a list of <Series.Sequence /> components as its children, but got ${castedChild} instead`);\n            }\n            const debugInfo = `index = ${i}, duration = ${castedChild.props.durationInFrames}`;\n            if (!castedChild?.props.children) {\n                throw new TypeError(`A <Series.Sequence /> component (${debugInfo}) was detected to not have any children. Delete it to fix this error.`);\n            }\n            const durationInFramesProp = castedChild.props.durationInFrames;\n            const { durationInFrames, children: _children, from, name, ...passedProps } = castedChild.props;\n            if (i !== flattenedChildren.length - 1 || durationInFramesProp !== Infinity) {\n                validateDurationInFrames(durationInFramesProp, {\n                    component: `of a <Series.Sequence /> component`,\n                    allowFloats: true\n                });\n            }\n            const offset = castedChild.props.offset ?? 0;\n            if (Number.isNaN(offset)) {\n                throw new TypeError(`The \"offset\" property of a <Series.Sequence /> must not be NaN, but got NaN (${debugInfo}).`);\n            }\n            if (!Number.isFinite(offset)) {\n                throw new TypeError(`The \"offset\" property of a <Series.Sequence /> must be finite, but got ${offset} (${debugInfo}).`);\n            }\n            if (offset % 1 !== 0) {\n                throw new TypeError(`The \"offset\" property of a <Series.Sequence /> must be finite, but got ${offset} (${debugInfo}).`);\n            }\n            const currentStartFrame = startFrame + offset;\n            startFrame += durationInFramesProp + offset;\n            return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(Sequence, {\n                name: name || \"<Series.Sequence>\",\n                from: currentStartFrame,\n                durationInFrames: durationInFramesProp,\n                ...passedProps,\n                ref: castedChild.ref,\n                children: child\n            });\n        });\n    }, [\n        props2.children\n    ]);\n    if (ENABLE_V5_BREAKING_CHANGES) {\n        return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(IsInsideSeriesContainer, {\n            children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(Sequence, {\n                ...props2,\n                children: childrenValue\n            })\n        });\n    }\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(IsInsideSeriesContainer, {\n        children: childrenValue\n    });\n};\nSeries.Sequence = SeriesSequence;\naddSequenceStackTraces(SeriesSequence);\n// src/validation/validation-spring-duration.ts\nvar validateSpringDuration = (dur)=>{\n    if (typeof dur === \"undefined\") {\n        return;\n    }\n    if (typeof dur !== \"number\") {\n        throw new TypeError(`A \"duration\" of a spring must be a \"number\" but is \"${typeof dur}\"`);\n    }\n    if (Number.isNaN(dur)) {\n        throw new TypeError('A \"duration\" of a spring is NaN, which it must not be');\n    }\n    if (!Number.isFinite(dur)) {\n        throw new TypeError('A \"duration\" of a spring must be finite, but is ' + dur);\n    }\n    if (dur <= 0) {\n        throw new TypeError('A \"duration\" of a spring must be positive, but is ' + dur);\n    }\n};\n// src/spring/spring-utils.ts\nfunction advance({ animation, now, config }) {\n    const { toValue, lastTimestamp, current, velocity } = animation;\n    const deltaTime = Math.min(now - lastTimestamp, 64);\n    if (config.damping <= 0) {\n        throw new Error(\"Spring damping must be greater than 0, otherwise the spring() animation will never end, causing an infinite loop.\");\n    }\n    const c2 = config.damping;\n    const m = config.mass;\n    const k = config.stiffness;\n    const cacheKey = [\n        toValue,\n        lastTimestamp,\n        current,\n        velocity,\n        c2,\n        m,\n        k,\n        now\n    ].join(\"-\");\n    if (advanceCache[cacheKey]) {\n        return advanceCache[cacheKey];\n    }\n    const v0 = -velocity;\n    const x0 = toValue - current;\n    const zeta = c2 / (2 * Math.sqrt(k * m));\n    const omega0 = Math.sqrt(k / m);\n    const omega1 = omega0 * Math.sqrt(1 - zeta ** 2);\n    const t = deltaTime / 1000;\n    const sin1 = Math.sin(omega1 * t);\n    const cos1 = Math.cos(omega1 * t);\n    const underDampedEnvelope = Math.exp(-zeta * omega0 * t);\n    const underDampedFrag1 = underDampedEnvelope * (sin1 * ((v0 + zeta * omega0 * x0) / omega1) + x0 * cos1);\n    const underDampedPosition = toValue - underDampedFrag1;\n    const underDampedVelocity = zeta * omega0 * underDampedFrag1 - underDampedEnvelope * (cos1 * (v0 + zeta * omega0 * x0) - omega1 * x0 * sin1);\n    const criticallyDampedEnvelope = Math.exp(-omega0 * t);\n    const criticallyDampedPosition = toValue - criticallyDampedEnvelope * (x0 + (v0 + omega0 * x0) * t);\n    const criticallyDampedVelocity = criticallyDampedEnvelope * (v0 * (t * omega0 - 1) + t * x0 * omega0 * omega0);\n    const animationNode = {\n        toValue,\n        prevPosition: current,\n        lastTimestamp: now,\n        current: zeta < 1 ? underDampedPosition : criticallyDampedPosition,\n        velocity: zeta < 1 ? underDampedVelocity : criticallyDampedVelocity\n    };\n    advanceCache[cacheKey] = animationNode;\n    return animationNode;\n}\nfunction springCalculation({ frame, fps, config = {} }) {\n    const from = 0;\n    const to = 1;\n    const cacheKey = [\n        frame,\n        fps,\n        config.damping,\n        config.mass,\n        config.overshootClamping,\n        config.stiffness\n    ].join(\"-\");\n    if (calculationCache[cacheKey]) {\n        return calculationCache[cacheKey];\n    }\n    let animation = {\n        lastTimestamp: 0,\n        current: from,\n        toValue: to,\n        velocity: 0,\n        prevPosition: 0\n    };\n    const frameClamped = Math.max(0, frame);\n    const unevenRest = frameClamped % 1;\n    for(let f = 0; f <= Math.floor(frameClamped); f++){\n        if (f === Math.floor(frameClamped)) {\n            f += unevenRest;\n        }\n        const time = f / fps * 1000;\n        animation = advance({\n            animation,\n            now: time,\n            config: {\n                ...defaultSpringConfig,\n                ...config\n            }\n        });\n    }\n    calculationCache[cacheKey] = animation;\n    return animation;\n}\nvar defaultSpringConfig = {\n    damping: 10,\n    mass: 1,\n    stiffness: 100,\n    overshootClamping: false\n};\nvar advanceCache = {};\nvar calculationCache = {};\n// src/spring/measure-spring.ts\nfunction measureSpring({ fps, config = {}, threshold = 0.005 }) {\n    if (typeof threshold !== \"number\") {\n        throw new TypeError(`threshold must be a number, got ${threshold} of type ${typeof threshold}`);\n    }\n    if (threshold === 0) {\n        return Infinity;\n    }\n    if (threshold === 1) {\n        return 0;\n    }\n    if (isNaN(threshold)) {\n        throw new TypeError(\"Threshold is NaN\");\n    }\n    if (!Number.isFinite(threshold)) {\n        throw new TypeError(\"Threshold is not finite\");\n    }\n    if (threshold < 0) {\n        throw new TypeError(\"Threshold is below 0\");\n    }\n    const cacheKey = [\n        fps,\n        config.damping,\n        config.mass,\n        config.overshootClamping,\n        config.stiffness,\n        threshold\n    ].join(\"-\");\n    if (cache.has(cacheKey)) {\n        return cache.get(cacheKey);\n    }\n    validateFps(fps, \"to the measureSpring() function\", false);\n    let frame = 0;\n    let finishedFrame = 0;\n    const calc = ()=>{\n        return springCalculation({\n            fps,\n            frame,\n            config\n        });\n    };\n    let animation = calc();\n    const calcDifference = ()=>{\n        return Math.abs(animation.current - animation.toValue);\n    };\n    let difference = calcDifference();\n    while(difference >= threshold){\n        frame++;\n        animation = calc();\n        difference = calcDifference();\n    }\n    finishedFrame = frame;\n    for(let i = 0; i < 20; i++){\n        frame++;\n        animation = calc();\n        difference = calcDifference();\n        if (difference >= threshold) {\n            i = 0;\n            finishedFrame = frame + 1;\n        }\n    }\n    cache.set(cacheKey, finishedFrame);\n    return finishedFrame;\n}\nvar cache = new Map;\n// src/spring/index.ts\nfunction spring({ frame: passedFrame, fps, config = {}, from = 0, to = 1, durationInFrames: passedDurationInFrames, durationRestThreshold, delay = 0, reverse = false }) {\n    validateSpringDuration(passedDurationInFrames);\n    validateFrame({\n        frame: passedFrame,\n        durationInFrames: Infinity,\n        allowFloats: true\n    });\n    validateFps(fps, \"to spring()\", false);\n    const needsToCalculateNaturalDuration = reverse || typeof passedDurationInFrames !== \"undefined\";\n    const naturalDuration = needsToCalculateNaturalDuration ? measureSpring({\n        fps,\n        config,\n        threshold: durationRestThreshold\n    }) : undefined;\n    const naturalDurationGetter = needsToCalculateNaturalDuration ? {\n        get: ()=>naturalDuration\n    } : {\n        get: ()=>{\n            throw new Error(\"did not calculate natural duration, this is an error with Remotion. Please report\");\n        }\n    };\n    const reverseProcessed = reverse ? (passedDurationInFrames ?? naturalDurationGetter.get()) - passedFrame : passedFrame;\n    const delayProcessed = reverseProcessed + (reverse ? delay : -delay);\n    const durationProcessed = passedDurationInFrames === undefined ? delayProcessed : delayProcessed / (passedDurationInFrames / naturalDurationGetter.get());\n    if (passedDurationInFrames && delayProcessed > passedDurationInFrames) {\n        return to;\n    }\n    const spr = springCalculation({\n        fps,\n        frame: durationProcessed,\n        config\n    });\n    const inner2 = config.overshootClamping ? to >= from ? Math.min(spr.current, to) : Math.max(spr.current, to) : spr.current;\n    const interpolated = from === 0 && to === 1 ? inner2 : interpolate(inner2, [\n        0,\n        1\n    ], [\n        from,\n        to\n    ]);\n    return interpolated;\n}\n// src/Still.tsx\n\nvar Still = (props2)=>{\n    const newProps = {\n        ...props2,\n        durationInFrames: 1,\n        fps: 1\n    };\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(Composition, newProps);\n};\n// src/video/OffthreadVideo.tsx\n\n// src/video/OffthreadVideoForRendering.tsx\n\n\nvar OffthreadVideoForRendering = ({ onError, volume: volumeProp, playbackRate, src, muted, allowAmplificationDuringRender, transparent = false, toneMapped = true, toneFrequency, name, loopVolumeCurveBehavior, delayRenderRetries, delayRenderTimeoutInMilliseconds, onVideoFrame, ...props2 })=>{\n    const absoluteFrame = useTimelinePosition();\n    const frame = useCurrentFrame();\n    const volumePropsFrame = useFrameForVolumeProp(loopVolumeCurveBehavior ?? \"repeat\");\n    const videoConfig = useUnsafeVideoConfig();\n    const sequenceContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(SequenceContext);\n    const mediaStartsAt = useMediaStartsAt();\n    const { registerRenderAsset, unregisterRenderAsset } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(RenderAssetManager);\n    if (!src) {\n        throw new TypeError(\"No `src` was passed to <OffthreadVideo>.\");\n    }\n    const id = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>`offthreadvideo-${random(src ?? \"\")}-${sequenceContext?.cumulatedFrom}-${sequenceContext?.relativeFrom}-${sequenceContext?.durationInFrames}`, [\n        src,\n        sequenceContext?.cumulatedFrom,\n        sequenceContext?.relativeFrom,\n        sequenceContext?.durationInFrames\n    ]);\n    if (!videoConfig) {\n        throw new Error(\"No video config found\");\n    }\n    const volume = evaluateVolume({\n        volume: volumeProp,\n        frame: volumePropsFrame,\n        mediaVolume: 1,\n        allowAmplificationDuringRender: allowAmplificationDuringRender ?? false\n    });\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (!src) {\n            throw new Error(\"No src passed\");\n        }\n        if (!window.remotion_audioEnabled) {\n            return;\n        }\n        if (muted) {\n            return;\n        }\n        if (volume <= 0) {\n            return;\n        }\n        registerRenderAsset({\n            type: \"video\",\n            src: getAbsoluteSrc(src),\n            id,\n            frame: absoluteFrame,\n            volume,\n            mediaFrame: frame,\n            playbackRate: playbackRate ?? 1,\n            allowAmplificationDuringRender: allowAmplificationDuringRender ?? false,\n            toneFrequency: toneFrequency ?? null,\n            audioStartFrame: Math.max(0, -(sequenceContext?.relativeFrom ?? 0))\n        });\n        return ()=>unregisterRenderAsset(id);\n    }, [\n        muted,\n        src,\n        registerRenderAsset,\n        id,\n        unregisterRenderAsset,\n        volume,\n        frame,\n        absoluteFrame,\n        playbackRate,\n        allowAmplificationDuringRender,\n        toneFrequency,\n        sequenceContext?.relativeFrom\n    ]);\n    const currentTime = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        return getExpectedMediaFrameUncorrected({\n            frame,\n            playbackRate: playbackRate || 1,\n            startFrom: -mediaStartsAt\n        }) / videoConfig.fps;\n    }, [\n        frame,\n        mediaStartsAt,\n        playbackRate,\n        videoConfig.fps\n    ]);\n    const actualSrc = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        return getOffthreadVideoSource({\n            src,\n            currentTime,\n            transparent,\n            toneMapped\n        });\n    }, [\n        toneMapped,\n        currentTime,\n        src,\n        transparent\n    ]);\n    const [imageSrc, setImageSrc] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect)(()=>{\n        if (!window.remotion_videoEnabled) {\n            return;\n        }\n        const cleanup = [];\n        setImageSrc(null);\n        const controller = new AbortController;\n        const newHandle = delayRender(`Fetching ${actualSrc} from server`, {\n            retries: delayRenderRetries ?? undefined,\n            timeoutInMilliseconds: delayRenderTimeoutInMilliseconds ?? undefined\n        });\n        const execute = async ()=>{\n            try {\n                const res = await fetch(actualSrc, {\n                    signal: controller.signal\n                });\n                if (res.status !== 200) {\n                    if (res.status === 500) {\n                        const json = await res.json();\n                        if (json.error) {\n                            const cleanedUpErrorMessage = json.error.replace(/^Error: /, \"\");\n                            throw new Error(cleanedUpErrorMessage);\n                        }\n                    }\n                    throw new Error(`Server returned status ${res.status} while fetching ${actualSrc}`);\n                }\n                const blob = await res.blob();\n                const url = URL.createObjectURL(blob);\n                cleanup.push(()=>URL.revokeObjectURL(url));\n                setImageSrc({\n                    src: url,\n                    handle: newHandle\n                });\n            } catch (err) {\n                if (err.message.includes(\"aborted\")) {\n                    continueRender(newHandle);\n                    return;\n                }\n                if (controller.signal.aborted) {\n                    continueRender(newHandle);\n                    return;\n                }\n                if (err.message.includes(\"Failed to fetch\")) {\n                    err = new Error(`Failed to fetch ${actualSrc}. This could be caused by Chrome rejecting the request because the disk space is low. Consider increasing the disk size of your environment.`, {\n                        cause: err\n                    });\n                }\n                if (onError) {\n                    onError(err);\n                } else {\n                    cancelRender(err);\n                }\n            }\n        };\n        execute();\n        cleanup.push(()=>{\n            if (controller.signal.aborted) {\n                return;\n            }\n            controller.abort();\n        });\n        return ()=>{\n            cleanup.forEach((c2)=>c2());\n        };\n    }, [\n        actualSrc,\n        delayRenderRetries,\n        delayRenderTimeoutInMilliseconds,\n        onError\n    ]);\n    const onErr = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        if (onError) {\n            onError?.(new Error(\"Failed to load image with src \" + imageSrc));\n        } else {\n            cancelRender(\"Failed to load image with src \" + imageSrc);\n        }\n    }, [\n        imageSrc,\n        onError\n    ]);\n    const className = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        return [\n            OFFTHREAD_VIDEO_CLASS_NAME,\n            props2.className\n        ].filter(truthy).join(\" \");\n    }, [\n        props2.className\n    ]);\n    const onImageFrame = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((img)=>{\n        if (onVideoFrame) {\n            onVideoFrame(img);\n        }\n    }, [\n        onVideoFrame\n    ]);\n    if (!imageSrc || !window.remotion_videoEnabled) {\n        return null;\n    }\n    continueRender(imageSrc.handle);\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(Img, {\n        src: imageSrc.src,\n        className,\n        delayRenderRetries,\n        delayRenderTimeoutInMilliseconds,\n        onImageFrame,\n        ...props2,\n        onError: onErr\n    });\n};\n// src/video/VideoForPreview.tsx\n\n// src/video/emit-video-frame.ts\n\nvar useEmitVideoFrame = ({ ref, onVideoFrame })=>{\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        const { current } = ref;\n        if (!current) {\n            return;\n        }\n        if (!onVideoFrame) {\n            return;\n        }\n        let handle = 0;\n        const callback = ()=>{\n            if (!ref.current) {\n                return;\n            }\n            onVideoFrame(ref.current);\n            handle = ref.current.requestVideoFrameCallback(callback);\n        };\n        callback();\n        return ()=>{\n            current.cancelVideoFrameCallback(handle);\n        };\n    }, [\n        onVideoFrame,\n        ref\n    ]);\n};\n// src/video/VideoForPreview.tsx\n\nvar VideoForDevelopmentRefForwardingFunction = (props2, ref)=>{\n    const videoRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const { volume, muted, playbackRate, onlyWarnForMediaSeekingError, src, onDuration, acceptableTimeShift, acceptableTimeShiftInSeconds, toneFrequency, name, _remotionInternalNativeLoopPassed, _remotionInternalStack, _remotionDebugSeeking, style, pauseWhenBuffering, showInTimeline, loopVolumeCurveBehavior, onError, onAutoPlayError, onVideoFrame, crossOrigin, ...nativeProps } = props2;\n    const volumePropFrame = useFrameForVolumeProp(loopVolumeCurveBehavior ?? \"repeat\");\n    const { fps, durationInFrames } = useVideoConfig();\n    const parentSequence = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(SequenceContext);\n    const { hidden } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(SequenceVisibilityToggleContext);\n    const [timelineId] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(()=>String(Math.random()));\n    const isSequenceHidden = hidden[timelineId] ?? false;\n    if (typeof acceptableTimeShift !== \"undefined\") {\n        throw new Error(\"acceptableTimeShift has been removed. Use acceptableTimeShiftInSeconds instead.\");\n    }\n    const actualVolume = useMediaTagVolume(videoRef);\n    const [mediaVolume] = useMediaVolumeState();\n    const [mediaMuted] = useMediaMutedState();\n    useMediaInTimeline({\n        mediaRef: videoRef,\n        volume,\n        mediaVolume,\n        mediaType: \"video\",\n        src,\n        playbackRate: props2.playbackRate ?? 1,\n        displayName: name ?? null,\n        id: timelineId,\n        stack: _remotionInternalStack,\n        showInTimeline,\n        premountDisplay: null,\n        onAutoPlayError: onAutoPlayError ?? null\n    });\n    useSyncVolumeWithMediaTag({\n        volumePropFrame,\n        actualVolume,\n        volume,\n        mediaVolume,\n        mediaRef: videoRef\n    });\n    useMediaPlayback({\n        mediaRef: videoRef,\n        src,\n        mediaType: \"video\",\n        playbackRate: props2.playbackRate ?? 1,\n        onlyWarnForMediaSeekingError,\n        acceptableTimeshift: acceptableTimeShiftInSeconds ?? DEFAULT_ACCEPTABLE_TIMESHIFT,\n        isPremounting: Boolean(parentSequence?.premounting),\n        pauseWhenBuffering,\n        debugSeeking: _remotionDebugSeeking,\n        onAutoPlayError: onAutoPlayError ?? null\n    });\n    const actualFrom = parentSequence ? parentSequence.relativeFrom : 0;\n    const duration = parentSequence ? Math.min(parentSequence.durationInFrames, durationInFrames) : durationInFrames;\n    const actualSrc = useAppendVideoFragment({\n        actualSrc: usePreload(src),\n        actualFrom,\n        duration,\n        fps\n    });\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useImperativeHandle)(ref, ()=>{\n        return videoRef.current;\n    }, []);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        const { current } = videoRef;\n        if (!current) {\n            return;\n        }\n        const errorHandler = ()=>{\n            if (current.error) {\n                console.error(\"Error occurred in video\", current?.error);\n                if (onError) {\n                    const err = new Error(`Code ${current.error.code}: ${current.error.message}`);\n                    onError(err);\n                    return;\n                }\n                throw new Error(`The browser threw an error while playing the video ${src}: Code ${current.error.code} - ${current?.error?.message}. See https://remotion.dev/docs/media-playback-error for help. Pass an onError() prop to handle the error.`);\n            } else {\n                if (onError) {\n                    const err = new Error(`The browser threw an error while playing the video ${src}`);\n                    onError(err);\n                    return;\n                }\n                throw new Error(\"The browser threw an error while playing the video\");\n            }\n        };\n        current.addEventListener(\"error\", errorHandler, {\n            once: true\n        });\n        return ()=>{\n            current.removeEventListener(\"error\", errorHandler);\n        };\n    }, [\n        onError,\n        src\n    ]);\n    const currentOnDurationCallback = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)();\n    currentOnDurationCallback.current = onDuration;\n    useEmitVideoFrame({\n        ref: videoRef,\n        onVideoFrame\n    });\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        const { current } = videoRef;\n        if (!current) {\n            return;\n        }\n        if (current.duration) {\n            currentOnDurationCallback.current?.(src, current.duration);\n            return;\n        }\n        const onLoadedMetadata = ()=>{\n            currentOnDurationCallback.current?.(src, current.duration);\n        };\n        current.addEventListener(\"loadedmetadata\", onLoadedMetadata);\n        return ()=>{\n            current.removeEventListener(\"loadedmetadata\", onLoadedMetadata);\n        };\n    }, [\n        src\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        const { current } = videoRef;\n        if (!current) {\n            return;\n        }\n        if (isIosSafari()) {\n            current.preload = \"metadata\";\n        } else {\n            current.preload = \"auto\";\n        }\n    }, []);\n    const actualStyle = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        return {\n            ...style,\n            opacity: isSequenceHidden ? 0 : style?.opacity ?? 1\n        };\n    }, [\n        isSequenceHidden,\n        style\n    ]);\n    const crossOriginValue = crossOrigin ?? (onVideoFrame ? \"anonymous\" : undefined);\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"video\", {\n        ref: videoRef,\n        muted: muted || mediaMuted,\n        playsInline: true,\n        src: actualSrc,\n        loop: _remotionInternalNativeLoopPassed,\n        style: actualStyle,\n        disableRemotePlayback: true,\n        crossOrigin: crossOriginValue,\n        ...nativeProps\n    });\n};\nvar VideoForPreview = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(VideoForDevelopmentRefForwardingFunction);\n// src/video/OffthreadVideo.tsx\n\nvar OffthreadVideo = (props2)=>{\n    const { startFrom, endAt, name, pauseWhenBuffering, stack, showInTimeline, ...otherProps } = props2;\n    const environment = getRemotionEnvironment();\n    const onDuration = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        return;\n    }, []);\n    if (typeof props2.src !== \"string\") {\n        throw new TypeError(`The \\`<OffthreadVideo>\\` tag requires a string for \\`src\\`, but got ${JSON.stringify(props2.src)} instead.`);\n    }\n    if (props2.imageFormat) {\n        throw new TypeError(`The \\`<OffthreadVideo>\\` tag does no longer accept \\`imageFormat\\`. Use the \\`transparent\\` prop if you want to render a transparent video.`);\n    }\n    if (typeof startFrom !== \"undefined\" || typeof endAt !== \"undefined\") {\n        validateStartFromProps(startFrom, endAt);\n        const startFromFrameNo = startFrom ?? 0;\n        const endAtFrameNo = endAt ?? Infinity;\n        return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(Sequence, {\n            layout: \"none\",\n            from: 0 - startFromFrameNo,\n            showInTimeline: false,\n            durationInFrames: endAtFrameNo,\n            name,\n            children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(OffthreadVideo, {\n                pauseWhenBuffering: pauseWhenBuffering ?? false,\n                ...otherProps\n            })\n        });\n    }\n    validateMediaProps(props2, \"Video\");\n    if (environment.isRendering) {\n        return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(OffthreadVideoForRendering, {\n            ...otherProps\n        });\n    }\n    const { transparent, toneMapped, _remotionDebugSeeking, onAutoPlayError, onVideoFrame, crossOrigin, ...withoutTransparent } = otherProps;\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(VideoForPreview, {\n        _remotionInternalStack: stack ?? null,\n        _remotionInternalNativeLoopPassed: false,\n        _remotionDebugSeeking: _remotionDebugSeeking ?? false,\n        onDuration,\n        onlyWarnForMediaSeekingError: true,\n        pauseWhenBuffering: pauseWhenBuffering ?? false,\n        showInTimeline: showInTimeline ?? true,\n        onAutoPlayError: onAutoPlayError ?? undefined,\n        onVideoFrame: onVideoFrame ?? null,\n        crossOrigin,\n        ...withoutTransparent\n    });\n};\n// src/video/Video.tsx\n\n// src/video/VideoForRendering.tsx\n\n// src/video/seek-until-right.ts\nvar roundTo6Commas = (num)=>{\n    return Math.round(num * 1e5) / 1e5;\n};\nvar seekToTime = (element, desiredTime)=>{\n    element.currentTime = desiredTime;\n    let cancel;\n    let cancelSeeked = null;\n    const prom = new Promise((resolve)=>{\n        cancel = element.requestVideoFrameCallback((now, metadata)=>{\n            const displayIn = metadata.expectedDisplayTime - now;\n            if (displayIn <= 0) {\n                resolve(metadata.mediaTime);\n                return;\n            }\n            setTimeout(()=>{\n                resolve(metadata.mediaTime);\n            }, displayIn + 150);\n        });\n    });\n    const waitForSeekedEvent = new Promise((resolve)=>{\n        const onDone = ()=>{\n            resolve();\n        };\n        element.addEventListener(\"seeked\", onDone, {\n            once: true\n        });\n        cancelSeeked = ()=>{\n            element.removeEventListener(\"seeked\", onDone);\n        };\n    });\n    return {\n        wait: Promise.all([\n            prom,\n            waitForSeekedEvent\n        ]).then(([time])=>time),\n        cancel: ()=>{\n            cancelSeeked?.();\n            element.cancelVideoFrameCallback(cancel);\n        }\n    };\n};\nvar seekToTimeMultipleUntilRight = (element, desiredTime, fps)=>{\n    const threshold = 1 / fps / 2;\n    let currentCancel = ()=>{\n        return;\n    };\n    if (Number.isFinite(element.duration) && element.currentTime >= element.duration && desiredTime >= element.duration) {\n        return {\n            prom: Promise.resolve(),\n            cancel: ()=>{}\n        };\n    }\n    const prom = new Promise((resolve, reject)=>{\n        const firstSeek = seekToTime(element, desiredTime + threshold);\n        firstSeek.wait.then((seekedTo)=>{\n            const difference = Math.abs(desiredTime - seekedTo);\n            if (difference <= threshold) {\n                return resolve();\n            }\n            const sign = desiredTime > seekedTo ? 1 : -1;\n            const newSeek = seekToTime(element, seekedTo + threshold * sign);\n            currentCancel = newSeek.cancel;\n            newSeek.wait.then((newTime)=>{\n                const newDifference = Math.abs(desiredTime - newTime);\n                if (roundTo6Commas(newDifference) <= roundTo6Commas(threshold)) {\n                    return resolve();\n                }\n                const thirdSeek = seekToTime(element, desiredTime + threshold);\n                currentCancel = thirdSeek.cancel;\n                return thirdSeek.wait.then(()=>{\n                    resolve();\n                }).catch((err)=>{\n                    reject(err);\n                });\n            }).catch((err)=>{\n                reject(err);\n            });\n        });\n        currentCancel = firstSeek.cancel;\n    });\n    return {\n        prom,\n        cancel: ()=>{\n            currentCancel();\n        }\n    };\n};\n// src/video/VideoForRendering.tsx\n\nvar VideoForRenderingForwardFunction = ({ onError, volume: volumeProp, allowAmplificationDuringRender, playbackRate, onDuration, toneFrequency, name, acceptableTimeShiftInSeconds, delayRenderRetries, delayRenderTimeoutInMilliseconds, loopVolumeCurveBehavior, ...props2 }, ref)=>{\n    const absoluteFrame = useTimelinePosition();\n    const frame = useCurrentFrame();\n    const volumePropsFrame = useFrameForVolumeProp(loopVolumeCurveBehavior ?? \"repeat\");\n    const videoConfig = useUnsafeVideoConfig();\n    const videoRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const sequenceContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(SequenceContext);\n    const mediaStartsAt = useMediaStartsAt();\n    const environment = getRemotionEnvironment();\n    const { registerRenderAsset, unregisterRenderAsset } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(RenderAssetManager);\n    const id = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>`video-${random(props2.src ?? \"\")}-${sequenceContext?.cumulatedFrom}-${sequenceContext?.relativeFrom}-${sequenceContext?.durationInFrames}`, [\n        props2.src,\n        sequenceContext?.cumulatedFrom,\n        sequenceContext?.relativeFrom,\n        sequenceContext?.durationInFrames\n    ]);\n    if (!videoConfig) {\n        throw new Error(\"No video config found\");\n    }\n    const volume = evaluateVolume({\n        volume: volumeProp,\n        frame: volumePropsFrame,\n        mediaVolume: 1,\n        allowAmplificationDuringRender: allowAmplificationDuringRender ?? false\n    });\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (!props2.src) {\n            throw new Error(\"No src passed\");\n        }\n        if (props2.muted) {\n            return;\n        }\n        if (volume <= 0) {\n            return;\n        }\n        if (!window.remotion_audioEnabled) {\n            return;\n        }\n        registerRenderAsset({\n            type: \"video\",\n            src: getAbsoluteSrc(props2.src),\n            id,\n            frame: absoluteFrame,\n            volume,\n            mediaFrame: frame,\n            playbackRate: playbackRate ?? 1,\n            allowAmplificationDuringRender: allowAmplificationDuringRender ?? false,\n            toneFrequency: toneFrequency ?? null,\n            audioStartFrame: Math.max(0, -(sequenceContext?.relativeFrom ?? 0))\n        });\n        return ()=>unregisterRenderAsset(id);\n    }, [\n        props2.muted,\n        props2.src,\n        registerRenderAsset,\n        id,\n        unregisterRenderAsset,\n        volume,\n        frame,\n        absoluteFrame,\n        playbackRate,\n        allowAmplificationDuringRender,\n        toneFrequency,\n        sequenceContext?.relativeFrom\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useImperativeHandle)(ref, ()=>{\n        return videoRef.current;\n    }, []);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (!window.remotion_videoEnabled) {\n            return;\n        }\n        const { current } = videoRef;\n        if (!current) {\n            return;\n        }\n        const currentTime = getMediaTime({\n            frame,\n            playbackRate: playbackRate || 1,\n            startFrom: -mediaStartsAt,\n            fps: videoConfig.fps\n        });\n        const handle = delayRender(`Rendering <Video /> with src=\"${props2.src}\"`, {\n            retries: delayRenderRetries ?? undefined,\n            timeoutInMilliseconds: delayRenderTimeoutInMilliseconds ?? undefined\n        });\n        if (window.process?.env?.NODE_ENV === \"test\") {\n            continueRender(handle);\n            return;\n        }\n        if (isApproximatelyTheSame(current.currentTime, currentTime)) {\n            if (current.readyState >= 2) {\n                continueRender(handle);\n                return;\n            }\n            const loadedDataHandler = ()=>{\n                continueRender(handle);\n            };\n            current.addEventListener(\"loadeddata\", loadedDataHandler, {\n                once: true\n            });\n            return ()=>{\n                current.removeEventListener(\"loadeddata\", loadedDataHandler);\n            };\n        }\n        const endedHandler = ()=>{\n            continueRender(handle);\n        };\n        const seek2 = seekToTimeMultipleUntilRight(current, currentTime, videoConfig.fps);\n        seek2.prom.then(()=>{\n            continueRender(handle);\n        });\n        current.addEventListener(\"ended\", endedHandler, {\n            once: true\n        });\n        const errorHandler = ()=>{\n            if (current?.error) {\n                console.error(\"Error occurred in video\", current?.error);\n                if (onError) {\n                    return;\n                }\n                throw new Error(`The browser threw an error while playing the video ${props2.src}: Code ${current.error.code} - ${current?.error?.message}. See https://remotion.dev/docs/media-playback-error for help. Pass an onError() prop to handle the error.`);\n            } else {\n                throw new Error(\"The browser threw an error\");\n            }\n        };\n        current.addEventListener(\"error\", errorHandler, {\n            once: true\n        });\n        return ()=>{\n            seek2.cancel();\n            current.removeEventListener(\"ended\", endedHandler);\n            current.removeEventListener(\"error\", errorHandler);\n            continueRender(handle);\n        };\n    }, [\n        volumePropsFrame,\n        props2.src,\n        playbackRate,\n        videoConfig.fps,\n        frame,\n        mediaStartsAt,\n        onError,\n        delayRenderRetries,\n        delayRenderTimeoutInMilliseconds\n    ]);\n    const { src } = props2;\n    if (environment.isRendering) {\n        (0,react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect)(()=>{\n            if (window.process?.env?.NODE_ENV === \"test\") {\n                return;\n            }\n            const newHandle = delayRender(\"Loading <Video> duration with src=\" + src, {\n                retries: delayRenderRetries ?? undefined,\n                timeoutInMilliseconds: delayRenderTimeoutInMilliseconds ?? undefined\n            });\n            const { current } = videoRef;\n            const didLoad = ()=>{\n                if (current?.duration) {\n                    onDuration(src, current.duration);\n                }\n                continueRender(newHandle);\n            };\n            if (current?.duration) {\n                onDuration(src, current.duration);\n                continueRender(newHandle);\n            } else {\n                current?.addEventListener(\"loadedmetadata\", didLoad, {\n                    once: true\n                });\n            }\n            return ()=>{\n                current?.removeEventListener(\"loadedmetadata\", didLoad);\n                continueRender(newHandle);\n            };\n        }, [\n            src,\n            onDuration,\n            delayRenderRetries,\n            delayRenderTimeoutInMilliseconds\n        ]);\n    }\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"video\", {\n        ref: videoRef,\n        ...props2\n    });\n};\nvar VideoForRendering = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(VideoForRenderingForwardFunction);\n// src/video/Video.tsx\n\nvar VideoForwardingFunction = (props2, ref)=>{\n    const { startFrom, endAt, name, pauseWhenBuffering, stack, _remotionInternalNativeLoopPassed, showInTimeline, onAutoPlayError, ...otherProps } = props2;\n    const { loop, _remotionDebugSeeking, ...propsOtherThanLoop } = props2;\n    const { fps } = useVideoConfig();\n    const environment = getRemotionEnvironment();\n    const { durations, setDurations } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(DurationsContext);\n    if (typeof ref === \"string\") {\n        throw new Error(\"string refs are not supported\");\n    }\n    if (typeof props2.src !== \"string\") {\n        throw new TypeError(`The \\`<Video>\\` tag requires a string for \\`src\\`, but got ${JSON.stringify(props2.src)} instead.`);\n    }\n    const preloadedSrc = usePreload(props2.src);\n    const onDuration = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((src, durationInSeconds)=>{\n        setDurations({\n            type: \"got-duration\",\n            durationInSeconds,\n            src\n        });\n    }, [\n        setDurations\n    ]);\n    const onVideoFrame = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{}, []);\n    const durationFetched = durations[getAbsoluteSrc(preloadedSrc)] ?? durations[getAbsoluteSrc(props2.src)];\n    if (loop && durationFetched !== undefined) {\n        const mediaDuration = durationFetched * fps;\n        return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(Loop, {\n            durationInFrames: calculateLoopDuration({\n                endAt,\n                mediaDuration,\n                playbackRate: props2.playbackRate ?? 1,\n                startFrom\n            }),\n            layout: \"none\",\n            name,\n            children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(Video, {\n                ...propsOtherThanLoop,\n                ref,\n                _remotionInternalNativeLoopPassed: true\n            })\n        });\n    }\n    if (typeof startFrom !== \"undefined\" || typeof endAt !== \"undefined\") {\n        validateStartFromProps(startFrom, endAt);\n        const startFromFrameNo = startFrom ?? 0;\n        const endAtFrameNo = endAt ?? Infinity;\n        return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(Sequence, {\n            layout: \"none\",\n            from: 0 - startFromFrameNo,\n            showInTimeline: false,\n            durationInFrames: endAtFrameNo,\n            name,\n            children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(Video, {\n                pauseWhenBuffering: pauseWhenBuffering ?? false,\n                ...otherProps,\n                ref\n            })\n        });\n    }\n    validateMediaProps(props2, \"Video\");\n    if (environment.isRendering) {\n        return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(VideoForRendering, {\n            onDuration,\n            onVideoFrame: onVideoFrame ?? null,\n            ...otherProps,\n            ref\n        });\n    }\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(VideoForPreview, {\n        onlyWarnForMediaSeekingError: false,\n        ...otherProps,\n        ref,\n        onVideoFrame: null,\n        pauseWhenBuffering: pauseWhenBuffering ?? false,\n        onDuration,\n        _remotionInternalStack: stack ?? null,\n        _remotionInternalNativeLoopPassed: _remotionInternalNativeLoopPassed ?? false,\n        _remotionDebugSeeking: _remotionDebugSeeking ?? false,\n        showInTimeline: showInTimeline ?? true,\n        onAutoPlayError: onAutoPlayError ?? undefined\n    });\n};\nvar Video = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(VideoForwardingFunction);\naddSequenceStackTraces(Video);\n// src/index.ts\ncheckMultipleRemotionVersions();\nvar Experimental = {\n    Clipper,\n    Null,\n    useIsPlayer\n};\nvar proxyObj = {};\nvar Config = new Proxy(proxyObj, {\n    get (_, prop) {\n        if (prop === \"Bundling\" || prop === \"Rendering\" || prop === \"Log\" || prop === \"Puppeteer\" || prop === \"Output\") {\n            return Config;\n        }\n        return ()=>{\n            console.warn(\"  The CLI configuration has been extracted from Remotion Core.\");\n            console.warn(\"Update the import from the config file:\");\n            console.warn();\n            console.warn(\"- Delete:\");\n            console.warn('import {Config} from \"remotion\";');\n            console.warn(\"+ Replace:\");\n            console.warn('import {Config} from \"@remotion/cli/config\";');\n            console.warn();\n            console.warn(\"For more information, see https://www.remotion.dev/docs/4-0-migration.\");\n            process.exit(1);\n        };\n    }\n});\naddSequenceStackTraces(Sequence);\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVtb3Rpb24vZGlzdC9lc20vaW5kZXgubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLElBQUlBLFlBQVlDLE9BQU9DLGNBQWM7QUFDckMsSUFBSUMsV0FBVyxDQUFDQyxRQUFRQztJQUN0QixJQUFLLElBQUlDLFFBQVFELElBQ2ZMLFVBQVVJLFFBQVFFLE1BQU07UUFDdEJDLEtBQUtGLEdBQUcsQ0FBQ0MsS0FBSztRQUNkRSxZQUFZO1FBQ1pDLGNBQWM7UUFDZEMsS0FBSyxDQUFDQyxXQUFhTixHQUFHLENBQUNDLEtBQUssR0FBRyxJQUFNSztJQUN2QztBQUNKO0FBRUEsb0JBQW9CO0FBQ2tCO0FBQ3RDLElBQUksT0FBT0MsZ0RBQWFBLEtBQUssWUFBWTtJQUN2QyxNQUFNQyxNQUFNO1FBQ1Y7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO0tBQ0Q7SUFDRCxNQUFNLElBQUlDLE1BQU1ELElBQUlFLElBQUksQ0FBQztBQUMzQjtBQUVBLGtCQUFrQjtBQUM0QjtBQUU5Qyx1QkFBdUI7QUFDcUU7QUFDcEQ7QUFDeEMsSUFBSVEsb0NBQXNCTCxvREFBY0EsQ0FBQztJQUN2Q00sZUFBZTtRQUNiLE1BQU0sSUFBSVYsTUFBTTtJQUNsQjtJQUNBVyxZQUFZO0FBQ2Q7QUFDQSxJQUFJQyx1QkFBdUIsQ0FBQyxFQUMxQkMsUUFBUSxFQUNUO0lBQ0MsTUFBTSxDQUFDRixZQUFZRCxjQUFjLEdBQUdILCtDQUFRQSxDQUFDO0lBQzdDLE1BQU1PLFVBQVVSLDhDQUFPQSxDQUFDO1FBQ3RCLE9BQU87WUFDTEk7WUFDQUM7UUFDRjtJQUNGLEdBQUc7UUFBQ0E7UUFBWUQ7S0FBYztJQUM5QixJQUFJLEtBQTZCLEVBQUUsRUFNbEM7SUFDRCxPQUFPLGFBQWEsR0FBR0Ysc0RBQUdBLENBQUNDLG9CQUFvQlEsUUFBUSxFQUFFO1FBQ3ZEQyxPQUFPSjtR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QVFDLElBQUksQ0FBQztZQUNiRCxRQUFRQyxJQUFJLENBQUM7WUFDYkQsUUFBUUMsSUFBSSxDQUFDO1lBQ2JELFFBQVFDLElBQUksQ0FBQztZQUNiRCxRQUFRQyxJQUFJO1lBQ1pELFFBQVFDLElBQUksQ0FBQztZQUNiMUosUUFBUXdqRCxJQUFJLENBQUM7UUFDZjtJQUNGO0FBQ0Y7QUFDQW5pRCx1QkFBdUI0VztBQXlDckIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZW1vdGlvbi1jYXB0aW9ucy8uL25vZGVfbW9kdWxlcy9yZW1vdGlvbi9kaXN0L2VzbS9pbmRleC5tanM/N2Q0YSJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgX19kZWZQcm9wID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fZXhwb3J0ID0gKHRhcmdldCwgYWxsKSA9PiB7XG4gIGZvciAodmFyIG5hbWUgaW4gYWxsKVxuICAgIF9fZGVmUHJvcCh0YXJnZXQsIG5hbWUsIHtcbiAgICAgIGdldDogYWxsW25hbWVdLFxuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIHNldDogKG5ld1ZhbHVlKSA9PiBhbGxbbmFtZV0gPSAoKSA9PiBuZXdWYWx1ZVxuICAgIH0pO1xufTtcblxuLy8gc3JjL19jaGVjay1yc2MudHNcbmltcG9ydCB7IGNyZWF0ZUNvbnRleHQgfSBmcm9tIFwicmVhY3RcIjtcbmlmICh0eXBlb2YgY3JlYXRlQ29udGV4dCAhPT0gXCJmdW5jdGlvblwiKSB7XG4gIGNvbnN0IGVyciA9IFtcbiAgICAnUmVtb3Rpb24gcmVxdWlyZXMgUmVhY3QuY3JlYXRlQ29udGV4dCwgYnV0IGl0IGlzIFwidW5kZWZpbmVkXCIuJyxcbiAgICAnSWYgeW91IGFyZSBpbiBhIFJlYWN0IFNlcnZlciBDb21wb25lbnQsIHR1cm4gaXQgaW50byBhIGNsaWVudCBjb21wb25lbnQgYnkgYWRkaW5nIFwidXNlIGNsaWVudFwiIGF0IHRoZSB0b3Agb2YgdGhlIGZpbGUuJyxcbiAgICBcIlwiLFxuICAgIFwiQmVmb3JlOlwiLFxuICAgICcgIGltcG9ydCB7dXNlQ3VycmVudEZyYW1lfSBmcm9tIFwicmVtb3Rpb25cIjsnLFxuICAgIFwiXCIsXG4gICAgXCJBZnRlcjpcIixcbiAgICAnICBcInVzZSBjbGllbnRcIjsnLFxuICAgICcgIGltcG9ydCB7dXNlQ3VycmVudEZyYW1lfSBmcm9tIFwicmVtb3Rpb25cIjsnXG4gIF07XG4gIHRocm93IG5ldyBFcnJvcihlcnIuam9pbihcIlxcblwiKSk7XG59XG5cbi8vIHNyYy9DbGlwcGVyLnRzeFxuaW1wb3J0IHsgdXNlQ29udGV4dCwgdXNlRWZmZWN0IH0gZnJvbSBcInJlYWN0XCI7XG5cbi8vIHNyYy9OYXRpdmVMYXllcnMudHN4XG5pbXBvcnQgeyBjcmVhdGVDb250ZXh0IGFzIGNyZWF0ZUNvbnRleHQyLCB1c2VMYXlvdXRFZmZlY3QsIHVzZU1lbW8sIHVzZVN0YXRlIH0gZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgeyBqc3ggfSBmcm9tIFwicmVhY3QvanN4LXJ1bnRpbWVcIjtcbnZhciBOYXRpdmVMYXllcnNDb250ZXh0ID0gY3JlYXRlQ29udGV4dDIoe1xuICBzZXRDbGlwUmVnaW9uOiAoKSA9PiB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiTmF0aXZlTGF5ZXJzIG5vdCBzZXRcIik7XG4gIH0sXG4gIGNsaXBSZWdpb246IG51bGxcbn0pO1xudmFyIE5hdGl2ZUxheWVyc1Byb3ZpZGVyID0gKHtcbiAgY2hpbGRyZW5cbn0pID0+IHtcbiAgY29uc3QgW2NsaXBSZWdpb24sIHNldENsaXBSZWdpb25dID0gdXNlU3RhdGUobnVsbCk7XG4gIGNvbnN0IGNvbnRleHQgPSB1c2VNZW1vKCgpID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgc2V0Q2xpcFJlZ2lvbixcbiAgICAgIGNsaXBSZWdpb25cbiAgICB9O1xuICB9LCBbY2xpcFJlZ2lvbiwgc2V0Q2xpcFJlZ2lvbl0pO1xuICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHVzZUxheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgICB3aW5kb3cucmVtb3Rpb25fZ2V0Q2xpcFJlZ2lvbiA9ICgpID0+IHtcbiAgICAgICAgcmV0dXJuIGNsaXBSZWdpb247XG4gICAgICB9O1xuICAgIH0sIFtjbGlwUmVnaW9uLCBzZXRDbGlwUmVnaW9uXSk7XG4gIH1cbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBqc3goTmF0aXZlTGF5ZXJzQ29udGV4dC5Qcm92aWRlciwge1xuICAgIHZhbHVlOiBjb250ZXh0LFxuICAgIGNoaWxkcmVuXG4gIH0pO1xufTtcblxuLy8gc3JjL0NsaXBwZXIudHN4XG52YXIgQ2xpcHBlciA9ICh7IGhlaWdodCwgd2lkdGgsIHgsIHkgfSkgPT4ge1xuICBjb25zdCB7IHNldENsaXBSZWdpb24gfSA9IHVzZUNvbnRleHQoTmF0aXZlTGF5ZXJzQ29udGV4dCk7XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgc2V0Q2xpcFJlZ2lvbigoYykgPT4ge1xuICAgICAgaWYgKGMgPT09IFwiaGlkZVwiKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCByZW5kZXIgPENsaXBwZXI+LCBiZWNhdXNlIGFub3RoZXIgPE51bGw+IGlzIGFscmVhZHkgcmVuZGVyZWRcIik7XG4gICAgICB9XG4gICAgICBpZiAoYyA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4geyBoZWlnaHQsIHdpZHRoLCB4LCB5IH07XG4gICAgICB9XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgcmVuZGVyIDxDbGlwcGVyPiwgYmVjYXVzZSBhbm90aGVyIGNvbXBvbmVudCBjbGlwcGluZyB0aGUgcmVnaW9uIHdhcyBhbHJlYWR5IHJlbmRlcmVkIChtb3N0IGxpa2VseSA8Q2xpcHBlcj4pXCIpO1xuICAgIH0pO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBzZXRDbGlwUmVnaW9uKG51bGwpO1xuICAgIH07XG4gIH0sIFtoZWlnaHQsIHNldENsaXBSZWdpb24sIHdpZHRoLCB4LCB5XSk7XG4gIHJldHVybiBudWxsO1xufTtcblxuLy8gc3JjL2VuYWJsZS1zZXF1ZW5jZS1zdGFjay10cmFjZXMudHNcbmltcG9ydCBSZWFjdCBmcm9tIFwicmVhY3RcIjtcblxuLy8gc3JjL2dldC1yZW1vdGlvbi1lbnZpcm9ubWVudC50c1xuZnVuY3Rpb24gZ2V0Tm9kZUVudlN0cmluZygpIHtcbiAgcmV0dXJuIFtcIk5PRFwiLCBcIkVfRU5cIiwgXCJWXCJdLmpvaW4oXCJcIik7XG59XG52YXIgZ2V0RW52U3RyaW5nID0gKCkgPT4ge1xuICByZXR1cm4gW1wiZVwiLCBcIm52XCJdLmpvaW4oXCJcIik7XG59O1xudmFyIGdldFJlbW90aW9uRW52aXJvbm1lbnQgPSAoKSA9PiB7XG4gIGNvbnN0IGlzUGxheWVyID0gdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB3aW5kb3cucmVtb3Rpb25faXNQbGF5ZXI7XG4gIGNvbnN0IGlzUmVuZGVyaW5nID0gdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB0eXBlb2Ygd2luZG93LnByb2Nlc3MgIT09IFwidW5kZWZpbmVkXCIgJiYgdHlwZW9mIHdpbmRvdy5wcm9jZXNzLmVudiAhPT0gXCJ1bmRlZmluZWRcIiAmJiAod2luZG93LnByb2Nlc3NbZ2V0RW52U3RyaW5nKCldW2dldE5vZGVFbnZTdHJpbmcoKV0gPT09IFwidGVzdFwiIHx8IHdpbmRvdy5wcm9jZXNzW2dldEVudlN0cmluZygpXVtnZXROb2RlRW52U3RyaW5nKCldID09PSBcInByb2R1Y3Rpb25cIiAmJiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIHR5cGVvZiB3aW5kb3cucmVtb3Rpb25fcHVwcGV0ZWVyVGltZW91dCAhPT0gXCJ1bmRlZmluZWRcIik7XG4gIGNvbnN0IGlzU3R1ZGlvID0gdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB3aW5kb3cucmVtb3Rpb25faXNTdHVkaW87XG4gIHJldHVybiB7XG4gICAgaXNTdHVkaW8sXG4gICAgaXNSZW5kZXJpbmcsXG4gICAgaXNQbGF5ZXJcbiAgfTtcbn07XG5cbi8vIHNyYy9lbmFibGUtc2VxdWVuY2Utc3RhY2stdHJhY2VzLnRzXG52YXIgb3JpZ2luYWxDcmVhdGVFbGVtZW50ID0gUmVhY3QuY3JlYXRlRWxlbWVudDtcbnZhciBjb21wb25lbnRzVG9BZGRTdGFja3NUbyA9IFtdO1xudmFyIGVuYWJsZVNlcXVlbmNlU3RhY2tUcmFjZXMgPSAoKSA9PiB7XG4gIGlmICghZ2V0UmVtb3Rpb25FbnZpcm9ubWVudCgpLmlzU3R1ZGlvKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IHByb3h5ID0gbmV3IFByb3h5KG9yaWdpbmFsQ3JlYXRlRWxlbWVudCwge1xuICAgIGFwcGx5KHRhcmdldCwgdGhpc0FyZywgYXJnQXJyYXkpIHtcbiAgICAgIGlmIChjb21wb25lbnRzVG9BZGRTdGFja3NUby5pbmNsdWRlcyhhcmdBcnJheVswXSkpIHtcbiAgICAgICAgY29uc3QgW2ZpcnN0LCBwcm9wcywgLi4ucmVzdF0gPSBhcmdBcnJheTtcbiAgICAgICAgY29uc3QgbmV3UHJvcHMgPSB7XG4gICAgICAgICAgLi4ucHJvcHMgPz8ge30sXG4gICAgICAgICAgc3RhY2s6IG5ldyBFcnJvcigpLnN0YWNrXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBSZWZsZWN0LmFwcGx5KHRhcmdldCwgdGhpc0FyZywgW2ZpcnN0LCBuZXdQcm9wcywgLi4ucmVzdF0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFJlZmxlY3QuYXBwbHkodGFyZ2V0LCB0aGlzQXJnLCBhcmdBcnJheSk7XG4gICAgfVxuICB9KTtcbiAgUmVhY3QuY3JlYXRlRWxlbWVudCA9IHByb3h5O1xufTtcbnZhciBhZGRTZXF1ZW5jZVN0YWNrVHJhY2VzID0gKGNvbXBvbmVudCkgPT4ge1xuICBjb21wb25lbnRzVG9BZGRTdGFja3NUby5wdXNoKGNvbXBvbmVudCk7XG4gIGVuYWJsZVNlcXVlbmNlU3RhY2tUcmFjZXMoKTtcbn07XG5cbi8vIHNyYy9pcy1wbGF5ZXIudHN4XG5pbXBvcnQgeyBjcmVhdGVDb250ZXh0IGFzIGNyZWF0ZUNvbnRleHQzLCB1c2VDb250ZXh0IGFzIHVzZUNvbnRleHQyIH0gZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgeyBqc3ggYXMganN4MiB9IGZyb20gXCJyZWFjdC9qc3gtcnVudGltZVwiO1xudmFyIElzUGxheWVyQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQzKGZhbHNlKTtcbnZhciBJc1BsYXllckNvbnRleHRQcm92aWRlciA9ICh7XG4gIGNoaWxkcmVuXG59KSA9PiB7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8ganN4MihJc1BsYXllckNvbnRleHQuUHJvdmlkZXIsIHtcbiAgICB2YWx1ZTogdHJ1ZSxcbiAgICBjaGlsZHJlblxuICB9KTtcbn07XG52YXIgdXNlSXNQbGF5ZXIgPSAoKSA9PiB7XG4gIHJldHVybiB1c2VDb250ZXh0MihJc1BsYXllckNvbnRleHQpO1xufTtcblxuLy8gc3JjL3RydXRoeS50c1xuZnVuY3Rpb24gdHJ1dGh5KHZhbHVlKSB7XG4gIHJldHVybiBCb29sZWFuKHZhbHVlKTtcbn1cblxuLy8gc3JjL3ZlcnNpb24udHNcbnZhciBWRVJTSU9OID0gXCI0LjAuMjIxXCI7XG5cbi8vIHNyYy9tdWx0aXBsZS12ZXJzaW9ucy13YXJuaW5nLnRzXG52YXIgY2hlY2tNdWx0aXBsZVJlbW90aW9uVmVyc2lvbnMgPSAoKSA9PiB7XG4gIGlmICh0eXBlb2YgZ2xvYmFsVGhpcyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBhbHJlYWR5SW1wb3J0ZWQgPSBnbG9iYWxUaGlzLnJlbW90aW9uX2ltcG9ydGVkIHx8IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiYgd2luZG93LnJlbW90aW9uX2ltcG9ydGVkO1xuICBpZiAoYWxyZWFkeUltcG9ydGVkKSB7XG4gICAgaWYgKGFscmVhZHlJbXBvcnRlZCA9PT0gVkVSU0lPTikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBcXHVEODNEXFx1REVBOCBNdWx0aXBsZSB2ZXJzaW9ucyBvZiBSZW1vdGlvbiBkZXRlY3RlZDogJHtbXG4gICAgICBWRVJTSU9OLFxuICAgICAgdHlwZW9mIGFscmVhZHlJbXBvcnRlZCA9PT0gXCJzdHJpbmdcIiA/IGFscmVhZHlJbXBvcnRlZCA6IFwiYW4gb2xkZXIgdmVyc2lvblwiXG4gICAgXS5maWx0ZXIodHJ1dGh5KS5qb2luKFwiIGFuZCBcIil9LiBUaGlzIHdpbGwgY2F1c2UgdGhpbmdzIHRvIGJyZWFrIGluIGFuIHVuZXhwZWN0ZWQgd2F5LlxcbkNoZWNrIHRoYXQgYWxsIHlvdXIgUmVtb3Rpb24gcGFja2FnZXMgYXJlIG9uIHRoZSBzYW1lIHZlcnNpb24uIElmIHlvdXIgZGVwZW5kZW5jaWVzIGRlcGVuZCBvbiBSZW1vdGlvbiwgbWFrZSB0aGVtIHBlZXIgZGVwZW5kZW5jaWVzLiBZb3UgY2FuIGFsc28gcnVuIFxcYG5weCByZW1vdGlvbiB2ZXJzaW9uc1xcYCBmcm9tIHlvdXIgdGVybWluYWwgdG8gc2VlIHdoaWNoIHZlcnNpb25zIGFyZSBtaXNtYXRjaGluZy5gKTtcbiAgfVxuICBnbG9iYWxUaGlzLnJlbW90aW9uX2ltcG9ydGVkID0gVkVSU0lPTjtcbiAgaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICB3aW5kb3cucmVtb3Rpb25faW1wb3J0ZWQgPSBWRVJTSU9OO1xuICB9XG59O1xuXG4vLyBzcmMvTnVsbC50c3hcbmltcG9ydCB7IHVzZUNvbnRleHQgYXMgdXNlQ29udGV4dDMsIHVzZUVmZmVjdCBhcyB1c2VFZmZlY3QyIH0gZnJvbSBcInJlYWN0XCI7XG52YXIgTnVsbCA9ICgpID0+IHtcbiAgY29uc3QgeyBzZXRDbGlwUmVnaW9uIH0gPSB1c2VDb250ZXh0MyhOYXRpdmVMYXllcnNDb250ZXh0KTtcbiAgdXNlRWZmZWN0MigoKSA9PiB7XG4gICAgc2V0Q2xpcFJlZ2lvbigoYykgPT4ge1xuICAgICAgaWYgKGMgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIFwiaGlkZVwiO1xuICAgICAgfVxuICAgICAgaWYgKGMgPT09IFwiaGlkZVwiKSB7XG4gICAgICAgIHJldHVybiBcImhpZGVcIjtcbiAgICAgIH1cbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCByZW5kZXIgPE51bGw+LCBiZWNhdXNlIGFub3RoZXIgY29tcG9uZW50IGNsaXBwaW5nIHRoZSByZWdpb24gd2FzIGFscmVhZHkgcmVuZGVyZWQgKG1vc3QgbGlrZWx5IDxDbGlwcGVyPilcIik7XG4gICAgfSk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHNldENsaXBSZWdpb24obnVsbCk7XG4gICAgfTtcbiAgfSwgW3NldENsaXBSZWdpb25dKTtcbiAgcmV0dXJuIG51bGw7XG59O1xuXG4vLyBzcmMvU2VxdWVuY2UudHN4XG5pbXBvcnQge1xuICBmb3J3YXJkUmVmIGFzIGZvcndhcmRSZWYyLFxuICB1c2VDb250ZXh0IGFzIHVzZUNvbnRleHQxMixcbiAgdXNlRWZmZWN0IGFzIHVzZUVmZmVjdDUsXG4gIHVzZU1lbW8gYXMgdXNlTWVtbzEwLFxuICB1c2VTdGF0ZSBhcyB1c2VTdGF0ZTVcbn0gZnJvbSBcInJlYWN0XCI7XG5cbi8vIHNyYy9BYnNvbHV0ZUZpbGwudHN4XG5pbXBvcnQgeyBmb3J3YXJkUmVmLCB1c2VNZW1vIGFzIHVzZU1lbW8yIH0gZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgeyBqc3ggYXMganN4MyB9IGZyb20gXCJyZWFjdC9qc3gtcnVudGltZVwiO1xudmFyIEFic29sdXRlRmlsbFJlZkZvcndhcmRpbmcgPSAocHJvcHMsIHJlZikgPT4ge1xuICBjb25zdCB7IHN0eWxlLCAuLi5vdGhlciB9ID0gcHJvcHM7XG4gIGNvbnN0IGFjdHVhbFN0eWxlID0gdXNlTWVtbzIoKCkgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICBwb3NpdGlvbjogXCJhYnNvbHV0ZVwiLFxuICAgICAgdG9wOiAwLFxuICAgICAgbGVmdDogMCxcbiAgICAgIHJpZ2h0OiAwLFxuICAgICAgYm90dG9tOiAwLFxuICAgICAgd2lkdGg6IFwiMTAwJVwiLFxuICAgICAgaGVpZ2h0OiBcIjEwMCVcIixcbiAgICAgIGRpc3BsYXk6IFwiZmxleFwiLFxuICAgICAgZmxleERpcmVjdGlvbjogXCJjb2x1bW5cIixcbiAgICAgIC4uLnN0eWxlXG4gICAgfTtcbiAgfSwgW3N0eWxlXSk7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8ganN4MyhcImRpdlwiLCB7XG4gICAgcmVmLFxuICAgIHN0eWxlOiBhY3R1YWxTdHlsZSxcbiAgICAuLi5vdGhlclxuICB9KTtcbn07XG52YXIgQWJzb2x1dGVGaWxsID0gZm9yd2FyZFJlZihBYnNvbHV0ZUZpbGxSZWZGb3J3YXJkaW5nKTtcblxuLy8gc3JjL1NlcXVlbmNlQ29udGV4dC50c3hcbmltcG9ydCB7IGNyZWF0ZUNvbnRleHQgYXMgY3JlYXRlQ29udGV4dDQgfSBmcm9tIFwicmVhY3RcIjtcbnZhciBTZXF1ZW5jZUNvbnRleHQgPSBjcmVhdGVDb250ZXh0NChudWxsKTtcblxuLy8gc3JjL1NlcXVlbmNlTWFuYWdlci50c3hcbmltcG9ydCBSZWFjdDMsIHsgdXNlQ2FsbGJhY2ssIHVzZU1lbW8gYXMgdXNlTWVtbzMsIHVzZVN0YXRlIGFzIHVzZVN0YXRlMiB9IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHsganN4IGFzIGpzeDQgfSBmcm9tIFwicmVhY3QvanN4LXJ1bnRpbWVcIjtcbnZhciBTZXF1ZW5jZU1hbmFnZXIgPSBSZWFjdDMuY3JlYXRlQ29udGV4dCh7XG4gIHJlZ2lzdGVyU2VxdWVuY2U6ICgpID0+IHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJTZXF1ZW5jZU1hbmFnZXJDb250ZXh0IG5vdCBpbml0aWFsaXplZFwiKTtcbiAgfSxcbiAgdW5yZWdpc3RlclNlcXVlbmNlOiAoKSA9PiB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiU2VxdWVuY2VNYW5hZ2VyQ29udGV4dCBub3QgaW5pdGlhbGl6ZWRcIik7XG4gIH0sXG4gIHNlcXVlbmNlczogW11cbn0pO1xudmFyIFNlcXVlbmNlVmlzaWJpbGl0eVRvZ2dsZUNvbnRleHQgPSBSZWFjdDMuY3JlYXRlQ29udGV4dCh7XG4gIGhpZGRlbjoge30sXG4gIHNldEhpZGRlbjogKCkgPT4ge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlNlcXVlbmNlVmlzaWJpbGl0eVRvZ2dsZSBub3QgaW5pdGlhbGl6ZWRcIik7XG4gIH1cbn0pO1xudmFyIFNlcXVlbmNlTWFuYWdlclByb3ZpZGVyID0gKHsgY2hpbGRyZW4gfSkgPT4ge1xuICBjb25zdCBbc2VxdWVuY2VzLCBzZXRTZXF1ZW5jZXNdID0gdXNlU3RhdGUyKFtdKTtcbiAgY29uc3QgW2hpZGRlbiwgc2V0SGlkZGVuXSA9IHVzZVN0YXRlMih7fSk7XG4gIGNvbnN0IHJlZ2lzdGVyU2VxdWVuY2UgPSB1c2VDYWxsYmFjaygoc2VxKSA9PiB7XG4gICAgc2V0U2VxdWVuY2VzKChzZXFzKSA9PiB7XG4gICAgICByZXR1cm4gWy4uLnNlcXMsIHNlcV07XG4gICAgfSk7XG4gIH0sIFtdKTtcbiAgY29uc3QgdW5yZWdpc3RlclNlcXVlbmNlID0gdXNlQ2FsbGJhY2soKHNlcSkgPT4ge1xuICAgIHNldFNlcXVlbmNlcygoc2VxcykgPT4gc2Vxcy5maWx0ZXIoKHMpID0+IHMuaWQgIT09IHNlcSkpO1xuICB9LCBbXSk7XG4gIGNvbnN0IHNlcXVlbmNlQ29udGV4dCA9IHVzZU1lbW8zKCgpID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgcmVnaXN0ZXJTZXF1ZW5jZSxcbiAgICAgIHNlcXVlbmNlcyxcbiAgICAgIHVucmVnaXN0ZXJTZXF1ZW5jZVxuICAgIH07XG4gIH0sIFtyZWdpc3RlclNlcXVlbmNlLCBzZXF1ZW5jZXMsIHVucmVnaXN0ZXJTZXF1ZW5jZV0pO1xuICBjb25zdCBoaWRkZW5Db250ZXh0ID0gdXNlTWVtbzMoKCkgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICBoaWRkZW4sXG4gICAgICBzZXRIaWRkZW5cbiAgICB9O1xuICB9LCBbaGlkZGVuXSk7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8ganN4NChTZXF1ZW5jZU1hbmFnZXIuUHJvdmlkZXIsIHtcbiAgICB2YWx1ZTogc2VxdWVuY2VDb250ZXh0LFxuICAgIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8ganN4NChTZXF1ZW5jZVZpc2liaWxpdHlUb2dnbGVDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgICB2YWx1ZTogaGlkZGVuQ29udGV4dCxcbiAgICAgIGNoaWxkcmVuXG4gICAgfSlcbiAgfSk7XG59O1xuXG4vLyBzcmMvbm9uY2UudHNcbmltcG9ydCB7IGNyZWF0ZUNvbnRleHQgYXMgY3JlYXRlQ29udGV4dDUsIHVzZUNvbnRleHQgYXMgdXNlQ29udGV4dDQsIHVzZUVmZmVjdCBhcyB1c2VFZmZlY3QzLCB1c2VSZWYsIHVzZVN0YXRlIGFzIHVzZVN0YXRlMyB9IGZyb20gXCJyZWFjdFwiO1xudmFyIE5vbmNlQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQ1KHtcbiAgZ2V0Tm9uY2U6ICgpID0+IDAsXG4gIGZhc3RSZWZyZXNoZXM6IDBcbn0pO1xudmFyIHVzZU5vbmNlID0gKCkgPT4ge1xuICBjb25zdCBjb250ZXh0ID0gdXNlQ29udGV4dDQoTm9uY2VDb250ZXh0KTtcbiAgY29uc3QgW25vbmNlLCBzZXROb25jZV0gPSB1c2VTdGF0ZTMoKCkgPT4gY29udGV4dC5nZXROb25jZSgpKTtcbiAgY29uc3QgbGFzdENvbnRleHQgPSB1c2VSZWYoY29udGV4dCk7XG4gIHVzZUVmZmVjdDMoKCkgPT4ge1xuICAgIGlmIChsYXN0Q29udGV4dC5jdXJyZW50ID09PSBjb250ZXh0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGxhc3RDb250ZXh0LmN1cnJlbnQgPSBjb250ZXh0O1xuICAgIHNldE5vbmNlKGNvbnRleHQuZ2V0Tm9uY2UpO1xuICB9LCBbY29udGV4dF0pO1xuICByZXR1cm4gbm9uY2U7XG59O1xuXG4vLyBzcmMvdGltZWxpbmUtcG9zaXRpb24tc3RhdGUudHNcbnZhciBleHBvcnRzX3RpbWVsaW5lX3Bvc2l0aW9uX3N0YXRlID0ge307XG5fX2V4cG9ydChleHBvcnRzX3RpbWVsaW5lX3Bvc2l0aW9uX3N0YXRlLCB7XG4gIHVzZVRpbWVsaW5lU2V0RnJhbWU6ICgpID0+IHVzZVRpbWVsaW5lU2V0RnJhbWUsXG4gIHVzZVRpbWVsaW5lUG9zaXRpb246ICgpID0+IHVzZVRpbWVsaW5lUG9zaXRpb24sXG4gIHVzZVBsYXlpbmdTdGF0ZTogKCkgPT4gdXNlUGxheWluZ1N0YXRlLFxuICBwZXJzaXN0Q3VycmVudEZyYW1lOiAoKSA9PiBwZXJzaXN0Q3VycmVudEZyYW1lLFxuICBnZXRJbml0aWFsRnJhbWVTdGF0ZTogKCkgPT4gZ2V0SW5pdGlhbEZyYW1lU3RhdGUsXG4gIGdldEZyYW1lRm9yQ29tcG9zaXRpb246ICgpID0+IGdldEZyYW1lRm9yQ29tcG9zaXRpb24sXG4gIFRpbWVsaW5lQ29udGV4dDogKCkgPT4gVGltZWxpbmVDb250ZXh0LFxuICBTZXRUaW1lbGluZUNvbnRleHQ6ICgpID0+IFNldFRpbWVsaW5lQ29udGV4dFxufSk7XG5pbXBvcnQgeyBjcmVhdGVDb250ZXh0IGFzIGNyZWF0ZUNvbnRleHQ5LCB1c2VDb250ZXh0IGFzIHVzZUNvbnRleHQ3LCB1c2VNZW1vIGFzIHVzZU1lbW83IH0gZnJvbSBcInJlYWN0XCI7XG5cbi8vIHNyYy91c2UtdmlkZW8udHNcbmltcG9ydCB7IHVzZUNvbnRleHQgYXMgdXNlQ29udGV4dDYsIHVzZU1lbW8gYXMgdXNlTWVtbzYgfSBmcm9tIFwicmVhY3RcIjtcblxuLy8gc3JjL0NvbXBvc2l0aW9uTWFuYWdlckNvbnRleHQudHN4XG5pbXBvcnQgeyBjcmVhdGVDb250ZXh0IGFzIGNyZWF0ZUNvbnRleHQ2IH0gZnJvbSBcInJlYWN0XCI7XG52YXIgQ29tcG9zaXRpb25NYW5hZ2VyID0gY3JlYXRlQ29udGV4dDYoe1xuICBjb21wb3NpdGlvbnM6IFtdLFxuICByZWdpc3RlckNvbXBvc2l0aW9uOiAoKSA9PiB7XG4gICAgcmV0dXJuO1xuICB9LFxuICB1bnJlZ2lzdGVyQ29tcG9zaXRpb246ICgpID0+IHtcbiAgICByZXR1cm47XG4gIH0sXG4gIHJlZ2lzdGVyRm9sZGVyOiAoKSA9PiB7XG4gICAgcmV0dXJuO1xuICB9LFxuICB1bnJlZ2lzdGVyRm9sZGVyOiAoKSA9PiB7XG4gICAgcmV0dXJuO1xuICB9LFxuICBzZXRDdXJyZW50Q29tcG9zaXRpb25NZXRhZGF0YTogKCkgPT4ge1xuICAgIHJldHVybjtcbiAgfSxcbiAgdXBkYXRlQ29tcG9zaXRpb25EZWZhdWx0UHJvcHM6ICgpID0+IHtcbiAgICByZXR1cm47XG4gIH0sXG4gIGZvbGRlcnM6IFtdLFxuICBjdXJyZW50Q29tcG9zaXRpb25NZXRhZGF0YTogbnVsbCxcbiAgY2FudmFzQ29udGVudDogbnVsbCxcbiAgc2V0Q2FudmFzQ29udGVudDogKCkgPT4ge1xuICAgIHJldHVybjtcbiAgfVxufSk7XG5cbi8vIHNyYy9SZXNvbHZlQ29tcG9zaXRpb25Db25maWcudHN4XG5pbXBvcnQge1xuICBjcmVhdGVDb250ZXh0IGFzIGNyZWF0ZUNvbnRleHQ4LFxuICBjcmVhdGVSZWYsXG4gIHVzZUNhbGxiYWNrIGFzIHVzZUNhbGxiYWNrMyxcbiAgdXNlQ29udGV4dCBhcyB1c2VDb250ZXh0NSxcbiAgdXNlRWZmZWN0IGFzIHVzZUVmZmVjdDQsXG4gIHVzZUltcGVyYXRpdmVIYW5kbGUgYXMgdXNlSW1wZXJhdGl2ZUhhbmRsZTIsXG4gIHVzZU1lbW8gYXMgdXNlTWVtbzUsXG4gIHVzZVN0YXRlIGFzIHVzZVN0YXRlNFxufSBmcm9tIFwicmVhY3RcIjtcblxuLy8gc3JjL0VkaXRvclByb3BzLnRzeFxuaW1wb3J0IFJlYWN0NCwge1xuICBjcmVhdGVDb250ZXh0IGFzIGNyZWF0ZUNvbnRleHQ3LFxuICB1c2VDYWxsYmFjayBhcyB1c2VDYWxsYmFjazIsXG4gIHVzZUltcGVyYXRpdmVIYW5kbGUsXG4gIHVzZU1lbW8gYXMgdXNlTWVtbzRcbn0gZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgeyBqc3ggYXMganN4NSB9IGZyb20gXCJyZWFjdC9qc3gtcnVudGltZVwiO1xudmFyIEVkaXRvclByb3BzQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQ3KHtcbiAgcHJvcHM6IHt9LFxuICB1cGRhdGVQcm9wczogKCkgPT4ge1xuICAgIHRocm93IG5ldyBFcnJvcihcIk5vdCBpbXBsZW1lbnRlZFwiKTtcbiAgfSxcbiAgcmVzZXRVbnNhdmVkOiAoKSA9PiB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiTm90IGltcGxlbWVudGVkXCIpO1xuICB9XG59KTtcbnZhciBlZGl0b3JQcm9wc1Byb3ZpZGVyUmVmID0gUmVhY3Q0LmNyZWF0ZVJlZigpO1xudmFyIEVkaXRvclByb3BzUHJvdmlkZXIgPSAoeyBjaGlsZHJlbiB9KSA9PiB7XG4gIGNvbnN0IFtwcm9wcywgc2V0UHJvcHNdID0gUmVhY3Q0LnVzZVN0YXRlKHt9KTtcbiAgY29uc3QgdXBkYXRlUHJvcHMgPSB1c2VDYWxsYmFjazIoKHtcbiAgICBkZWZhdWx0UHJvcHMsXG4gICAgaWQsXG4gICAgbmV3UHJvcHNcbiAgfSkgPT4ge1xuICAgIHNldFByb3BzKChwcmV2KSA9PiB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi5wcmV2LFxuICAgICAgICBbaWRdOiB0eXBlb2YgbmV3UHJvcHMgPT09IFwiZnVuY3Rpb25cIiA/IG5ld1Byb3BzKHByZXZbaWRdID8/IGRlZmF1bHRQcm9wcykgOiBuZXdQcm9wc1xuICAgICAgfTtcbiAgICB9KTtcbiAgfSwgW10pO1xuICBjb25zdCByZXNldFVuc2F2ZWQgPSB1c2VDYWxsYmFjazIoKCkgPT4ge1xuICAgIHNldFByb3BzKHt9KTtcbiAgfSwgW10pO1xuICB1c2VJbXBlcmF0aXZlSGFuZGxlKGVkaXRvclByb3BzUHJvdmlkZXJSZWYsICgpID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgZ2V0UHJvcHM6ICgpID0+IHByb3BzLFxuICAgICAgc2V0UHJvcHNcbiAgICB9O1xuICB9LCBbcHJvcHNdKTtcbiAgY29uc3QgY3R4ID0gdXNlTWVtbzQoKCkgPT4ge1xuICAgIHJldHVybiB7IHByb3BzLCB1cGRhdGVQcm9wcywgcmVzZXRVbnNhdmVkIH07XG4gIH0sIFtwcm9wcywgcmVzZXRVbnNhdmVkLCB1cGRhdGVQcm9wc10pO1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeDUoRWRpdG9yUHJvcHNDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgdmFsdWU6IGN0eCxcbiAgICBjaGlsZHJlblxuICB9KTtcbn07XG5cbi8vIHNyYy9zdGF0aWMtZmlsZS50c1xudmFyIHByb2JsZW1hdGljQ2hhcmFjdGVycyA9IHtcbiAgXCIlM0FcIjogXCI6XCIsXG4gIFwiJTJGXCI6IFwiL1wiLFxuICBcIiUzRlwiOiBcIj9cIixcbiAgXCIlMjNcIjogXCIjXCIsXG4gIFwiJTVCXCI6IFwiW1wiLFxuICBcIiU1RFwiOiBcIl1cIixcbiAgXCIlNDBcIjogXCJAXCIsXG4gIFwiJTIxXCI6IFwiIVwiLFxuICBcIiUyNFwiOiBcIiRcIixcbiAgXCIlMjZcIjogXCImXCIsXG4gIFwiJTI3XCI6IFwiJ1wiLFxuICBcIiUyOFwiOiBcIihcIixcbiAgXCIlMjlcIjogXCIpXCIsXG4gIFwiJTJBXCI6IFwiKlwiLFxuICBcIiUyQlwiOiBcIitcIixcbiAgXCIlMkNcIjogXCIsXCIsXG4gIFwiJTNCXCI6IFwiO1wiXG59O1xudmFyIGRpZFdhcm4gPSB7fTtcbnZhciB3YXJuT25jZSA9IChtZXNzYWdlKSA9PiB7XG4gIGlmIChkaWRXYXJuW21lc3NhZ2VdKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnNvbGUud2FybihtZXNzYWdlKTtcbiAgZGlkV2FyblttZXNzYWdlXSA9IHRydWU7XG59O1xudmFyIGluY2x1ZGVzSGV4T2ZVbnNhZmVDaGFyID0gKHBhdGgpID0+IHtcbiAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMocHJvYmxlbWF0aWNDaGFyYWN0ZXJzKSkge1xuICAgIGlmIChwYXRoLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgIHJldHVybiB7IGNvbnRhaW5zSGV4OiB0cnVlLCBoZXhDb2RlOiBrZXkgfTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHsgY29udGFpbnNIZXg6IGZhbHNlIH07XG59O1xudmFyIHRyaW1MZWFkaW5nU2xhc2ggPSAocGF0aCkgPT4ge1xuICBpZiAocGF0aC5zdGFydHNXaXRoKFwiL1wiKSkge1xuICAgIHJldHVybiB0cmltTGVhZGluZ1NsYXNoKHBhdGguc3Vic3RyaW5nKDEpKTtcbiAgfVxuICByZXR1cm4gcGF0aDtcbn07XG52YXIgaW5uZXIgPSAocGF0aCkgPT4ge1xuICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB3aW5kb3cucmVtb3Rpb25fc3RhdGljQmFzZSkge1xuICAgIGlmIChwYXRoLnN0YXJ0c1dpdGgod2luZG93LnJlbW90aW9uX3N0YXRpY0Jhc2UpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFRoZSB2YWx1ZSBcIiR7cGF0aH1cIiBpcyBhbHJlYWR5IHByZWZpeGVkIHdpdGggdGhlIHN0YXRpYyBiYXNlICR7d2luZG93LnJlbW90aW9uX3N0YXRpY0Jhc2V9LiBZb3UgZG9uJ3QgbmVlZCB0byBjYWxsIHN0YXRpY0ZpbGUoKSBvbiBpdC5gKTtcbiAgICB9XG4gICAgcmV0dXJuIGAke3dpbmRvdy5yZW1vdGlvbl9zdGF0aWNCYXNlfS8ke3RyaW1MZWFkaW5nU2xhc2gocGF0aCl9YDtcbiAgfVxuICByZXR1cm4gYC8ke3RyaW1MZWFkaW5nU2xhc2gocGF0aCl9YDtcbn07XG52YXIgZW5jb2RlQnlTcGxpdHRpbmcgPSAocGF0aCkgPT4ge1xuICBjb25zdCBzcGxpdEJ5U2xhc2ggPSBwYXRoLnNwbGl0KFwiL1wiKTtcbiAgY29uc3QgZW5jb2RlZEFycmF5ID0gc3BsaXRCeVNsYXNoLm1hcCgoZWxlbWVudCkgPT4ge1xuICAgIHJldHVybiBlbmNvZGVVUklDb21wb25lbnQoZWxlbWVudCk7XG4gIH0pO1xuICBjb25zdCBtZXJnZWQgPSBlbmNvZGVkQXJyYXkuam9pbihcIi9cIik7XG4gIHJldHVybiBtZXJnZWQ7XG59O1xudmFyIHN0YXRpY0ZpbGUgPSAocGF0aCkgPT4ge1xuICBpZiAocGF0aC5zdGFydHNXaXRoKFwiaHR0cDovL1wiKSB8fCBwYXRoLnN0YXJ0c1dpdGgoXCJodHRwczovL1wiKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYHN0YXRpY0ZpbGUoKSBkb2VzIG5vdCBzdXBwb3J0IHJlbW90ZSBVUkxzIC0gZ290IFwiJHtwYXRofVwiLiBJbnN0ZWFkLCBwYXNzIHRoZSBVUkwgd2l0aG91dCB3cmFwcGluZyBpdCBpbiBzdGF0aWNGaWxlKCkuIFNlZTogaHR0cHM6Ly9yZW1vdGlvbi5kZXYvZG9jcy9zdGF0aWNmaWxlLXJlbW90ZS11cmxzYCk7XG4gIH1cbiAgaWYgKHBhdGguc3RhcnRzV2l0aChcIi4uXCIpIHx8IHBhdGguc3RhcnRzV2l0aChcIi4vXCIpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgc3RhdGljRmlsZSgpIGRvZXMgbm90IHN1cHBvcnQgcmVsYXRpdmUgcGF0aHMgLSBnb3QgXCIke3BhdGh9XCIuIEluc3RlYWQsIHBhc3MgdGhlIG5hbWUgb2YgYSBmaWxlIHRoYXQgaXMgaW5zaWRlIHRoZSBwdWJsaWMvIGZvbGRlci4gU2VlOiBodHRwczovL3JlbW90aW9uLmRldi9kb2NzL3N0YXRpY2ZpbGUtcmVsYXRpdmUtcGF0aHNgKTtcbiAgfVxuICBpZiAocGF0aC5zdGFydHNXaXRoKFwiL1VzZXJzXCIpIHx8IHBhdGguc3RhcnRzV2l0aChcIi9ob21lXCIpIHx8IHBhdGguc3RhcnRzV2l0aChcIi90bXBcIikgfHwgcGF0aC5zdGFydHNXaXRoKFwiL2V0Y1wiKSB8fCBwYXRoLnN0YXJ0c1dpdGgoXCIvb3B0XCIpIHx8IHBhdGguc3RhcnRzV2l0aChcIi92YXJcIikgfHwgcGF0aC5zdGFydHNXaXRoKFwiQzpcIikgfHwgcGF0aC5zdGFydHNXaXRoKFwiRDpcIikgfHwgcGF0aC5zdGFydHNXaXRoKFwiRTpcIikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBzdGF0aWNGaWxlKCkgZG9lcyBub3Qgc3VwcG9ydCBhYnNvbHV0ZSBwYXRocyAtIGdvdCBcIiR7cGF0aH1cIi4gSW5zdGVhZCwgcGFzcyB0aGUgbmFtZSBvZiBhIGZpbGUgdGhhdCBpcyBpbnNpZGUgdGhlIHB1YmxpYy8gZm9sZGVyLiBTZWU6IGh0dHBzOi8vcmVtb3Rpb24uZGV2L2RvY3Mvc3RhdGljZmlsZS1yZWxhdGl2ZS1wYXRoc2ApO1xuICB9XG4gIGlmIChwYXRoLnN0YXJ0c1dpdGgoXCJwdWJsaWMvXCIpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgRG8gbm90IGluY2x1ZGUgdGhlIHB1YmxpYy8gcHJlZml4IHdoZW4gdXNpbmcgc3RhdGljRmlsZSgpIC0gZ290IFwiJHtwYXRofVwiLiBTZWU6IGh0dHBzOi8vcmVtb3Rpb24uZGV2L2RvY3Mvc3RhdGljZmlsZS1yZWxhdGl2ZS1wYXRoc2ApO1xuICB9XG4gIGNvbnN0IGluY2x1ZGVzSGV4ID0gaW5jbHVkZXNIZXhPZlVuc2FmZUNoYXIocGF0aCk7XG4gIGlmIChpbmNsdWRlc0hleC5jb250YWluc0hleCkge1xuICAgIHdhcm5PbmNlKGBXQVJOSU5HOiBZb3Ugc2VlbSB0byBwYXNzIGFuIGFscmVhZHkgZW5jb2RlZCBwYXRoIChwYXRoIGNvbnRhaW5zICR7aW5jbHVkZXNIZXguaGV4Q29kZX0pLiBTaW5jZSBSZW1vdGlvbiA0LjAsIHRoZSBlbmNvZGluZyBpcyBkb25lIGJ5IHN0YXRpY0ZpbGUoKSBpdHNlbGYuIFlvdSBtYXkgd2FudCB0byByZW1vdmUgYSBlbmNvZGVVUklDb21wb25lbnQoKSB3cmFwcGluZy5gKTtcbiAgfVxuICBjb25zdCBwcmVwcm9jZXNzZWQgPSBlbmNvZGVCeVNwbGl0dGluZyhwYXRoKTtcbiAgY29uc3QgcHJlcGFyc2VkID0gaW5uZXIocHJlcHJvY2Vzc2VkKTtcbiAgaWYgKCFwcmVwYXJzZWQuc3RhcnRzV2l0aChcIi9cIikpIHtcbiAgICByZXR1cm4gYC8ke3ByZXBhcnNlZH1gO1xuICB9XG4gIHJldHVybiBwcmVwYXJzZWQ7XG59O1xuXG4vLyBzcmMvaW5wdXQtcHJvcHMtc2VyaWFsaXphdGlvbi50c1xudmFyIERBVEVfVE9LRU4gPSBcInJlbW90aW9uLWRhdGU6XCI7XG52YXIgRklMRV9UT0tFTiA9IFwicmVtb3Rpb24tZmlsZTpcIjtcbnZhciBzZXJpYWxpemVKU09OV2l0aERhdGUgPSAoe1xuICBkYXRhLFxuICBpbmRlbnQsXG4gIHN0YXRpY0Jhc2Vcbn0pID0+IHtcbiAgbGV0IGN1c3RvbURhdGVVc2VkID0gZmFsc2U7XG4gIGxldCBjdXN0b21GaWxlVXNlZCA9IGZhbHNlO1xuICBsZXQgbWFwVXNlZCA9IGZhbHNlO1xuICBsZXQgc2V0VXNlZCA9IGZhbHNlO1xuICB0cnkge1xuICAgIGNvbnN0IHNlcmlhbGl6ZWRTdHJpbmcgPSBKU09OLnN0cmluZ2lmeShkYXRhLCBmdW5jdGlvbihrZXksIHZhbHVlKSB7XG4gICAgICBjb25zdCBpdGVtID0gdGhpc1trZXldO1xuICAgICAgaWYgKGl0ZW0gaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICAgIGN1c3RvbURhdGVVc2VkID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIGAke0RBVEVfVE9LRU59JHtpdGVtLnRvSVNPU3RyaW5nKCl9YDtcbiAgICAgIH1cbiAgICAgIGlmIChpdGVtIGluc3RhbmNlb2YgTWFwKSB7XG4gICAgICAgIG1hcFVzZWQgPSB0cnVlO1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9XG4gICAgICBpZiAoaXRlbSBpbnN0YW5jZW9mIFNldCkge1xuICAgICAgICBzZXRVc2VkID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBpdGVtID09PSBcInN0cmluZ1wiICYmIHN0YXRpY0Jhc2UgIT09IG51bGwgJiYgaXRlbS5zdGFydHNXaXRoKHN0YXRpY0Jhc2UpKSB7XG4gICAgICAgIGN1c3RvbUZpbGVVc2VkID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIGAke0ZJTEVfVE9LRU59JHtpdGVtLnJlcGxhY2Uoc3RhdGljQmFzZSArIFwiL1wiLCBcIlwiKX1gO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH0sIGluZGVudCk7XG4gICAgcmV0dXJuIHsgc2VyaWFsaXplZFN0cmluZywgY3VzdG9tRGF0ZVVzZWQsIGN1c3RvbUZpbGVVc2VkLCBtYXBVc2VkLCBzZXRVc2VkIH07XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkNvdWxkIG5vdCBzZXJpYWxpemUgdGhlIHBhc3NlZCBpbnB1dCBwcm9wcyB0byBKU09OOiBcIiArIGVyci5tZXNzYWdlKTtcbiAgfVxufTtcbnZhciBkZXNlcmlhbGl6ZUpTT05XaXRoQ3VzdG9tRmllbGRzID0gKGRhdGEpID0+IHtcbiAgcmV0dXJuIEpTT04ucGFyc2UoZGF0YSwgKF8sIHZhbHVlKSA9PiB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiAmJiB2YWx1ZS5zdGFydHNXaXRoKERBVEVfVE9LRU4pKSB7XG4gICAgICByZXR1cm4gbmV3IERhdGUodmFsdWUucmVwbGFjZShEQVRFX1RPS0VOLCBcIlwiKSk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgJiYgdmFsdWUuc3RhcnRzV2l0aChGSUxFX1RPS0VOKSkge1xuICAgICAgcmV0dXJuIHN0YXRpY0ZpbGUodmFsdWUucmVwbGFjZShGSUxFX1RPS0VOLCBcIlwiKSk7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbiAgfSk7XG59O1xudmFyIHNlcmlhbGl6ZVRoZW5EZXNlcmlhbGl6ZUluU3R1ZGlvID0gKHByb3BzKSA9PiB7XG4gIGlmIChnZXRSZW1vdGlvbkVudmlyb25tZW50KCkuaXNTdHVkaW8pIHtcbiAgICByZXR1cm4gZGVzZXJpYWxpemVKU09OV2l0aEN1c3RvbUZpZWxkcyhzZXJpYWxpemVKU09OV2l0aERhdGUoe1xuICAgICAgZGF0YTogcHJvcHMsXG4gICAgICBpbmRlbnQ6IDIsXG4gICAgICBzdGF0aWNCYXNlOiB3aW5kb3cucmVtb3Rpb25fc3RhdGljQmFzZVxuICAgIH0pLnNlcmlhbGl6ZWRTdHJpbmcpO1xuICB9XG4gIHJldHVybiBwcm9wcztcbn07XG5cbi8vIHNyYy9jb25maWcvaW5wdXQtcHJvcHMudHNcbnZhciBkaWRXYXJuU1NSSW1wb3J0ID0gZmFsc2U7XG52YXIgd2Fybk9uY2VTU1JJbXBvcnQgPSAoKSA9PiB7XG4gIGlmIChkaWRXYXJuU1NSSW1wb3J0KSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGRpZFdhcm5TU1JJbXBvcnQgPSB0cnVlO1xuICBjb25zb2xlLndhcm4oXCJDYWxsZWQgYGdldElucHV0UHJvcHMoKWAgb24gdGhlIHNlcnZlci4gVGhpcyBmdW5jdGlvbiBpcyBub3QgYXZhaWxhYmxlIHNlcnZlci1zaWRlIGFuZCBoYXMgcmV0dXJuZWQgYW4gZW1wdHkgb2JqZWN0LlwiKTtcbiAgY29uc29sZS53YXJuKFwiVG8gaGlkZSB0aGlzIHdhcm5pbmcsIGRvbid0IGNhbGwgdGhpcyBmdW5jdGlvbiBvbiB0aGUgc2VydmVyOlwiKTtcbiAgY29uc29sZS53YXJuKFwiICB0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJyA/IHt9IDogZ2V0SW5wdXRQcm9wcygpXCIpO1xufTtcbnZhciBnZXRJbnB1dFByb3BzID0gKCkgPT4ge1xuICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHdhcm5PbmNlU1NSSW1wb3J0KCk7XG4gICAgcmV0dXJuIHt9O1xuICB9XG4gIGlmIChnZXRSZW1vdGlvbkVudmlyb25tZW50KCkuaXNQbGF5ZXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJZb3UgY2Fubm90IGNhbGwgYGdldElucHV0UHJvcHMoKWAgZnJvbSBhIDxQbGF5ZXI+LiBJbnN0ZWFkLCB0aGUgcHJvcHMgYXJlIGF2YWlsYWJsZSBhcyBSZWFjdCBwcm9wcyBmcm9tIGNvbXBvbmVudCB0aGF0IHlvdSBwYXNzZWQgYXMgYGNvbXBvbmVudGAgcHJvcC5cIik7XG4gIH1cbiAgY29uc3QgcGFyYW0gPSB3aW5kb3cucmVtb3Rpb25faW5wdXRQcm9wcztcbiAgaWYgKCFwYXJhbSkge1xuICAgIHJldHVybiB7fTtcbiAgfVxuICBjb25zdCBwYXJzZWQgPSBkZXNlcmlhbGl6ZUpTT05XaXRoQ3VzdG9tRmllbGRzKHBhcmFtKTtcbiAgcmV0dXJuIHBhcnNlZDtcbn07XG5cbi8vIHNyYy9jb2RlYy50c1xudmFyIHZhbGlkQ29kZWNzID0gW1xuICBcImgyNjRcIixcbiAgXCJoMjY1XCIsXG4gIFwidnA4XCIsXG4gIFwidnA5XCIsXG4gIFwibXAzXCIsXG4gIFwiYWFjXCIsXG4gIFwid2F2XCIsXG4gIFwicHJvcmVzXCIsXG4gIFwiaDI2NC1ta3ZcIixcbiAgXCJoMjY0LXRzXCIsXG4gIFwiZ2lmXCJcbl07XG5cbi8vIHNyYy92YWxpZGF0aW9uL3ZhbGlkYXRlLWRlZmF1bHQtY29kZWMudHNcbmZ1bmN0aW9uIHZhbGlkYXRlRGVmYXVsdENvZGVjKGRlZmF1bHRDb2RlYywgbG9jYXRpb24pIHtcbiAgaWYgKHR5cGVvZiBkZWZhdWx0Q29kZWMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKHR5cGVvZiBkZWZhdWx0Q29kZWMgIT09IFwic3RyaW5nXCIpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBUaGUgXCJkZWZhdWx0Q29kZWNcIiBwcm9wICR7bG9jYXRpb259IG11c3QgYmUgYSBzdHJpbmcsIGJ1dCB5b3UgcGFzc2VkIGEgdmFsdWUgb2YgdHlwZSAke3R5cGVvZiBkZWZhdWx0Q29kZWN9LmApO1xuICB9XG4gIGlmICghdmFsaWRDb2RlY3MuaW5jbHVkZXMoZGVmYXVsdENvZGVjKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgVGhlIFwiZGVmYXVsdENvZGVjXCIgcHJvcCAke2xvY2F0aW9ufSBtdXN0IGJlIG9uZSBvZiAke3ZhbGlkQ29kZWNzLmpvaW4oXCIsIFwiKX0sIGJ1dCB5b3UgcGFzc2VkICR7ZGVmYXVsdENvZGVjfS5gKTtcbiAgfVxufVxuXG4vLyBzcmMvdmFsaWRhdGlvbi92YWxpZGF0ZS1kaW1lbnNpb25zLnRzXG5mdW5jdGlvbiB2YWxpZGF0ZURpbWVuc2lvbihhbW91bnQsIG5hbWVPZlByb3AsIGxvY2F0aW9uKSB7XG4gIGlmICh0eXBlb2YgYW1vdW50ICE9PSBcIm51bWJlclwiKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBUaGUgXCIke25hbWVPZlByb3B9XCIgcHJvcCAke2xvY2F0aW9ufSBtdXN0IGJlIGEgbnVtYmVyLCBidXQgeW91IHBhc3NlZCBhIHZhbHVlIG9mIHR5cGUgJHt0eXBlb2YgYW1vdW50fWApO1xuICB9XG4gIGlmIChpc05hTihhbW91bnQpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgVGhlIFwiJHtuYW1lT2ZQcm9wfVwiIHByb3AgJHtsb2NhdGlvbn0gbXVzdCBub3QgYmUgTmFOLCBidXQgaXMgTmFOLmApO1xuICB9XG4gIGlmICghTnVtYmVyLmlzRmluaXRlKGFtb3VudCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBUaGUgXCIke25hbWVPZlByb3B9XCIgcHJvcCAke2xvY2F0aW9ufSBtdXN0IGJlIGZpbml0ZSwgYnV0IGlzICR7YW1vdW50fS5gKTtcbiAgfVxuICBpZiAoYW1vdW50ICUgMSAhPT0gMCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFRoZSBcIiR7bmFtZU9mUHJvcH1cIiBwcm9wICR7bG9jYXRpb259IG11c3QgYmUgYW4gaW50ZWdlciwgYnV0IGlzICR7YW1vdW50fS5gKTtcbiAgfVxuICBpZiAoYW1vdW50IDw9IDApIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBUaGUgXCIke25hbWVPZlByb3B9XCIgcHJvcCAke2xvY2F0aW9ufSBtdXN0IGJlIHBvc2l0aXZlLCBidXQgZ290ICR7YW1vdW50fS5gKTtcbiAgfVxufVxuXG4vLyBzcmMvdmFsaWRhdGlvbi92YWxpZGF0ZS1kdXJhdGlvbi1pbi1mcmFtZXMudHNcbmZ1bmN0aW9uIHZhbGlkYXRlRHVyYXRpb25JbkZyYW1lcyhkdXJhdGlvbkluRnJhbWVzLCBvcHRpb25zKSB7XG4gIGNvbnN0IHsgYWxsb3dGbG9hdHMsIGNvbXBvbmVudCB9ID0gb3B0aW9ucztcbiAgaWYgKHR5cGVvZiBkdXJhdGlvbkluRnJhbWVzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBUaGUgXCJkdXJhdGlvbkluRnJhbWVzXCIgcHJvcCAke2NvbXBvbmVudH0gaXMgbWlzc2luZy5gKTtcbiAgfVxuICBpZiAodHlwZW9mIGR1cmF0aW9uSW5GcmFtZXMgIT09IFwibnVtYmVyXCIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFRoZSBcImR1cmF0aW9uSW5GcmFtZXNcIiBwcm9wICR7Y29tcG9uZW50fSBtdXN0IGJlIGEgbnVtYmVyLCBidXQgeW91IHBhc3NlZCBhIHZhbHVlIG9mIHR5cGUgJHt0eXBlb2YgZHVyYXRpb25JbkZyYW1lc31gKTtcbiAgfVxuICBpZiAoZHVyYXRpb25JbkZyYW1lcyA8PSAwKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgVGhlIFwiZHVyYXRpb25JbkZyYW1lc1wiIHByb3AgJHtjb21wb25lbnR9IG11c3QgYmUgcG9zaXRpdmUsIGJ1dCBnb3QgJHtkdXJhdGlvbkluRnJhbWVzfS5gKTtcbiAgfVxuICBpZiAoIWFsbG93RmxvYXRzICYmIGR1cmF0aW9uSW5GcmFtZXMgJSAxICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgVGhlIFwiZHVyYXRpb25JbkZyYW1lc1wiIHByb3AgJHtjb21wb25lbnR9IG11c3QgYmUgYW4gaW50ZWdlciwgYnV0IGdvdCAke2R1cmF0aW9uSW5GcmFtZXN9LmApO1xuICB9XG4gIGlmICghTnVtYmVyLmlzRmluaXRlKGR1cmF0aW9uSW5GcmFtZXMpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgVGhlIFwiZHVyYXRpb25JbkZyYW1lc1wiIHByb3AgJHtjb21wb25lbnR9IG11c3QgYmUgZmluaXRlLCBidXQgZ290ICR7ZHVyYXRpb25JbkZyYW1lc30uYCk7XG4gIH1cbn1cblxuLy8gc3JjL3ZhbGlkYXRpb24vdmFsaWRhdGUtZnBzLnRzXG5mdW5jdGlvbiB2YWxpZGF0ZUZwcyhmcHMsIGxvY2F0aW9uLCBpc0dpZikge1xuICBpZiAodHlwZW9mIGZwcyAhPT0gXCJudW1iZXJcIikge1xuICAgIHRocm93IG5ldyBFcnJvcihgXCJmcHNcIiBtdXN0IGJlIGEgbnVtYmVyLCBidXQgeW91IHBhc3NlZCBhIHZhbHVlIG9mIHR5cGUgJHt0eXBlb2YgZnBzfSAke2xvY2F0aW9ufWApO1xuICB9XG4gIGlmICghTnVtYmVyLmlzRmluaXRlKGZwcykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFwiZnBzXCIgbXVzdCBiZSBhIGZpbml0ZSwgYnV0IHlvdSBwYXNzZWQgJHtmcHN9ICR7bG9jYXRpb259YCk7XG4gIH1cbiAgaWYgKGlzTmFOKGZwcykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFwiZnBzXCIgbXVzdCBub3QgYmUgTmFOLCBidXQgZ290ICR7ZnBzfSAke2xvY2F0aW9ufWApO1xuICB9XG4gIGlmIChmcHMgPD0gMCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFwiZnBzXCIgbXVzdCBiZSBwb3NpdGl2ZSwgYnV0IGdvdCAke2Zwc30gJHtsb2NhdGlvbn1gKTtcbiAgfVxuICBpZiAoaXNHaWYgJiYgZnBzID4gNTApIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBUaGUgRlBTIGZvciBhIEdJRiBjYW5ub3QgYmUgaGlnaGVyIHRoYW4gNTAuIFVzZSB0aGUgLS1ldmVyeS1udGgtZnJhbWUgb3B0aW9uIHRvIGxvd2VyIHRoZSBGUFM6IGh0dHBzOi8vcmVtb3Rpb24uZGV2L2RvY3MvcmVuZGVyLWFzLWdpZmApO1xuICB9XG59XG5cbi8vIHNyYy9yZXNvbHZlLXZpZGVvLWNvbmZpZy50c1xudmFyIHZhbGlkYXRlQ2FsY3VsYXRlZCA9ICh7XG4gIGNhbGN1bGF0ZWQsXG4gIGNvbXBvc2l0aW9uSWQsXG4gIGNvbXBvc2l0aW9uRnBzLFxuICBjb21wb3NpdGlvbkhlaWdodCxcbiAgY29tcG9zaXRpb25XaWR0aCxcbiAgY29tcG9zaXRpb25EdXJhdGlvbkluRnJhbWVzXG59KSA9PiB7XG4gIGNvbnN0IGNhbGN1bGF0ZU1ldGFkYXRhRXJyb3JMb2NhdGlvbiA9IGBjYWxjdWxhdGVkIGJ5IGNhbGN1bGF0ZU1ldGFkYXRhKCkgZm9yIHRoZSBjb21wb3NpdGlvbiBcIiR7Y29tcG9zaXRpb25JZH1cImA7XG4gIGNvbnN0IGRlZmF1bHRFcnJvckxvY2F0aW9uID0gYG9mIHRoZSBcIjxDb21wb3NpdGlvbiAvPlwiIGNvbXBvbmVudCB3aXRoIHRoZSBpZCBcIiR7Y29tcG9zaXRpb25JZH1cImA7XG4gIGNvbnN0IHdpZHRoID0gY2FsY3VsYXRlZD8ud2lkdGggPz8gY29tcG9zaXRpb25XaWR0aCA/PyB1bmRlZmluZWQ7XG4gIHZhbGlkYXRlRGltZW5zaW9uKHdpZHRoLCBcIndpZHRoXCIsIGNhbGN1bGF0ZWQ/LndpZHRoID8gY2FsY3VsYXRlTWV0YWRhdGFFcnJvckxvY2F0aW9uIDogZGVmYXVsdEVycm9yTG9jYXRpb24pO1xuICBjb25zdCBoZWlnaHQgPSBjYWxjdWxhdGVkPy5oZWlnaHQgPz8gY29tcG9zaXRpb25IZWlnaHQgPz8gdW5kZWZpbmVkO1xuICB2YWxpZGF0ZURpbWVuc2lvbihoZWlnaHQsIFwiaGVpZ2h0XCIsIGNhbGN1bGF0ZWQ/LmhlaWdodCA/IGNhbGN1bGF0ZU1ldGFkYXRhRXJyb3JMb2NhdGlvbiA6IGRlZmF1bHRFcnJvckxvY2F0aW9uKTtcbiAgY29uc3QgZnBzID0gY2FsY3VsYXRlZD8uZnBzID8/IGNvbXBvc2l0aW9uRnBzID8/IG51bGw7XG4gIHZhbGlkYXRlRnBzKGZwcywgY2FsY3VsYXRlZD8uZnBzID8gY2FsY3VsYXRlTWV0YWRhdGFFcnJvckxvY2F0aW9uIDogZGVmYXVsdEVycm9yTG9jYXRpb24sIGZhbHNlKTtcbiAgY29uc3QgZHVyYXRpb25JbkZyYW1lcyA9IGNhbGN1bGF0ZWQ/LmR1cmF0aW9uSW5GcmFtZXMgPz8gY29tcG9zaXRpb25EdXJhdGlvbkluRnJhbWVzID8/IG51bGw7XG4gIHZhbGlkYXRlRHVyYXRpb25JbkZyYW1lcyhkdXJhdGlvbkluRnJhbWVzLCB7XG4gICAgYWxsb3dGbG9hdHM6IGZhbHNlLFxuICAgIGNvbXBvbmVudDogYG9mIHRoZSBcIjxDb21wb3NpdGlvbiAvPlwiIGNvbXBvbmVudCB3aXRoIHRoZSBpZCBcIiR7Y29tcG9zaXRpb25JZH1cImBcbiAgfSk7XG4gIGNvbnN0IGRlZmF1bHRDb2RlYyA9IGNhbGN1bGF0ZWQ/LmRlZmF1bHRDb2RlYztcbiAgdmFsaWRhdGVEZWZhdWx0Q29kZWMoZGVmYXVsdENvZGVjLCBjYWxjdWxhdGVNZXRhZGF0YUVycm9yTG9jYXRpb24pO1xuICByZXR1cm4geyB3aWR0aCwgaGVpZ2h0LCBmcHMsIGR1cmF0aW9uSW5GcmFtZXMsIGRlZmF1bHRDb2RlYyB9O1xufTtcbnZhciByZXNvbHZlVmlkZW9Db25maWcgPSAoe1xuICBjYWxjdWxhdGVNZXRhZGF0YSxcbiAgc2lnbmFsLFxuICBkZWZhdWx0UHJvcHMsXG4gIG9yaWdpbmFsUHJvcHMsXG4gIGNvbXBvc2l0aW9uSWQsXG4gIGNvbXBvc2l0aW9uRHVyYXRpb25JbkZyYW1lcyxcbiAgY29tcG9zaXRpb25GcHMsXG4gIGNvbXBvc2l0aW9uSGVpZ2h0LFxuICBjb21wb3NpdGlvbldpZHRoXG59KSA9PiB7XG4gIGNvbnN0IGNhbGN1bGF0ZWRQcm9tID0gY2FsY3VsYXRlTWV0YWRhdGEgPyBjYWxjdWxhdGVNZXRhZGF0YSh7XG4gICAgZGVmYXVsdFByb3BzLFxuICAgIHByb3BzOiBvcmlnaW5hbFByb3BzLFxuICAgIGFib3J0U2lnbmFsOiBzaWduYWwsXG4gICAgY29tcG9zaXRpb25JZFxuICB9KSA6IG51bGw7XG4gIGlmIChjYWxjdWxhdGVkUHJvbSAhPT0gbnVsbCAmJiB0eXBlb2YgY2FsY3VsYXRlZFByb20gPT09IFwib2JqZWN0XCIgJiYgXCJ0aGVuXCIgaW4gY2FsY3VsYXRlZFByb20pIHtcbiAgICByZXR1cm4gY2FsY3VsYXRlZFByb20udGhlbigoYykgPT4ge1xuICAgICAgY29uc3QgeyBoZWlnaHQsIHdpZHRoLCBkdXJhdGlvbkluRnJhbWVzLCBmcHMsIGRlZmF1bHRDb2RlYyB9ID0gdmFsaWRhdGVDYWxjdWxhdGVkKHtcbiAgICAgICAgY2FsY3VsYXRlZDogYyxcbiAgICAgICAgY29tcG9zaXRpb25EdXJhdGlvbkluRnJhbWVzLFxuICAgICAgICBjb21wb3NpdGlvbkZwcyxcbiAgICAgICAgY29tcG9zaXRpb25IZWlnaHQsXG4gICAgICAgIGNvbXBvc2l0aW9uV2lkdGgsXG4gICAgICAgIGNvbXBvc2l0aW9uSWRcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgd2lkdGgsXG4gICAgICAgIGhlaWdodCxcbiAgICAgICAgZnBzLFxuICAgICAgICBkdXJhdGlvbkluRnJhbWVzLFxuICAgICAgICBpZDogY29tcG9zaXRpb25JZCxcbiAgICAgICAgZGVmYXVsdFByb3BzOiBzZXJpYWxpemVUaGVuRGVzZXJpYWxpemVJblN0dWRpbyhkZWZhdWx0UHJvcHMpLFxuICAgICAgICBwcm9wczogc2VyaWFsaXplVGhlbkRlc2VyaWFsaXplSW5TdHVkaW8oYy5wcm9wcyA/PyBvcmlnaW5hbFByb3BzKSxcbiAgICAgICAgZGVmYXVsdENvZGVjOiBkZWZhdWx0Q29kZWMgPz8gbnVsbFxuICAgICAgfTtcbiAgICB9KTtcbiAgfVxuICBjb25zdCBkYXRhID0gdmFsaWRhdGVDYWxjdWxhdGVkKHtcbiAgICBjYWxjdWxhdGVkOiBjYWxjdWxhdGVkUHJvbSxcbiAgICBjb21wb3NpdGlvbkR1cmF0aW9uSW5GcmFtZXMsXG4gICAgY29tcG9zaXRpb25GcHMsXG4gICAgY29tcG9zaXRpb25IZWlnaHQsXG4gICAgY29tcG9zaXRpb25XaWR0aCxcbiAgICBjb21wb3NpdGlvbklkXG4gIH0pO1xuICBpZiAoY2FsY3VsYXRlZFByb20gPT09IG51bGwpIHtcbiAgICByZXR1cm4ge1xuICAgICAgLi4uZGF0YSxcbiAgICAgIGlkOiBjb21wb3NpdGlvbklkLFxuICAgICAgZGVmYXVsdFByb3BzOiBzZXJpYWxpemVUaGVuRGVzZXJpYWxpemVJblN0dWRpbyhkZWZhdWx0UHJvcHMgPz8ge30pLFxuICAgICAgcHJvcHM6IHNlcmlhbGl6ZVRoZW5EZXNlcmlhbGl6ZUluU3R1ZGlvKG9yaWdpbmFsUHJvcHMpLFxuICAgICAgZGVmYXVsdENvZGVjOiBudWxsXG4gICAgfTtcbiAgfVxuICByZXR1cm4ge1xuICAgIC4uLmRhdGEsXG4gICAgaWQ6IGNvbXBvc2l0aW9uSWQsXG4gICAgZGVmYXVsdFByb3BzOiBzZXJpYWxpemVUaGVuRGVzZXJpYWxpemVJblN0dWRpbyhkZWZhdWx0UHJvcHMgPz8ge30pLFxuICAgIHByb3BzOiBzZXJpYWxpemVUaGVuRGVzZXJpYWxpemVJblN0dWRpbyhjYWxjdWxhdGVkUHJvbS5wcm9wcyA/PyBvcmlnaW5hbFByb3BzKSxcbiAgICBkZWZhdWx0Q29kZWM6IGNhbGN1bGF0ZWRQcm9tLmRlZmF1bHRDb2RlYyA/PyBudWxsXG4gIH07XG59O1xudmFyIHJlc29sdmVWaWRlb0NvbmZpZ09yQ2F0Y2ggPSAocGFyYW1zKSA9PiB7XG4gIHRyeSB7XG4gICAgY29uc3QgcHJvbWlzZU9yUmV0dXJuVmFsdWUgPSByZXNvbHZlVmlkZW9Db25maWcocGFyYW1zKTtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJzdWNjZXNzXCIsXG4gICAgICByZXN1bHQ6IHByb21pc2VPclJldHVyblZhbHVlXG4gICAgfTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiZXJyb3JcIixcbiAgICAgIGVycm9yOiBlcnJcbiAgICB9O1xuICB9XG59O1xuXG4vLyBzcmMvUmVzb2x2ZUNvbXBvc2l0aW9uQ29uZmlnLnRzeFxuaW1wb3J0IHsganN4IGFzIGpzeDYgfSBmcm9tIFwicmVhY3QvanN4LXJ1bnRpbWVcIjtcbnZhciBSZXNvbHZlQ29tcG9zaXRpb25Db250ZXh0ID0gY3JlYXRlQ29udGV4dDgobnVsbCk7XG52YXIgcmVzb2x2ZUNvbXBvc2l0aW9uc1JlZiA9IGNyZWF0ZVJlZigpO1xudmFyIG5lZWRzUmVzb2x1dGlvbiA9IChjb21wb3NpdGlvbikgPT4ge1xuICByZXR1cm4gQm9vbGVhbihjb21wb3NpdGlvbi5jYWxjdWxhdGVNZXRhZGF0YSk7XG59O1xudmFyIFBST1BTX1VQREFURURfRVhURVJOQUxMWSA9IFwicmVtb3Rpb24ucHJvcHNVcGRhdGVkRXh0ZXJuYWxseVwiO1xudmFyIFJlc29sdmVDb21wb3NpdGlvbkNvbmZpZyA9ICh7IGNoaWxkcmVuIH0pID0+IHtcbiAgY29uc3QgW2N1cnJlbnRSZW5kZXJNb2RhbENvbXBvc2l0aW9uLCBzZXRDdXJyZW50UmVuZGVyTW9kYWxDb21wb3NpdGlvbl0gPSB1c2VTdGF0ZTQobnVsbCk7XG4gIGNvbnN0IHsgY29tcG9zaXRpb25zLCBjYW52YXNDb250ZW50LCBjdXJyZW50Q29tcG9zaXRpb25NZXRhZGF0YSB9ID0gdXNlQ29udGV4dDUoQ29tcG9zaXRpb25NYW5hZ2VyKTtcbiAgY29uc3QgeyBmYXN0UmVmcmVzaGVzIH0gPSB1c2VDb250ZXh0NShOb25jZUNvbnRleHQpO1xuICBjb25zdCBzZWxlY3RlZENvbXBvc2l0aW9uID0gdXNlTWVtbzUoKCkgPT4ge1xuICAgIHJldHVybiBjb21wb3NpdGlvbnMuZmluZCgoYykgPT4gY2FudmFzQ29udGVudCAmJiBjYW52YXNDb250ZW50LnR5cGUgPT09IFwiY29tcG9zaXRpb25cIiAmJiBjYW52YXNDb250ZW50LmNvbXBvc2l0aW9uSWQgPT09IGMuaWQpO1xuICB9LCBbY2FudmFzQ29udGVudCwgY29tcG9zaXRpb25zXSk7XG4gIGNvbnN0IHJlbmRlck1vZGFsQ29tcG9zaXRpb24gPSBjb21wb3NpdGlvbnMuZmluZCgoYykgPT4gYy5pZCA9PT0gY3VycmVudFJlbmRlck1vZGFsQ29tcG9zaXRpb24pO1xuICBjb25zdCB7IHByb3BzOiBhbGxFZGl0b3JQcm9wcyB9ID0gdXNlQ29udGV4dDUoRWRpdG9yUHJvcHNDb250ZXh0KTtcbiAgY29uc3QgaW5wdXRQcm9wcyA9IHVzZU1lbW81KCgpID0+IHtcbiAgICByZXR1cm4gdHlwZW9mIHdpbmRvdyA9PT0gXCJ1bmRlZmluZWRcIiB8fCBnZXRSZW1vdGlvbkVudmlyb25tZW50KCkuaXNQbGF5ZXIgPyB7fSA6IGdldElucHV0UHJvcHMoKSA/PyB7fTtcbiAgfSwgW10pO1xuICBjb25zdCBbcmVzb2x2ZWRDb25maWdzLCBzZXRSZXNvbHZlZENvbmZpZ3NdID0gdXNlU3RhdGU0KHt9KTtcbiAgY29uc3Qgc2VsZWN0ZWRFZGl0b3JQcm9wcyA9IHVzZU1lbW81KCgpID0+IHtcbiAgICByZXR1cm4gc2VsZWN0ZWRDb21wb3NpdGlvbiA/IGFsbEVkaXRvclByb3BzW3NlbGVjdGVkQ29tcG9zaXRpb24uaWRdID8/IHt9IDoge307XG4gIH0sIFthbGxFZGl0b3JQcm9wcywgc2VsZWN0ZWRDb21wb3NpdGlvbl0pO1xuICBjb25zdCByZW5kZXJNb2RhbFByb3BzID0gdXNlTWVtbzUoKCkgPT4ge1xuICAgIHJldHVybiByZW5kZXJNb2RhbENvbXBvc2l0aW9uID8gYWxsRWRpdG9yUHJvcHNbcmVuZGVyTW9kYWxDb21wb3NpdGlvbi5pZF0gPz8ge30gOiB7fTtcbiAgfSwgW2FsbEVkaXRvclByb3BzLCByZW5kZXJNb2RhbENvbXBvc2l0aW9uXSk7XG4gIGNvbnN0IGhhc1Jlc29sdXRpb24gPSBCb29sZWFuKGN1cnJlbnRDb21wb3NpdGlvbk1ldGFkYXRhKTtcbiAgY29uc3QgZG9SZXNvbHV0aW9uID0gdXNlQ2FsbGJhY2szKCh7XG4gICAgY2FsY3VsYXRlTWV0YWRhdGEsXG4gICAgY29tYmluZWRQcm9wcyxcbiAgICBjb21wb3NpdGlvbkR1cmF0aW9uSW5GcmFtZXMsXG4gICAgY29tcG9zaXRpb25GcHMsXG4gICAgY29tcG9zaXRpb25IZWlnaHQsXG4gICAgY29tcG9zaXRpb25JZCxcbiAgICBjb21wb3NpdGlvbldpZHRoLFxuICAgIGRlZmF1bHRQcm9wc1xuICB9KSA9PiB7XG4gICAgY29uc3QgY29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXI7XG4gICAgaWYgKGhhc1Jlc29sdXRpb24pIHtcbiAgICAgIHJldHVybiBjb250cm9sbGVyO1xuICAgIH1cbiAgICBjb25zdCB7IHNpZ25hbCB9ID0gY29udHJvbGxlcjtcbiAgICBjb25zdCByZXN1bHQgPSByZXNvbHZlVmlkZW9Db25maWdPckNhdGNoKHtcbiAgICAgIGNvbXBvc2l0aW9uSWQsXG4gICAgICBjYWxjdWxhdGVNZXRhZGF0YSxcbiAgICAgIG9yaWdpbmFsUHJvcHM6IGNvbWJpbmVkUHJvcHMsXG4gICAgICBzaWduYWwsXG4gICAgICBkZWZhdWx0UHJvcHMsXG4gICAgICBjb21wb3NpdGlvbkR1cmF0aW9uSW5GcmFtZXMsXG4gICAgICBjb21wb3NpdGlvbkZwcyxcbiAgICAgIGNvbXBvc2l0aW9uSGVpZ2h0LFxuICAgICAgY29tcG9zaXRpb25XaWR0aFxuICAgIH0pO1xuICAgIGlmIChyZXN1bHQudHlwZSA9PT0gXCJlcnJvclwiKSB7XG4gICAgICBzZXRSZXNvbHZlZENvbmZpZ3MoKHIpID0+ICh7XG4gICAgICAgIC4uLnIsXG4gICAgICAgIFtjb21wb3NpdGlvbklkXToge1xuICAgICAgICAgIHR5cGU6IFwiZXJyb3JcIixcbiAgICAgICAgICBlcnJvcjogcmVzdWx0LmVycm9yXG4gICAgICAgIH1cbiAgICAgIH0pKTtcbiAgICAgIHJldHVybiBjb250cm9sbGVyO1xuICAgIH1cbiAgICBjb25zdCBwcm9tT3JOb3QgPSByZXN1bHQucmVzdWx0O1xuICAgIGlmICh0eXBlb2YgcHJvbU9yTm90ID09PSBcIm9iamVjdFwiICYmIFwidGhlblwiIGluIHByb21Pck5vdCkge1xuICAgICAgc2V0UmVzb2x2ZWRDb25maWdzKChyKSA9PiB7XG4gICAgICAgIGNvbnN0IHByZXYgPSByW2NvbXBvc2l0aW9uSWRdO1xuICAgICAgICBpZiAocHJldj8udHlwZSA9PT0gXCJzdWNjZXNzXCIgfHwgcHJldj8udHlwZSA9PT0gXCJzdWNjZXNzLWFuZC1yZWZyZXNoaW5nXCIpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4ucixcbiAgICAgICAgICAgIFtjb21wb3NpdGlvbklkXToge1xuICAgICAgICAgICAgICB0eXBlOiBcInN1Y2Nlc3MtYW5kLXJlZnJlc2hpbmdcIixcbiAgICAgICAgICAgICAgcmVzdWx0OiBwcmV2LnJlc3VsdFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAuLi5yLFxuICAgICAgICAgIFtjb21wb3NpdGlvbklkXToge1xuICAgICAgICAgICAgdHlwZTogXCJsb2FkaW5nXCJcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9KTtcbiAgICAgIHByb21Pck5vdC50aGVuKChjKSA9PiB7XG4gICAgICAgIGlmIChjb250cm9sbGVyLnNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHNldFJlc29sdmVkQ29uZmlncygocikgPT4gKHtcbiAgICAgICAgICAuLi5yLFxuICAgICAgICAgIFtjb21wb3NpdGlvbklkXToge1xuICAgICAgICAgICAgdHlwZTogXCJzdWNjZXNzXCIsXG4gICAgICAgICAgICByZXN1bHQ6IGNcbiAgICAgICAgICB9XG4gICAgICAgIH0pKTtcbiAgICAgIH0pLmNhdGNoKChlcnIpID0+IHtcbiAgICAgICAgaWYgKGNvbnRyb2xsZXIuc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgc2V0UmVzb2x2ZWRDb25maWdzKChyKSA9PiAoe1xuICAgICAgICAgIC4uLnIsXG4gICAgICAgICAgW2NvbXBvc2l0aW9uSWRdOiB7XG4gICAgICAgICAgICB0eXBlOiBcImVycm9yXCIsXG4gICAgICAgICAgICBlcnJvcjogZXJyXG4gICAgICAgICAgfVxuICAgICAgICB9KSk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2V0UmVzb2x2ZWRDb25maWdzKChyKSA9PiAoe1xuICAgICAgICAuLi5yLFxuICAgICAgICBbY29tcG9zaXRpb25JZF06IHtcbiAgICAgICAgICB0eXBlOiBcInN1Y2Nlc3NcIixcbiAgICAgICAgICByZXN1bHQ6IHByb21Pck5vdFxuICAgICAgICB9XG4gICAgICB9KSk7XG4gICAgfVxuICAgIHJldHVybiBjb250cm9sbGVyO1xuICB9LCBbaGFzUmVzb2x1dGlvbl0pO1xuICBjb25zdCBjdXJyZW50Q29tcG9zaXRpb24gPSBjYW52YXNDb250ZW50Py50eXBlID09PSBcImNvbXBvc2l0aW9uXCIgPyBjYW52YXNDb250ZW50LmNvbXBvc2l0aW9uSWQgOiBudWxsO1xuICB1c2VJbXBlcmF0aXZlSGFuZGxlMihyZXNvbHZlQ29tcG9zaXRpb25zUmVmLCAoKSA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHNldEN1cnJlbnRSZW5kZXJNb2RhbENvbXBvc2l0aW9uOiAoaWQpID0+IHtcbiAgICAgICAgc2V0Q3VycmVudFJlbmRlck1vZGFsQ29tcG9zaXRpb24oaWQpO1xuICAgICAgfSxcbiAgICAgIHJlbG9hZEN1cnJlbnRseVNlbGVjdGVkQ29tcG9zaXRpb246ICgpID0+IHtcbiAgICAgICAgaWYgKCFjdXJyZW50Q29tcG9zaXRpb24pIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY29tcG9zaXRpb24gPSBjb21wb3NpdGlvbnMuZmluZCgoYykgPT4gYy5pZCA9PT0gY3VycmVudENvbXBvc2l0aW9uKTtcbiAgICAgICAgaWYgKCFjb21wb3NpdGlvbikge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ291bGQgbm90IGZpbmQgY29tcG9zaXRpb24gd2l0aCBpZCAke2N1cnJlbnRDb21wb3NpdGlvbn1gKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBlZGl0b3JQcm9wcyA9IGFsbEVkaXRvclByb3BzW2N1cnJlbnRDb21wb3NpdGlvbl0gPz8ge307XG4gICAgICAgIGNvbnN0IGRlZmF1bHRQcm9wcyA9IHtcbiAgICAgICAgICAuLi5jb21wb3NpdGlvbi5kZWZhdWx0UHJvcHMgPz8ge30sXG4gICAgICAgICAgLi4uZWRpdG9yUHJvcHMgPz8ge31cbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgcHJvcHMgPSB7XG4gICAgICAgICAgLi4uZGVmYXVsdFByb3BzLFxuICAgICAgICAgIC4uLmlucHV0UHJvcHMgPz8ge31cbiAgICAgICAgfTtcbiAgICAgICAgZG9SZXNvbHV0aW9uKHtcbiAgICAgICAgICBkZWZhdWx0UHJvcHMsXG4gICAgICAgICAgY2FsY3VsYXRlTWV0YWRhdGE6IGNvbXBvc2l0aW9uLmNhbGN1bGF0ZU1ldGFkYXRhLFxuICAgICAgICAgIGNvbWJpbmVkUHJvcHM6IHByb3BzLFxuICAgICAgICAgIGNvbXBvc2l0aW9uRHVyYXRpb25JbkZyYW1lczogY29tcG9zaXRpb24uZHVyYXRpb25JbkZyYW1lcyA/PyBudWxsLFxuICAgICAgICAgIGNvbXBvc2l0aW9uRnBzOiBjb21wb3NpdGlvbi5mcHMgPz8gbnVsbCxcbiAgICAgICAgICBjb21wb3NpdGlvbkhlaWdodDogY29tcG9zaXRpb24uaGVpZ2h0ID8/IG51bGwsXG4gICAgICAgICAgY29tcG9zaXRpb25XaWR0aDogY29tcG9zaXRpb24ud2lkdGggPz8gbnVsbCxcbiAgICAgICAgICBjb21wb3NpdGlvbklkOiBjb21wb3NpdGlvbi5pZFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9O1xuICB9LCBbXG4gICAgYWxsRWRpdG9yUHJvcHMsXG4gICAgY29tcG9zaXRpb25zLFxuICAgIGN1cnJlbnRDb21wb3NpdGlvbixcbiAgICBkb1Jlc29sdXRpb24sXG4gICAgaW5wdXRQcm9wc1xuICBdKTtcbiAgY29uc3QgaXNUaGVTYW1lID0gc2VsZWN0ZWRDb21wb3NpdGlvbj8uaWQgPT09IHJlbmRlck1vZGFsQ29tcG9zaXRpb24/LmlkO1xuICBjb25zdCBjdXJyZW50RGVmYXVsdFByb3BzID0gdXNlTWVtbzUoKCkgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICAuLi5zZWxlY3RlZENvbXBvc2l0aW9uPy5kZWZhdWx0UHJvcHMgPz8ge30sXG4gICAgICAuLi5zZWxlY3RlZEVkaXRvclByb3BzID8/IHt9XG4gICAgfTtcbiAgfSwgW3NlbGVjdGVkQ29tcG9zaXRpb24/LmRlZmF1bHRQcm9wcywgc2VsZWN0ZWRFZGl0b3JQcm9wc10pO1xuICBjb25zdCBvcmlnaW5hbFByb3BzID0gdXNlTWVtbzUoKCkgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICAuLi5jdXJyZW50RGVmYXVsdFByb3BzLFxuICAgICAgLi4uaW5wdXRQcm9wcyA/PyB7fVxuICAgIH07XG4gIH0sIFtjdXJyZW50RGVmYXVsdFByb3BzLCBpbnB1dFByb3BzXSk7XG4gIGNvbnN0IGNhblJlc29sdmUgPSBzZWxlY3RlZENvbXBvc2l0aW9uICYmIG5lZWRzUmVzb2x1dGlvbihzZWxlY3RlZENvbXBvc2l0aW9uKTtcbiAgY29uc3Qgc2hvdWxkSWdub3JlVXBkYXRlID0gdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB3aW5kb3cucmVtb3Rpb25faWdub3JlRmFzdFJlZnJlc2hVcGRhdGUgJiYgZmFzdFJlZnJlc2hlcyA8PSB3aW5kb3cucmVtb3Rpb25faWdub3JlRmFzdFJlZnJlc2hVcGRhdGU7XG4gIHVzZUVmZmVjdDQoKCkgPT4ge1xuICAgIGlmIChzaG91bGRJZ25vcmVVcGRhdGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGNhblJlc29sdmUpIHtcbiAgICAgIGNvbnN0IGNvbnRyb2xsZXIgPSBkb1Jlc29sdXRpb24oe1xuICAgICAgICBjYWxjdWxhdGVNZXRhZGF0YTogc2VsZWN0ZWRDb21wb3NpdGlvbi5jYWxjdWxhdGVNZXRhZGF0YSxcbiAgICAgICAgY29tYmluZWRQcm9wczogb3JpZ2luYWxQcm9wcyxcbiAgICAgICAgY29tcG9zaXRpb25EdXJhdGlvbkluRnJhbWVzOiBzZWxlY3RlZENvbXBvc2l0aW9uLmR1cmF0aW9uSW5GcmFtZXMgPz8gbnVsbCxcbiAgICAgICAgY29tcG9zaXRpb25GcHM6IHNlbGVjdGVkQ29tcG9zaXRpb24uZnBzID8/IG51bGwsXG4gICAgICAgIGNvbXBvc2l0aW9uSGVpZ2h0OiBzZWxlY3RlZENvbXBvc2l0aW9uLmhlaWdodCA/PyBudWxsLFxuICAgICAgICBjb21wb3NpdGlvbldpZHRoOiBzZWxlY3RlZENvbXBvc2l0aW9uLndpZHRoID8/IG51bGwsXG4gICAgICAgIGRlZmF1bHRQcm9wczogY3VycmVudERlZmF1bHRQcm9wcyxcbiAgICAgICAgY29tcG9zaXRpb25JZDogc2VsZWN0ZWRDb21wb3NpdGlvbi5pZFxuICAgICAgfSk7XG4gICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICBjb250cm9sbGVyLmFib3J0KCk7XG4gICAgICB9O1xuICAgIH1cbiAgfSwgW1xuICAgIGNhblJlc29sdmUsXG4gICAgY3VycmVudERlZmF1bHRQcm9wcyxcbiAgICBkb1Jlc29sdXRpb24sXG4gICAgb3JpZ2luYWxQcm9wcyxcbiAgICBzZWxlY3RlZENvbXBvc2l0aW9uPy5jYWxjdWxhdGVNZXRhZGF0YSxcbiAgICBzZWxlY3RlZENvbXBvc2l0aW9uPy5kdXJhdGlvbkluRnJhbWVzLFxuICAgIHNlbGVjdGVkQ29tcG9zaXRpb24/LmZwcyxcbiAgICBzZWxlY3RlZENvbXBvc2l0aW9uPy5oZWlnaHQsXG4gICAgc2VsZWN0ZWRDb21wb3NpdGlvbj8uaWQsXG4gICAgc2VsZWN0ZWRDb21wb3NpdGlvbj8ud2lkdGgsXG4gICAgc2hvdWxkSWdub3JlVXBkYXRlXG4gIF0pO1xuICB1c2VFZmZlY3Q0KCgpID0+IHtcbiAgICBpZiAoc2hvdWxkSWdub3JlVXBkYXRlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHdpbmRvdy5kaXNwYXRjaEV2ZW50KG5ldyBDdXN0b21FdmVudChcInJlbW90aW9uLnByb3BzVXBkYXRlZEV4dGVybmFsbHlcIikpO1xuICB9LCBbZmFzdFJlZnJlc2hlc10pO1xuICB1c2VFZmZlY3Q0KCgpID0+IHtcbiAgICBpZiAocmVuZGVyTW9kYWxDb21wb3NpdGlvbiAmJiAhaXNUaGVTYW1lKSB7XG4gICAgICBjb25zdCBjb21iaW5lZFByb3BzID0ge1xuICAgICAgICAuLi5yZW5kZXJNb2RhbENvbXBvc2l0aW9uLmRlZmF1bHRQcm9wcyA/PyB7fSxcbiAgICAgICAgLi4ucmVuZGVyTW9kYWxQcm9wcyA/PyB7fSxcbiAgICAgICAgLi4uaW5wdXRQcm9wcyA/PyB7fVxuICAgICAgfTtcbiAgICAgIGNvbnN0IGNvbnRyb2xsZXIgPSBkb1Jlc29sdXRpb24oe1xuICAgICAgICBjYWxjdWxhdGVNZXRhZGF0YTogcmVuZGVyTW9kYWxDb21wb3NpdGlvbi5jYWxjdWxhdGVNZXRhZGF0YSxcbiAgICAgICAgY29tcG9zaXRpb25EdXJhdGlvbkluRnJhbWVzOiByZW5kZXJNb2RhbENvbXBvc2l0aW9uLmR1cmF0aW9uSW5GcmFtZXMgPz8gbnVsbCxcbiAgICAgICAgY29tcG9zaXRpb25GcHM6IHJlbmRlck1vZGFsQ29tcG9zaXRpb24uZnBzID8/IG51bGwsXG4gICAgICAgIGNvbXBvc2l0aW9uSGVpZ2h0OiByZW5kZXJNb2RhbENvbXBvc2l0aW9uLmhlaWdodCA/PyBudWxsLFxuICAgICAgICBjb21wb3NpdGlvbklkOiByZW5kZXJNb2RhbENvbXBvc2l0aW9uLmlkLFxuICAgICAgICBjb21wb3NpdGlvbldpZHRoOiByZW5kZXJNb2RhbENvbXBvc2l0aW9uLndpZHRoID8/IG51bGwsXG4gICAgICAgIGRlZmF1bHRQcm9wczogY3VycmVudERlZmF1bHRQcm9wcyxcbiAgICAgICAgY29tYmluZWRQcm9wc1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICBjb250cm9sbGVyLmFib3J0KCk7XG4gICAgICB9O1xuICAgIH1cbiAgfSwgW1xuICAgIGN1cnJlbnREZWZhdWx0UHJvcHMsXG4gICAgZG9SZXNvbHV0aW9uLFxuICAgIGlucHV0UHJvcHMsXG4gICAgaXNUaGVTYW1lLFxuICAgIHJlbmRlck1vZGFsQ29tcG9zaXRpb24sXG4gICAgcmVuZGVyTW9kYWxQcm9wc1xuICBdKTtcbiAgY29uc3QgcmVzb2x2ZWRDb25maWdzSW5jbHVkaW5nU3RhdGljT25lcyA9IHVzZU1lbW81KCgpID0+IHtcbiAgICBjb25zdCBzdGF0aWNDb21wcyA9IGNvbXBvc2l0aW9ucy5maWx0ZXIoKGMpID0+IHtcbiAgICAgIHJldHVybiBjLmNhbGN1bGF0ZU1ldGFkYXRhID09PSBudWxsO1xuICAgIH0pO1xuICAgIHJldHVybiB7XG4gICAgICAuLi5yZXNvbHZlZENvbmZpZ3MsXG4gICAgICAuLi5zdGF0aWNDb21wcy5yZWR1Y2UoKGFjYywgY3VycikgPT4ge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIC4uLmFjYyxcbiAgICAgICAgICBbY3Vyci5pZF06IHtcbiAgICAgICAgICAgIHR5cGU6IFwic3VjY2Vzc1wiLFxuICAgICAgICAgICAgcmVzdWx0OiB7IC4uLmN1cnIsIGRlZmF1bHRQcm9wczogY3Vyci5kZWZhdWx0UHJvcHMgPz8ge30gfVxuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH0sIHt9KVxuICAgIH07XG4gIH0sIFtjb21wb3NpdGlvbnMsIHJlc29sdmVkQ29uZmlnc10pO1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeDYoUmVzb2x2ZUNvbXBvc2l0aW9uQ29udGV4dC5Qcm92aWRlciwge1xuICAgIHZhbHVlOiByZXNvbHZlZENvbmZpZ3NJbmNsdWRpbmdTdGF0aWNPbmVzLFxuICAgIGNoaWxkcmVuXG4gIH0pO1xufTtcbnZhciB1c2VSZXNvbHZlZFZpZGVvQ29uZmlnID0gKHByZWZlcnJlZENvbXBvc2l0aW9uSWQpID0+IHtcbiAgY29uc3QgY29udGV4dCA9IHVzZUNvbnRleHQ1KFJlc29sdmVDb21wb3NpdGlvbkNvbnRleHQpO1xuICBjb25zdCB7IHByb3BzOiBhbGxFZGl0b3JQcm9wcyB9ID0gdXNlQ29udGV4dDUoRWRpdG9yUHJvcHNDb250ZXh0KTtcbiAgY29uc3QgeyBjb21wb3NpdGlvbnMsIGNhbnZhc0NvbnRlbnQsIGN1cnJlbnRDb21wb3NpdGlvbk1ldGFkYXRhIH0gPSB1c2VDb250ZXh0NShDb21wb3NpdGlvbk1hbmFnZXIpO1xuICBjb25zdCBjdXJyZW50Q29tcG9zaXRpb24gPSBjYW52YXNDb250ZW50Py50eXBlID09PSBcImNvbXBvc2l0aW9uXCIgPyBjYW52YXNDb250ZW50LmNvbXBvc2l0aW9uSWQgOiBudWxsO1xuICBjb25zdCBjb21wb3NpdGlvbklkID0gcHJlZmVycmVkQ29tcG9zaXRpb25JZCA/PyBjdXJyZW50Q29tcG9zaXRpb247XG4gIGNvbnN0IGNvbXBvc2l0aW9uID0gY29tcG9zaXRpb25zLmZpbmQoKGMpID0+IGMuaWQgPT09IGNvbXBvc2l0aW9uSWQpO1xuICBjb25zdCBzZWxlY3RlZEVkaXRvclByb3BzID0gdXNlTWVtbzUoKCkgPT4ge1xuICAgIHJldHVybiBjb21wb3NpdGlvbiA/IGFsbEVkaXRvclByb3BzW2NvbXBvc2l0aW9uLmlkXSA/PyB7fSA6IHt9O1xuICB9LCBbYWxsRWRpdG9yUHJvcHMsIGNvbXBvc2l0aW9uXSk7XG4gIHJldHVybiB1c2VNZW1vNSgoKSA9PiB7XG4gICAgaWYgKCFjb21wb3NpdGlvbikge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGlmIChjdXJyZW50Q29tcG9zaXRpb25NZXRhZGF0YSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogXCJzdWNjZXNzXCIsXG4gICAgICAgIHJlc3VsdDoge1xuICAgICAgICAgIC4uLmN1cnJlbnRDb21wb3NpdGlvbk1ldGFkYXRhLFxuICAgICAgICAgIGlkOiBjb21wb3NpdGlvbi5pZCxcbiAgICAgICAgICBwcm9wczogY3VycmVudENvbXBvc2l0aW9uTWV0YWRhdGEucHJvcHMsXG4gICAgICAgICAgZGVmYXVsdFByb3BzOiBjb21wb3NpdGlvbi5kZWZhdWx0UHJvcHMgPz8ge30sXG4gICAgICAgICAgZGVmYXVsdENvZGVjOiBjdXJyZW50Q29tcG9zaXRpb25NZXRhZGF0YS5kZWZhdWx0Q29kZWNcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gICAgaWYgKCFuZWVkc1Jlc29sdXRpb24oY29tcG9zaXRpb24pKSB7XG4gICAgICB2YWxpZGF0ZUR1cmF0aW9uSW5GcmFtZXMoY29tcG9zaXRpb24uZHVyYXRpb25JbkZyYW1lcywge1xuICAgICAgICBhbGxvd0Zsb2F0czogZmFsc2UsXG4gICAgICAgIGNvbXBvbmVudDogYGluIDxDb21wb3NpdGlvbiBpZD1cIiR7Y29tcG9zaXRpb24uaWR9XCI+YFxuICAgICAgfSk7XG4gICAgICB2YWxpZGF0ZUZwcyhjb21wb3NpdGlvbi5mcHMsIGBpbiA8Q29tcG9zaXRpb24gaWQ9XCIke2NvbXBvc2l0aW9uLmlkfVwiPmAsIGZhbHNlKTtcbiAgICAgIHZhbGlkYXRlRGltZW5zaW9uKGNvbXBvc2l0aW9uLndpZHRoLCBcIndpZHRoXCIsIGBpbiA8Q29tcG9zaXRpb24gaWQ9XCIke2NvbXBvc2l0aW9uLmlkfVwiPmApO1xuICAgICAgdmFsaWRhdGVEaW1lbnNpb24oY29tcG9zaXRpb24uaGVpZ2h0LCBcImhlaWdodFwiLCBgaW4gPENvbXBvc2l0aW9uIGlkPVwiJHtjb21wb3NpdGlvbi5pZH1cIj5gKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwic3VjY2Vzc1wiLFxuICAgICAgICByZXN1bHQ6IHtcbiAgICAgICAgICB3aWR0aDogY29tcG9zaXRpb24ud2lkdGgsXG4gICAgICAgICAgaGVpZ2h0OiBjb21wb3NpdGlvbi5oZWlnaHQsXG4gICAgICAgICAgZnBzOiBjb21wb3NpdGlvbi5mcHMsXG4gICAgICAgICAgaWQ6IGNvbXBvc2l0aW9uLmlkLFxuICAgICAgICAgIGR1cmF0aW9uSW5GcmFtZXM6IGNvbXBvc2l0aW9uLmR1cmF0aW9uSW5GcmFtZXMsXG4gICAgICAgICAgZGVmYXVsdFByb3BzOiBjb21wb3NpdGlvbi5kZWZhdWx0UHJvcHMgPz8ge30sXG4gICAgICAgICAgcHJvcHM6IHtcbiAgICAgICAgICAgIC4uLmNvbXBvc2l0aW9uLmRlZmF1bHRQcm9wcyA/PyB7fSxcbiAgICAgICAgICAgIC4uLnNlbGVjdGVkRWRpdG9yUHJvcHMgPz8ge30sXG4gICAgICAgICAgICAuLi50eXBlb2Ygd2luZG93ID09PSBcInVuZGVmaW5lZFwiIHx8IGdldFJlbW90aW9uRW52aXJvbm1lbnQoKS5pc1BsYXllciA/IHt9IDogZ2V0SW5wdXRQcm9wcygpID8/IHt9XG4gICAgICAgICAgfSxcbiAgICAgICAgICBkZWZhdWx0Q29kZWM6IG51bGxcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gICAgaWYgKCFjb250ZXh0W2NvbXBvc2l0aW9uLmlkXSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBjb250ZXh0W2NvbXBvc2l0aW9uLmlkXTtcbiAgfSwgW2NvbXBvc2l0aW9uLCBjb250ZXh0LCBjdXJyZW50Q29tcG9zaXRpb25NZXRhZGF0YSwgc2VsZWN0ZWRFZGl0b3JQcm9wc10pO1xufTtcblxuLy8gc3JjL3VzZS12aWRlby50c1xudmFyIHVzZVZpZGVvID0gKCkgPT4ge1xuICBjb25zdCB7IGNhbnZhc0NvbnRlbnQsIGNvbXBvc2l0aW9ucywgY3VycmVudENvbXBvc2l0aW9uTWV0YWRhdGEgfSA9IHVzZUNvbnRleHQ2KENvbXBvc2l0aW9uTWFuYWdlcik7XG4gIGNvbnN0IHNlbGVjdGVkID0gY29tcG9zaXRpb25zLmZpbmQoKGMpID0+IHtcbiAgICByZXR1cm4gY2FudmFzQ29udGVudD8udHlwZSA9PT0gXCJjb21wb3NpdGlvblwiICYmIGMuaWQgPT09IGNhbnZhc0NvbnRlbnQuY29tcG9zaXRpb25JZDtcbiAgfSk7XG4gIGNvbnN0IHJlc29sdmVkID0gdXNlUmVzb2x2ZWRWaWRlb0NvbmZpZyhzZWxlY3RlZD8uaWQgPz8gbnVsbCk7XG4gIHJldHVybiB1c2VNZW1vNigoKSA9PiB7XG4gICAgaWYgKCFyZXNvbHZlZCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGlmIChyZXNvbHZlZC50eXBlID09PSBcImVycm9yXCIpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpZiAocmVzb2x2ZWQudHlwZSA9PT0gXCJsb2FkaW5nXCIpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpZiAoIXNlbGVjdGVkKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLnJlc29sdmVkLnJlc3VsdCxcbiAgICAgIGRlZmF1bHRQcm9wczogc2VsZWN0ZWQuZGVmYXVsdFByb3BzID8/IHt9LFxuICAgICAgaWQ6IHNlbGVjdGVkLmlkLFxuICAgICAgLi4uY3VycmVudENvbXBvc2l0aW9uTWV0YWRhdGEgPz8ge30sXG4gICAgICBjb21wb25lbnQ6IHNlbGVjdGVkLmNvbXBvbmVudFxuICAgIH07XG4gIH0sIFtjdXJyZW50Q29tcG9zaXRpb25NZXRhZGF0YSwgcmVzb2x2ZWQsIHNlbGVjdGVkXSk7XG59O1xuXG4vLyBzcmMvdGltZWxpbmUtcG9zaXRpb24tc3RhdGUudHNcbnZhciBUaW1lbGluZUNvbnRleHQgPSBjcmVhdGVDb250ZXh0OSh7XG4gIGZyYW1lOiB7fSxcbiAgcGxheWluZzogZmFsc2UsXG4gIHBsYXliYWNrUmF0ZTogMSxcbiAgcm9vdElkOiBcIlwiLFxuICBpbXBlcmF0aXZlUGxheWluZzoge1xuICAgIGN1cnJlbnQ6IGZhbHNlXG4gIH0sXG4gIHNldFBsYXliYWNrUmF0ZTogKCkgPT4ge1xuICAgIHRocm93IG5ldyBFcnJvcihcImRlZmF1bHRcIik7XG4gIH0sXG4gIGF1ZGlvQW5kVmlkZW9UYWdzOiB7IGN1cnJlbnQ6IFtdIH1cbn0pO1xudmFyIFNldFRpbWVsaW5lQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQ5KHtcbiAgc2V0RnJhbWU6ICgpID0+IHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJkZWZhdWx0XCIpO1xuICB9LFxuICBzZXRQbGF5aW5nOiAoKSA9PiB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiZGVmYXVsdFwiKTtcbiAgfVxufSk7XG52YXIgbWFrZUtleSA9ICgpID0+IHtcbiAgcmV0dXJuIGByZW1vdGlvbi50aW1lLWFsbGA7XG59O1xudmFyIHBlcnNpc3RDdXJyZW50RnJhbWUgPSAodGltZSkgPT4ge1xuICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShtYWtlS2V5KCksIEpTT04uc3RyaW5naWZ5KHRpbWUpKTtcbn07XG52YXIgZ2V0SW5pdGlhbEZyYW1lU3RhdGUgPSAoKSA9PiB7XG4gIGNvbnN0IGl0ZW0gPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbShtYWtlS2V5KCkpID8/IFwie31cIjtcbiAgY29uc3Qgb2JqID0gSlNPTi5wYXJzZShpdGVtKTtcbiAgcmV0dXJuIG9iajtcbn07XG52YXIgZ2V0RnJhbWVGb3JDb21wb3NpdGlvbiA9IChjb21wb3NpdGlvbikgPT4ge1xuICBjb25zdCBpdGVtID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0obWFrZUtleSgpKSA/PyBcInt9XCI7XG4gIGNvbnN0IG9iaiA9IEpTT04ucGFyc2UoaXRlbSk7XG4gIGlmIChvYmpbY29tcG9zaXRpb25dICE9PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gTnVtYmVyKG9ialtjb21wb3NpdGlvbl0pO1xuICB9XG4gIGlmICh0eXBlb2Ygd2luZG93ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgcmV0dXJuIHdpbmRvdy5yZW1vdGlvbl9pbml0aWFsRnJhbWUgPz8gMDtcbn07XG52YXIgdXNlVGltZWxpbmVQb3NpdGlvbiA9ICgpID0+IHtcbiAgY29uc3QgdmlkZW9Db25maWcgPSB1c2VWaWRlbygpO1xuICBjb25zdCBzdGF0ZSA9IHVzZUNvbnRleHQ3KFRpbWVsaW5lQ29udGV4dCk7XG4gIGlmICghdmlkZW9Db25maWcpIHtcbiAgICByZXR1cm4gdHlwZW9mIHdpbmRvdyA9PT0gXCJ1bmRlZmluZWRcIiA/IDAgOiB3aW5kb3cucmVtb3Rpb25faW5pdGlhbEZyYW1lID8/IDA7XG4gIH1cbiAgY29uc3QgdW5jbGFtcGVkID0gc3RhdGUuZnJhbWVbdmlkZW9Db25maWcuaWRdID8/IChnZXRSZW1vdGlvbkVudmlyb25tZW50KCkuaXNQbGF5ZXIgPyAwIDogZ2V0RnJhbWVGb3JDb21wb3NpdGlvbih2aWRlb0NvbmZpZy5pZCkpO1xuICByZXR1cm4gTWF0aC5taW4odmlkZW9Db25maWcuZHVyYXRpb25JbkZyYW1lcyAtIDEsIHVuY2xhbXBlZCk7XG59O1xudmFyIHVzZVRpbWVsaW5lU2V0RnJhbWUgPSAoKSA9PiB7XG4gIGNvbnN0IHsgc2V0RnJhbWUgfSA9IHVzZUNvbnRleHQ3KFNldFRpbWVsaW5lQ29udGV4dCk7XG4gIHJldHVybiBzZXRGcmFtZTtcbn07XG52YXIgdXNlUGxheWluZ1N0YXRlID0gKCkgPT4ge1xuICBjb25zdCB7IHBsYXlpbmcsIGltcGVyYXRpdmVQbGF5aW5nIH0gPSB1c2VDb250ZXh0NyhUaW1lbGluZUNvbnRleHQpO1xuICBjb25zdCB7IHNldFBsYXlpbmcgfSA9IHVzZUNvbnRleHQ3KFNldFRpbWVsaW5lQ29udGV4dCk7XG4gIHJldHVybiB1c2VNZW1vNygoKSA9PiBbcGxheWluZywgc2V0UGxheWluZywgaW1wZXJhdGl2ZVBsYXlpbmddLCBbaW1wZXJhdGl2ZVBsYXlpbmcsIHBsYXlpbmcsIHNldFBsYXlpbmddKTtcbn07XG5cbi8vIHNyYy91c2UtdmlkZW8tY29uZmlnLnRzXG5pbXBvcnQgeyB1c2VDb250ZXh0IGFzIHVzZUNvbnRleHQ5IH0gZnJvbSBcInJlYWN0XCI7XG5cbi8vIHNyYy9DYW5Vc2VSZW1vdGlvbkhvb2tzLnRzeFxuaW1wb3J0IHsgY3JlYXRlQ29udGV4dCBhcyBjcmVhdGVDb250ZXh0MTAgfSBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7IGpzeCBhcyBqc3g3IH0gZnJvbSBcInJlYWN0L2pzeC1ydW50aW1lXCI7XG52YXIgQ2FuVXNlUmVtb3Rpb25Ib29rcyA9IGNyZWF0ZUNvbnRleHQxMChmYWxzZSk7XG52YXIgQ2FuVXNlUmVtb3Rpb25Ib29rc1Byb3ZpZGVyID0gKHsgY2hpbGRyZW4gfSkgPT4ge1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeDcoQ2FuVXNlUmVtb3Rpb25Ib29rcy5Qcm92aWRlciwge1xuICAgIHZhbHVlOiB0cnVlLFxuICAgIGNoaWxkcmVuXG4gIH0pO1xufTtcblxuLy8gc3JjL3VzZS11bnNhZmUtdmlkZW8tY29uZmlnLnRzXG5pbXBvcnQgeyB1c2VDb250ZXh0IGFzIHVzZUNvbnRleHQ4LCB1c2VNZW1vIGFzIHVzZU1lbW84IH0gZnJvbSBcInJlYWN0XCI7XG52YXIgdXNlVW5zYWZlVmlkZW9Db25maWcgPSAoKSA9PiB7XG4gIGNvbnN0IGNvbnRleHQgPSB1c2VDb250ZXh0OChTZXF1ZW5jZUNvbnRleHQpO1xuICBjb25zdCBjdHhXaWR0aCA9IGNvbnRleHQ/LndpZHRoID8/IG51bGw7XG4gIGNvbnN0IGN0eEhlaWdodCA9IGNvbnRleHQ/LmhlaWdodCA/PyBudWxsO1xuICBjb25zdCBjdHhEdXJhdGlvbiA9IGNvbnRleHQ/LmR1cmF0aW9uSW5GcmFtZXMgPz8gbnVsbDtcbiAgY29uc3QgdmlkZW8gPSB1c2VWaWRlbygpO1xuICByZXR1cm4gdXNlTWVtbzgoKCkgPT4ge1xuICAgIGlmICghdmlkZW8pIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBpZCxcbiAgICAgIGR1cmF0aW9uSW5GcmFtZXMsXG4gICAgICBmcHMsXG4gICAgICBoZWlnaHQsXG4gICAgICB3aWR0aCxcbiAgICAgIGRlZmF1bHRQcm9wcyxcbiAgICAgIHByb3BzLFxuICAgICAgZGVmYXVsdENvZGVjXG4gICAgfSA9IHZpZGVvO1xuICAgIHJldHVybiB7XG4gICAgICBpZCxcbiAgICAgIHdpZHRoOiBjdHhXaWR0aCA/PyB3aWR0aCxcbiAgICAgIGhlaWdodDogY3R4SGVpZ2h0ID8/IGhlaWdodCxcbiAgICAgIGZwcyxcbiAgICAgIGR1cmF0aW9uSW5GcmFtZXM6IGN0eER1cmF0aW9uID8/IGR1cmF0aW9uSW5GcmFtZXMsXG4gICAgICBkZWZhdWx0UHJvcHMsXG4gICAgICBwcm9wcyxcbiAgICAgIGRlZmF1bHRDb2RlY1xuICAgIH07XG4gIH0sIFtjdHhEdXJhdGlvbiwgY3R4SGVpZ2h0LCBjdHhXaWR0aCwgdmlkZW9dKTtcbn07XG5cbi8vIHNyYy91c2UtdmlkZW8tY29uZmlnLnRzXG52YXIgdXNlVmlkZW9Db25maWcgPSAoKSA9PiB7XG4gIGNvbnN0IHZpZGVvQ29uZmlnID0gdXNlVW5zYWZlVmlkZW9Db25maWcoKTtcbiAgY29uc3QgY29udGV4dCA9IHVzZUNvbnRleHQ5KENhblVzZVJlbW90aW9uSG9va3MpO1xuICBjb25zdCBpc1BsYXllciA9IHVzZUlzUGxheWVyKCk7XG4gIGlmICghdmlkZW9Db25maWcpIHtcbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB3aW5kb3cucmVtb3Rpb25faXNQbGF5ZXIgfHwgaXNQbGF5ZXIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihbXG4gICAgICAgIFwiTm8gdmlkZW8gY29uZmlnIGZvdW5kLiBMaWtlbHkgcmVhc29uczpcIixcbiAgICAgICAgXCItIFlvdSBhcmUgcHJvYmFibHkgY2FsbGluZyB1c2VWaWRlb0NvbmZpZygpIGZyb20gb3V0c2lkZSB0aGUgY29tcG9uZW50IHBhc3NlZCB0byA8UGxheWVyIC8+LiBTZWUgaHR0cHM6Ly93d3cucmVtb3Rpb24uZGV2L2RvY3MvcGxheWVyL2V4YW1wbGVzIGZvciBob3cgdG8gc2V0IHVwIHRoZSBQbGF5ZXIgY29ycmVjdGx5LlwiLFxuICAgICAgICBcIi0gWW91IGhhdmUgbXVsdGlwbGUgdmVyc2lvbnMgb2YgUmVtb3Rpb24gaW5zdGFsbGVkIHdoaWNoIGNhdXNlcyB0aGUgUmVhY3QgY29udGV4dCB0byBnZXQgbG9zdC5cIlxuICAgICAgXS5qb2luKFwiLVwiKSk7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihcIk5vIHZpZGVvIGNvbmZpZyBmb3VuZC4gWW91IGFyZSBwcm9iYWJseSBjYWxsaW5nIHVzZVZpZGVvQ29uZmlnKCkgZnJvbSBhIGNvbXBvbmVudCB3aGljaCBoYXMgbm90IGJlZW4gcmVnaXN0ZXJlZCBhcyBhIDxDb21wb3NpdGlvbiAvPi4gU2VlIGh0dHBzOi8vd3d3LnJlbW90aW9uLmRldi9kb2NzL3RoZS1mdW5kYW1lbnRhbHMjZGVmaW5pbmctY29tcG9zaXRpb25zIGZvciBtb3JlIGluZm9ybWF0aW9uLlwiKTtcbiAgfVxuICBpZiAoIWNvbnRleHQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYWxsZWQgdXNlVmlkZW9Db25maWcoKSBvdXRzaWRlIGEgUmVtb3Rpb24gY29tcG9zaXRpb24uXCIpO1xuICB9XG4gIHJldHVybiB2aWRlb0NvbmZpZztcbn07XG5cbi8vIHNyYy9mcmVlemUudHN4XG5pbXBvcnQgeyB1c2VDb250ZXh0IGFzIHVzZUNvbnRleHQxMSwgdXNlTWVtbyBhcyB1c2VNZW1vOSB9IGZyb20gXCJyZWFjdFwiO1xuXG4vLyBzcmMvdXNlLWN1cnJlbnQtZnJhbWUudHNcbmltcG9ydCB7IHVzZUNvbnRleHQgYXMgdXNlQ29udGV4dDEwIH0gZnJvbSBcInJlYWN0XCI7XG52YXIgdXNlQ3VycmVudEZyYW1lID0gKCkgPT4ge1xuICBjb25zdCBjYW5Vc2VSZW1vdGlvbkhvb2tzID0gdXNlQ29udGV4dDEwKENhblVzZVJlbW90aW9uSG9va3MpO1xuICBpZiAoIWNhblVzZVJlbW90aW9uSG9va3MpIHtcbiAgICBpZiAoZ2V0UmVtb3Rpb25FbnZpcm9ubWVudCgpLmlzUGxheWVyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYHVzZUN1cnJlbnRGcmFtZSBjYW4gb25seSBiZSBjYWxsZWQgaW5zaWRlIGEgY29tcG9uZW50IHRoYXQgd2FzIHBhc3NlZCB0byA8UGxheWVyPi4gU2VlOiBodHRwczovL3d3dy5yZW1vdGlvbi5kZXYvZG9jcy9wbGF5ZXIvZXhhbXBsZXNgKTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKGB1c2VDdXJyZW50RnJhbWUoKSBjYW4gb25seSBiZSBjYWxsZWQgaW5zaWRlIGEgY29tcG9uZW50IHRoYXQgd2FzIHJlZ2lzdGVyZWQgYXMgYSBjb21wb3NpdGlvbi4gU2VlIGh0dHBzOi8vd3d3LnJlbW90aW9uLmRldi9kb2NzL3RoZS1mdW5kYW1lbnRhbHMjZGVmaW5pbmctY29tcG9zaXRpb25zYCk7XG4gIH1cbiAgY29uc3QgZnJhbWUgPSB1c2VUaW1lbGluZVBvc2l0aW9uKCk7XG4gIGNvbnN0IGNvbnRleHQgPSB1c2VDb250ZXh0MTAoU2VxdWVuY2VDb250ZXh0KTtcbiAgY29uc3QgY29udGV4dE9mZnNldCA9IGNvbnRleHQgPyBjb250ZXh0LmN1bXVsYXRlZEZyb20gKyBjb250ZXh0LnJlbGF0aXZlRnJvbSA6IDA7XG4gIHJldHVybiBmcmFtZSAtIGNvbnRleHRPZmZzZXQ7XG59O1xuXG4vLyBzcmMvZnJlZXplLnRzeFxuaW1wb3J0IHsganN4IGFzIGpzeDggfSBmcm9tIFwicmVhY3QvanN4LXJ1bnRpbWVcIjtcbnZhciBGcmVlemUgPSAoe1xuICBmcmFtZTogZnJhbWVUb0ZyZWV6ZSxcbiAgY2hpbGRyZW4sXG4gIGFjdGl2ZSA9IHRydWVcbn0pID0+IHtcbiAgY29uc3QgZnJhbWUgPSB1c2VDdXJyZW50RnJhbWUoKTtcbiAgY29uc3QgdmlkZW9Db25maWcgPSB1c2VWaWRlb0NvbmZpZygpO1xuICBpZiAodHlwZW9mIGZyYW1lVG9GcmVlemUgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFRoZSA8RnJlZXplIC8+IGNvbXBvbmVudCByZXF1aXJlcyBhICdmcmFtZScgcHJvcCwgYnV0IG5vbmUgd2FzIHBhc3NlZC5gKTtcbiAgfVxuICBpZiAodHlwZW9mIGZyYW1lVG9GcmVlemUgIT09IFwibnVtYmVyXCIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFRoZSAnZnJhbWUnIHByb3Agb2YgPEZyZWV6ZSAvPiBtdXN0IGJlIGEgbnVtYmVyLCBidXQgaXMgb2YgdHlwZSAke3R5cGVvZiBmcmFtZVRvRnJlZXplfWApO1xuICB9XG4gIGlmIChOdW1iZXIuaXNOYU4oZnJhbWVUb0ZyZWV6ZSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFRoZSAnZnJhbWUnIHByb3Agb2YgPEZyZWV6ZSAvPiBtdXN0IGJlIGEgcmVhbCBudW1iZXIsIGJ1dCBpdCBpcyBOYU4uYCk7XG4gIH1cbiAgaWYgKCFOdW1iZXIuaXNGaW5pdGUoZnJhbWVUb0ZyZWV6ZSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFRoZSAnZnJhbWUnIHByb3Agb2YgPEZyZWV6ZSAvPiBtdXN0IGJlIGEgZmluaXRlIG51bWJlciwgYnV0IGl0IGlzICR7ZnJhbWVUb0ZyZWV6ZX0uYCk7XG4gIH1cbiAgY29uc3QgaXNBY3RpdmUgPSB1c2VNZW1vOSgoKSA9PiB7XG4gICAgaWYgKHR5cGVvZiBhY3RpdmUgPT09IFwiYm9vbGVhblwiKSB7XG4gICAgICByZXR1cm4gYWN0aXZlO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGFjdGl2ZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICByZXR1cm4gYWN0aXZlKGZyYW1lKTtcbiAgICB9XG4gIH0sIFthY3RpdmUsIGZyYW1lXSk7XG4gIGNvbnN0IHRpbWVsaW5lQ29udGV4dCA9IHVzZUNvbnRleHQxMShUaW1lbGluZUNvbnRleHQpO1xuICBjb25zdCBzZXF1ZW5jZUNvbnRleHQgPSB1c2VDb250ZXh0MTEoU2VxdWVuY2VDb250ZXh0KTtcbiAgY29uc3QgcmVsYXRpdmVGcm9tID0gc2VxdWVuY2VDb250ZXh0Py5yZWxhdGl2ZUZyb20gPz8gMDtcbiAgY29uc3QgdGltZWxpbmVWYWx1ZSA9IHVzZU1lbW85KCgpID0+IHtcbiAgICBpZiAoIWlzQWN0aXZlKSB7XG4gICAgICByZXR1cm4gdGltZWxpbmVDb250ZXh0O1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgLi4udGltZWxpbmVDb250ZXh0LFxuICAgICAgcGxheWluZzogZmFsc2UsXG4gICAgICBpbXBlcmF0aXZlUGxheWluZzoge1xuICAgICAgICBjdXJyZW50OiBmYWxzZVxuICAgICAgfSxcbiAgICAgIGZyYW1lOiB7XG4gICAgICAgIFt2aWRlb0NvbmZpZy5pZF06IGZyYW1lVG9GcmVlemUgKyByZWxhdGl2ZUZyb21cbiAgICAgIH1cbiAgICB9O1xuICB9LCBbaXNBY3RpdmUsIHRpbWVsaW5lQ29udGV4dCwgdmlkZW9Db25maWcuaWQsIGZyYW1lVG9GcmVlemUsIHJlbGF0aXZlRnJvbV0pO1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeDgoVGltZWxpbmVDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgdmFsdWU6IHRpbWVsaW5lVmFsdWUsXG4gICAgY2hpbGRyZW5cbiAgfSk7XG59O1xuXG4vLyBzcmMvU2VxdWVuY2UudHN4XG5pbXBvcnQgeyBqc3ggYXMganN4OSB9IGZyb20gXCJyZWFjdC9qc3gtcnVudGltZVwiO1xudmFyIFJlZ3VsYXJTZXF1ZW5jZVJlZkZvcndhcmRpbmdGdW5jdGlvbiA9ICh7XG4gIGZyb20gPSAwLFxuICBkdXJhdGlvbkluRnJhbWVzID0gSW5maW5pdHksXG4gIGNoaWxkcmVuLFxuICBuYW1lLFxuICBoZWlnaHQsXG4gIHdpZHRoLFxuICBzaG93SW5UaW1lbGluZSA9IHRydWUsXG4gIF9yZW1vdGlvbkludGVybmFsTG9vcERpc3BsYXk6IGxvb3BEaXNwbGF5LFxuICBfcmVtb3Rpb25JbnRlcm5hbFN0YWNrOiBzdGFjayxcbiAgX3JlbW90aW9uSW50ZXJuYWxQcmVtb3VudERpc3BsYXk6IHByZW1vdW50RGlzcGxheSxcbiAgLi4ub3RoZXJcbn0sIHJlZikgPT4ge1xuICBjb25zdCB7IGxheW91dCA9IFwiYWJzb2x1dGUtZmlsbFwiIH0gPSBvdGhlcjtcbiAgY29uc3QgW2lkXSA9IHVzZVN0YXRlNSgoKSA9PiBTdHJpbmcoTWF0aC5yYW5kb20oKSkpO1xuICBjb25zdCBwYXJlbnRTZXF1ZW5jZSA9IHVzZUNvbnRleHQxMihTZXF1ZW5jZUNvbnRleHQpO1xuICBjb25zdCB7IHJvb3RJZCB9ID0gdXNlQ29udGV4dDEyKFRpbWVsaW5lQ29udGV4dCk7XG4gIGNvbnN0IGN1bXVsYXRlZEZyb20gPSBwYXJlbnRTZXF1ZW5jZSA/IHBhcmVudFNlcXVlbmNlLmN1bXVsYXRlZEZyb20gKyBwYXJlbnRTZXF1ZW5jZS5yZWxhdGl2ZUZyb20gOiAwO1xuICBjb25zdCBub25jZSA9IHVzZU5vbmNlKCk7XG4gIGlmIChsYXlvdXQgIT09IFwiYWJzb2x1dGUtZmlsbFwiICYmIGxheW91dCAhPT0gXCJub25lXCIpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBUaGUgbGF5b3V0IHByb3Agb2YgPFNlcXVlbmNlIC8+IGV4cGVjdHMgZWl0aGVyIFwiYWJzb2x1dGUtZmlsbFwiIG9yIFwibm9uZVwiLCBidXQgeW91IHBhc3NlZDogJHtsYXlvdXR9YCk7XG4gIH1cbiAgaWYgKGxheW91dCA9PT0gXCJub25lXCIgJiYgdHlwZW9mIG90aGVyLnN0eWxlICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSWYgbGF5b3V0PVwibm9uZVwiLCB5b3UgbWF5IG5vdCBwYXNzIGEgc3R5bGUuJyk7XG4gIH1cbiAgaWYgKHR5cGVvZiBkdXJhdGlvbkluRnJhbWVzICE9PSBcIm51bWJlclwiKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgWW91IHBhc3NlZCB0byBkdXJhdGlvbkluRnJhbWVzIGFuIGFyZ3VtZW50IG9mIHR5cGUgJHt0eXBlb2YgZHVyYXRpb25JbkZyYW1lc30sIGJ1dCBpdCBtdXN0IGJlIGEgbnVtYmVyLmApO1xuICB9XG4gIGlmIChkdXJhdGlvbkluRnJhbWVzIDw9IDApIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBkdXJhdGlvbkluRnJhbWVzIG11c3QgYmUgcG9zaXRpdmUsIGJ1dCBnb3QgJHtkdXJhdGlvbkluRnJhbWVzfWApO1xuICB9XG4gIGlmICh0eXBlb2YgZnJvbSAhPT0gXCJudW1iZXJcIikge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFlvdSBwYXNzZWQgdG8gdGhlIFwiZnJvbVwiIHByb3BzIG9mIHlvdXIgPFNlcXVlbmNlPiBhbiBhcmd1bWVudCBvZiB0eXBlICR7dHlwZW9mIGZyb219LCBidXQgaXQgbXVzdCBiZSBhIG51bWJlci5gKTtcbiAgfVxuICBpZiAoIU51bWJlci5pc0Zpbml0ZShmcm9tKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFRoZSBcImZyb21cIiBwcm9wIG9mIGEgc2VxdWVuY2UgbXVzdCBiZSBmaW5pdGUsIGJ1dCBnb3QgJHtmcm9tfS5gKTtcbiAgfVxuICBjb25zdCBhYnNvbHV0ZUZyYW1lID0gdXNlVGltZWxpbmVQb3NpdGlvbigpO1xuICBjb25zdCB2aWRlb0NvbmZpZyA9IHVzZVZpZGVvQ29uZmlnKCk7XG4gIGNvbnN0IHBhcmVudFNlcXVlbmNlRHVyYXRpb24gPSBwYXJlbnRTZXF1ZW5jZSA/IE1hdGgubWluKHBhcmVudFNlcXVlbmNlLmR1cmF0aW9uSW5GcmFtZXMgLSBmcm9tLCBkdXJhdGlvbkluRnJhbWVzKSA6IGR1cmF0aW9uSW5GcmFtZXM7XG4gIGNvbnN0IGFjdHVhbER1cmF0aW9uSW5GcmFtZXMgPSBNYXRoLm1heCgwLCBNYXRoLm1pbih2aWRlb0NvbmZpZy5kdXJhdGlvbkluRnJhbWVzIC0gZnJvbSwgcGFyZW50U2VxdWVuY2VEdXJhdGlvbikpO1xuICBjb25zdCB7IHJlZ2lzdGVyU2VxdWVuY2UsIHVucmVnaXN0ZXJTZXF1ZW5jZSB9ID0gdXNlQ29udGV4dDEyKFNlcXVlbmNlTWFuYWdlcik7XG4gIGNvbnN0IHsgaGlkZGVuIH0gPSB1c2VDb250ZXh0MTIoU2VxdWVuY2VWaXNpYmlsaXR5VG9nZ2xlQ29udGV4dCk7XG4gIGNvbnN0IHByZW1vdW50aW5nID0gdXNlTWVtbzEwKCgpID0+IHtcbiAgICByZXR1cm4gcGFyZW50U2VxdWVuY2U/LnByZW1vdW50aW5nID8/IEJvb2xlYW4ob3RoZXIuX3JlbW90aW9uSW50ZXJuYWxJc1ByZW1vdW50aW5nKTtcbiAgfSwgW290aGVyLl9yZW1vdGlvbkludGVybmFsSXNQcmVtb3VudGluZywgcGFyZW50U2VxdWVuY2U/LnByZW1vdW50aW5nXSk7XG4gIGNvbnN0IGNvbnRleHRWYWx1ZSA9IHVzZU1lbW8xMCgoKSA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGN1bXVsYXRlZEZyb20sXG4gICAgICByZWxhdGl2ZUZyb206IGZyb20sXG4gICAgICBkdXJhdGlvbkluRnJhbWVzOiBhY3R1YWxEdXJhdGlvbkluRnJhbWVzLFxuICAgICAgcGFyZW50RnJvbTogcGFyZW50U2VxdWVuY2U/LnJlbGF0aXZlRnJvbSA/PyAwLFxuICAgICAgaWQsXG4gICAgICBoZWlnaHQ6IGhlaWdodCA/PyBwYXJlbnRTZXF1ZW5jZT8uaGVpZ2h0ID8/IG51bGwsXG4gICAgICB3aWR0aDogd2lkdGggPz8gcGFyZW50U2VxdWVuY2U/LndpZHRoID8/IG51bGwsXG4gICAgICBwcmVtb3VudGluZ1xuICAgIH07XG4gIH0sIFtcbiAgICBjdW11bGF0ZWRGcm9tLFxuICAgIGZyb20sXG4gICAgYWN0dWFsRHVyYXRpb25JbkZyYW1lcyxcbiAgICBwYXJlbnRTZXF1ZW5jZSxcbiAgICBpZCxcbiAgICBoZWlnaHQsXG4gICAgd2lkdGgsXG4gICAgcHJlbW91bnRpbmdcbiAgXSk7XG4gIGNvbnN0IHRpbWVsaW5lQ2xpcE5hbWUgPSB1c2VNZW1vMTAoKCkgPT4ge1xuICAgIHJldHVybiBuYW1lID8/IFwiXCI7XG4gIH0sIFtuYW1lXSk7XG4gIHVzZUVmZmVjdDUoKCkgPT4ge1xuICAgIGlmICghZ2V0UmVtb3Rpb25FbnZpcm9ubWVudCgpLmlzU3R1ZGlvKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHJlZ2lzdGVyU2VxdWVuY2Uoe1xuICAgICAgZnJvbSxcbiAgICAgIGR1cmF0aW9uOiBhY3R1YWxEdXJhdGlvbkluRnJhbWVzLFxuICAgICAgaWQsXG4gICAgICBkaXNwbGF5TmFtZTogdGltZWxpbmVDbGlwTmFtZSxcbiAgICAgIHBhcmVudDogcGFyZW50U2VxdWVuY2U/LmlkID8/IG51bGwsXG4gICAgICB0eXBlOiBcInNlcXVlbmNlXCIsXG4gICAgICByb290SWQsXG4gICAgICBzaG93SW5UaW1lbGluZSxcbiAgICAgIG5vbmNlLFxuICAgICAgbG9vcERpc3BsYXksXG4gICAgICBzdGFjazogc3RhY2sgPz8gbnVsbCxcbiAgICAgIHByZW1vdW50RGlzcGxheTogcHJlbW91bnREaXNwbGF5ID8/IG51bGxcbiAgICB9KTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgdW5yZWdpc3RlclNlcXVlbmNlKGlkKTtcbiAgICB9O1xuICB9LCBbXG4gICAgZHVyYXRpb25JbkZyYW1lcyxcbiAgICBpZCxcbiAgICBuYW1lLFxuICAgIHJlZ2lzdGVyU2VxdWVuY2UsXG4gICAgdGltZWxpbmVDbGlwTmFtZSxcbiAgICB1bnJlZ2lzdGVyU2VxdWVuY2UsXG4gICAgcGFyZW50U2VxdWVuY2U/LmlkLFxuICAgIGFjdHVhbER1cmF0aW9uSW5GcmFtZXMsXG4gICAgcm9vdElkLFxuICAgIGZyb20sXG4gICAgc2hvd0luVGltZWxpbmUsXG4gICAgbm9uY2UsXG4gICAgbG9vcERpc3BsYXksXG4gICAgc3RhY2ssXG4gICAgcHJlbW91bnREaXNwbGF5XG4gIF0pO1xuICBjb25zdCBlbmRUaHJlc2hvbGQgPSBNYXRoLmNlaWwoY3VtdWxhdGVkRnJvbSArIGZyb20gKyBkdXJhdGlvbkluRnJhbWVzIC0gMSk7XG4gIGNvbnN0IGNvbnRlbnQgPSBhYnNvbHV0ZUZyYW1lIDwgY3VtdWxhdGVkRnJvbSArIGZyb20gPyBudWxsIDogYWJzb2x1dGVGcmFtZSA+IGVuZFRocmVzaG9sZCA/IG51bGwgOiBjaGlsZHJlbjtcbiAgY29uc3Qgc3R5bGVJZlRoZXJlID0gb3RoZXIubGF5b3V0ID09PSBcIm5vbmVcIiA/IHVuZGVmaW5lZCA6IG90aGVyLnN0eWxlO1xuICBjb25zdCBkZWZhdWx0U3R5bGUgPSB1c2VNZW1vMTAoKCkgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICBmbGV4RGlyZWN0aW9uOiB1bmRlZmluZWQsXG4gICAgICAuLi53aWR0aCA/IHsgd2lkdGggfSA6IHt9LFxuICAgICAgLi4uaGVpZ2h0ID8geyBoZWlnaHQgfSA6IHt9LFxuICAgICAgLi4uc3R5bGVJZlRoZXJlID8/IHt9XG4gICAgfTtcbiAgfSwgW2hlaWdodCwgc3R5bGVJZlRoZXJlLCB3aWR0aF0pO1xuICBpZiAocmVmICE9PSBudWxsICYmIGxheW91dCA9PT0gXCJub25lXCIpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJdCBpcyBub3Qgc3VwcG9ydGVkIHRvIHBhc3MgYm90aCBhIGByZWZgIGFuZCBgbGF5b3V0PVwibm9uZVwiYCB0byA8U2VxdWVuY2UgLz4uJyk7XG4gIH1cbiAgY29uc3QgaXNTZXF1ZW5jZUhpZGRlbiA9IGhpZGRlbltpZF0gPz8gZmFsc2U7XG4gIGlmIChpc1NlcXVlbmNlSGlkZGVuKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBqc3g5KFNlcXVlbmNlQ29udGV4dC5Qcm92aWRlciwge1xuICAgIHZhbHVlOiBjb250ZXh0VmFsdWUsXG4gICAgY2hpbGRyZW46IGNvbnRlbnQgPT09IG51bGwgPyBudWxsIDogb3RoZXIubGF5b3V0ID09PSBcIm5vbmVcIiA/IGNvbnRlbnQgOiAvKiBAX19QVVJFX18gKi8ganN4OShBYnNvbHV0ZUZpbGwsIHtcbiAgICAgIHJlZixcbiAgICAgIHN0eWxlOiBkZWZhdWx0U3R5bGUsXG4gICAgICBjbGFzc05hbWU6IG90aGVyLmNsYXNzTmFtZSxcbiAgICAgIGNoaWxkcmVuOiBjb250ZW50XG4gICAgfSlcbiAgfSk7XG59O1xudmFyIFJlZ3VsYXJTZXF1ZW5jZSA9IGZvcndhcmRSZWYyKFJlZ3VsYXJTZXF1ZW5jZVJlZkZvcndhcmRpbmdGdW5jdGlvbik7XG52YXIgUHJlbW91bnRlZFNlcXVlbmNlUmVmRm9yd2FyZGluZ0Z1bmN0aW9uID0gKHByb3BzLCByZWYpID0+IHtcbiAgY29uc3QgZnJhbWUgPSB1c2VDdXJyZW50RnJhbWUoKTtcbiAgaWYgKHByb3BzLmxheW91dCA9PT0gXCJub25lXCIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2A8U2VxdWVuY2U+YCB3aXRoIGBwcmVtb3VudEZvcmAgcHJvcCBkb2VzIG5vdCBzdXBwb3J0IGxheW91dD1cIm5vbmVcIicpO1xuICB9XG4gIGNvbnN0IHsgc3R5bGU6IHBhc3NlZFN0eWxlLCBmcm9tID0gMCwgcHJlbW91bnRGb3IgPSAwLCAuLi5vdGhlclByb3BzIH0gPSBwcm9wcztcbiAgY29uc3QgcHJlbW91bnRpbmdBY3RpdmUgPSBmcmFtZSA8IGZyb20gJiYgZnJhbWUgPj0gZnJvbSAtIHByZW1vdW50Rm9yO1xuICBjb25zdCBzdHlsZSA9IHVzZU1lbW8xMCgoKSA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLnBhc3NlZFN0eWxlLFxuICAgICAgb3BhY2l0eTogcHJlbW91bnRpbmdBY3RpdmUgPyAwIDogMSxcbiAgICAgIHBvaW50ZXJFdmVudHM6IHByZW1vdW50aW5nQWN0aXZlID8gXCJub25lXCIgOiBwYXNzZWRTdHlsZT8ucG9pbnRlckV2ZW50cyA/PyB1bmRlZmluZWRcbiAgICB9O1xuICB9LCBbcHJlbW91bnRpbmdBY3RpdmUsIHBhc3NlZFN0eWxlXSk7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8ganN4OShGcmVlemUsIHtcbiAgICBmcmFtZTogZnJvbSxcbiAgICBhY3RpdmU6IHByZW1vdW50aW5nQWN0aXZlLFxuICAgIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8ganN4OShTZXF1ZW5jZSwge1xuICAgICAgcmVmLFxuICAgICAgZnJvbSxcbiAgICAgIHN0eWxlLFxuICAgICAgX3JlbW90aW9uSW50ZXJuYWxQcmVtb3VudERpc3BsYXk6IHByZW1vdW50Rm9yLFxuICAgICAgX3JlbW90aW9uSW50ZXJuYWxJc1ByZW1vdW50aW5nOiBwcmVtb3VudGluZ0FjdGl2ZSxcbiAgICAgIC4uLm90aGVyUHJvcHNcbiAgICB9KVxuICB9KTtcbn07XG52YXIgUHJlbW91bnRlZFNlcXVlbmNlID0gZm9yd2FyZFJlZjIoUHJlbW91bnRlZFNlcXVlbmNlUmVmRm9yd2FyZGluZ0Z1bmN0aW9uKTtcbnZhciBTZXF1ZW5jZVJlZkZvcndhcmRpbmdGdW5jdGlvbiA9IChwcm9wcywgcmVmKSA9PiB7XG4gIGlmIChwcm9wcy5sYXlvdXQgIT09IFwibm9uZVwiICYmIHByb3BzLnByZW1vdW50Rm9yICYmICFnZXRSZW1vdGlvbkVudmlyb25tZW50KCkuaXNSZW5kZXJpbmcpIHtcbiAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeDkoUHJlbW91bnRlZFNlcXVlbmNlLCB7XG4gICAgICAuLi5wcm9wcyxcbiAgICAgIHJlZlxuICAgIH0pO1xuICB9XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8ganN4OShSZWd1bGFyU2VxdWVuY2UsIHtcbiAgICAuLi5wcm9wcyxcbiAgICByZWZcbiAgfSk7XG59O1xudmFyIFNlcXVlbmNlID0gZm9yd2FyZFJlZjIoU2VxdWVuY2VSZWZGb3J3YXJkaW5nRnVuY3Rpb24pO1xuLy8gc3JjL0FydGlmYWN0LnRzeFxuaW1wb3J0IHsgdXNlQ29udGV4dCBhcyB1c2VDb250ZXh0MTMsIHVzZUVmZmVjdCBhcyB1c2VFZmZlY3Q2LCB1c2VTdGF0ZSBhcyB1c2VTdGF0ZTcgfSBmcm9tIFwicmVhY3RcIjtcblxuLy8gc3JjL1JlbmRlckFzc2V0TWFuYWdlci50c3hcbmltcG9ydCB7XG4gIGNyZWF0ZUNvbnRleHQgYXMgY3JlYXRlQ29udGV4dDExLFxuICB1c2VDYWxsYmFjayBhcyB1c2VDYWxsYmFjazQsXG4gIHVzZUxheW91dEVmZmVjdCBhcyB1c2VMYXlvdXRFZmZlY3QyLFxuICB1c2VNZW1vIGFzIHVzZU1lbW8xMSxcbiAgdXNlU3RhdGUgYXMgdXNlU3RhdGU2XG59IGZyb20gXCJyZWFjdFwiO1xuXG4vLyBzcmMvdmFsaWRhdGlvbi92YWxpZGF0ZS1hcnRpZmFjdC50c1xudmFyIHZhbGlkYXRlQXJ0aWZhY3RGaWxlbmFtZSA9IChmaWxlbmFtZSkgPT4ge1xuICBpZiAodHlwZW9mIGZpbGVuYW1lICE9PSBcInN0cmluZ1wiKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgVGhlIFwiZmlsZW5hbWVcIiBtdXN0IGJlIGEgc3RyaW5nLCBidXQgeW91IHBhc3NlZCBhIHZhbHVlIG9mIHR5cGUgJHt0eXBlb2YgZmlsZW5hbWV9YCk7XG4gIH1cbiAgaWYgKGZpbGVuYW1lLnRyaW0oKSA9PT0gXCJcIikge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSBgZmlsZW5hbWVgIG11c3Qgbm90IGJlIGVtcHR5XCIpO1xuICB9XG4gIGlmICghZmlsZW5hbWUubWF0Y2goL14oWzAtOWEtekEtWi0hXy4qJygpLzomJEA9OyssP10rKS9nKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignVGhlIGBmaWxlbmFtZWAgbXVzdCBtYXRjaCBcIi9eKFswLTlhLXpBLVotIV8uKlxcJygpLzomJEA9OyssP10rKS9nXCIuIFVzZSBmb3J3YXJkIHNsYXNoZXMgb25seSwgZXZlbiBvbiBXaW5kb3dzLicpO1xuICB9XG59O1xudmFyIHZhbGlkYXRlQ29udGVudCA9IChjb250ZW50KSA9PiB7XG4gIGlmICh0eXBlb2YgY29udGVudCAhPT0gXCJzdHJpbmdcIiAmJiAhKGNvbnRlbnQgaW5zdGFuY2VvZiBVaW50OEFycmF5KSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFRoZSBcImNvbnRlbnRcIiBtdXN0IGJlIGEgc3RyaW5nIG9yIFVpbnQ4QXJyYXksIGJ1dCB5b3UgcGFzc2VkIGEgdmFsdWUgb2YgdHlwZSAke3R5cGVvZiBjb250ZW50fWApO1xuICB9XG4gIGlmICh0eXBlb2YgY29udGVudCA9PT0gXCJzdHJpbmdcIiAmJiBjb250ZW50LnRyaW0oKSA9PT0gXCJcIikge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSBgY29udGVudGAgbXVzdCBub3QgYmUgZW1wdHlcIik7XG4gIH1cbn07XG52YXIgdmFsaWRhdGVSZW5kZXJBc3NldCA9IChhcnRpZmFjdCkgPT4ge1xuICBpZiAoYXJ0aWZhY3QudHlwZSAhPT0gXCJhcnRpZmFjdFwiKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhbGlkYXRlQXJ0aWZhY3RGaWxlbmFtZShhcnRpZmFjdC5maWxlbmFtZSk7XG4gIHZhbGlkYXRlQ29udGVudChhcnRpZmFjdC5jb250ZW50KTtcbn07XG5cbi8vIHNyYy9SZW5kZXJBc3NldE1hbmFnZXIudHN4XG5pbXBvcnQgeyBqc3ggYXMganN4MTAgfSBmcm9tIFwicmVhY3QvanN4LXJ1bnRpbWVcIjtcbnZhciBSZW5kZXJBc3NldE1hbmFnZXIgPSBjcmVhdGVDb250ZXh0MTEoe1xuICByZWdpc3RlclJlbmRlckFzc2V0OiAoKSA9PiB7XG4gICAgcmV0dXJuO1xuICB9LFxuICB1bnJlZ2lzdGVyUmVuZGVyQXNzZXQ6ICgpID0+IHtcbiAgICByZXR1cm47XG4gIH0sXG4gIHJlbmRlckFzc2V0czogW11cbn0pO1xudmFyIFJlbmRlckFzc2V0TWFuYWdlclByb3ZpZGVyID0gKHsgY2hpbGRyZW4gfSkgPT4ge1xuICBjb25zdCBbcmVuZGVyQXNzZXRzLCBzZXRSZW5kZXJBc3NldHNdID0gdXNlU3RhdGU2KFtdKTtcbiAgY29uc3QgcmVnaXN0ZXJSZW5kZXJBc3NldCA9IHVzZUNhbGxiYWNrNCgocmVuZGVyQXNzZXQpID0+IHtcbiAgICB2YWxpZGF0ZVJlbmRlckFzc2V0KHJlbmRlckFzc2V0KTtcbiAgICBzZXRSZW5kZXJBc3NldHMoKGFzc2V0cykgPT4ge1xuICAgICAgcmV0dXJuIFsuLi5hc3NldHMsIHJlbmRlckFzc2V0XTtcbiAgICB9KTtcbiAgfSwgW10pO1xuICBjb25zdCB1bnJlZ2lzdGVyUmVuZGVyQXNzZXQgPSB1c2VDYWxsYmFjazQoKGlkKSA9PiB7XG4gICAgc2V0UmVuZGVyQXNzZXRzKChhc3N0cykgPT4ge1xuICAgICAgcmV0dXJuIGFzc3RzLmZpbHRlcigoYSkgPT4gYS5pZCAhPT0gaWQpO1xuICAgIH0pO1xuICB9LCBbXSk7XG4gIHVzZUxheW91dEVmZmVjdDIoKCkgPT4ge1xuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICB3aW5kb3cucmVtb3Rpb25fY29sbGVjdEFzc2V0cyA9ICgpID0+IHtcbiAgICAgICAgc2V0UmVuZGVyQXNzZXRzKFtdKTtcbiAgICAgICAgcmV0dXJuIHJlbmRlckFzc2V0cztcbiAgICAgIH07XG4gICAgfVxuICB9LCBbcmVuZGVyQXNzZXRzXSk7XG4gIGNvbnN0IGNvbnRleHRWYWx1ZSA9IHVzZU1lbW8xMSgoKSA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJlZ2lzdGVyUmVuZGVyQXNzZXQsXG4gICAgICB1bnJlZ2lzdGVyUmVuZGVyQXNzZXQsXG4gICAgICByZW5kZXJBc3NldHNcbiAgICB9O1xuICB9LCBbcmVuZGVyQXNzZXRzLCByZWdpc3RlclJlbmRlckFzc2V0LCB1bnJlZ2lzdGVyUmVuZGVyQXNzZXRdKTtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBqc3gxMChSZW5kZXJBc3NldE1hbmFnZXIuUHJvdmlkZXIsIHtcbiAgICB2YWx1ZTogY29udGV4dFZhbHVlLFxuICAgIGNoaWxkcmVuXG4gIH0pO1xufTtcblxuLy8gc3JjL0FydGlmYWN0LnRzeFxudmFyIEFydGlmYWN0ID0gKHsgZmlsZW5hbWUsIGNvbnRlbnQgfSkgPT4ge1xuICBjb25zdCB7IHJlZ2lzdGVyUmVuZGVyQXNzZXQsIHVucmVnaXN0ZXJSZW5kZXJBc3NldCB9ID0gdXNlQ29udGV4dDEzKFJlbmRlckFzc2V0TWFuYWdlcik7XG4gIGNvbnN0IFtlbnZdID0gdXNlU3RhdGU3KCgpID0+IGdldFJlbW90aW9uRW52aXJvbm1lbnQoKSk7XG4gIGNvbnN0IGZyYW1lID0gdXNlQ3VycmVudEZyYW1lKCk7XG4gIGNvbnN0IFtpZF0gPSB1c2VTdGF0ZTcoKCkgPT4ge1xuICAgIHJldHVybiBTdHJpbmcoTWF0aC5yYW5kb20oKSk7XG4gIH0pO1xuICB1c2VFZmZlY3Q2KCgpID0+IHtcbiAgICBpZiAoIWVudi5pc1JlbmRlcmluZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoY29udGVudCBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcbiAgICAgIHJlZ2lzdGVyUmVuZGVyQXNzZXQoe1xuICAgICAgICB0eXBlOiBcImFydGlmYWN0XCIsXG4gICAgICAgIGlkLFxuICAgICAgICBjb250ZW50OiBidG9hKG5ldyBUZXh0RGVjb2RlcihcInV0ZjhcIikuZGVjb2RlKGNvbnRlbnQpKSxcbiAgICAgICAgZmlsZW5hbWUsXG4gICAgICAgIGZyYW1lLFxuICAgICAgICBiaW5hcnk6IHRydWVcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZWdpc3RlclJlbmRlckFzc2V0KHtcbiAgICAgICAgdHlwZTogXCJhcnRpZmFjdFwiLFxuICAgICAgICBpZCxcbiAgICAgICAgY29udGVudCxcbiAgICAgICAgZmlsZW5hbWUsXG4gICAgICAgIGZyYW1lLFxuICAgICAgICBiaW5hcnk6IGZhbHNlXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHJldHVybiB1bnJlZ2lzdGVyUmVuZGVyQXNzZXQoaWQpO1xuICAgIH07XG4gIH0sIFtcbiAgICBjb250ZW50LFxuICAgIGVudi5pc1JlbmRlcmluZyxcbiAgICBmaWxlbmFtZSxcbiAgICBmcmFtZSxcbiAgICBpZCxcbiAgICByZWdpc3RlclJlbmRlckFzc2V0LFxuICAgIHVucmVnaXN0ZXJSZW5kZXJBc3NldFxuICBdKTtcbiAgcmV0dXJuIG51bGw7XG59O1xuLy8gc3JjL2F1ZGlvL0F1ZGlvLnRzeFxuaW1wb3J0IHsgZm9yd2FyZFJlZiBhcyBmb3J3YXJkUmVmNSwgdXNlQ2FsbGJhY2sgYXMgdXNlQ2FsbGJhY2s5LCB1c2VDb250ZXh0IGFzIHVzZUNvbnRleHQyMyB9IGZyb20gXCJyZWFjdFwiO1xuXG4vLyBzcmMvYWJzb2x1dGUtc3JjLnRzXG52YXIgZ2V0QWJzb2x1dGVTcmMgPSAocmVsYXRpdmVTcmMpID0+IHtcbiAgaWYgKHR5cGVvZiB3aW5kb3cgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICByZXR1cm4gcmVsYXRpdmVTcmM7XG4gIH1cbiAgcmV0dXJuIG5ldyBVUkwocmVsYXRpdmVTcmMsIHdpbmRvdy5vcmlnaW4pLmhyZWY7XG59O1xuXG4vLyBzcmMvY2FsY3VsYXRlLWxvb3AudHNcbnZhciBjYWxjdWxhdGVMb29wRHVyYXRpb24gPSAoe1xuICBlbmRBdCxcbiAgbWVkaWFEdXJhdGlvbixcbiAgcGxheWJhY2tSYXRlLFxuICBzdGFydEZyb21cbn0pID0+IHtcbiAgbGV0IGR1cmF0aW9uID0gbWVkaWFEdXJhdGlvbjtcbiAgaWYgKHR5cGVvZiBlbmRBdCAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIGR1cmF0aW9uID0gZW5kQXQ7XG4gIH1cbiAgaWYgKHR5cGVvZiBzdGFydEZyb20gIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICBkdXJhdGlvbiAtPSBzdGFydEZyb207XG4gIH1cbiAgY29uc3QgYWN0dWFsRHVyYXRpb24gPSBkdXJhdGlvbiAvIHBsYXliYWNrUmF0ZTtcbiAgcmV0dXJuIE1hdGguZmxvb3IoYWN0dWFsRHVyYXRpb24pO1xufTtcblxuLy8gc3JjL2NhbmNlbC1yZW5kZXIudHNcbmZ1bmN0aW9uIGNhbmNlbFJlbmRlcihlcnIpIHtcbiAgbGV0IGVycm9yO1xuICBpZiAoaXNFcnJvckxpa2UoZXJyKSkge1xuICAgIGVycm9yID0gZXJyO1xuICAgIGlmICghZXJyb3Iuc3RhY2spIHtcbiAgICAgIGVycm9yLnN0YWNrID0gbmV3IEVycm9yKGVycm9yLm1lc3NhZ2UpLnN0YWNrO1xuICAgIH1cbiAgfSBlbHNlIGlmICh0eXBlb2YgZXJyID09PSBcInN0cmluZ1wiKSB7XG4gICAgZXJyb3IgPSBFcnJvcihlcnIpO1xuICB9IGVsc2Uge1xuICAgIGVycm9yID0gRXJyb3IoXCJSZW5kZXJpbmcgd2FzIGNhbmNlbGxlZFwiKTtcbiAgfVxuICB3aW5kb3cucmVtb3Rpb25fY2FuY2VsbGVkRXJyb3IgPSBlcnJvci5zdGFjaztcbiAgdGhyb3cgZXJyb3I7XG59XG52YXIgaXNFcnJvckxpa2UgPSAoZXJyKSA9PiB7XG4gIGlmIChlcnIgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmIChlcnIgPT09IG51bGwpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKHR5cGVvZiBlcnIgIT09IFwib2JqZWN0XCIpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKCEoXCJzdGFja1wiIGluIGVycikpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKHR5cGVvZiBlcnIuc3RhY2sgIT09IFwic3RyaW5nXCIpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKCEoXCJtZXNzYWdlXCIgaW4gZXJyKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAodHlwZW9mIGVyci5tZXNzYWdlICE9PSBcInN0cmluZ1wiKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB0cnVlO1xufTtcblxuLy8gc3JjL2xvb3AvaW5kZXgudHN4XG5pbXBvcnQgUmVhY3Q4LCB7IGNyZWF0ZUNvbnRleHQgYXMgY3JlYXRlQ29udGV4dDEyLCB1c2VNZW1vIGFzIHVzZU1lbW8xMiB9IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHsganN4IGFzIGpzeDExIH0gZnJvbSBcInJlYWN0L2pzeC1ydW50aW1lXCI7XG52YXIgTG9vcENvbnRleHQgPSBjcmVhdGVDb250ZXh0MTIobnVsbCk7XG52YXIgdXNlTG9vcCA9ICgpID0+IHtcbiAgcmV0dXJuIFJlYWN0OC51c2VDb250ZXh0KExvb3BDb250ZXh0KTtcbn07XG52YXIgTG9vcCA9ICh7IGR1cmF0aW9uSW5GcmFtZXMsIHRpbWVzID0gSW5maW5pdHksIGNoaWxkcmVuLCBuYW1lLCAuLi5wcm9wcyB9KSA9PiB7XG4gIGNvbnN0IGN1cnJlbnRGcmFtZSA9IHVzZUN1cnJlbnRGcmFtZSgpO1xuICBjb25zdCB7IGR1cmF0aW9uSW5GcmFtZXM6IGNvbXBEdXJhdGlvbiB9ID0gdXNlVmlkZW9Db25maWcoKTtcbiAgdmFsaWRhdGVEdXJhdGlvbkluRnJhbWVzKGR1cmF0aW9uSW5GcmFtZXMsIHtcbiAgICBjb21wb25lbnQ6IFwib2YgdGhlIDxMb29wIC8+IGNvbXBvbmVudFwiLFxuICAgIGFsbG93RmxvYXRzOiB0cnVlXG4gIH0pO1xuICBpZiAodHlwZW9mIHRpbWVzICE9PSBcIm51bWJlclwiKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgWW91IHBhc3NlZCB0byBcInRpbWVzXCIgYW4gYXJndW1lbnQgb2YgdHlwZSAke3R5cGVvZiB0aW1lc30sIGJ1dCBpdCBtdXN0IGJlIGEgbnVtYmVyLmApO1xuICB9XG4gIGlmICh0aW1lcyAhPT0gSW5maW5pdHkgJiYgdGltZXMgJSAxICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgVGhlIFwidGltZXNcIiBwcm9wIG9mIGEgbG9vcCBtdXN0IGJlIGFuIGludGVnZXIsIGJ1dCBnb3QgJHt0aW1lc30uYCk7XG4gIH1cbiAgaWYgKHRpbWVzIDwgMCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFRoZSBcInRpbWVzXCIgcHJvcCBvZiBhIGxvb3AgbXVzdCBiZSBhdCBsZWFzdCAwLCBidXQgZ290ICR7dGltZXN9YCk7XG4gIH1cbiAgY29uc3QgbWF4VGltZXMgPSBNYXRoLmNlaWwoY29tcER1cmF0aW9uIC8gZHVyYXRpb25JbkZyYW1lcyk7XG4gIGNvbnN0IGFjdHVhbFRpbWVzID0gTWF0aC5taW4obWF4VGltZXMsIHRpbWVzKTtcbiAgY29uc3Qgc3R5bGUgPSBwcm9wcy5sYXlvdXQgPT09IFwibm9uZVwiID8gdW5kZWZpbmVkIDogcHJvcHMuc3R5bGU7XG4gIGNvbnN0IG1heEZyYW1lID0gZHVyYXRpb25JbkZyYW1lcyAqIChhY3R1YWxUaW1lcyAtIDEpO1xuICBjb25zdCBpdGVyYXRpb24gPSBNYXRoLmZsb29yKGN1cnJlbnRGcmFtZSAvIGR1cmF0aW9uSW5GcmFtZXMpO1xuICBjb25zdCBzdGFydCA9IGl0ZXJhdGlvbiAqIGR1cmF0aW9uSW5GcmFtZXM7XG4gIGNvbnN0IGZyb20gPSBNYXRoLm1pbihzdGFydCwgbWF4RnJhbWUpO1xuICBjb25zdCBsb29wRGlzcGxheSA9IHVzZU1lbW8xMigoKSA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG51bWJlck9mVGltZXM6IGFjdHVhbFRpbWVzLFxuICAgICAgc3RhcnRPZmZzZXQ6IC1mcm9tLFxuICAgICAgZHVyYXRpb25JbkZyYW1lc1xuICAgIH07XG4gIH0sIFthY3R1YWxUaW1lcywgZHVyYXRpb25JbkZyYW1lcywgZnJvbV0pO1xuICBjb25zdCBsb29wQ29udGV4dCA9IHVzZU1lbW8xMigoKSA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGl0ZXJhdGlvbjogTWF0aC5mbG9vcihjdXJyZW50RnJhbWUgLyBkdXJhdGlvbkluRnJhbWVzKSxcbiAgICAgIGR1cmF0aW9uSW5GcmFtZXNcbiAgICB9O1xuICB9LCBbY3VycmVudEZyYW1lLCBkdXJhdGlvbkluRnJhbWVzXSk7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8ganN4MTEoTG9vcENvbnRleHQuUHJvdmlkZXIsIHtcbiAgICB2YWx1ZTogbG9vcENvbnRleHQsXG4gICAgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBqc3gxMShTZXF1ZW5jZSwge1xuICAgICAgZHVyYXRpb25JbkZyYW1lcyxcbiAgICAgIGZyb20sXG4gICAgICBuYW1lOiBuYW1lID8/IFwiPExvb3A+XCIsXG4gICAgICBfcmVtb3Rpb25JbnRlcm5hbExvb3BEaXNwbGF5OiBsb29wRGlzcGxheSxcbiAgICAgIGxheW91dDogcHJvcHMubGF5b3V0LFxuICAgICAgc3R5bGUsXG4gICAgICBjaGlsZHJlblxuICAgIH0pXG4gIH0pO1xufTtcbkxvb3AudXNlTG9vcCA9IHVzZUxvb3A7XG5cbi8vIHNyYy9wcmVmZXRjaC50c1xuaW1wb3J0IHsgdXNlQ29udGV4dCBhcyB1c2VDb250ZXh0MTQgfSBmcm9tIFwicmVhY3RcIjtcblxuLy8gc3JjL3ByZWZldGNoLXN0YXRlLnRzeFxuaW1wb3J0IHsgY3JlYXRlQ29udGV4dCBhcyBjcmVhdGVDb250ZXh0MTMsIHVzZUVmZmVjdCBhcyB1c2VFZmZlY3Q3LCB1c2VTdGF0ZSBhcyB1c2VTdGF0ZTggfSBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7IGpzeCBhcyBqc3gxMiB9IGZyb20gXCJyZWFjdC9qc3gtcnVudGltZVwiO1xudmFyIFByZWxvYWRDb250ZXh0ID0gY3JlYXRlQ29udGV4dDEzKHt9KTtcbnZhciBwcmVsb2FkcyA9IHt9O1xudmFyIHVwZGF0ZXJzID0gW107XG52YXIgc2V0UHJlbG9hZHMgPSAodXBkYXRlcikgPT4ge1xuICBwcmVsb2FkcyA9IHVwZGF0ZXIocHJlbG9hZHMpO1xuICB1cGRhdGVycy5mb3JFYWNoKCh1KSA9PiB1KCkpO1xufTtcbnZhciBQcmVmZXRjaFByb3ZpZGVyID0gKHsgY2hpbGRyZW4gfSkgPT4ge1xuICBjb25zdCBbX3ByZWxvYWRzLCBfc2V0UHJlbG9hZHNdID0gdXNlU3RhdGU4KCgpID0+IHByZWxvYWRzKTtcbiAgdXNlRWZmZWN0NygoKSA9PiB7XG4gICAgY29uc3QgdXBkYXRlckZ1bmN0aW9uID0gKCkgPT4ge1xuICAgICAgX3NldFByZWxvYWRzKHByZWxvYWRzKTtcbiAgICB9O1xuICAgIHVwZGF0ZXJzLnB1c2godXBkYXRlckZ1bmN0aW9uKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgdXBkYXRlcnMgPSB1cGRhdGVycy5maWx0ZXIoKHUpID0+IHUgIT09IHVwZGF0ZXJGdW5jdGlvbik7XG4gICAgfTtcbiAgfSwgW10pO1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeDEyKFByZWxvYWRDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgdmFsdWU6IF9wcmVsb2FkcyxcbiAgICBjaGlsZHJlblxuICB9KTtcbn07XG5cbi8vIHNyYy9wcmVmZXRjaC50c1xudmFyIHVzZVByZWxvYWQgPSAoc3JjKSA9PiB7XG4gIGNvbnN0IHByZWxvYWRzMiA9IHVzZUNvbnRleHQxNChQcmVsb2FkQ29udGV4dCk7XG4gIHJldHVybiBwcmVsb2FkczJbc3JjXSA/PyBzcmM7XG59O1xudmFyIGJsb2JUb0Jhc2U2NCA9IGZ1bmN0aW9uKGJsb2IpIHtcbiAgY29uc3QgcmVhZGVyID0gbmV3IEZpbGVSZWFkZXI7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgcmVhZGVyLm9ubG9hZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgY29uc3QgZGF0YVVybCA9IHJlYWRlci5yZXN1bHQ7XG4gICAgICByZXNvbHZlKGRhdGFVcmwpO1xuICAgIH07XG4gICAgcmVhZGVyLm9uZXJyb3IgPSAoZXJyKSA9PiB7XG4gICAgICByZXR1cm4gcmVqZWN0KGVycik7XG4gICAgfTtcbiAgICByZWFkZXIucmVhZEFzRGF0YVVSTChibG9iKTtcbiAgfSk7XG59O1xudmFyIGdldEJsb2JGcm9tUmVhZGVyID0gYXN5bmMgKHtcbiAgcmVhZGVyLFxuICBjb250ZW50VHlwZSxcbiAgY29udGVudExlbmd0aCxcbiAgb25Qcm9ncmVzc1xufSkgPT4ge1xuICBsZXQgcmVjZWl2ZWRMZW5ndGggPSAwO1xuICBjb25zdCBjaHVua3MgPSBbXTtcbiAgd2hpbGUgKHRydWUpIHtcbiAgICBjb25zdCB7IGRvbmUsIHZhbHVlIH0gPSBhd2FpdCByZWFkZXIucmVhZCgpO1xuICAgIGlmIChkb25lKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgY2h1bmtzLnB1c2godmFsdWUpO1xuICAgIHJlY2VpdmVkTGVuZ3RoICs9IHZhbHVlLmxlbmd0aDtcbiAgICBpZiAob25Qcm9ncmVzcykge1xuICAgICAgb25Qcm9ncmVzcyh7IGxvYWRlZEJ5dGVzOiByZWNlaXZlZExlbmd0aCwgdG90YWxCeXRlczogY29udGVudExlbmd0aCB9KTtcbiAgICB9XG4gIH1cbiAgY29uc3QgY2h1bmtzQWxsID0gbmV3IFVpbnQ4QXJyYXkocmVjZWl2ZWRMZW5ndGgpO1xuICBsZXQgcG9zaXRpb24gPSAwO1xuICBmb3IgKGNvbnN0IGNodW5rIG9mIGNodW5rcykge1xuICAgIGNodW5rc0FsbC5zZXQoY2h1bmssIHBvc2l0aW9uKTtcbiAgICBwb3NpdGlvbiArPSBjaHVuay5sZW5ndGg7XG4gIH1cbiAgcmV0dXJuIG5ldyBCbG9iKFtjaHVua3NBbGxdLCB7XG4gICAgdHlwZTogY29udGVudFR5cGUgPz8gdW5kZWZpbmVkXG4gIH0pO1xufTtcbnZhciBwcmVmZXRjaCA9IChzcmMsIG9wdGlvbnMpID0+IHtcbiAgY29uc3QgbWV0aG9kID0gb3B0aW9ucz8ubWV0aG9kID8/IFwiYmxvYi11cmxcIjtcbiAgaWYgKGdldFJlbW90aW9uRW52aXJvbm1lbnQoKS5pc1JlbmRlcmluZykge1xuICAgIHJldHVybiB7XG4gICAgICBmcmVlOiAoKSA9PiB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0sXG4gICAgICB3YWl0VW50aWxEb25lOiAoKSA9PiBQcm9taXNlLnJlc29sdmUoc3JjKVxuICAgIH07XG4gIH1cbiAgbGV0IGNhbmNlbGVkID0gZmFsc2U7XG4gIGxldCBvYmplY3RVcmwgPSBudWxsO1xuICBsZXQgcmVzb2x2ZSA9ICgpID0+IHtcbiAgICByZXR1cm47XG4gIH07XG4gIGxldCByZWplY3QgPSAoKSA9PiB7XG4gICAgcmV0dXJuO1xuICB9O1xuICBjb25zdCB3YWl0VW50aWxEb25lID0gbmV3IFByb21pc2UoKHJlcywgcmVqKSA9PiB7XG4gICAgcmVzb2x2ZSA9IHJlcztcbiAgICByZWplY3QgPSByZWo7XG4gIH0pO1xuICBjb25zdCBjb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcjtcbiAgbGV0IGNhbkJlQWJvcnRlZCA9IHRydWU7XG4gIGZldGNoKHNyYywge1xuICAgIHNpZ25hbDogY29udHJvbGxlci5zaWduYWxcbiAgfSkudGhlbigocmVzKSA9PiB7XG4gICAgY2FuQmVBYm9ydGVkID0gZmFsc2U7XG4gICAgaWYgKGNhbmNlbGVkKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaWYgKCFyZXMub2spIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgSFRUUCBlcnJvciwgc3RhdHVzID0gJHtyZXMuc3RhdHVzfWApO1xuICAgIH1cbiAgICBjb25zdCBoZWFkZXJDb250ZW50VHlwZSA9IHJlcy5oZWFkZXJzLmdldChcIkNvbnRlbnQtVHlwZVwiKTtcbiAgICBjb25zdCBjb250ZW50VHlwZSA9IG9wdGlvbnM/LmNvbnRlbnRUeXBlID8/IGhlYWRlckNvbnRlbnRUeXBlO1xuICAgIGNvbnN0IGhhc1Byb3BlckNvbnRlbnRUeXBlID0gY29udGVudFR5cGUgJiYgKGNvbnRlbnRUeXBlLnN0YXJ0c1dpdGgoXCJ2aWRlby9cIikgfHwgY29udGVudFR5cGUuc3RhcnRzV2l0aChcImF1ZGlvL1wiKSB8fCBjb250ZW50VHlwZS5zdGFydHNXaXRoKFwiaW1hZ2UvXCIpKTtcbiAgICBpZiAoIWhhc1Byb3BlckNvbnRlbnRUeXBlKSB7XG4gICAgICBjb25zb2xlLndhcm4oYENhbGxlZCBwcmVmZXRjaCgpIG9uICR7c3JjfSB3aGljaCByZXR1cm5lZCBhIFwiQ29udGVudC1UeXBlXCIgb2YgJHtoZWFkZXJDb250ZW50VHlwZX0uIFByZWZldGNoZWQgY29udGVudCBzaG91bGQgaGF2ZSBhIHByb3BlciBjb250ZW50IHR5cGUgKHZpZGVvLy4uLiBvciBhdWRpby8uLi4pIG9yIGEgY29udGVudFR5cGUgcGFzc2VkIHRoZSBvcHRpb25zIG9mIHByZWZldGNoKCkuIE90aGVyd2lzZSwgcHJlZmV0Y2hpbmcgd2lsbCBub3Qgd29yayBwcm9wZXJseSBpbiBhbGwgYnJvd3NlcnMuYCk7XG4gICAgfVxuICAgIGlmICghcmVzLmJvZHkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgSFRUUCByZXNwb25zZSBvZiAke3NyY30gaGFzIG5vIGJvZHlgKTtcbiAgICB9XG4gICAgY29uc3QgcmVhZGVyID0gcmVzLmJvZHkuZ2V0UmVhZGVyKCk7XG4gICAgcmV0dXJuIGdldEJsb2JGcm9tUmVhZGVyKHtcbiAgICAgIHJlYWRlcixcbiAgICAgIGNvbnRlbnRUeXBlOiBvcHRpb25zPy5jb250ZW50VHlwZSA/PyBoZWFkZXJDb250ZW50VHlwZSA/PyBudWxsLFxuICAgICAgY29udGVudExlbmd0aDogcmVzLmhlYWRlcnMuZ2V0KFwiQ29udGVudC1MZW5ndGhcIikgPyBwYXJzZUludChyZXMuaGVhZGVycy5nZXQoXCJDb250ZW50LUxlbmd0aFwiKSwgMTApIDogbnVsbCxcbiAgICAgIG9uUHJvZ3Jlc3M6IG9wdGlvbnM/Lm9uUHJvZ3Jlc3NcbiAgICB9KTtcbiAgfSkudGhlbigoYnVmKSA9PiB7XG4gICAgaWYgKCFidWYpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgYWN0dWFsQmxvYiA9IG9wdGlvbnM/LmNvbnRlbnRUeXBlID8gbmV3IEJsb2IoW2J1Zl0sIHsgdHlwZTogb3B0aW9ucy5jb250ZW50VHlwZSB9KSA6IGJ1ZjtcbiAgICBpZiAobWV0aG9kID09PSBcImJhc2U2NFwiKSB7XG4gICAgICByZXR1cm4gYmxvYlRvQmFzZTY0KGFjdHVhbEJsb2IpO1xuICAgIH1cbiAgICByZXR1cm4gVVJMLmNyZWF0ZU9iamVjdFVSTChhY3R1YWxCbG9iKTtcbiAgfSkudGhlbigodXJsKSA9PiB7XG4gICAgaWYgKGNhbmNlbGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIG9iamVjdFVybCA9IHVybDtcbiAgICBzZXRQcmVsb2FkcygocCkgPT4gKHtcbiAgICAgIC4uLnAsXG4gICAgICBbc3JjXTogb2JqZWN0VXJsXG4gICAgfSkpO1xuICAgIHJlc29sdmUob2JqZWN0VXJsKTtcbiAgfSkuY2F0Y2goKGVycikgPT4ge1xuICAgIHJlamVjdChlcnIpO1xuICB9KTtcbiAgcmV0dXJuIHtcbiAgICBmcmVlOiAoKSA9PiB7XG4gICAgICBpZiAob2JqZWN0VXJsKSB7XG4gICAgICAgIGlmIChtZXRob2QgPT09IFwiYmxvYi11cmxcIikge1xuICAgICAgICAgIFVSTC5yZXZva2VPYmplY3RVUkwob2JqZWN0VXJsKTtcbiAgICAgICAgfVxuICAgICAgICBzZXRQcmVsb2FkcygocCkgPT4ge1xuICAgICAgICAgIGNvbnN0IGNvcHkgPSB7IC4uLnAgfTtcbiAgICAgICAgICBkZWxldGUgY29weVtzcmNdO1xuICAgICAgICAgIHJldHVybiBjb3B5O1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNhbmNlbGVkID0gdHJ1ZTtcbiAgICAgICAgaWYgKGNhbkJlQWJvcnRlZCkge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb250cm9sbGVyLmFib3J0KG5ldyBFcnJvcihcImZyZWUoKSBjYWxsZWRcIikpO1xuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIHdhaXRVbnRpbERvbmU6ICgpID0+IHtcbiAgICAgIHJldHVybiB3YWl0VW50aWxEb25lO1xuICAgIH1cbiAgfTtcbn07XG5cbi8vIHNyYy92YWxpZGF0ZS1tZWRpYS1wcm9wcy50c1xudmFyIHZhbGlkYXRlTWVkaWFQcm9wcyA9IChwcm9wcywgY29tcG9uZW50KSA9PiB7XG4gIGlmICh0eXBlb2YgcHJvcHMudm9sdW1lICE9PSBcIm51bWJlclwiICYmIHR5cGVvZiBwcm9wcy52b2x1bWUgIT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgcHJvcHMudm9sdW1lICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgWW91IGhhdmUgcGFzc2VkIGEgdm9sdW1lIG9mIHR5cGUgJHt0eXBlb2YgcHJvcHMudm9sdW1lfSB0byB5b3VyIDwke2NvbXBvbmVudH0gLz4gY29tcG9uZW50LiBWb2x1bWUgbXVzdCBiZSBhIG51bWJlciBvciBhIGZ1bmN0aW9uIHdpdGggdGhlIHNpZ25hdHVyZSAnKGZyYW1lOiBudW1iZXIpID0+IG51bWJlcicgdW5kZWZpbmVkLmApO1xuICB9XG4gIGlmICh0eXBlb2YgcHJvcHMudm9sdW1lID09PSBcIm51bWJlclwiICYmIHByb3BzLnZvbHVtZSA8IDApIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBZb3UgaGF2ZSBwYXNzZWQgYSB2b2x1bWUgYmVsb3cgMCB0byB5b3VyIDwke2NvbXBvbmVudH0gLz4gY29tcG9uZW50LiBWb2x1bWUgbXVzdCBiZSBiZXR3ZWVuIDAgYW5kIDFgKTtcbiAgfVxuICBpZiAodHlwZW9mIHByb3BzLnBsYXliYWNrUmF0ZSAhPT0gXCJudW1iZXJcIiAmJiB0eXBlb2YgcHJvcHMucGxheWJhY2tSYXRlICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgWW91IGhhdmUgcGFzc2VkIGEgcGxheWJhY2tSYXRlIG9mIHR5cGUgJHt0eXBlb2YgcHJvcHMucGxheWJhY2tSYXRlfSB0byB5b3VyIDwke2NvbXBvbmVudH0gLz4gY29tcG9uZW50LiBQbGF5YmFjayByYXRlIG11c3QgYSByZWFsIG51bWJlciBvciB1bmRlZmluZWQuYCk7XG4gIH1cbiAgaWYgKHR5cGVvZiBwcm9wcy5wbGF5YmFja1JhdGUgPT09IFwibnVtYmVyXCIgJiYgKGlzTmFOKHByb3BzLnBsYXliYWNrUmF0ZSkgfHwgIU51bWJlci5pc0Zpbml0ZShwcm9wcy5wbGF5YmFja1JhdGUpIHx8IHByb3BzLnBsYXliYWNrUmF0ZSA8PSAwKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFlvdSBoYXZlIHBhc3NlZCBhIHBsYXliYWNrUmF0ZSBvZiAke3Byb3BzLnBsYXliYWNrUmF0ZX0gdG8geW91ciA8JHtjb21wb25lbnR9IC8+IGNvbXBvbmVudC4gUGxheWJhY2sgcmF0ZSBtdXN0IGJlIGEgcmVhbCBudW1iZXIgYWJvdmUgMC5gKTtcbiAgfVxufTtcblxuLy8gc3JjL3ZhbGlkYXRlLXN0YXJ0LWZyb20tcHJvcHMudHNcbnZhciB2YWxpZGF0ZVN0YXJ0RnJvbVByb3BzID0gKHN0YXJ0RnJvbSwgZW5kQXQpID0+IHtcbiAgaWYgKHR5cGVvZiBzdGFydEZyb20gIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICBpZiAodHlwZW9mIHN0YXJ0RnJvbSAhPT0gXCJudW1iZXJcIikge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgdHlwZSBvZiBzdGFydEZyb20gcHJvcCBtdXN0IGJlIGEgbnVtYmVyLCBpbnN0ZWFkIGdvdCB0eXBlICR7dHlwZW9mIHN0YXJ0RnJvbX0uYCk7XG4gICAgfVxuICAgIGlmIChpc05hTihzdGFydEZyb20pIHx8IHN0YXJ0RnJvbSA9PT0gSW5maW5pdHkpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJzdGFydEZyb20gcHJvcCBjYW4gbm90IGJlIE5hTiBvciBJbmZpbml0eS5cIik7XG4gICAgfVxuICAgIGlmIChzdGFydEZyb20gPCAwKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBzdGFydEZyb20gbXVzdCBiZSBncmVhdGVyIHRoYW4gZXF1YWwgdG8gMCBpbnN0ZWFkIGdvdCAke3N0YXJ0RnJvbX0uYCk7XG4gICAgfVxuICB9XG4gIGlmICh0eXBlb2YgZW5kQXQgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICBpZiAodHlwZW9mIGVuZEF0ICE9PSBcIm51bWJlclwiKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGB0eXBlIG9mIGVuZEF0IHByb3AgbXVzdCBiZSBhIG51bWJlciwgaW5zdGVhZCBnb3QgdHlwZSAke3R5cGVvZiBlbmRBdH0uYCk7XG4gICAgfVxuICAgIGlmIChpc05hTihlbmRBdCkpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJlbmRBdCBwcm9wIGNhbiBub3QgYmUgTmFOLlwiKTtcbiAgICB9XG4gICAgaWYgKGVuZEF0IDw9IDApIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYGVuZEF0IG11c3QgYmUgYSBwb3NpdGl2ZSBudW1iZXIsIGluc3RlYWQgZ290ICR7ZW5kQXR9LmApO1xuICAgIH1cbiAgfVxuICBpZiAoZW5kQXQgPCBzdGFydEZyb20pIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiZW5kQXQgcHJvcCBtdXN0IGJlIGdyZWF0ZXIgdGhhbiBzdGFydEZyb20gcHJvcC5cIik7XG4gIH1cbn07XG5cbi8vIHNyYy92aWRlby9kdXJhdGlvbi1zdGF0ZS50c3hcbmltcG9ydCB7IGNyZWF0ZUNvbnRleHQgYXMgY3JlYXRlQ29udGV4dDE0LCB1c2VNZW1vIGFzIHVzZU1lbW8xMywgdXNlUmVkdWNlciB9IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHsganN4IGFzIGpzeDEzIH0gZnJvbSBcInJlYWN0L2pzeC1ydW50aW1lXCI7XG52YXIgZHVyYXRpb25SZWR1Y2VyID0gKHN0YXRlLCBhY3Rpb24pID0+IHtcbiAgc3dpdGNoIChhY3Rpb24udHlwZSkge1xuICAgIGNhc2UgXCJnb3QtZHVyYXRpb25cIjoge1xuICAgICAgY29uc3QgYWJzb2x1dGVTcmMgPSBnZXRBYnNvbHV0ZVNyYyhhY3Rpb24uc3JjKTtcbiAgICAgIGlmIChzdGF0ZVthYnNvbHV0ZVNyY10gPT09IGFjdGlvbi5kdXJhdGlvbkluU2Vjb25kcykge1xuICAgICAgICByZXR1cm4gc3RhdGU7XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi5zdGF0ZSxcbiAgICAgICAgW2Fic29sdXRlU3JjXTogYWN0aW9uLmR1cmF0aW9uSW5TZWNvbmRzXG4gICAgICB9O1xuICAgIH1cbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIHN0YXRlO1xuICB9XG59O1xudmFyIER1cmF0aW9uc0NvbnRleHQgPSBjcmVhdGVDb250ZXh0MTQoe1xuICBkdXJhdGlvbnM6IHt9LFxuICBzZXREdXJhdGlvbnM6ICgpID0+IHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJjb250ZXh0IG1pc3NpbmdcIik7XG4gIH1cbn0pO1xudmFyIER1cmF0aW9uc0NvbnRleHRQcm92aWRlciA9ICh7IGNoaWxkcmVuIH0pID0+IHtcbiAgY29uc3QgW2R1cmF0aW9ucywgc2V0RHVyYXRpb25zXSA9IHVzZVJlZHVjZXIoZHVyYXRpb25SZWR1Y2VyLCB7fSk7XG4gIGNvbnN0IHZhbHVlID0gdXNlTWVtbzEzKCgpID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgZHVyYXRpb25zLFxuICAgICAgc2V0RHVyYXRpb25zXG4gICAgfTtcbiAgfSwgW2R1cmF0aW9uc10pO1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeDEzKER1cmF0aW9uc0NvbnRleHQuUHJvdmlkZXIsIHtcbiAgICB2YWx1ZSxcbiAgICBjaGlsZHJlblxuICB9KTtcbn07XG5cbi8vIHNyYy9hdWRpby9BdWRpb0ZvclByZXZpZXcudHN4XG5pbXBvcnQge1xuICBmb3J3YXJkUmVmIGFzIGZvcndhcmRSZWYzLFxuICB1c2VDb250ZXh0IGFzIHVzZUNvbnRleHQyMSxcbiAgdXNlRWZmZWN0IGFzIHVzZUVmZmVjdDE2LFxuICB1c2VJbXBlcmF0aXZlSGFuZGxlIGFzIHVzZUltcGVyYXRpdmVIYW5kbGUzLFxuICB1c2VNZW1vIGFzIHVzZU1lbW8yMCxcbiAgdXNlUmVmIGFzIHVzZVJlZjgsXG4gIHVzZVN0YXRlIGFzIHVzZVN0YXRlMTRcbn0gZnJvbSBcInJlYWN0XCI7XG5cbi8vIHNyYy9yYW5kb20udHNcbmZ1bmN0aW9uIG11bGJlcnJ5MzIoYSkge1xuICBsZXQgdCA9IGEgKyAxODMxNTY1ODEzO1xuICB0ID0gTWF0aC5pbXVsKHQgXiB0ID4+PiAxNSwgdCB8IDEpO1xuICB0IF49IHQgKyBNYXRoLmltdWwodCBeIHQgPj4+IDcsIHQgfCA2MSk7XG4gIHJldHVybiAoKHQgXiB0ID4+PiAxNCkgPj4+IDApIC8gNDI5NDk2NzI5Njtcbn1cbmZ1bmN0aW9uIGhhc2hDb2RlKHN0cikge1xuICBsZXQgaSA9IDA7XG4gIGxldCBjaHIgPSAwO1xuICBsZXQgaGFzaCA9IDA7XG4gIGZvciAoaSA9IDA7aSA8IHN0ci5sZW5ndGg7IGkrKykge1xuICAgIGNociA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuICAgIGhhc2ggPSAoaGFzaCA8PCA1KSAtIGhhc2ggKyBjaHI7XG4gICAgaGFzaCB8PSAwO1xuICB9XG4gIHJldHVybiBoYXNoO1xufVxudmFyIHJhbmRvbSA9IChzZWVkLCBkdW1teSkgPT4ge1xuICBpZiAoZHVtbXkgIT09IHVuZGVmaW5lZCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJyYW5kb20oKSB0YWtlcyBvbmx5IG9uZSBhcmd1bWVudFwiKTtcbiAgfVxuICBpZiAoc2VlZCA9PT0gbnVsbCkge1xuICAgIHJldHVybiBNYXRoLnJhbmRvbSgpO1xuICB9XG4gIGlmICh0eXBlb2Ygc2VlZCA9PT0gXCJzdHJpbmdcIikge1xuICAgIHJldHVybiBtdWxiZXJyeTMyKGhhc2hDb2RlKHNlZWQpKTtcbiAgfVxuICBpZiAodHlwZW9mIHNlZWQgPT09IFwibnVtYmVyXCIpIHtcbiAgICByZXR1cm4gbXVsYmVycnkzMihzZWVkICogMTAwMDAwMDAwMDApO1xuICB9XG4gIHRocm93IG5ldyBFcnJvcihcInJhbmRvbSgpIGFyZ3VtZW50IG11c3QgYmUgYSBudW1iZXIgb3IgYSBzdHJpbmdcIik7XG59O1xuXG4vLyBzcmMvdXNlLW1lZGlhLWluLXRpbWVsaW5lLnRzXG5pbXBvcnQgeyB1c2VDb250ZXh0IGFzIHVzZUNvbnRleHQxNiwgdXNlRWZmZWN0IGFzIHVzZUVmZmVjdDgsIHVzZU1lbW8gYXMgdXNlTWVtbzE0LCB1c2VTdGF0ZSBhcyB1c2VTdGF0ZTkgfSBmcm9tIFwicmVhY3RcIjtcblxuLy8gc3JjL2F1ZGlvL3VzZS1hdWRpby1mcmFtZS50c1xuaW1wb3J0IHsgdXNlQ29udGV4dCBhcyB1c2VDb250ZXh0MTUgfSBmcm9tIFwicmVhY3RcIjtcbnZhciB1c2VNZWRpYVN0YXJ0c0F0ID0gKCkgPT4ge1xuICBjb25zdCBwYXJlbnRTZXF1ZW5jZSA9IHVzZUNvbnRleHQxNShTZXF1ZW5jZUNvbnRleHQpO1xuICBjb25zdCBzdGFydHNBdCA9IE1hdGgubWluKDAsIHBhcmVudFNlcXVlbmNlPy5yZWxhdGl2ZUZyb20gPz8gMCk7XG4gIHJldHVybiBzdGFydHNBdDtcbn07XG52YXIgdXNlRnJhbWVGb3JWb2x1bWVQcm9wID0gKGJlaGF2aW9yKSA9PiB7XG4gIGNvbnN0IGxvb3AgPSBMb29wLnVzZUxvb3AoKTtcbiAgY29uc3QgZnJhbWUgPSB1c2VDdXJyZW50RnJhbWUoKTtcbiAgY29uc3Qgc3RhcnRzQXQgPSB1c2VNZWRpYVN0YXJ0c0F0KCk7XG4gIGlmIChiZWhhdmlvciA9PT0gXCJyZXBlYXRcIiB8fCBsb29wID09PSBudWxsKSB7XG4gICAgcmV0dXJuIGZyYW1lICsgc3RhcnRzQXQ7XG4gIH1cbiAgcmV0dXJuIGZyYW1lICsgc3RhcnRzQXQgKyBsb29wLmR1cmF0aW9uSW5GcmFtZXMgKiBsb29wLml0ZXJhdGlvbjtcbn07XG5cbi8vIHNyYy9nZXQtYXNzZXQtZmlsZS1uYW1lLnRzXG52YXIgZ2V0QXNzZXREaXNwbGF5TmFtZSA9IChmaWxlbmFtZSkgPT4ge1xuICBpZiAoL2RhdGE6fGJsb2I6Ly50ZXN0KGZpbGVuYW1lLnN1YnN0cmluZygwLCA1KSkpIHtcbiAgICByZXR1cm4gXCJEYXRhIFVSTFwiO1xuICB9XG4gIGNvbnN0IHNwbGl0dGVkID0gZmlsZW5hbWUuc3BsaXQoXCIvXCIpLm1hcCgocykgPT4gcy5zcGxpdChcIlxcXFxcIikpLmZsYXQoMSk7XG4gIHJldHVybiBzcGxpdHRlZFtzcGxpdHRlZC5sZW5ndGggLSAxXTtcbn07XG5cbi8vIHNyYy9wbGF5LWFuZC1oYW5kbGUtbm90LWFsbG93ZWQtZXJyb3IudHNcbnZhciBwbGF5QW5kSGFuZGxlTm90QWxsb3dlZEVycm9yID0gKG1lZGlhUmVmLCBtZWRpYVR5cGUsIG9uQXV0b1BsYXlFcnJvcikgPT4ge1xuICBjb25zdCB7IGN1cnJlbnQgfSA9IG1lZGlhUmVmO1xuICBpZiAoIWN1cnJlbnQpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgcHJvbSA9IGN1cnJlbnQucGxheSgpO1xuICBpZiAocHJvbS5jYXRjaCkge1xuICAgIHByb20uY2F0Y2goKGVycikgPT4ge1xuICAgICAgaWYgKCFjdXJyZW50KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChlcnIubWVzc2FnZS5pbmNsdWRlcyhcInJlcXVlc3Qgd2FzIGludGVycnVwdGVkIGJ5IGEgY2FsbCB0byBwYXVzZVwiKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoZXJyLm1lc3NhZ2UuaW5jbHVkZXMoXCJUaGUgb3BlcmF0aW9uIHdhcyBhYm9ydGVkLlwiKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoZXJyLm1lc3NhZ2UuaW5jbHVkZXMoXCJUaGUgZmV0Y2hpbmcgcHJvY2VzcyBmb3IgdGhlIG1lZGlhIHJlc291cmNlIHdhcyBhYm9ydGVkIGJ5IHRoZSB1c2VyIGFnZW50XCIpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChlcnIubWVzc2FnZS5pbmNsdWRlcyhcInJlcXVlc3Qgd2FzIGludGVycnVwdGVkIGJ5IGEgbmV3IGxvYWQgcmVxdWVzdFwiKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoZXJyLm1lc3NhZ2UuaW5jbHVkZXMoXCJiZWNhdXNlIHRoZSBtZWRpYSB3YXMgcmVtb3ZlZCBmcm9tIHRoZSBkb2N1bWVudFwiKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zb2xlLmxvZyhgQ291bGQgbm90IHBsYXkgJHttZWRpYVR5cGV9IGR1ZSB0byBmb2xsb3dpbmcgZXJyb3I6IGAsIGVycik7XG4gICAgICBpZiAoIWN1cnJlbnQubXV0ZWQpIHtcbiAgICAgICAgaWYgKG9uQXV0b1BsYXlFcnJvcikge1xuICAgICAgICAgIG9uQXV0b1BsYXlFcnJvcigpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zb2xlLmxvZyhgVGhlIHZpZGVvIHdpbGwgYmUgbXV0ZWQgYW5kIHdlJ2xsIHJldHJ5IHBsYXlpbmcgaXQuYCk7XG4gICAgICAgIGlmIChtZWRpYVR5cGUgPT09IFwidmlkZW9cIiAmJiBnZXRSZW1vdGlvbkVudmlyb25tZW50KCkuaXNQbGF5ZXIpIHtcbiAgICAgICAgICBjb25zb2xlLmxvZyhcIlVzZSBvbkF1dG9QbGF5RXJyb3IoKSB0byBoYW5kbGUgdGhpcyBlcnJvciB5b3Vyc2VsZi5cIik7XG4gICAgICAgIH1cbiAgICAgICAgY3VycmVudC5tdXRlZCA9IHRydWU7XG4gICAgICAgIGN1cnJlbnQucGxheSgpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59O1xuXG4vLyBzcmMvdm9sdW1lLXByb3AudHNcbnZhciBldmFsdWF0ZVZvbHVtZSA9ICh7XG4gIGZyYW1lLFxuICB2b2x1bWUsXG4gIG1lZGlhVm9sdW1lID0gMSxcbiAgYWxsb3dBbXBsaWZpY2F0aW9uRHVyaW5nUmVuZGVyXG59KSA9PiB7XG4gIGNvbnN0IG1heFZvbHVtZSA9IGFsbG93QW1wbGlmaWNhdGlvbkR1cmluZ1JlbmRlciA/IEluZmluaXR5IDogMTtcbiAgaWYgKHR5cGVvZiB2b2x1bWUgPT09IFwibnVtYmVyXCIpIHtcbiAgICByZXR1cm4gTWF0aC5taW4obWF4Vm9sdW1lLCB2b2x1bWUgKiBtZWRpYVZvbHVtZSk7XG4gIH1cbiAgaWYgKHR5cGVvZiB2b2x1bWUgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICByZXR1cm4gTnVtYmVyKG1lZGlhVm9sdW1lKTtcbiAgfVxuICBjb25zdCBldmFsdWF0ZWQgPSB2b2x1bWUoZnJhbWUpICogbWVkaWFWb2x1bWU7XG4gIGlmICh0eXBlb2YgZXZhbHVhdGVkICE9PSBcIm51bWJlclwiKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgWW91IHBhc3NlZCBpbiBhIGEgZnVuY3Rpb24gdG8gdGhlIHZvbHVtZSBwcm9wIGJ1dCBpdCBkaWQgbm90IHJldHVybiBhIG51bWJlciBidXQgYSB2YWx1ZSBvZiB0eXBlICR7dHlwZW9mIGV2YWx1YXRlZH0gZm9yIGZyYW1lICR7ZnJhbWV9YCk7XG4gIH1cbiAgaWYgKE51bWJlci5pc05hTihldmFsdWF0ZWQpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgWW91IHBhc3NlZCBpbiBhIGZ1bmN0aW9uIHRvIHRoZSB2b2x1bWUgcHJvcCBidXQgaXQgcmV0dXJuZWQgTmFOIGZvciBmcmFtZSAke2ZyYW1lfS5gKTtcbiAgfVxuICBpZiAoIU51bWJlci5pc0Zpbml0ZShldmFsdWF0ZWQpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgWW91IHBhc3NlZCBpbiBhIGZ1bmN0aW9uIHRvIHRoZSB2b2x1bWUgcHJvcCBidXQgaXQgcmV0dXJuZWQgYSBub24tZmluaXRlIG51bWJlciBmb3IgZnJhbWUgJHtmcmFtZX0uYCk7XG4gIH1cbiAgcmV0dXJuIE1hdGgubWF4KDAsIE1hdGgubWluKG1heFZvbHVtZSwgZXZhbHVhdGVkKSk7XG59O1xuXG4vLyBzcmMvdXNlLW1lZGlhLWluLXRpbWVsaW5lLnRzXG52YXIgZGlkV2FybjIgPSB7fTtcbnZhciB3YXJuT25jZTIgPSAobWVzc2FnZSkgPT4ge1xuICBpZiAoZGlkV2FybjJbbWVzc2FnZV0pIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc29sZS53YXJuKG1lc3NhZ2UpO1xuICBkaWRXYXJuMlttZXNzYWdlXSA9IHRydWU7XG59O1xudmFyIHVzZU1lZGlhSW5UaW1lbGluZSA9ICh7XG4gIHZvbHVtZSxcbiAgbWVkaWFWb2x1bWUsXG4gIG1lZGlhUmVmLFxuICBzcmMsXG4gIG1lZGlhVHlwZSxcbiAgcGxheWJhY2tSYXRlLFxuICBkaXNwbGF5TmFtZSxcbiAgaWQsXG4gIHN0YWNrLFxuICBzaG93SW5UaW1lbGluZSxcbiAgcHJlbW91bnREaXNwbGF5LFxuICBvbkF1dG9QbGF5RXJyb3Jcbn0pID0+IHtcbiAgY29uc3QgdmlkZW9Db25maWcgPSB1c2VWaWRlb0NvbmZpZygpO1xuICBjb25zdCB7IHJvb3RJZCwgYXVkaW9BbmRWaWRlb1RhZ3MgfSA9IHVzZUNvbnRleHQxNihUaW1lbGluZUNvbnRleHQpO1xuICBjb25zdCBwYXJlbnRTZXF1ZW5jZSA9IHVzZUNvbnRleHQxNihTZXF1ZW5jZUNvbnRleHQpO1xuICBjb25zdCBhY3R1YWxGcm9tID0gcGFyZW50U2VxdWVuY2UgPyBwYXJlbnRTZXF1ZW5jZS5yZWxhdGl2ZUZyb20gKyBwYXJlbnRTZXF1ZW5jZS5jdW11bGF0ZWRGcm9tIDogMDtcbiAgY29uc3QgW3BsYXlpbmddID0gdXNlUGxheWluZ1N0YXRlKCk7XG4gIGNvbnN0IHN0YXJ0c0F0ID0gdXNlTWVkaWFTdGFydHNBdCgpO1xuICBjb25zdCB7IHJlZ2lzdGVyU2VxdWVuY2UsIHVucmVnaXN0ZXJTZXF1ZW5jZSB9ID0gdXNlQ29udGV4dDE2KFNlcXVlbmNlTWFuYWdlcik7XG4gIGNvbnN0IFtpbml0aWFsVm9sdW1lXSA9IHVzZVN0YXRlOSgoKSA9PiB2b2x1bWUpO1xuICBjb25zdCBub25jZSA9IHVzZU5vbmNlKCk7XG4gIGNvbnN0IGR1cmF0aW9uID0gcGFyZW50U2VxdWVuY2UgPyBNYXRoLm1pbihwYXJlbnRTZXF1ZW5jZS5kdXJhdGlvbkluRnJhbWVzLCB2aWRlb0NvbmZpZy5kdXJhdGlvbkluRnJhbWVzKSA6IHZpZGVvQ29uZmlnLmR1cmF0aW9uSW5GcmFtZXM7XG4gIGNvbnN0IGRvZXNWb2x1bWVDaGFuZ2UgPSB0eXBlb2Ygdm9sdW1lID09PSBcImZ1bmN0aW9uXCI7XG4gIGNvbnN0IHZvbHVtZXMgPSB1c2VNZW1vMTQoKCkgPT4ge1xuICAgIGlmICh0eXBlb2Ygdm9sdW1lID09PSBcIm51bWJlclwiKSB7XG4gICAgICByZXR1cm4gdm9sdW1lO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IEFycmF5KE1hdGguZmxvb3IoTWF0aC5tYXgoMCwgZHVyYXRpb24gKyBzdGFydHNBdCkpKS5maWxsKHRydWUpLm1hcCgoXywgaSkgPT4ge1xuICAgICAgcmV0dXJuIGV2YWx1YXRlVm9sdW1lKHtcbiAgICAgICAgZnJhbWU6IGkgKyBzdGFydHNBdCxcbiAgICAgICAgdm9sdW1lLFxuICAgICAgICBtZWRpYVZvbHVtZSxcbiAgICAgICAgYWxsb3dBbXBsaWZpY2F0aW9uRHVyaW5nUmVuZGVyOiBmYWxzZVxuICAgICAgfSk7XG4gICAgfSkuam9pbihcIixcIik7XG4gIH0sIFtkdXJhdGlvbiwgc3RhcnRzQXQsIHZvbHVtZSwgbWVkaWFWb2x1bWVdKTtcbiAgdXNlRWZmZWN0OCgoKSA9PiB7XG4gICAgaWYgKHR5cGVvZiB2b2x1bWUgPT09IFwibnVtYmVyXCIgJiYgdm9sdW1lICE9PSBpbml0aWFsVm9sdW1lKSB7XG4gICAgICB3YXJuT25jZTIoYFJlbW90aW9uOiBUaGUgJHttZWRpYVR5cGV9IHdpdGggc3JjICR7c3JjfSBoYXMgY2hhbmdlZCBpdCdzIHZvbHVtZS4gUHJlZmVyIHRoZSBjYWxsYmFjayBzeW50YXggZm9yIHNldHRpbmcgdm9sdW1lIHRvIGdldCBiZXR0ZXIgdGltZWxpbmUgZGlzcGxheTogaHR0cHM6Ly93d3cucmVtb3Rpb24uZGV2L2RvY3MvdXNpbmctYXVkaW8vI2NvbnRyb2xsaW5nLXZvbHVtZWApO1xuICAgIH1cbiAgfSwgW2luaXRpYWxWb2x1bWUsIG1lZGlhVHlwZSwgc3JjLCB2b2x1bWVdKTtcbiAgdXNlRWZmZWN0OCgoKSA9PiB7XG4gICAgaWYgKCFtZWRpYVJlZi5jdXJyZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghc3JjKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBzcmMgcGFzc2VkXCIpO1xuICAgIH1cbiAgICBpZiAoIWdldFJlbW90aW9uRW52aXJvbm1lbnQoKS5pc1N0dWRpbyAmJiB3aW5kb3cucHJvY2Vzcz8uZW52Py5OT0RFX0VOViAhPT0gXCJ0ZXN0XCIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCFzaG93SW5UaW1lbGluZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICByZWdpc3RlclNlcXVlbmNlKHtcbiAgICAgIHR5cGU6IG1lZGlhVHlwZSxcbiAgICAgIHNyYyxcbiAgICAgIGlkLFxuICAgICAgZHVyYXRpb24sXG4gICAgICBmcm9tOiAwLFxuICAgICAgcGFyZW50OiBwYXJlbnRTZXF1ZW5jZT8uaWQgPz8gbnVsbCxcbiAgICAgIGRpc3BsYXlOYW1lOiBkaXNwbGF5TmFtZSA/PyBnZXRBc3NldERpc3BsYXlOYW1lKHNyYyksXG4gICAgICByb290SWQsXG4gICAgICB2b2x1bWU6IHZvbHVtZXMsXG4gICAgICBzaG93SW5UaW1lbGluZTogdHJ1ZSxcbiAgICAgIG5vbmNlLFxuICAgICAgc3RhcnRNZWRpYUZyb206IDAgLSBzdGFydHNBdCxcbiAgICAgIGRvZXNWb2x1bWVDaGFuZ2UsXG4gICAgICBsb29wRGlzcGxheTogdW5kZWZpbmVkLFxuICAgICAgcGxheWJhY2tSYXRlLFxuICAgICAgc3RhY2ssXG4gICAgICBwcmVtb3VudERpc3BsYXlcbiAgICB9KTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgdW5yZWdpc3RlclNlcXVlbmNlKGlkKTtcbiAgICB9O1xuICB9LCBbXG4gICAgYWN0dWFsRnJvbSxcbiAgICBkdXJhdGlvbixcbiAgICBpZCxcbiAgICBwYXJlbnRTZXF1ZW5jZSxcbiAgICBzcmMsXG4gICAgcmVnaXN0ZXJTZXF1ZW5jZSxcbiAgICByb290SWQsXG4gICAgdW5yZWdpc3RlclNlcXVlbmNlLFxuICAgIHZpZGVvQ29uZmlnLFxuICAgIHZvbHVtZXMsXG4gICAgZG9lc1ZvbHVtZUNoYW5nZSxcbiAgICBub25jZSxcbiAgICBtZWRpYVJlZixcbiAgICBtZWRpYVR5cGUsXG4gICAgc3RhcnRzQXQsXG4gICAgcGxheWJhY2tSYXRlLFxuICAgIGRpc3BsYXlOYW1lLFxuICAgIHN0YWNrLFxuICAgIHNob3dJblRpbWVsaW5lLFxuICAgIHByZW1vdW50RGlzcGxheVxuICBdKTtcbiAgdXNlRWZmZWN0OCgoKSA9PiB7XG4gICAgY29uc3QgdGFnID0ge1xuICAgICAgaWQsXG4gICAgICBwbGF5OiAoKSA9PiB7XG4gICAgICAgIGlmICghcGxheWluZykge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGxheUFuZEhhbmRsZU5vdEFsbG93ZWRFcnJvcihtZWRpYVJlZiwgbWVkaWFUeXBlLCBvbkF1dG9QbGF5RXJyb3IpO1xuICAgICAgfVxuICAgIH07XG4gICAgYXVkaW9BbmRWaWRlb1RhZ3MuY3VycmVudC5wdXNoKHRhZyk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGF1ZGlvQW5kVmlkZW9UYWdzLmN1cnJlbnQgPSBhdWRpb0FuZFZpZGVvVGFncy5jdXJyZW50LmZpbHRlcigoYSkgPT4gYS5pZCAhPT0gaWQpO1xuICAgIH07XG4gIH0sIFthdWRpb0FuZFZpZGVvVGFncywgaWQsIG1lZGlhUmVmLCBtZWRpYVR5cGUsIG9uQXV0b1BsYXlFcnJvciwgcGxheWluZ10pO1xufTtcblxuLy8gc3JjL3VzZS1tZWRpYS1wbGF5YmFjay50c1xuaW1wb3J0IHsgdXNlQ2FsbGJhY2sgYXMgdXNlQ2FsbGJhY2s3LCB1c2VDb250ZXh0IGFzIHVzZUNvbnRleHQxOCwgdXNlRWZmZWN0IGFzIHVzZUVmZmVjdDEyLCB1c2VSZWYgYXMgdXNlUmVmNiB9IGZyb20gXCJyZWFjdFwiO1xuXG4vLyBzcmMvYnVmZmVyLXVudGlsLWZpcnN0LWZyYW1lLnRzXG5pbXBvcnQgeyB1c2VDYWxsYmFjayBhcyB1c2VDYWxsYmFjazYsIHVzZU1lbW8gYXMgdXNlTWVtbzE3LCB1c2VSZWYgYXMgdXNlUmVmMyB9IGZyb20gXCJyZWFjdFwiO1xuXG4vLyBzcmMvdXNlLWJ1ZmZlci1zdGF0ZS50c1xuaW1wb3J0IHsgdXNlQ29udGV4dCBhcyB1c2VDb250ZXh0MTcsIHVzZU1lbW8gYXMgdXNlTWVtbzE2IH0gZnJvbSBcInJlYWN0XCI7XG5cbi8vIHNyYy9idWZmZXJpbmcudHN4XG5pbXBvcnQgUmVhY3QxMSwgeyB1c2VDYWxsYmFjayBhcyB1c2VDYWxsYmFjazUsIHVzZUVmZmVjdCBhcyB1c2VFZmZlY3Q5LCB1c2VNZW1vIGFzIHVzZU1lbW8xNSwgdXNlUmVmIGFzIHVzZVJlZjIsIHVzZVN0YXRlIGFzIHVzZVN0YXRlMTAgfSBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7IGpzeCBhcyBqc3gxNCB9IGZyb20gXCJyZWFjdC9qc3gtcnVudGltZVwiO1xudmFyIHVzZUJ1ZmZlck1hbmFnZXIgPSAoKSA9PiB7XG4gIGNvbnN0IFtibG9ja3MsIHNldEJsb2Nrc10gPSB1c2VTdGF0ZTEwKFtdKTtcbiAgY29uc3QgW29uQnVmZmVyaW5nQ2FsbGJhY2tzLCBzZXRPbkJ1ZmZlcmluZ0NhbGxiYWNrc10gPSB1c2VTdGF0ZTEwKFtdKTtcbiAgY29uc3QgW29uUmVzdW1lQ2FsbGJhY2tzLCBzZXRPblJlc3VtZUNhbGxiYWNrc10gPSB1c2VTdGF0ZTEwKFtdKTtcbiAgY29uc3QgYnVmZmVyaW5nID0gdXNlUmVmMihmYWxzZSk7XG4gIGNvbnN0IGFkZEJsb2NrID0gdXNlQ2FsbGJhY2s1KChibG9jaykgPT4ge1xuICAgIHNldEJsb2NrcygoYikgPT4gWy4uLmIsIGJsb2NrXSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHVuYmxvY2s6ICgpID0+IHtcbiAgICAgICAgc2V0QmxvY2tzKChiKSA9PiB7XG4gICAgICAgICAgY29uc3QgbmV3QXJyID0gYi5maWx0ZXIoKGJ4KSA9PiBieCAhPT0gYmxvY2spO1xuICAgICAgICAgIGlmIChuZXdBcnIubGVuZ3RoID09PSBiLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIGI7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBuZXdBcnI7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH07XG4gIH0sIFtdKTtcbiAgY29uc3QgbGlzdGVuRm9yQnVmZmVyaW5nID0gdXNlQ2FsbGJhY2s1KChjYWxsYmFjaykgPT4ge1xuICAgIHNldE9uQnVmZmVyaW5nQ2FsbGJhY2tzKChjKSA9PiBbLi4uYywgY2FsbGJhY2tdKTtcbiAgICByZXR1cm4ge1xuICAgICAgcmVtb3ZlOiAoKSA9PiB7XG4gICAgICAgIHNldE9uQnVmZmVyaW5nQ2FsbGJhY2tzKChjKSA9PiBjLmZpbHRlcigoY2IpID0+IGNiICE9PSBjYWxsYmFjaykpO1xuICAgICAgfVxuICAgIH07XG4gIH0sIFtdKTtcbiAgY29uc3QgbGlzdGVuRm9yUmVzdW1lID0gdXNlQ2FsbGJhY2s1KChjYWxsYmFjaykgPT4ge1xuICAgIHNldE9uUmVzdW1lQ2FsbGJhY2tzKChjKSA9PiBbLi4uYywgY2FsbGJhY2tdKTtcbiAgICByZXR1cm4ge1xuICAgICAgcmVtb3ZlOiAoKSA9PiB7XG4gICAgICAgIHNldE9uUmVzdW1lQ2FsbGJhY2tzKChjKSA9PiBjLmZpbHRlcigoY2IpID0+IGNiICE9PSBjYWxsYmFjaykpO1xuICAgICAgfVxuICAgIH07XG4gIH0sIFtdKTtcbiAgdXNlRWZmZWN0OSgoKSA9PiB7XG4gICAgaWYgKGJsb2Nrcy5sZW5ndGggPiAwKSB7XG4gICAgICBvbkJ1ZmZlcmluZ0NhbGxiYWNrcy5mb3JFYWNoKChjKSA9PiBjKCkpO1xuICAgIH1cbiAgfSwgW2Jsb2Nrc10pO1xuICB1c2VFZmZlY3Q5KCgpID0+IHtcbiAgICBpZiAoYmxvY2tzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgb25SZXN1bWVDYWxsYmFja3MuZm9yRWFjaCgoYykgPT4gYygpKTtcbiAgICB9XG4gIH0sIFtibG9ja3NdKTtcbiAgcmV0dXJuIHVzZU1lbW8xNSgoKSA9PiB7XG4gICAgcmV0dXJuIHsgYWRkQmxvY2ssIGxpc3RlbkZvckJ1ZmZlcmluZywgbGlzdGVuRm9yUmVzdW1lLCBidWZmZXJpbmcgfTtcbiAgfSwgW2FkZEJsb2NrLCBidWZmZXJpbmcsIGxpc3RlbkZvckJ1ZmZlcmluZywgbGlzdGVuRm9yUmVzdW1lXSk7XG59O1xudmFyIEJ1ZmZlcmluZ0NvbnRleHRSZWFjdCA9IFJlYWN0MTEuY3JlYXRlQ29udGV4dChudWxsKTtcbnZhciBCdWZmZXJpbmdQcm92aWRlciA9ICh7IGNoaWxkcmVuIH0pID0+IHtcbiAgY29uc3QgYnVmZmVyTWFuYWdlciA9IHVzZUJ1ZmZlck1hbmFnZXIoKTtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBqc3gxNChCdWZmZXJpbmdDb250ZXh0UmVhY3QuUHJvdmlkZXIsIHtcbiAgICB2YWx1ZTogYnVmZmVyTWFuYWdlcixcbiAgICBjaGlsZHJlblxuICB9KTtcbn07XG52YXIgdXNlSXNQbGF5ZXJCdWZmZXJpbmcgPSAoYnVmZmVyTWFuYWdlcikgPT4ge1xuICBjb25zdCBbaXNCdWZmZXJpbmcsIHNldElzQnVmZmVyaW5nXSA9IHVzZVN0YXRlMTAoYnVmZmVyTWFuYWdlci5idWZmZXJpbmcuY3VycmVudCk7XG4gIHVzZUVmZmVjdDkoKCkgPT4ge1xuICAgIGNvbnN0IG9uQnVmZmVyID0gKCkgPT4ge1xuICAgICAgc2V0SXNCdWZmZXJpbmcodHJ1ZSk7XG4gICAgfTtcbiAgICBjb25zdCBvblJlc3VtZSA9ICgpID0+IHtcbiAgICAgIHNldElzQnVmZmVyaW5nKGZhbHNlKTtcbiAgICB9O1xuICAgIGJ1ZmZlck1hbmFnZXIubGlzdGVuRm9yQnVmZmVyaW5nKG9uQnVmZmVyKTtcbiAgICBidWZmZXJNYW5hZ2VyLmxpc3RlbkZvclJlc3VtZShvblJlc3VtZSk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGJ1ZmZlck1hbmFnZXIubGlzdGVuRm9yQnVmZmVyaW5nKCgpID0+IHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSk7XG4gICAgICBidWZmZXJNYW5hZ2VyLmxpc3RlbkZvclJlc3VtZSgoKSA9PiB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0pO1xuICAgIH07XG4gIH0sIFtidWZmZXJNYW5hZ2VyXSk7XG4gIHJldHVybiBpc0J1ZmZlcmluZztcbn07XG5cbi8vIHNyYy91c2UtYnVmZmVyLXN0YXRlLnRzXG52YXIgdXNlQnVmZmVyU3RhdGUgPSAoKSA9PiB7XG4gIGNvbnN0IGJ1ZmZlciA9IHVzZUNvbnRleHQxNyhCdWZmZXJpbmdDb250ZXh0UmVhY3QpO1xuICBjb25zdCBhZGRCbG9jayA9IGJ1ZmZlciA/IGJ1ZmZlci5hZGRCbG9jayA6IG51bGw7XG4gIHJldHVybiB1c2VNZW1vMTYoKCkgPT4gKHtcbiAgICBkZWxheVBsYXliYWNrOiAoKSA9PiB7XG4gICAgICBpZiAoIWFkZEJsb2NrKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRyaWVkIHRvIGVuYWJsZSB0aGUgYnVmZmVyaW5nIHN0YXRlLCBidXQgYSBSZW1vdGlvbiBjb250ZXh0IHdhcyBub3QgZm91bmQuIFRoaXMgQVBJIGNhbiBvbmx5IGJlIGNhbGxlZCBpbiBhIGNvbXBvbmVudCB0aGF0IHdhcyBwYXNzZWQgdG8gdGhlIFJlbW90aW9uIFBsYXllciBvciBhIDxDb21wb3NpdGlvbj4uIE9yIHlvdSBtaWdodCBoYXZlIGV4cGVyaWVuY2VkIGEgdmVyc2lvbiBtaXNtYXRjaCAtIHJ1biBgbnB4IHJlbW90aW9uIHZlcnNpb25zYCBhbmQgZW5zdXJlIGFsbCBwYWNrYWdlcyBoYXZlIHRoZSBzYW1lIHZlcnNpb24uIFRoaXMgZXJyb3IgaXMgdGhyb3duIGJ5IHRoZSBidWZmZXIgc3RhdGUgaHR0cHM6Ly9yZW1vdGlvbi5kZXYvZG9jcy9wbGF5ZXIvYnVmZmVyLXN0YXRlXCIpO1xuICAgICAgfVxuICAgICAgY29uc3QgeyB1bmJsb2NrIH0gPSBhZGRCbG9jayh7XG4gICAgICAgIGlkOiBTdHJpbmcoTWF0aC5yYW5kb20oKSlcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHsgdW5ibG9jayB9O1xuICAgIH1cbiAgfSksIFthZGRCbG9ja10pO1xufTtcblxuLy8gc3JjL2J1ZmZlci11bnRpbC1maXJzdC1mcmFtZS50c1xudmFyIHVzZUJ1ZmZlclVudGlsRmlyc3RGcmFtZSA9ICh7XG4gIG1lZGlhUmVmLFxuICBtZWRpYVR5cGUsXG4gIG9uVmFyaWFibGVGcHNWaWRlb0RldGVjdGVkLFxuICBwYXVzZVdoZW5CdWZmZXJpbmdcbn0pID0+IHtcbiAgY29uc3QgYnVmZmVyaW5nUmVmID0gdXNlUmVmMyhmYWxzZSk7XG4gIGNvbnN0IHsgZGVsYXlQbGF5YmFjayB9ID0gdXNlQnVmZmVyU3RhdGUoKTtcbiAgY29uc3QgYnVmZmVyVW50aWxGaXJzdEZyYW1lID0gdXNlQ2FsbGJhY2s2KChyZXF1ZXN0ZWRUaW1lKSA9PiB7XG4gICAgaWYgKG1lZGlhVHlwZSAhPT0gXCJ2aWRlb1wiKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghcGF1c2VXaGVuQnVmZmVyaW5nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGN1cnJlbnQgPSBtZWRpYVJlZi5jdXJyZW50O1xuICAgIGlmICghY3VycmVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIWN1cnJlbnQucmVxdWVzdFZpZGVvRnJhbWVDYWxsYmFjaykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBidWZmZXJpbmdSZWYuY3VycmVudCA9IHRydWU7XG4gICAgY29uc3QgcGxheWJhY2sgPSBkZWxheVBsYXliYWNrKCk7XG4gICAgY29uc3QgdW5ibG9jayA9ICgpID0+IHtcbiAgICAgIHBsYXliYWNrLnVuYmxvY2soKTtcbiAgICAgIGN1cnJlbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImVuZGVkXCIsIHVuYmxvY2ssIHtcbiAgICAgICAgb25jZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgICBjdXJyZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJwYXVzZVwiLCB1bmJsb2NrLCB7XG4gICAgICAgIG9uY2U6IHRydWVcbiAgICAgIH0pO1xuICAgICAgYnVmZmVyaW5nUmVmLmN1cnJlbnQgPSBmYWxzZTtcbiAgICB9O1xuICAgIGNvbnN0IG9uRW5kZWRPclBhdXNlT3JDYW5QbGF5ID0gKCkgPT4ge1xuICAgICAgdW5ibG9jaygpO1xuICAgIH07XG4gICAgY3VycmVudC5yZXF1ZXN0VmlkZW9GcmFtZUNhbGxiYWNrKChfLCBpbmZvKSA9PiB7XG4gICAgICBjb25zdCBkaWZmZXJlbmNlRnJvbVJlcXVlc3RlZCA9IE1hdGguYWJzKGluZm8ubWVkaWFUaW1lIC0gcmVxdWVzdGVkVGltZSk7XG4gICAgICBpZiAoZGlmZmVyZW5jZUZyb21SZXF1ZXN0ZWQgPiAwLjUpIHtcbiAgICAgICAgb25WYXJpYWJsZUZwc1ZpZGVvRGV0ZWN0ZWQoKTtcbiAgICAgIH1cbiAgICAgIHVuYmxvY2soKTtcbiAgICB9KTtcbiAgICBjdXJyZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJlbmRlZFwiLCBvbkVuZGVkT3JQYXVzZU9yQ2FuUGxheSwgeyBvbmNlOiB0cnVlIH0pO1xuICAgIGN1cnJlbnQuYWRkRXZlbnRMaXN0ZW5lcihcInBhdXNlXCIsIG9uRW5kZWRPclBhdXNlT3JDYW5QbGF5LCB7IG9uY2U6IHRydWUgfSk7XG4gICAgY3VycmVudC5hZGRFdmVudExpc3RlbmVyKFwiY2FucGxheVwiLCBvbkVuZGVkT3JQYXVzZU9yQ2FuUGxheSwge1xuICAgICAgb25jZTogdHJ1ZVxuICAgIH0pO1xuICB9LCBbXG4gICAgZGVsYXlQbGF5YmFjayxcbiAgICBtZWRpYVJlZixcbiAgICBtZWRpYVR5cGUsXG4gICAgb25WYXJpYWJsZUZwc1ZpZGVvRGV0ZWN0ZWQsXG4gICAgcGF1c2VXaGVuQnVmZmVyaW5nXG4gIF0pO1xuICByZXR1cm4gdXNlTWVtbzE3KCgpID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgaXNCdWZmZXJpbmc6ICgpID0+IGJ1ZmZlcmluZ1JlZi5jdXJyZW50LFxuICAgICAgYnVmZmVyVW50aWxGaXJzdEZyYW1lXG4gICAgfTtcbiAgfSwgW2J1ZmZlclVudGlsRmlyc3RGcmFtZV0pO1xufTtcblxuLy8gc3JjL3VzZS1tZWRpYS1idWZmZXJpbmcudHNcbmltcG9ydCB7IHVzZUVmZmVjdCBhcyB1c2VFZmZlY3QxMCwgdXNlU3RhdGUgYXMgdXNlU3RhdGUxMSB9IGZyb20gXCJyZWFjdFwiO1xudmFyIHVzZU1lZGlhQnVmZmVyaW5nID0gKHtcbiAgZWxlbWVudCxcbiAgc2hvdWxkQnVmZmVyLFxuICBpc1ByZW1vdW50aW5nXG59KSA9PiB7XG4gIGNvbnN0IGJ1ZmZlciA9IHVzZUJ1ZmZlclN0YXRlKCk7XG4gIGNvbnN0IFtpc0J1ZmZlcmluZywgc2V0SXNCdWZmZXJpbmddID0gdXNlU3RhdGUxMShmYWxzZSk7XG4gIHVzZUVmZmVjdDEwKCgpID0+IHtcbiAgICBsZXQgY2xlYW51cEZucyA9IFtdO1xuICAgIGNvbnN0IHsgY3VycmVudCB9ID0gZWxlbWVudDtcbiAgICBpZiAoIWN1cnJlbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCFzaG91bGRCdWZmZXIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGlzUHJlbW91bnRpbmcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgY2xlYW51cCA9ICgpID0+IHtcbiAgICAgIGNsZWFudXBGbnMuZm9yRWFjaCgoZm4pID0+IGZuKCkpO1xuICAgICAgY2xlYW51cEZucyA9IFtdO1xuICAgICAgc2V0SXNCdWZmZXJpbmcoZmFsc2UpO1xuICAgIH07XG4gICAgY29uc3Qgb25XYWl0aW5nID0gKCkgPT4ge1xuICAgICAgc2V0SXNCdWZmZXJpbmcodHJ1ZSk7XG4gICAgICBjb25zdCB7IHVuYmxvY2sgfSA9IGJ1ZmZlci5kZWxheVBsYXliYWNrKCk7XG4gICAgICBjb25zdCBvbkNhblBsYXkgPSAoKSA9PiB7XG4gICAgICAgIGNsZWFudXAoKTtcbiAgICAgICAgaW5pdCgpO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IG9uRXJyb3IgPSAoKSA9PiB7XG4gICAgICAgIGNsZWFudXAoKTtcbiAgICAgICAgaW5pdCgpO1xuICAgICAgfTtcbiAgICAgIGN1cnJlbnQuYWRkRXZlbnRMaXN0ZW5lcihcImNhbnBsYXlcIiwgb25DYW5QbGF5LCB7XG4gICAgICAgIG9uY2U6IHRydWVcbiAgICAgIH0pO1xuICAgICAgY2xlYW51cEZucy5wdXNoKCgpID0+IHtcbiAgICAgICAgY3VycmVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwiY2FucGxheVwiLCBvbkNhblBsYXkpO1xuICAgICAgfSk7XG4gICAgICBjdXJyZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJlcnJvclwiLCBvbkVycm9yLCB7XG4gICAgICAgIG9uY2U6IHRydWVcbiAgICAgIH0pO1xuICAgICAgY2xlYW51cEZucy5wdXNoKCgpID0+IHtcbiAgICAgICAgY3VycmVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwiZXJyb3JcIiwgb25FcnJvcik7XG4gICAgICB9KTtcbiAgICAgIGNsZWFudXBGbnMucHVzaCgoKSA9PiB7XG4gICAgICAgIHVuYmxvY2soKTtcbiAgICAgIH0pO1xuICAgIH07XG4gICAgY29uc3QgaW5pdCA9ICgpID0+IHtcbiAgICAgIGlmIChjdXJyZW50LnJlYWR5U3RhdGUgPCBjdXJyZW50LkhBVkVfRlVUVVJFX0RBVEEpIHtcbiAgICAgICAgb25XYWl0aW5nKCk7XG4gICAgICAgIGlmICghbmF2aWdhdG9yLnVzZXJBZ2VudC5pbmNsdWRlcyhcIkZpcmVmb3gvXCIpKSB7XG4gICAgICAgICAgY3VycmVudC5sb2FkKCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGN1cnJlbnQuYWRkRXZlbnRMaXN0ZW5lcihcIndhaXRpbmdcIiwgb25XYWl0aW5nKTtcbiAgICAgICAgY2xlYW51cEZucy5wdXNoKCgpID0+IHtcbiAgICAgICAgICBjdXJyZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ3YWl0aW5nXCIsIG9uV2FpdGluZyk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH07XG4gICAgaW5pdCgpO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBjbGVhbnVwKCk7XG4gICAgfTtcbiAgfSwgW2J1ZmZlciwgZWxlbWVudCwgaXNQcmVtb3VudGluZywgc2hvdWxkQnVmZmVyXSk7XG4gIHJldHVybiBpc0J1ZmZlcmluZztcbn07XG5cbi8vIHNyYy91c2UtcmVxdWVzdC12aWRlby1jYWxsYmFjay10aW1lLnRzXG5pbXBvcnQgeyB1c2VFZmZlY3QgYXMgdXNlRWZmZWN0MTEsIHVzZVJlZiBhcyB1c2VSZWY0IH0gZnJvbSBcInJlYWN0XCI7XG52YXIgdXNlUmVxdWVzdFZpZGVvQ2FsbGJhY2tUaW1lID0gKHtcbiAgbWVkaWFSZWYsXG4gIG1lZGlhVHlwZSxcbiAgbGFzdFNlZWssXG4gIG9uVmFyaWFibGVGcHNWaWRlb0RldGVjdGVkXG59KSA9PiB7XG4gIGNvbnN0IGN1cnJlbnRUaW1lID0gdXNlUmVmNChudWxsKTtcbiAgdXNlRWZmZWN0MTEoKCkgPT4ge1xuICAgIGNvbnN0IHsgY3VycmVudCB9ID0gbWVkaWFSZWY7XG4gICAgaWYgKGN1cnJlbnQpIHtcbiAgICAgIGN1cnJlbnRUaW1lLmN1cnJlbnQgPSBjdXJyZW50LmN1cnJlbnRUaW1lO1xuICAgIH0gZWxzZSB7XG4gICAgICBjdXJyZW50VGltZS5jdXJyZW50ID0gbnVsbDtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKG1lZGlhVHlwZSAhPT0gXCJ2aWRlb1wiKSB7XG4gICAgICBjdXJyZW50VGltZS5jdXJyZW50ID0gbnVsbDtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgdmlkZW9UYWcgPSBjdXJyZW50O1xuICAgIGlmICghdmlkZW9UYWcucmVxdWVzdFZpZGVvRnJhbWVDYWxsYmFjaykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsZXQgY2FuY2VsID0gKCkgPT4ge1xuICAgICAgcmV0dXJuO1xuICAgIH07XG4gICAgY29uc3QgcmVxdWVzdCA9ICgpID0+IHtcbiAgICAgIGlmICghdmlkZW9UYWcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgY2IgPSB2aWRlb1RhZy5yZXF1ZXN0VmlkZW9GcmFtZUNhbGxiYWNrKChfLCBpbmZvKSA9PiB7XG4gICAgICAgIGlmIChjdXJyZW50VGltZS5jdXJyZW50ICE9PSBudWxsKSB7XG4gICAgICAgICAgY29uc3QgZGlmZmVyZW5jZSA9IE1hdGguYWJzKGN1cnJlbnRUaW1lLmN1cnJlbnQgLSBpbmZvLm1lZGlhVGltZSk7XG4gICAgICAgICAgY29uc3QgZGlmZmVyZW5jZVRvTGFzdFNlZWsgPSBNYXRoLmFicyhsYXN0U2Vlay5jdXJyZW50ID09PSBudWxsID8gSW5maW5pdHkgOiBpbmZvLm1lZGlhVGltZSAtIGxhc3RTZWVrLmN1cnJlbnQpO1xuICAgICAgICAgIGlmIChkaWZmZXJlbmNlID4gMC41ICYmIGRpZmZlcmVuY2VUb0xhc3RTZWVrID4gMC41ICYmIGluZm8ubWVkaWFUaW1lID4gY3VycmVudFRpbWUuY3VycmVudCkge1xuICAgICAgICAgICAgb25WYXJpYWJsZUZwc1ZpZGVvRGV0ZWN0ZWQoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY3VycmVudFRpbWUuY3VycmVudCA9IGluZm8ubWVkaWFUaW1lO1xuICAgICAgICByZXF1ZXN0KCk7XG4gICAgICB9KTtcbiAgICAgIGNhbmNlbCA9ICgpID0+IHtcbiAgICAgICAgdmlkZW9UYWcuY2FuY2VsVmlkZW9GcmFtZUNhbGxiYWNrKGNiKTtcbiAgICAgICAgY2FuY2VsID0gKCkgPT4ge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfTtcbiAgICAgIH07XG4gICAgfTtcbiAgICByZXF1ZXN0KCk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGNhbmNlbCgpO1xuICAgIH07XG4gIH0sIFtsYXN0U2VlaywgbWVkaWFSZWYsIG1lZGlhVHlwZSwgb25WYXJpYWJsZUZwc1ZpZGVvRGV0ZWN0ZWRdKTtcbiAgcmV0dXJuIGN1cnJlbnRUaW1lO1xufTtcblxuLy8gc3JjL2ludGVycG9sYXRlLnRzXG5mdW5jdGlvbiBpbnRlcnBvbGF0ZUZ1bmN0aW9uKGlucHV0LCBpbnB1dFJhbmdlLCBvdXRwdXRSYW5nZSwgb3B0aW9ucykge1xuICBjb25zdCB7IGV4dHJhcG9sYXRlTGVmdCwgZXh0cmFwb2xhdGVSaWdodCwgZWFzaW5nIH0gPSBvcHRpb25zO1xuICBsZXQgcmVzdWx0ID0gaW5wdXQ7XG4gIGNvbnN0IFtpbnB1dE1pbiwgaW5wdXRNYXhdID0gaW5wdXRSYW5nZTtcbiAgY29uc3QgW291dHB1dE1pbiwgb3V0cHV0TWF4XSA9IG91dHB1dFJhbmdlO1xuICBpZiAocmVzdWx0IDwgaW5wdXRNaW4pIHtcbiAgICBpZiAoZXh0cmFwb2xhdGVMZWZ0ID09PSBcImlkZW50aXR5XCIpIHtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGlmIChleHRyYXBvbGF0ZUxlZnQgPT09IFwiY2xhbXBcIikge1xuICAgICAgcmVzdWx0ID0gaW5wdXRNaW47XG4gICAgfSBlbHNlIGlmIChleHRyYXBvbGF0ZUxlZnQgPT09IFwid3JhcFwiKSB7XG4gICAgICBjb25zdCByYW5nZSA9IGlucHV0TWF4IC0gaW5wdXRNaW47XG4gICAgICByZXN1bHQgPSAoKHJlc3VsdCAtIGlucHV0TWluKSAlIHJhbmdlICsgcmFuZ2UpICUgcmFuZ2UgKyBpbnB1dE1pbjtcbiAgICB9IGVsc2UgaWYgKGV4dHJhcG9sYXRlTGVmdCA9PT0gXCJleHRlbmRcIikge1xuICAgIH1cbiAgfVxuICBpZiAocmVzdWx0ID4gaW5wdXRNYXgpIHtcbiAgICBpZiAoZXh0cmFwb2xhdGVSaWdodCA9PT0gXCJpZGVudGl0eVwiKSB7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBpZiAoZXh0cmFwb2xhdGVSaWdodCA9PT0gXCJjbGFtcFwiKSB7XG4gICAgICByZXN1bHQgPSBpbnB1dE1heDtcbiAgICB9IGVsc2UgaWYgKGV4dHJhcG9sYXRlUmlnaHQgPT09IFwid3JhcFwiKSB7XG4gICAgICBjb25zdCByYW5nZSA9IGlucHV0TWF4IC0gaW5wdXRNaW47XG4gICAgICByZXN1bHQgPSAoKHJlc3VsdCAtIGlucHV0TWluKSAlIHJhbmdlICsgcmFuZ2UpICUgcmFuZ2UgKyBpbnB1dE1pbjtcbiAgICB9IGVsc2UgaWYgKGV4dHJhcG9sYXRlUmlnaHQgPT09IFwiZXh0ZW5kXCIpIHtcbiAgICB9XG4gIH1cbiAgaWYgKG91dHB1dE1pbiA9PT0gb3V0cHV0TWF4KSB7XG4gICAgcmV0dXJuIG91dHB1dE1pbjtcbiAgfVxuICByZXN1bHQgPSAocmVzdWx0IC0gaW5wdXRNaW4pIC8gKGlucHV0TWF4IC0gaW5wdXRNaW4pO1xuICByZXN1bHQgPSBlYXNpbmcocmVzdWx0KTtcbiAgcmVzdWx0ID0gcmVzdWx0ICogKG91dHB1dE1heCAtIG91dHB1dE1pbikgKyBvdXRwdXRNaW47XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBmaW5kUmFuZ2UoaW5wdXQsIGlucHV0UmFuZ2UpIHtcbiAgbGV0IGk7XG4gIGZvciAoaSA9IDE7aSA8IGlucHV0UmFuZ2UubGVuZ3RoIC0gMTsgKytpKSB7XG4gICAgaWYgKGlucHV0UmFuZ2VbaV0gPj0gaW5wdXQpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gaSAtIDE7XG59XG5mdW5jdGlvbiBjaGVja1ZhbGlkSW5wdXRSYW5nZShhcnIpIHtcbiAgZm9yIChsZXQgaSA9IDE7aSA8IGFyci5sZW5ndGg7ICsraSkge1xuICAgIGlmICghKGFycltpXSA+IGFycltpIC0gMV0pKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYGlucHV0UmFuZ2UgbXVzdCBiZSBzdHJpY3RseSBtb25vdG9uaWNhbGx5IGluY3JlYXNpbmcgYnV0IGdvdCBbJHthcnIuam9pbihcIixcIil9XWApO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gY2hlY2tJbmZpbml0ZVJhbmdlKG5hbWUsIGFycikge1xuICBpZiAoYXJyLmxlbmd0aCA8IDIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IobmFtZSArIFwiIG11c3QgaGF2ZSBhdCBsZWFzdCAyIGVsZW1lbnRzXCIpO1xuICB9XG4gIGZvciAoY29uc3QgZWxlbWVudCBvZiBhcnIpIHtcbiAgICBpZiAodHlwZW9mIGVsZW1lbnQgIT09IFwibnVtYmVyXCIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgJHtuYW1lfSBtdXN0IGNvbnRhaW4gb25seSBudW1iZXJzYCk7XG4gICAgfVxuICAgIGlmICghTnVtYmVyLmlzRmluaXRlKGVsZW1lbnQpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7bmFtZX0gbXVzdCBjb250YWluIG9ubHkgZmluaXRlIG51bWJlcnMsIGJ1dCBnb3QgWyR7YXJyLmpvaW4oXCIsXCIpfV1gKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGludGVycG9sYXRlKGlucHV0LCBpbnB1dFJhbmdlLCBvdXRwdXRSYW5nZSwgb3B0aW9ucykge1xuICBpZiAodHlwZW9mIGlucHV0ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiaW5wdXQgY2FuIG5vdCBiZSB1bmRlZmluZWRcIik7XG4gIH1cbiAgaWYgKHR5cGVvZiBpbnB1dFJhbmdlID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiaW5wdXRSYW5nZSBjYW4gbm90IGJlIHVuZGVmaW5lZFwiKTtcbiAgfVxuICBpZiAodHlwZW9mIG91dHB1dFJhbmdlID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwib3V0cHV0UmFuZ2UgY2FuIG5vdCBiZSB1bmRlZmluZWRcIik7XG4gIH1cbiAgaWYgKGlucHV0UmFuZ2UubGVuZ3RoICE9PSBvdXRwdXRSYW5nZS5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnB1dFJhbmdlIChcIiArIGlucHV0UmFuZ2UubGVuZ3RoICsgXCIpIGFuZCBvdXRwdXRSYW5nZSAoXCIgKyBvdXRwdXRSYW5nZS5sZW5ndGggKyBcIikgbXVzdCBoYXZlIHRoZSBzYW1lIGxlbmd0aFwiKTtcbiAgfVxuICBjaGVja0luZmluaXRlUmFuZ2UoXCJpbnB1dFJhbmdlXCIsIGlucHV0UmFuZ2UpO1xuICBjaGVja0luZmluaXRlUmFuZ2UoXCJvdXRwdXRSYW5nZVwiLCBvdXRwdXRSYW5nZSk7XG4gIGNoZWNrVmFsaWRJbnB1dFJhbmdlKGlucHV0UmFuZ2UpO1xuICBjb25zdCBlYXNpbmcgPSBvcHRpb25zPy5lYXNpbmcgPz8gKChudW0pID0+IG51bSk7XG4gIGxldCBleHRyYXBvbGF0ZUxlZnQgPSBcImV4dGVuZFwiO1xuICBpZiAob3B0aW9ucz8uZXh0cmFwb2xhdGVMZWZ0ICE9PSB1bmRlZmluZWQpIHtcbiAgICBleHRyYXBvbGF0ZUxlZnQgPSBvcHRpb25zLmV4dHJhcG9sYXRlTGVmdDtcbiAgfVxuICBsZXQgZXh0cmFwb2xhdGVSaWdodCA9IFwiZXh0ZW5kXCI7XG4gIGlmIChvcHRpb25zPy5leHRyYXBvbGF0ZVJpZ2h0ICE9PSB1bmRlZmluZWQpIHtcbiAgICBleHRyYXBvbGF0ZVJpZ2h0ID0gb3B0aW9ucy5leHRyYXBvbGF0ZVJpZ2h0O1xuICB9XG4gIGlmICh0eXBlb2YgaW5wdXQgIT09IFwibnVtYmVyXCIpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGludGVycG9sYXRlIGFuIGlucHV0IHdoaWNoIGlzIG5vdCBhIG51bWJlclwiKTtcbiAgfVxuICBjb25zdCByYW5nZSA9IGZpbmRSYW5nZShpbnB1dCwgaW5wdXRSYW5nZSk7XG4gIHJldHVybiBpbnRlcnBvbGF0ZUZ1bmN0aW9uKGlucHV0LCBbaW5wdXRSYW5nZVtyYW5nZV0sIGlucHV0UmFuZ2VbcmFuZ2UgKyAxXV0sIFtvdXRwdXRSYW5nZVtyYW5nZV0sIG91dHB1dFJhbmdlW3JhbmdlICsgMV1dLCB7XG4gICAgZWFzaW5nLFxuICAgIGV4dHJhcG9sYXRlTGVmdCxcbiAgICBleHRyYXBvbGF0ZVJpZ2h0XG4gIH0pO1xufVxuXG4vLyBzcmMvdmlkZW8vZ2V0LWN1cnJlbnQtdGltZS50c1xudmFyIGdldEV4cGVjdGVkTWVkaWFGcmFtZVVuY29ycmVjdGVkID0gKHtcbiAgZnJhbWUsXG4gIHBsYXliYWNrUmF0ZSxcbiAgc3RhcnRGcm9tXG59KSA9PiB7XG4gIHJldHVybiBpbnRlcnBvbGF0ZShmcmFtZSwgWy0xLCBzdGFydEZyb20sIHN0YXJ0RnJvbSArIDFdLCBbLTEsIHN0YXJ0RnJvbSwgc3RhcnRGcm9tICsgcGxheWJhY2tSYXRlXSk7XG59O1xudmFyIGdldE1lZGlhVGltZSA9ICh7XG4gIGZwcyxcbiAgZnJhbWUsXG4gIHBsYXliYWNrUmF0ZSxcbiAgc3RhcnRGcm9tXG59KSA9PiB7XG4gIGNvbnN0IGV4cGVjdGVkRnJhbWUgPSBnZXRFeHBlY3RlZE1lZGlhRnJhbWVVbmNvcnJlY3RlZCh7XG4gICAgZnJhbWUsXG4gICAgcGxheWJhY2tSYXRlLFxuICAgIHN0YXJ0RnJvbVxuICB9KTtcbiAgY29uc3QgbXNQZXJGcmFtZSA9IDEwMDAgLyBmcHM7XG4gIHJldHVybiBleHBlY3RlZEZyYW1lICogbXNQZXJGcmFtZSAvIDEwMDA7XG59O1xuXG4vLyBzcmMvdmlkZW8vdmlkZW8tZnJhZ21lbnQudHNcbmltcG9ydCB7IHVzZVJlZiBhcyB1c2VSZWY1IH0gZnJvbSBcInJlYWN0XCI7XG52YXIgdG9TZWNvbmRzID0gKHRpbWUsIGZwcykgPT4ge1xuICByZXR1cm4gTWF0aC5yb3VuZCh0aW1lIC8gZnBzICogMTAwKSAvIDEwMDtcbn07XG52YXIgaXNJb3NTYWZhcmkgPSAoKSA9PiB7XG4gIGlmICh0eXBlb2Ygd2luZG93ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IGlzSXBhZElQb2RJUGhvbmUgPSAvaVAoYWR8b2R8aG9uZSkvaS50ZXN0KHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50KTtcbiAgY29uc3QgaXNBcHBsZVdlYktpdCA9IC9BcHBsZVdlYktpdC8udGVzdCh3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudCk7XG4gIHJldHVybiBpc0lwYWRJUG9kSVBob25lICYmIGlzQXBwbGVXZWJLaXQ7XG59O1xudmFyIGlzSU9TU2FmYXJpQW5kQmxvYiA9IChhY3R1YWxTcmMpID0+IHtcbiAgcmV0dXJuIGlzSW9zU2FmYXJpKCkgJiYgYWN0dWFsU3JjLnN0YXJ0c1dpdGgoXCJibG9iOlwiKTtcbn07XG52YXIgZ2V0VmlkZW9GcmFnbWVudFN0YXJ0ID0gKHtcbiAgYWN0dWFsRnJvbSxcbiAgZnBzXG59KSA9PiB7XG4gIHJldHVybiB0b1NlY29uZHMoTWF0aC5tYXgoMCwgLWFjdHVhbEZyb20pLCBmcHMpO1xufTtcbnZhciBnZXRWaWRlb0ZyYWdtZW50RW5kID0gKHtcbiAgZHVyYXRpb24sXG4gIGZwc1xufSkgPT4ge1xuICByZXR1cm4gdG9TZWNvbmRzKGR1cmF0aW9uLCBmcHMpO1xufTtcbnZhciBhcHBlbmRWaWRlb0ZyYWdtZW50ID0gKHtcbiAgYWN0dWFsU3JjLFxuICBhY3R1YWxGcm9tLFxuICBkdXJhdGlvbixcbiAgZnBzXG59KSA9PiB7XG4gIGlmIChpc0lPU1NhZmFyaUFuZEJsb2IoYWN0dWFsU3JjKSkge1xuICAgIHJldHVybiBhY3R1YWxTcmM7XG4gIH1cbiAgaWYgKGFjdHVhbFNyYy5zdGFydHNXaXRoKFwiZGF0YTpcIikpIHtcbiAgICByZXR1cm4gYWN0dWFsU3JjO1xuICB9XG4gIGNvbnN0IGV4aXN0aW5nSGFzaCA9IEJvb2xlYW4obmV3IFVSTChhY3R1YWxTcmMsICh0eXBlb2Ygd2luZG93ID09PSBcInVuZGVmaW5lZFwiID8gbnVsbCA6IHdpbmRvdy5sb2NhdGlvbi5ocmVmKSA/PyBcImh0dHA6Ly9sb2NhbGhvc3Q6MzAwMFwiKS5oYXNoKTtcbiAgaWYgKGV4aXN0aW5nSGFzaCkge1xuICAgIHJldHVybiBhY3R1YWxTcmM7XG4gIH1cbiAgaWYgKCFOdW1iZXIuaXNGaW5pdGUoYWN0dWFsRnJvbSkpIHtcbiAgICByZXR1cm4gYWN0dWFsU3JjO1xuICB9XG4gIGNvbnN0IHdpdGhTdGFydEhhc2ggPSBgJHthY3R1YWxTcmN9I3Q9JHtnZXRWaWRlb0ZyYWdtZW50U3RhcnQoeyBhY3R1YWxGcm9tLCBmcHMgfSl9YDtcbiAgaWYgKCFOdW1iZXIuaXNGaW5pdGUoZHVyYXRpb24pKSB7XG4gICAgcmV0dXJuIHdpdGhTdGFydEhhc2g7XG4gIH1cbiAgcmV0dXJuIGAke3dpdGhTdGFydEhhc2h9LCR7Z2V0VmlkZW9GcmFnbWVudEVuZCh7IGR1cmF0aW9uLCBmcHMgfSl9YDtcbn07XG52YXIgaXNTdWJzZXRPZkR1cmF0aW9uID0gKHtcbiAgcHJldlN0YXJ0RnJvbSxcbiAgbmV3U3RhcnRGcm9tLFxuICBwcmV2RHVyYXRpb24sXG4gIG5ld0R1cmF0aW9uLFxuICBmcHNcbn0pID0+IHtcbiAgY29uc3QgcHJldmlvdXNGcm9tID0gZ2V0VmlkZW9GcmFnbWVudFN0YXJ0KHsgYWN0dWFsRnJvbTogcHJldlN0YXJ0RnJvbSwgZnBzIH0pO1xuICBjb25zdCBuZXdGcm9tID0gZ2V0VmlkZW9GcmFnbWVudFN0YXJ0KHsgYWN0dWFsRnJvbTogbmV3U3RhcnRGcm9tLCBmcHMgfSk7XG4gIGNvbnN0IHByZXZpb3VzRW5kID0gZ2V0VmlkZW9GcmFnbWVudEVuZCh7IGR1cmF0aW9uOiBwcmV2RHVyYXRpb24sIGZwcyB9KTtcbiAgY29uc3QgbmV3RW5kID0gZ2V0VmlkZW9GcmFnbWVudEVuZCh7IGR1cmF0aW9uOiBuZXdEdXJhdGlvbiwgZnBzIH0pO1xuICBpZiAobmV3RnJvbSA8IHByZXZpb3VzRnJvbSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAobmV3RW5kID4gcHJldmlvdXNFbmQpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59O1xudmFyIHVzZUFwcGVuZFZpZGVvRnJhZ21lbnQgPSAoe1xuICBhY3R1YWxTcmM6IGluaXRpYWxBY3R1YWxTcmMsXG4gIGFjdHVhbEZyb206IGluaXRpYWxBY3R1YWxGcm9tLFxuICBkdXJhdGlvbjogaW5pdGlhbER1cmF0aW9uLFxuICBmcHNcbn0pID0+IHtcbiAgY29uc3QgYWN0dWFsRnJvbVJlZiA9IHVzZVJlZjUoaW5pdGlhbEFjdHVhbEZyb20pO1xuICBjb25zdCBhY3R1YWxEdXJhdGlvbiA9IHVzZVJlZjUoaW5pdGlhbER1cmF0aW9uKTtcbiAgY29uc3QgYWN0dWFsU3JjID0gdXNlUmVmNShpbml0aWFsQWN0dWFsU3JjKTtcbiAgaWYgKCFpc1N1YnNldE9mRHVyYXRpb24oe1xuICAgIHByZXZTdGFydEZyb206IGFjdHVhbEZyb21SZWYuY3VycmVudCxcbiAgICBuZXdTdGFydEZyb206IGluaXRpYWxBY3R1YWxGcm9tLFxuICAgIHByZXZEdXJhdGlvbjogYWN0dWFsRHVyYXRpb24uY3VycmVudCxcbiAgICBuZXdEdXJhdGlvbjogaW5pdGlhbER1cmF0aW9uLFxuICAgIGZwc1xuICB9KSB8fCBpbml0aWFsQWN0dWFsU3JjICE9PSBhY3R1YWxTcmMuY3VycmVudCkge1xuICAgIGFjdHVhbEZyb21SZWYuY3VycmVudCA9IGluaXRpYWxBY3R1YWxGcm9tO1xuICAgIGFjdHVhbER1cmF0aW9uLmN1cnJlbnQgPSBpbml0aWFsRHVyYXRpb247XG4gICAgYWN0dWFsU3JjLmN1cnJlbnQgPSBpbml0aWFsQWN0dWFsU3JjO1xuICB9XG4gIGNvbnN0IGFwcGVuZGVkID0gYXBwZW5kVmlkZW9GcmFnbWVudCh7XG4gICAgYWN0dWFsU3JjOiBhY3R1YWxTcmMuY3VycmVudCxcbiAgICBhY3R1YWxGcm9tOiBhY3R1YWxGcm9tUmVmLmN1cnJlbnQsXG4gICAgZHVyYXRpb246IGFjdHVhbER1cmF0aW9uLmN1cnJlbnQsXG4gICAgZnBzXG4gIH0pO1xuICByZXR1cm4gYXBwZW5kZWQ7XG59O1xuXG4vLyBzcmMvd2Fybi1hYm91dC1ub24tc2Vla2FibGUtbWVkaWEudHNcbnZhciBhbHJlYWR5V2FybmVkID0ge307XG52YXIgd2FybkFib3V0Tm9uU2Vla2FibGVNZWRpYSA9IChyZWYsIHR5cGUpID0+IHtcbiAgaWYgKHJlZiA9PT0gbnVsbCkge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAocmVmLnNlZWthYmxlLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAocmVmLnNlZWthYmxlLmxlbmd0aCA+IDEpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKGFscmVhZHlXYXJuZWRbcmVmLnNyY10pIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgcmFuZ2UgPSB7IHN0YXJ0OiByZWYuc2Vla2FibGUuc3RhcnQoMCksIGVuZDogcmVmLnNlZWthYmxlLmVuZCgwKSB9O1xuICBpZiAocmFuZ2Uuc3RhcnQgPT09IDAgJiYgcmFuZ2UuZW5kID09PSAwKSB7XG4gICAgY29uc3QgbXNnID0gW1xuICAgICAgYFRoZSBtZWRpYSAke3JlZi5zcmN9IGNhbm5vdCBiZSBzZWVrZWQuIFRoaXMgY291bGQgYmUgb25lIG9mIGZldyByZWFzb25zOmAsXG4gICAgICBcIjEpIFRoZSBtZWRpYSByZXNvdXJjZSB3YXMgcmVwbGFjZWQgd2hpbGUgdGhlIHZpZGVvIGlzIHBsYXlpbmcgYnV0IGl0IHdhcyBub3QgbG9hZGVkIHlldC5cIixcbiAgICAgIFwiMikgVGhlIG1lZGlhIGRvZXMgbm90IHN1cHBvcnQgc2Vla2luZy5cIixcbiAgICAgIFwiMykgVGhlIG1lZGlhIHdhcyBsb2FkZWQgd2l0aCBzZWN1cml0eSBoZWFkZXJzIHBydmVudGluZyBpdCBmcm9tIGJlaW5nIGluY2x1ZGVkLlwiLFxuICAgICAgXCJQbGVhc2Ugc2VlIGh0dHBzOi8vcmVtb3Rpb24uZGV2L2RvY3Mvbm9uLXNlZWthYmxlLW1lZGlhIGZvciBhc3Npc3RhbmNlLlwiXG4gICAgXS5qb2luKFwiXFxuXCIpO1xuICAgIGlmICh0eXBlID09PSBcImNvbnNvbGUtZXJyb3JcIikge1xuICAgICAgY29uc29sZS5lcnJvcihtc2cpO1xuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gXCJjb25zb2xlLXdhcm5pbmdcIikge1xuICAgICAgY29uc29sZS53YXJuKGBUaGUgbWVkaWEgJHtyZWYuc3JjfSBkb2VzIG5vdCBzdXBwb3J0IHNlZWtpbmcuIFRoZSB2aWRlbyB3aWxsIHJlbmRlciBmaW5lLCBidXQgbWF5IG5vdCBwbGF5IGNvcnJlY3RseSBpbiB0aGUgUmVtb3Rpb24gU3R1ZGlvIGFuZCBpbiB0aGUgPFBsYXllcj4uIFNlZSBodHRwczovL3JlbW90aW9uLmRldi9kb2NzL25vbi1zZWVrYWJsZS1tZWRpYSBmb3IgYW4gZXhwbGFuYXRpb24uYCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihtc2cpO1xuICAgIH1cbiAgICBhbHJlYWR5V2FybmVkW3JlZi5zcmNdID0gdHJ1ZTtcbiAgfVxufTtcblxuLy8gc3JjL3VzZS1tZWRpYS1wbGF5YmFjay50c1xudmFyIERFRkFVTFRfQUNDRVBUQUJMRV9USU1FU0hJRlQgPSAwLjQ1O1xudmFyIHNlZWsgPSAobWVkaWFSZWYsIHRpbWUpID0+IHtcbiAgaWYgKCFtZWRpYVJlZi5jdXJyZW50KSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IHRpbWVUb1NldCA9IGlzSW9zU2FmYXJpKCkgPyBOdW1iZXIodGltZS50b0ZpeGVkKDEpKSA6IHRpbWU7XG4gIG1lZGlhUmVmLmN1cnJlbnQuY3VycmVudFRpbWUgPSB0aW1lVG9TZXQ7XG59O1xudmFyIHVzZU1lZGlhUGxheWJhY2sgPSAoe1xuICBtZWRpYVJlZixcbiAgc3JjLFxuICBtZWRpYVR5cGUsXG4gIHBsYXliYWNrUmF0ZTogbG9jYWxQbGF5YmFja1JhdGUsXG4gIG9ubHlXYXJuRm9yTWVkaWFTZWVraW5nRXJyb3IsXG4gIGFjY2VwdGFibGVUaW1lc2hpZnQsXG4gIHBhdXNlV2hlbkJ1ZmZlcmluZyxcbiAgaXNQcmVtb3VudGluZyxcbiAgZGVidWdTZWVraW5nLFxuICBvbkF1dG9QbGF5RXJyb3Jcbn0pID0+IHtcbiAgY29uc3QgeyBwbGF5YmFja1JhdGU6IGdsb2JhbFBsYXliYWNrUmF0ZSB9ID0gdXNlQ29udGV4dDE4KFRpbWVsaW5lQ29udGV4dCk7XG4gIGNvbnN0IGZyYW1lID0gdXNlQ3VycmVudEZyYW1lKCk7XG4gIGNvbnN0IGFic29sdXRlRnJhbWUgPSB1c2VUaW1lbGluZVBvc2l0aW9uKCk7XG4gIGNvbnN0IFtwbGF5aW5nXSA9IHVzZVBsYXlpbmdTdGF0ZSgpO1xuICBjb25zdCBidWZmZXJpbmcgPSB1c2VDb250ZXh0MTgoQnVmZmVyaW5nQ29udGV4dFJlYWN0KTtcbiAgY29uc3QgeyBmcHMgfSA9IHVzZVZpZGVvQ29uZmlnKCk7XG4gIGNvbnN0IG1lZGlhU3RhcnRzQXQgPSB1c2VNZWRpYVN0YXJ0c0F0KCk7XG4gIGNvbnN0IGxhc3RTZWVrRHVlVG9TaGlmdCA9IHVzZVJlZjYobnVsbCk7XG4gIGNvbnN0IGxhc3RTZWVrID0gdXNlUmVmNihudWxsKTtcbiAgaWYgKCFidWZmZXJpbmcpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJ1c2VNZWRpYVBsYXliYWNrIG11c3QgYmUgdXNlZCBpbnNpZGUgYSA8QnVmZmVyaW5nQ29udGV4dD5cIik7XG4gIH1cbiAgY29uc3QgaXNWYXJpYWJsZUZwc1ZpZGVvTWFwID0gdXNlUmVmNih7fSk7XG4gIGNvbnN0IG9uVmFyaWFibGVGcHNWaWRlb0RldGVjdGVkID0gdXNlQ2FsbGJhY2s3KCgpID0+IHtcbiAgICBpZiAoIXNyYykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoZGVidWdTZWVraW5nKSB7XG4gICAgICBjb25zb2xlLmxvZyhgRGV0ZWN0ZWQgJHtzcmN9IGFzIGEgdmFyaWFibGUgRlBTIHZpZGVvLiBEaXNhYmxpbmcgYnVmZmVyaW5nIHdoaWxlIHNlZWtpbmcuYCk7XG4gICAgfVxuICAgIGlzVmFyaWFibGVGcHNWaWRlb01hcC5jdXJyZW50W3NyY10gPSB0cnVlO1xuICB9LCBbZGVidWdTZWVraW5nLCBzcmNdKTtcbiAgY29uc3QgY3VycmVudFRpbWUgPSB1c2VSZXF1ZXN0VmlkZW9DYWxsYmFja1RpbWUoe1xuICAgIG1lZGlhUmVmLFxuICAgIG1lZGlhVHlwZSxcbiAgICBsYXN0U2VlayxcbiAgICBvblZhcmlhYmxlRnBzVmlkZW9EZXRlY3RlZFxuICB9KTtcbiAgY29uc3QgZGVzaXJlZFVuY2xhbXBlZFRpbWUgPSBnZXRNZWRpYVRpbWUoe1xuICAgIGZyYW1lLFxuICAgIHBsYXliYWNrUmF0ZTogbG9jYWxQbGF5YmFja1JhdGUsXG4gICAgc3RhcnRGcm9tOiAtbWVkaWFTdGFydHNBdCxcbiAgICBmcHNcbiAgfSk7XG4gIGNvbnN0IGlzTWVkaWFUYWdCdWZmZXJpbmcgPSB1c2VNZWRpYUJ1ZmZlcmluZyh7XG4gICAgZWxlbWVudDogbWVkaWFSZWYsXG4gICAgc2hvdWxkQnVmZmVyOiBwYXVzZVdoZW5CdWZmZXJpbmcsXG4gICAgaXNQcmVtb3VudGluZ1xuICB9KTtcbiAgY29uc3QgeyBidWZmZXJVbnRpbEZpcnN0RnJhbWUsIGlzQnVmZmVyaW5nIH0gPSB1c2VCdWZmZXJVbnRpbEZpcnN0RnJhbWUoe1xuICAgIG1lZGlhUmVmLFxuICAgIG1lZGlhVHlwZSxcbiAgICBvblZhcmlhYmxlRnBzVmlkZW9EZXRlY3RlZCxcbiAgICBwYXVzZVdoZW5CdWZmZXJpbmdcbiAgfSk7XG4gIGNvbnN0IHBsYXliYWNrUmF0ZSA9IGxvY2FsUGxheWJhY2tSYXRlICogZ2xvYmFsUGxheWJhY2tSYXRlO1xuICBjb25zdCBhY2NlcHRhYmxlVGltZVNoaWZ0QnV0TGVzc1RoYW5EdXJhdGlvbiA9ICgoKSA9PiB7XG4gICAgaWYgKG1lZGlhUmVmLmN1cnJlbnQ/LmR1cmF0aW9uKSB7XG4gICAgICByZXR1cm4gTWF0aC5taW4obWVkaWFSZWYuY3VycmVudC5kdXJhdGlvbiwgYWNjZXB0YWJsZVRpbWVzaGlmdCA/PyBERUZBVUxUX0FDQ0VQVEFCTEVfVElNRVNISUZUKTtcbiAgICB9XG4gICAgcmV0dXJuIGFjY2VwdGFibGVUaW1lc2hpZnQ7XG4gIH0pKCk7XG4gIGNvbnN0IGlzUGxheWVyQnVmZmVyaW5nID0gdXNlSXNQbGF5ZXJCdWZmZXJpbmcoYnVmZmVyaW5nKTtcbiAgdXNlRWZmZWN0MTIoKCkgPT4ge1xuICAgIGlmICghcGxheWluZykge1xuICAgICAgbWVkaWFSZWYuY3VycmVudD8ucGF1c2UoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgaXNNZWRpYVRhZ0J1ZmZlcmluZ09yU3RhbGxlZCA9IGlzTWVkaWFUYWdCdWZmZXJpbmcgfHwgaXNCdWZmZXJpbmcoKTtcbiAgICBpZiAoaXNQbGF5ZXJCdWZmZXJpbmcgJiYgIWlzTWVkaWFUYWdCdWZmZXJpbmdPclN0YWxsZWQpIHtcbiAgICAgIG1lZGlhUmVmLmN1cnJlbnQ/LnBhdXNlKCk7XG4gICAgfVxuICB9LCBbaXNCdWZmZXJpbmcsIGlzTWVkaWFUYWdCdWZmZXJpbmcsIGlzUGxheWVyQnVmZmVyaW5nLCBtZWRpYVJlZiwgcGxheWluZ10pO1xuICB1c2VFZmZlY3QxMigoKSA9PiB7XG4gICAgY29uc3QgdGFnTmFtZSA9IG1lZGlhVHlwZSA9PT0gXCJhdWRpb1wiID8gXCI8QXVkaW8+XCIgOiBcIjxWaWRlbz5cIjtcbiAgICBpZiAoIW1lZGlhUmVmLmN1cnJlbnQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgTm8gJHttZWRpYVR5cGV9IHJlZiBmb3VuZGApO1xuICAgIH1cbiAgICBpZiAoIXNyYykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBObyAnc3JjJyBhdHRyaWJ1dGUgd2FzIHBhc3NlZCB0byB0aGUgJHt0YWdOYW1lfSBlbGVtZW50LmApO1xuICAgIH1cbiAgICBjb25zdCBwbGF5YmFja1JhdGVUb1NldCA9IE1hdGgubWF4KDAsIHBsYXliYWNrUmF0ZSk7XG4gICAgaWYgKG1lZGlhUmVmLmN1cnJlbnQucGxheWJhY2tSYXRlICE9PSBwbGF5YmFja1JhdGVUb1NldCkge1xuICAgICAgbWVkaWFSZWYuY3VycmVudC5wbGF5YmFja1JhdGUgPSBwbGF5YmFja1JhdGVUb1NldDtcbiAgICB9XG4gICAgY29uc3QgeyBkdXJhdGlvbiB9ID0gbWVkaWFSZWYuY3VycmVudDtcbiAgICBjb25zdCBzaG91bGRCZVRpbWUgPSAhTnVtYmVyLmlzTmFOKGR1cmF0aW9uKSAmJiBOdW1iZXIuaXNGaW5pdGUoZHVyYXRpb24pID8gTWF0aC5taW4oZHVyYXRpb24sIGRlc2lyZWRVbmNsYW1wZWRUaW1lKSA6IGRlc2lyZWRVbmNsYW1wZWRUaW1lO1xuICAgIGNvbnN0IG1lZGlhVGFnVGltZSA9IG1lZGlhUmVmLmN1cnJlbnQuY3VycmVudFRpbWU7XG4gICAgY29uc3QgcnZjVGltZSA9IGN1cnJlbnRUaW1lLmN1cnJlbnQgPz8gbnVsbDtcbiAgICBjb25zdCBpc1ZhcmlhYmxlRnBzVmlkZW8gPSBpc1ZhcmlhYmxlRnBzVmlkZW9NYXAuY3VycmVudFtzcmNdO1xuICAgIGNvbnN0IHRpbWVTaGlmdE1lZGlhVGFnID0gTWF0aC5hYnMoc2hvdWxkQmVUaW1lIC0gbWVkaWFUYWdUaW1lKTtcbiAgICBjb25zdCB0aW1lU2hpZnRSdmNUYWcgPSBydmNUaW1lID8gTWF0aC5hYnMoc2hvdWxkQmVUaW1lIC0gcnZjVGltZSkgOiBudWxsO1xuICAgIGNvbnN0IHRpbWVTaGlmdCA9IHRpbWVTaGlmdFJ2Y1RhZyAmJiAhaXNWYXJpYWJsZUZwc1ZpZGVvID8gdGltZVNoaWZ0UnZjVGFnIDogdGltZVNoaWZ0TWVkaWFUYWc7XG4gICAgaWYgKGRlYnVnU2Vla2luZykge1xuICAgICAgY29uc29sZS5sb2coe1xuICAgICAgICBtZWRpYVRhZ1RpbWUsXG4gICAgICAgIHJ2Y1RpbWUsXG4gICAgICAgIHNob3VsZEJlVGltZSxcbiAgICAgICAgc3RhdGU6IG1lZGlhUmVmLmN1cnJlbnQucmVhZHlTdGF0ZSxcbiAgICAgICAgcGxheWluZzogIW1lZGlhUmVmLmN1cnJlbnQucGF1c2VkLFxuICAgICAgICBpc1ZhcmlhYmxlRnBzVmlkZW9cbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAodGltZVNoaWZ0ID4gYWNjZXB0YWJsZVRpbWVTaGlmdEJ1dExlc3NUaGFuRHVyYXRpb24gJiYgbGFzdFNlZWtEdWVUb1NoaWZ0LmN1cnJlbnQgIT09IHNob3VsZEJlVGltZSkge1xuICAgICAgaWYgKGRlYnVnU2Vla2luZykge1xuICAgICAgICBjb25zb2xlLmxvZyhcIlNlZWtpbmdcIiwge1xuICAgICAgICAgIHNob3VsZEJlVGltZSxcbiAgICAgICAgICBpc1RpbWU6IG1lZGlhVGFnVGltZSxcbiAgICAgICAgICBydmNUaW1lLFxuICAgICAgICAgIHRpbWVTaGlmdCxcbiAgICAgICAgICBpc1ZhcmlhYmxlRnBzVmlkZW9cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBzZWVrKG1lZGlhUmVmLCBzaG91bGRCZVRpbWUpO1xuICAgICAgbGFzdFNlZWsuY3VycmVudCA9IHNob3VsZEJlVGltZTtcbiAgICAgIGxhc3RTZWVrRHVlVG9TaGlmdC5jdXJyZW50ID0gc2hvdWxkQmVUaW1lO1xuICAgICAgaWYgKHBsYXlpbmcgJiYgIWlzVmFyaWFibGVGcHNWaWRlbykge1xuICAgICAgICBpZiAocGxheWJhY2tSYXRlID4gMCkge1xuICAgICAgICAgIGJ1ZmZlclVudGlsRmlyc3RGcmFtZShzaG91bGRCZVRpbWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZWRpYVJlZi5jdXJyZW50LnBhdXNlZCkge1xuICAgICAgICAgIHBsYXlBbmRIYW5kbGVOb3RBbGxvd2VkRXJyb3IobWVkaWFSZWYsIG1lZGlhVHlwZSwgb25BdXRvUGxheUVycm9yKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKCFvbmx5V2FybkZvck1lZGlhU2Vla2luZ0Vycm9yKSB7XG4gICAgICAgIHdhcm5BYm91dE5vblNlZWthYmxlTWVkaWEobWVkaWFSZWYuY3VycmVudCwgb25seVdhcm5Gb3JNZWRpYVNlZWtpbmdFcnJvciA/IFwiY29uc29sZS13YXJuaW5nXCIgOiBcImNvbnNvbGUtZXJyb3JcIik7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHNlZWtUaHJlc2hvbGQgPSBwbGF5aW5nID8gMC4xNSA6IDAuMDAwMDE7XG4gICAgY29uc3QgbWFrZXNTZW5zZVRvU2VlayA9IE1hdGguYWJzKG1lZGlhUmVmLmN1cnJlbnQuY3VycmVudFRpbWUgLSBzaG91bGRCZVRpbWUpID4gc2Vla1RocmVzaG9sZDtcbiAgICBjb25zdCBpc01lZGlhVGFnQnVmZmVyaW5nT3JTdGFsbGVkID0gaXNNZWRpYVRhZ0J1ZmZlcmluZyB8fCBpc0J1ZmZlcmluZygpO1xuICAgIGNvbnN0IGlzU29tZXRoaW5nRWxzZUJ1ZmZlcmluZyA9IGJ1ZmZlcmluZy5idWZmZXJpbmcuY3VycmVudCAmJiAhaXNNZWRpYVRhZ0J1ZmZlcmluZ09yU3RhbGxlZDtcbiAgICBpZiAoIXBsYXlpbmcgfHwgaXNTb21ldGhpbmdFbHNlQnVmZmVyaW5nKSB7XG4gICAgICBpZiAobWFrZXNTZW5zZVRvU2Vlaykge1xuICAgICAgICBzZWVrKG1lZGlhUmVmLCBzaG91bGRCZVRpbWUpO1xuICAgICAgICBsYXN0U2Vlay5jdXJyZW50ID0gc2hvdWxkQmVUaW1lO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAobWVkaWFSZWYuY3VycmVudC5wYXVzZWQgJiYgIW1lZGlhUmVmLmN1cnJlbnQuZW5kZWQgfHwgYWJzb2x1dGVGcmFtZSA9PT0gMCkge1xuICAgICAgaWYgKG1ha2VzU2Vuc2VUb1NlZWspIHtcbiAgICAgICAgc2VlayhtZWRpYVJlZiwgc2hvdWxkQmVUaW1lKTtcbiAgICAgICAgbGFzdFNlZWsuY3VycmVudCA9IHNob3VsZEJlVGltZTtcbiAgICAgIH1cbiAgICAgIHBsYXlBbmRIYW5kbGVOb3RBbGxvd2VkRXJyb3IobWVkaWFSZWYsIG1lZGlhVHlwZSwgb25BdXRvUGxheUVycm9yKTtcbiAgICAgIGlmICghaXNWYXJpYWJsZUZwc1ZpZGVvKSB7XG4gICAgICAgIGlmIChwbGF5YmFja1JhdGUgPiAwKSB7XG4gICAgICAgICAgYnVmZmVyVW50aWxGaXJzdEZyYW1lKHNob3VsZEJlVGltZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sIFtcbiAgICBhYnNvbHV0ZUZyYW1lLFxuICAgIGFjY2VwdGFibGVUaW1lU2hpZnRCdXRMZXNzVGhhbkR1cmF0aW9uLFxuICAgIGJ1ZmZlclVudGlsRmlyc3RGcmFtZSxcbiAgICBidWZmZXJpbmcuYnVmZmVyaW5nLFxuICAgIGN1cnJlbnRUaW1lLFxuICAgIGRlYnVnU2Vla2luZyxcbiAgICBkZXNpcmVkVW5jbGFtcGVkVGltZSxcbiAgICBpc0J1ZmZlcmluZyxcbiAgICBpc01lZGlhVGFnQnVmZmVyaW5nLFxuICAgIG1lZGlhUmVmLFxuICAgIG1lZGlhVHlwZSxcbiAgICBvbmx5V2FybkZvck1lZGlhU2Vla2luZ0Vycm9yLFxuICAgIHBsYXliYWNrUmF0ZSxcbiAgICBwbGF5aW5nLFxuICAgIHNyYyxcbiAgICBvbkF1dG9QbGF5RXJyb3JcbiAgXSk7XG59O1xuXG4vLyBzcmMvdXNlLW1lZGlhLXRhZy12b2x1bWUudHNcbmltcG9ydCB7IHVzZUVmZmVjdCBhcyB1c2VFZmZlY3QxMywgdXNlU3RhdGUgYXMgdXNlU3RhdGUxMiB9IGZyb20gXCJyZWFjdFwiO1xudmFyIHVzZU1lZGlhVGFnVm9sdW1lID0gKG1lZGlhUmVmKSA9PiB7XG4gIGNvbnN0IFthY3R1YWxWb2x1bWUsIHNldEFjdHVhbFZvbHVtZV0gPSB1c2VTdGF0ZTEyKDEpO1xuICB1c2VFZmZlY3QxMygoKSA9PiB7XG4gICAgY29uc3QgcmVmID0gbWVkaWFSZWYuY3VycmVudDtcbiAgICBpZiAoIXJlZikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBvbkNoYW5nZSA9ICgpID0+IHtcbiAgICAgIHNldEFjdHVhbFZvbHVtZShyZWYudm9sdW1lKTtcbiAgICB9O1xuICAgIHJlZi5hZGRFdmVudExpc3RlbmVyKFwidm9sdW1lY2hhbmdlXCIsIG9uQ2hhbmdlKTtcbiAgICByZXR1cm4gKCkgPT4gcmVmLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ2b2x1bWVjaGFuZ2VcIiwgb25DaGFuZ2UpO1xuICB9LCBbbWVkaWFSZWZdKTtcbiAgdXNlRWZmZWN0MTMoKCkgPT4ge1xuICAgIGNvbnN0IHJlZiA9IG1lZGlhUmVmLmN1cnJlbnQ7XG4gICAgaWYgKCFyZWYpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHJlZi52b2x1bWUgIT09IGFjdHVhbFZvbHVtZSkge1xuICAgICAgc2V0QWN0dWFsVm9sdW1lKHJlZi52b2x1bWUpO1xuICAgIH1cbiAgfSwgW2FjdHVhbFZvbHVtZSwgbWVkaWFSZWZdKTtcbiAgcmV0dXJuIGFjdHVhbFZvbHVtZTtcbn07XG5cbi8vIHNyYy91c2Utc3luYy12b2x1bWUtd2l0aC1tZWRpYS10YWcudHNcbmltcG9ydCB7IHVzZUVmZmVjdCBhcyB1c2VFZmZlY3QxNCB9IGZyb20gXCJyZWFjdFwiO1xuXG4vLyBzcmMvaXMtYXBwcm94aW1hdGVseS10aGUtc2FtZS50c1xudmFyIEZMT0FUSU5HX1BPSU5UX0VSUk9SX1RIUkVTSE9MRCA9IDAuMDAwMDE7XG52YXIgaXNBcHByb3hpbWF0ZWx5VGhlU2FtZSA9IChudW0xLCBudW0yKSA9PiB7XG4gIHJldHVybiBNYXRoLmFicyhudW0xIC0gbnVtMikgPCBGTE9BVElOR19QT0lOVF9FUlJPUl9USFJFU0hPTEQ7XG59O1xuXG4vLyBzcmMvdXNlLXN5bmMtdm9sdW1lLXdpdGgtbWVkaWEtdGFnLnRzXG52YXIgdXNlU3luY1ZvbHVtZVdpdGhNZWRpYVRhZyA9ICh7XG4gIHZvbHVtZVByb3BGcmFtZSxcbiAgYWN0dWFsVm9sdW1lLFxuICB2b2x1bWUsXG4gIG1lZGlhVm9sdW1lLFxuICBtZWRpYVJlZlxufSkgPT4ge1xuICB1c2VFZmZlY3QxNCgoKSA9PiB7XG4gICAgY29uc3QgdXNlclByZWZlcnJlZFZvbHVtZSA9IGV2YWx1YXRlVm9sdW1lKHtcbiAgICAgIGZyYW1lOiB2b2x1bWVQcm9wRnJhbWUsXG4gICAgICB2b2x1bWUsXG4gICAgICBtZWRpYVZvbHVtZSxcbiAgICAgIGFsbG93QW1wbGlmaWNhdGlvbkR1cmluZ1JlbmRlcjogZmFsc2VcbiAgICB9KTtcbiAgICBpZiAoIWlzQXBwcm94aW1hdGVseVRoZVNhbWUodXNlclByZWZlcnJlZFZvbHVtZSwgYWN0dWFsVm9sdW1lKSAmJiBtZWRpYVJlZi5jdXJyZW50KSB7XG4gICAgICBtZWRpYVJlZi5jdXJyZW50LnZvbHVtZSA9IHVzZXJQcmVmZXJyZWRWb2x1bWU7XG4gICAgfVxuICB9LCBbYWN0dWFsVm9sdW1lLCB2b2x1bWVQcm9wRnJhbWUsIG1lZGlhUmVmLCB2b2x1bWUsIG1lZGlhVm9sdW1lXSk7XG59O1xuXG4vLyBzcmMvdm9sdW1lLXBvc2l0aW9uLXN0YXRlLnRzXG5pbXBvcnQgeyBjcmVhdGVDb250ZXh0IGFzIGNyZWF0ZUNvbnRleHQxNSwgdXNlQ29udGV4dCBhcyB1c2VDb250ZXh0MTksIHVzZU1lbW8gYXMgdXNlTWVtbzE4IH0gZnJvbSBcInJlYWN0XCI7XG52YXIgTWVkaWFWb2x1bWVDb250ZXh0ID0gY3JlYXRlQ29udGV4dDE1KHtcbiAgbWVkaWFNdXRlZDogZmFsc2UsXG4gIG1lZGlhVm9sdW1lOiAxXG59KTtcbnZhciBTZXRNZWRpYVZvbHVtZUNvbnRleHQgPSBjcmVhdGVDb250ZXh0MTUoe1xuICBzZXRNZWRpYU11dGVkOiAoKSA9PiB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiZGVmYXVsdFwiKTtcbiAgfSxcbiAgc2V0TWVkaWFWb2x1bWU6ICgpID0+IHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJkZWZhdWx0XCIpO1xuICB9XG59KTtcbnZhciB1c2VNZWRpYVZvbHVtZVN0YXRlID0gKCkgPT4ge1xuICBjb25zdCB7IG1lZGlhVm9sdW1lIH0gPSB1c2VDb250ZXh0MTkoTWVkaWFWb2x1bWVDb250ZXh0KTtcbiAgY29uc3QgeyBzZXRNZWRpYVZvbHVtZSB9ID0gdXNlQ29udGV4dDE5KFNldE1lZGlhVm9sdW1lQ29udGV4dCk7XG4gIHJldHVybiB1c2VNZW1vMTgoKCkgPT4ge1xuICAgIHJldHVybiBbbWVkaWFWb2x1bWUsIHNldE1lZGlhVm9sdW1lXTtcbiAgfSwgW21lZGlhVm9sdW1lLCBzZXRNZWRpYVZvbHVtZV0pO1xufTtcbnZhciB1c2VNZWRpYU11dGVkU3RhdGUgPSAoKSA9PiB7XG4gIGNvbnN0IHsgbWVkaWFNdXRlZCB9ID0gdXNlQ29udGV4dDE5KE1lZGlhVm9sdW1lQ29udGV4dCk7XG4gIGNvbnN0IHsgc2V0TWVkaWFNdXRlZCB9ID0gdXNlQ29udGV4dDE5KFNldE1lZGlhVm9sdW1lQ29udGV4dCk7XG4gIHJldHVybiB1c2VNZW1vMTgoKCkgPT4ge1xuICAgIHJldHVybiBbbWVkaWFNdXRlZCwgc2V0TWVkaWFNdXRlZF07XG4gIH0sIFttZWRpYU11dGVkLCBzZXRNZWRpYU11dGVkXSk7XG59O1xuXG4vLyBzcmMvYXVkaW8vc2hhcmVkLWF1ZGlvLXRhZ3MudHN4XG5pbXBvcnQgUmVhY3QxMiwge1xuICBjcmVhdGVDb250ZXh0IGFzIGNyZWF0ZUNvbnRleHQxNixcbiAgY3JlYXRlUmVmIGFzIGNyZWF0ZVJlZjIsXG4gIHVzZUNhbGxiYWNrIGFzIHVzZUNhbGxiYWNrOCxcbiAgdXNlQ29udGV4dCBhcyB1c2VDb250ZXh0MjAsXG4gIHVzZUVmZmVjdCBhcyB1c2VFZmZlY3QxNSxcbiAgdXNlTWVtbyBhcyB1c2VNZW1vMTksXG4gIHVzZVJlZiBhcyB1c2VSZWY3LFxuICB1c2VTdGF0ZSBhcyB1c2VTdGF0ZTEzXG59IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHsganN4IGFzIGpzeDE1LCBqc3hzIH0gZnJvbSBcInJlYWN0L2pzeC1ydW50aW1lXCI7XG52YXIgRU1QVFlfQVVESU8gPSBcImRhdGE6YXVkaW8vbXAzO2Jhc2U2NCwvK01ZeEFBSmNBVjhBQWdBQUJuLy8vLy8vKy9nUTVCQU1BK0Q0UGcrQkFRQkFFQXdENFBnK0Q0RUJBRUFRREFQZysraFlCSC8vL2hVRlFWQlVGUkVEUU5IbWYvLy8vLy8vK01ZeEJVR2tBR0lNQUFBQVAvMjlYdDZsVXhCVFVVekxqRXdNRlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlYvK01ZeERVQUFBTklBQUFBQUZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZcIjtcbnZhciBjb21wYXJlUHJvcHMgPSAob2JqMSwgb2JqMikgPT4ge1xuICBjb25zdCBrZXlzQSA9IE9iamVjdC5rZXlzKG9iajEpLnNvcnQoKTtcbiAgY29uc3Qga2V5c0IgPSBPYmplY3Qua2V5cyhvYmoyKS5zb3J0KCk7XG4gIGlmIChrZXlzQS5sZW5ndGggIT09IGtleXNCLmxlbmd0aCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBmb3IgKGxldCBpID0gMDtpIDwga2V5c0EubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoa2V5c0FbaV0gIT09IGtleXNCW2ldKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChvYmoxW2tleXNBW2ldXSAhPT0gb2JqMltrZXlzQltpXV0pIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59O1xudmFyIGRpZFByb3BDaGFuZ2UgPSAoa2V5LCBuZXdQcm9wLCBwcmV2UHJvcCkgPT4ge1xuICBpZiAoa2V5ID09PSBcInNyY1wiICYmICFwcmV2UHJvcC5zdGFydHNXaXRoKFwiZGF0YTpcIikgJiYgIW5ld1Byb3Auc3RhcnRzV2l0aChcImRhdGE6XCIpKSB7XG4gICAgcmV0dXJuIG5ldyBVUkwocHJldlByb3AsIHdpbmRvdy5vcmlnaW4pLnRvU3RyaW5nKCkgIT09IG5ldyBVUkwobmV3UHJvcCwgd2luZG93Lm9yaWdpbikudG9TdHJpbmcoKTtcbiAgfVxuICBpZiAocHJldlByb3AgPT09IG5ld1Byb3ApIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59O1xudmFyIFNoYXJlZEF1ZGlvQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQxNihudWxsKTtcbnZhciBTaGFyZWRBdWRpb0NvbnRleHRQcm92aWRlciA9ICh7IGNoaWxkcmVuLCBudW1iZXJPZkF1ZGlvVGFncywgY29tcG9uZW50IH0pID0+IHtcbiAgY29uc3QgYXVkaW9zID0gdXNlUmVmNyhbXSk7XG4gIGNvbnN0IFtpbml0aWFsTnVtYmVyT2ZBdWRpb1RhZ3NdID0gdXNlU3RhdGUxMyhudW1iZXJPZkF1ZGlvVGFncyk7XG4gIGlmIChudW1iZXJPZkF1ZGlvVGFncyAhPT0gaW5pdGlhbE51bWJlck9mQXVkaW9UYWdzKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIG51bWJlciBvZiBzaGFyZWQgYXVkaW8gdGFncyBoYXMgY2hhbmdlZCBkeW5hbWljYWxseS4gT25jZSB5b3UgaGF2ZSBzZXQgdGhpcyBwcm9wZXJ0eSwgeW91IGNhbm5vdCBjaGFuZ2UgaXQgYWZ0ZXJ3YXJkcy5cIik7XG4gIH1cbiAgY29uc3QgcmVmcyA9IHVzZU1lbW8xOSgoKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBBcnJheShudW1iZXJPZkF1ZGlvVGFncykuZmlsbCh0cnVlKS5tYXAoKCkgPT4ge1xuICAgICAgcmV0dXJuIHsgaWQ6IE1hdGgucmFuZG9tKCksIHJlZjogY3JlYXRlUmVmMigpIH07XG4gICAgfSk7XG4gIH0sIFtudW1iZXJPZkF1ZGlvVGFnc10pO1xuICBjb25zdCB0YWtlbkF1ZGlvcyA9IHVzZVJlZjcobmV3IEFycmF5KG51bWJlck9mQXVkaW9UYWdzKS5maWxsKGZhbHNlKSk7XG4gIGNvbnN0IHJlcmVuZGVyQXVkaW9zID0gdXNlQ2FsbGJhY2s4KCgpID0+IHtcbiAgICByZWZzLmZvckVhY2goKHsgcmVmLCBpZCB9KSA9PiB7XG4gICAgICBjb25zdCBkYXRhID0gYXVkaW9zLmN1cnJlbnQ/LmZpbmQoKGEpID0+IGEuaWQgPT09IGlkKTtcbiAgICAgIGNvbnN0IHsgY3VycmVudCB9ID0gcmVmO1xuICAgICAgaWYgKCFjdXJyZW50KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChkYXRhID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY3VycmVudC5zcmMgPSBFTVBUWV9BVURJTztcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKCFkYXRhKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJFeHBlY3RlZCBhdWRpbyBkYXRhIHRvIGJlIHRoZXJlXCIpO1xuICAgICAgfVxuICAgICAgT2JqZWN0LmtleXMoZGF0YS5wcm9wcykuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICAgIGlmIChkaWRQcm9wQ2hhbmdlKGtleSwgZGF0YS5wcm9wc1trZXldLCBjdXJyZW50W2tleV0pKSB7XG4gICAgICAgICAgY3VycmVudFtrZXldID0gZGF0YS5wcm9wc1trZXldO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfSwgW3JlZnNdKTtcbiAgY29uc3QgcmVnaXN0ZXJBdWRpbyA9IHVzZUNhbGxiYWNrOCgoYXVkLCBhdWRpb0lkKSA9PiB7XG4gICAgY29uc3QgZm91bmQgPSBhdWRpb3MuY3VycmVudD8uZmluZCgoYSkgPT4gYS5hdWRpb0lkID09PSBhdWRpb0lkKTtcbiAgICBpZiAoZm91bmQpIHtcbiAgICAgIHJldHVybiBmb3VuZDtcbiAgICB9XG4gICAgY29uc3QgZmlyc3RGcmVlQXVkaW8gPSB0YWtlbkF1ZGlvcy5jdXJyZW50LmZpbmRJbmRleCgoYSkgPT4gYSA9PT0gZmFsc2UpO1xuICAgIGlmIChmaXJzdEZyZWVBdWRpbyA9PT0gLTEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVHJpZWQgdG8gc2ltdWx0YW5lb3VzbHkgbW91bnQgJHtudW1iZXJPZkF1ZGlvVGFncyArIDF9IDxBdWRpbyAvPiB0YWdzIGF0IHRoZSBzYW1lIHRpbWUuIFdpdGggdGhlIGN1cnJlbnQgc2V0dGluZ3MsIHRoZSBtYXhpbXVtIGFtb3VudCBvZiA8QXVkaW8gLz4gdGFncyBpcyBsaW1pdGVkIHRvICR7bnVtYmVyT2ZBdWRpb1RhZ3N9IGF0IHRoZSBzYW1lIHRpbWUuIFJlbW90aW9uIHByZS1tb3VudHMgc2lsZW50IGF1ZGlvIHRhZ3MgdG8gaGVscCBhdm9pZCBicm93c2VyIGF1dG9wbGF5IHJlc3RyaWN0aW9ucy4gU2VlIGh0dHBzOi8vcmVtb3Rpb24uZGV2L2RvY3MvcGxheWVyL2F1dG9wbGF5I3VzZS10aGUtbnVtYmVyb2ZzaGFyZWRhdWRpb3RhZ3MtcHJvcGVydHkgZm9yIG1vcmUgaW5mb3JtYXRpb24gb24gaG93IHRvIGluY3JlYXNlIHRoaXMgbGltaXQuYCk7XG4gICAgfVxuICAgIGNvbnN0IHsgaWQsIHJlZiB9ID0gcmVmc1tmaXJzdEZyZWVBdWRpb107XG4gICAgY29uc3QgY2xvbmVkID0gWy4uLnRha2VuQXVkaW9zLmN1cnJlbnRdO1xuICAgIGNsb25lZFtmaXJzdEZyZWVBdWRpb10gPSBpZDtcbiAgICB0YWtlbkF1ZGlvcy5jdXJyZW50ID0gY2xvbmVkO1xuICAgIGNvbnN0IG5ld0VsZW0gPSB7XG4gICAgICBwcm9wczogYXVkLFxuICAgICAgaWQsXG4gICAgICBlbDogcmVmLFxuICAgICAgYXVkaW9JZFxuICAgIH07XG4gICAgYXVkaW9zLmN1cnJlbnQ/LnB1c2gobmV3RWxlbSk7XG4gICAgcmVyZW5kZXJBdWRpb3MoKTtcbiAgICByZXR1cm4gbmV3RWxlbTtcbiAgfSwgW251bWJlck9mQXVkaW9UYWdzLCByZWZzLCByZXJlbmRlckF1ZGlvc10pO1xuICBjb25zdCB1bnJlZ2lzdGVyQXVkaW8gPSB1c2VDYWxsYmFjazgoKGlkKSA9PiB7XG4gICAgY29uc3QgY2xvbmVkID0gWy4uLnRha2VuQXVkaW9zLmN1cnJlbnRdO1xuICAgIGNvbnN0IGluZGV4ID0gcmVmcy5maW5kSW5kZXgoKHIpID0+IHIuaWQgPT09IGlkKTtcbiAgICBpZiAoaW5kZXggPT09IC0xKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRXJyb3Igb2NjdXJlZCBpbiBcIik7XG4gICAgfVxuICAgIGNsb25lZFtpbmRleF0gPSBmYWxzZTtcbiAgICB0YWtlbkF1ZGlvcy5jdXJyZW50ID0gY2xvbmVkO1xuICAgIGF1ZGlvcy5jdXJyZW50ID0gYXVkaW9zLmN1cnJlbnQ/LmZpbHRlcigoYSkgPT4gYS5pZCAhPT0gaWQpO1xuICAgIHJlcmVuZGVyQXVkaW9zKCk7XG4gIH0sIFtyZWZzLCByZXJlbmRlckF1ZGlvc10pO1xuICBjb25zdCB1cGRhdGVBdWRpbyA9IHVzZUNhbGxiYWNrOCgoe1xuICAgIGF1ZCxcbiAgICBhdWRpb0lkLFxuICAgIGlkXG4gIH0pID0+IHtcbiAgICBsZXQgY2hhbmdlZCA9IGZhbHNlO1xuICAgIGF1ZGlvcy5jdXJyZW50ID0gYXVkaW9zLmN1cnJlbnQ/Lm1hcCgocHJldkEpID0+IHtcbiAgICAgIGlmIChwcmV2QS5pZCA9PT0gaWQpIHtcbiAgICAgICAgY29uc3QgaXNUaGVTYW1lID0gY29tcGFyZVByb3BzKGF1ZCwgcHJldkEucHJvcHMpO1xuICAgICAgICBpZiAoaXNUaGVTYW1lKSB7XG4gICAgICAgICAgcmV0dXJuIHByZXZBO1xuICAgICAgICB9XG4gICAgICAgIGNoYW5nZWQgPSB0cnVlO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIC4uLnByZXZBLFxuICAgICAgICAgIHByb3BzOiBhdWQsXG4gICAgICAgICAgYXVkaW9JZFxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHByZXZBO1xuICAgIH0pO1xuICAgIGlmIChjaGFuZ2VkKSB7XG4gICAgICByZXJlbmRlckF1ZGlvcygpO1xuICAgIH1cbiAgfSwgW3JlcmVuZGVyQXVkaW9zXSk7XG4gIGNvbnN0IHBsYXlBbGxBdWRpb3MgPSB1c2VDYWxsYmFjazgoKCkgPT4ge1xuICAgIHJlZnMuZm9yRWFjaCgocmVmKSA9PiB7XG4gICAgICBwbGF5QW5kSGFuZGxlTm90QWxsb3dlZEVycm9yKHJlZi5yZWYsIFwiYXVkaW9cIiwgbnVsbCk7XG4gICAgfSk7XG4gIH0sIFtyZWZzXSk7XG4gIGNvbnN0IHZhbHVlID0gdXNlTWVtbzE5KCgpID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgcmVnaXN0ZXJBdWRpbyxcbiAgICAgIHVucmVnaXN0ZXJBdWRpbyxcbiAgICAgIHVwZGF0ZUF1ZGlvLFxuICAgICAgcGxheUFsbEF1ZGlvcyxcbiAgICAgIG51bWJlck9mQXVkaW9UYWdzXG4gICAgfTtcbiAgfSwgW1xuICAgIG51bWJlck9mQXVkaW9UYWdzLFxuICAgIHBsYXlBbGxBdWRpb3MsXG4gICAgcmVnaXN0ZXJBdWRpbyxcbiAgICB1bnJlZ2lzdGVyQXVkaW8sXG4gICAgdXBkYXRlQXVkaW9cbiAgXSk7XG4gIGNvbnN0IHJlc2V0QXVkaW8gPSB1c2VDYWxsYmFjazgoKCkgPT4ge1xuICAgIHRha2VuQXVkaW9zLmN1cnJlbnQgPSBuZXcgQXJyYXkobnVtYmVyT2ZBdWRpb1RhZ3MpLmZpbGwoZmFsc2UpO1xuICAgIGF1ZGlvcy5jdXJyZW50ID0gW107XG4gICAgcmVyZW5kZXJBdWRpb3MoKTtcbiAgfSwgW251bWJlck9mQXVkaW9UYWdzLCByZXJlbmRlckF1ZGlvc10pO1xuICB1c2VFZmZlY3QxNSgoKSA9PiB7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHJlc2V0QXVkaW8oKTtcbiAgICB9O1xuICB9LCBbY29tcG9uZW50LCByZXNldEF1ZGlvXSk7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8ganN4cyhTaGFyZWRBdWRpb0NvbnRleHQuUHJvdmlkZXIsIHtcbiAgICB2YWx1ZSxcbiAgICBjaGlsZHJlbjogW1xuICAgICAgcmVmcy5tYXAoKHsgaWQsIHJlZiB9KSA9PiB7XG4gICAgICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8ganN4MTUoXCJhdWRpb1wiLCB7XG4gICAgICAgICAgcmVmLFxuICAgICAgICAgIHByZWxvYWQ6IFwibWV0YWRhdGFcIixcbiAgICAgICAgICBzcmM6IEVNUFRZX0FVRElPXG4gICAgICAgIH0sIGlkKTtcbiAgICAgIH0pLFxuICAgICAgY2hpbGRyZW5cbiAgICBdXG4gIH0pO1xufTtcbnZhciB1c2VTaGFyZWRBdWRpbyA9IChhdWQsIGF1ZGlvSWQpID0+IHtcbiAgY29uc3QgY3R4ID0gdXNlQ29udGV4dDIwKFNoYXJlZEF1ZGlvQ29udGV4dCk7XG4gIGNvbnN0IFtlbGVtXSA9IHVzZVN0YXRlMTMoKCkgPT4ge1xuICAgIGlmIChjdHggJiYgY3R4Lm51bWJlck9mQXVkaW9UYWdzID4gMCkge1xuICAgICAgcmV0dXJuIGN0eC5yZWdpc3RlckF1ZGlvKGF1ZCwgYXVkaW9JZCk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBlbDogUmVhY3QxMi5jcmVhdGVSZWYoKSxcbiAgICAgIGlkOiBNYXRoLnJhbmRvbSgpLFxuICAgICAgcHJvcHM6IGF1ZCxcbiAgICAgIGF1ZGlvSWRcbiAgICB9O1xuICB9KTtcbiAgY29uc3QgZWZmZWN0VG9Vc2UgPSBSZWFjdDEyLnVzZUluc2VydGlvbkVmZmVjdCA/PyBSZWFjdDEyLnVzZUxheW91dEVmZmVjdDtcbiAgaWYgKHR5cGVvZiBkb2N1bWVudCAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIGVmZmVjdFRvVXNlKCgpID0+IHtcbiAgICAgIGlmIChjdHggJiYgY3R4Lm51bWJlck9mQXVkaW9UYWdzID4gMCkge1xuICAgICAgICBjdHgudXBkYXRlQXVkaW8oeyBpZDogZWxlbS5pZCwgYXVkLCBhdWRpb0lkIH0pO1xuICAgICAgfVxuICAgIH0sIFthdWQsIGN0eCwgZWxlbS5pZCwgYXVkaW9JZF0pO1xuICAgIGVmZmVjdFRvVXNlKCgpID0+IHtcbiAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIGlmIChjdHggJiYgY3R4Lm51bWJlck9mQXVkaW9UYWdzID4gMCkge1xuICAgICAgICAgIGN0eC51bnJlZ2lzdGVyQXVkaW8oZWxlbS5pZCk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSwgW2N0eCwgZWxlbS5pZF0pO1xuICB9XG4gIHJldHVybiBlbGVtO1xufTtcblxuLy8gc3JjL2F1ZGlvL0F1ZGlvRm9yUHJldmlldy50c3hcbmltcG9ydCB7IGpzeCBhcyBqc3gxNiB9IGZyb20gXCJyZWFjdC9qc3gtcnVudGltZVwiO1xudmFyIEF1ZGlvRm9yRGV2ZWxvcG1lbnRGb3J3YXJkUmVmRnVuY3Rpb24gPSAocHJvcHMsIHJlZikgPT4ge1xuICBjb25zdCBbaW5pdGlhbFNob3VsZFByZU1vdW50QXVkaW9FbGVtZW50c10gPSB1c2VTdGF0ZTE0KHByb3BzLnNob3VsZFByZU1vdW50QXVkaW9UYWdzKTtcbiAgaWYgKHByb3BzLnNob3VsZFByZU1vdW50QXVkaW9UYWdzICE9PSBpbml0aWFsU2hvdWxkUHJlTW91bnRBdWRpb0VsZW1lbnRzKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGNoYW5nZSB0aGUgYmVoYXZpb3IgZm9yIHByZS1tb3VudGluZyBhdWRpbyB0YWdzIGR5bmFtaWNhbGx5LlwiKTtcbiAgfVxuICBjb25zdCB7XG4gICAgdm9sdW1lLFxuICAgIG11dGVkLFxuICAgIHBsYXliYWNrUmF0ZSxcbiAgICBzaG91bGRQcmVNb3VudEF1ZGlvVGFncyxcbiAgICBzcmMsXG4gICAgb25EdXJhdGlvbixcbiAgICBhY2NlcHRhYmxlVGltZVNoaWZ0SW5TZWNvbmRzLFxuICAgIF9yZW1vdGlvbkludGVybmFsTmVlZHNEdXJhdGlvbkNhbGN1bGF0aW9uLFxuICAgIF9yZW1vdGlvbkludGVybmFsTmF0aXZlTG9vcFBhc3NlZCxcbiAgICBfcmVtb3Rpb25JbnRlcm5hbFN0YWNrLFxuICAgIF9yZW1vdGlvbkRlYnVnU2Vla2luZyxcbiAgICBhbGxvd0FtcGxpZmljYXRpb25EdXJpbmdSZW5kZXIsXG4gICAgbmFtZSxcbiAgICBwYXVzZVdoZW5CdWZmZXJpbmcsXG4gICAgc2hvd0luVGltZWxpbmUsXG4gICAgbG9vcFZvbHVtZUN1cnZlQmVoYXZpb3IsXG4gICAgc3RhY2ssXG4gICAgLi4ubmF0aXZlUHJvcHNcbiAgfSA9IHByb3BzO1xuICBjb25zdCBbbWVkaWFWb2x1bWVdID0gdXNlTWVkaWFWb2x1bWVTdGF0ZSgpO1xuICBjb25zdCBbbWVkaWFNdXRlZF0gPSB1c2VNZWRpYU11dGVkU3RhdGUoKTtcbiAgY29uc3Qgdm9sdW1lUHJvcEZyYW1lID0gdXNlRnJhbWVGb3JWb2x1bWVQcm9wKGxvb3BWb2x1bWVDdXJ2ZUJlaGF2aW9yID8/IFwicmVwZWF0XCIpO1xuICBjb25zdCB7IGhpZGRlbiB9ID0gdXNlQ29udGV4dDIxKFNlcXVlbmNlVmlzaWJpbGl0eVRvZ2dsZUNvbnRleHQpO1xuICBpZiAoIXNyYykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJObyAnc3JjJyB3YXMgcGFzc2VkIHRvIDxBdWRpbz4uXCIpO1xuICB9XG4gIGNvbnN0IHByZWxvYWRlZFNyYyA9IHVzZVByZWxvYWQoc3JjKTtcbiAgY29uc3Qgc2VxdWVuY2VDb250ZXh0ID0gdXNlQ29udGV4dDIxKFNlcXVlbmNlQ29udGV4dCk7XG4gIGNvbnN0IFt0aW1lbGluZUlkXSA9IHVzZVN0YXRlMTQoKCkgPT4gU3RyaW5nKE1hdGgucmFuZG9tKCkpKTtcbiAgY29uc3QgaXNTZXF1ZW5jZUhpZGRlbiA9IGhpZGRlblt0aW1lbGluZUlkXSA/PyBmYWxzZTtcbiAgY29uc3QgdXNlclByZWZlcnJlZFZvbHVtZSA9IGV2YWx1YXRlVm9sdW1lKHtcbiAgICBmcmFtZTogdm9sdW1lUHJvcEZyYW1lLFxuICAgIHZvbHVtZSxcbiAgICBtZWRpYVZvbHVtZSxcbiAgICBhbGxvd0FtcGxpZmljYXRpb25EdXJpbmdSZW5kZXI6IGZhbHNlXG4gIH0pO1xuICBjb25zdCBwcm9wc1RvUGFzcyA9IHVzZU1lbW8yMCgoKSA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG11dGVkOiBtdXRlZCB8fCBtZWRpYU11dGVkIHx8IGlzU2VxdWVuY2VIaWRkZW4gfHwgdXNlclByZWZlcnJlZFZvbHVtZSA8PSAwLFxuICAgICAgc3JjOiBwcmVsb2FkZWRTcmMsXG4gICAgICBsb29wOiBfcmVtb3Rpb25JbnRlcm5hbE5hdGl2ZUxvb3BQYXNzZWQsXG4gICAgICAuLi5uYXRpdmVQcm9wc1xuICAgIH07XG4gIH0sIFtcbiAgICBfcmVtb3Rpb25JbnRlcm5hbE5hdGl2ZUxvb3BQYXNzZWQsXG4gICAgaXNTZXF1ZW5jZUhpZGRlbixcbiAgICBtZWRpYU11dGVkLFxuICAgIG11dGVkLFxuICAgIG5hdGl2ZVByb3BzLFxuICAgIHByZWxvYWRlZFNyYyxcbiAgICB1c2VyUHJlZmVycmVkVm9sdW1lXG4gIF0pO1xuICBjb25zdCBpZCA9IHVzZU1lbW8yMCgoKSA9PiBgYXVkaW8tJHtyYW5kb20oc3JjID8/IFwiXCIpfS0ke3NlcXVlbmNlQ29udGV4dD8ucmVsYXRpdmVGcm9tfS0ke3NlcXVlbmNlQ29udGV4dD8uY3VtdWxhdGVkRnJvbX0tJHtzZXF1ZW5jZUNvbnRleHQ/LmR1cmF0aW9uSW5GcmFtZXN9LW11dGVkOiR7cHJvcHMubXV0ZWR9LWxvb3A6JHtwcm9wcy5sb29wfWAsIFtcbiAgICBzcmMsXG4gICAgc2VxdWVuY2VDb250ZXh0Py5yZWxhdGl2ZUZyb20sXG4gICAgc2VxdWVuY2VDb250ZXh0Py5jdW11bGF0ZWRGcm9tLFxuICAgIHNlcXVlbmNlQ29udGV4dD8uZHVyYXRpb25JbkZyYW1lcyxcbiAgICBwcm9wcy5tdXRlZCxcbiAgICBwcm9wcy5sb29wXG4gIF0pO1xuICBjb25zdCBhdWRpb1JlZiA9IHVzZVNoYXJlZEF1ZGlvKHByb3BzVG9QYXNzLCBpZCkuZWw7XG4gIGNvbnN0IGFjdHVhbFZvbHVtZSA9IHVzZU1lZGlhVGFnVm9sdW1lKGF1ZGlvUmVmKTtcbiAgdXNlU3luY1ZvbHVtZVdpdGhNZWRpYVRhZyh7XG4gICAgdm9sdW1lUHJvcEZyYW1lLFxuICAgIGFjdHVhbFZvbHVtZSxcbiAgICB2b2x1bWUsXG4gICAgbWVkaWFWb2x1bWUsXG4gICAgbWVkaWFSZWY6IGF1ZGlvUmVmXG4gIH0pO1xuICB1c2VNZWRpYUluVGltZWxpbmUoe1xuICAgIHZvbHVtZSxcbiAgICBtZWRpYVZvbHVtZSxcbiAgICBtZWRpYVJlZjogYXVkaW9SZWYsXG4gICAgc3JjLFxuICAgIG1lZGlhVHlwZTogXCJhdWRpb1wiLFxuICAgIHBsYXliYWNrUmF0ZTogcGxheWJhY2tSYXRlID8/IDEsXG4gICAgZGlzcGxheU5hbWU6IG5hbWUgPz8gbnVsbCxcbiAgICBpZDogdGltZWxpbmVJZCxcbiAgICBzdGFjazogX3JlbW90aW9uSW50ZXJuYWxTdGFjayxcbiAgICBzaG93SW5UaW1lbGluZSxcbiAgICBwcmVtb3VudERpc3BsYXk6IG51bGwsXG4gICAgb25BdXRvUGxheUVycm9yOiBudWxsXG4gIH0pO1xuICB1c2VNZWRpYVBsYXliYWNrKHtcbiAgICBtZWRpYVJlZjogYXVkaW9SZWYsXG4gICAgc3JjLFxuICAgIG1lZGlhVHlwZTogXCJhdWRpb1wiLFxuICAgIHBsYXliYWNrUmF0ZTogcGxheWJhY2tSYXRlID8/IDEsXG4gICAgb25seVdhcm5Gb3JNZWRpYVNlZWtpbmdFcnJvcjogZmFsc2UsXG4gICAgYWNjZXB0YWJsZVRpbWVzaGlmdDogYWNjZXB0YWJsZVRpbWVTaGlmdEluU2Vjb25kcyA/PyBERUZBVUxUX0FDQ0VQVEFCTEVfVElNRVNISUZULFxuICAgIGlzUHJlbW91bnRpbmc6IEJvb2xlYW4oc2VxdWVuY2VDb250ZXh0Py5wcmVtb3VudGluZyksXG4gICAgcGF1c2VXaGVuQnVmZmVyaW5nLFxuICAgIGRlYnVnU2Vla2luZzogX3JlbW90aW9uRGVidWdTZWVraW5nLFxuICAgIG9uQXV0b1BsYXlFcnJvcjogbnVsbFxuICB9KTtcbiAgdXNlSW1wZXJhdGl2ZUhhbmRsZTMocmVmLCAoKSA9PiB7XG4gICAgcmV0dXJuIGF1ZGlvUmVmLmN1cnJlbnQ7XG4gIH0sIFthdWRpb1JlZl0pO1xuICBjb25zdCBjdXJyZW50T25EdXJhdGlvbkNhbGxiYWNrID0gdXNlUmVmOCgpO1xuICBjdXJyZW50T25EdXJhdGlvbkNhbGxiYWNrLmN1cnJlbnQgPSBvbkR1cmF0aW9uO1xuICB1c2VFZmZlY3QxNigoKSA9PiB7XG4gICAgY29uc3QgeyBjdXJyZW50IH0gPSBhdWRpb1JlZjtcbiAgICBpZiAoIWN1cnJlbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGN1cnJlbnQuZHVyYXRpb24pIHtcbiAgICAgIGN1cnJlbnRPbkR1cmF0aW9uQ2FsbGJhY2suY3VycmVudD8uKGN1cnJlbnQuc3JjLCBjdXJyZW50LmR1cmF0aW9uKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qgb25Mb2FkZWRNZXRhZGF0YSA9ICgpID0+IHtcbiAgICAgIGN1cnJlbnRPbkR1cmF0aW9uQ2FsbGJhY2suY3VycmVudD8uKGN1cnJlbnQuc3JjLCBjdXJyZW50LmR1cmF0aW9uKTtcbiAgICB9O1xuICAgIGN1cnJlbnQuYWRkRXZlbnRMaXN0ZW5lcihcImxvYWRlZG1ldGFkYXRhXCIsIG9uTG9hZGVkTWV0YWRhdGEpO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBjdXJyZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJsb2FkZWRtZXRhZGF0YVwiLCBvbkxvYWRlZE1ldGFkYXRhKTtcbiAgICB9O1xuICB9LCBbYXVkaW9SZWYsIHNyY10pO1xuICBpZiAoaW5pdGlhbFNob3VsZFByZU1vdW50QXVkaW9FbGVtZW50cykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8ganN4MTYoXCJhdWRpb1wiLCB7XG4gICAgcmVmOiBhdWRpb1JlZixcbiAgICBwcmVsb2FkOiBcIm1ldGFkYXRhXCIsXG4gICAgLi4ucHJvcHNUb1Bhc3NcbiAgfSk7XG59O1xudmFyIEF1ZGlvRm9yUHJldmlldyA9IGZvcndhcmRSZWYzKEF1ZGlvRm9yRGV2ZWxvcG1lbnRGb3J3YXJkUmVmRnVuY3Rpb24pO1xuXG4vLyBzcmMvYXVkaW8vQXVkaW9Gb3JSZW5kZXJpbmcudHN4XG5pbXBvcnQge1xuICBmb3J3YXJkUmVmIGFzIGZvcndhcmRSZWY0LFxuICB1c2VDb250ZXh0IGFzIHVzZUNvbnRleHQyMixcbiAgdXNlRWZmZWN0IGFzIHVzZUVmZmVjdDE3LFxuICB1c2VJbXBlcmF0aXZlSGFuZGxlIGFzIHVzZUltcGVyYXRpdmVIYW5kbGU0LFxuICB1c2VMYXlvdXRFZmZlY3QgYXMgdXNlTGF5b3V0RWZmZWN0MyxcbiAgdXNlTWVtbyBhcyB1c2VNZW1vMjEsXG4gIHVzZVJlZiBhcyB1c2VSZWY5XG59IGZyb20gXCJyZWFjdFwiO1xuXG4vLyBzcmMvZGVsYXktcmVuZGVyLnRzXG5pZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIikge1xuICB3aW5kb3cucmVtb3Rpb25fcmVuZGVyUmVhZHkgPSBmYWxzZTtcbn1cbnZhciBoYW5kbGVzID0gW107XG5pZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIikge1xuICB3aW5kb3cucmVtb3Rpb25fZGVsYXlSZW5kZXJUaW1lb3V0cyA9IHt9O1xufVxudmFyIERFTEFZX1JFTkRFUl9DQUxMU1RBQ0tfVE9LRU4gPSBcIlRoZSBkZWxheVJlbmRlciB3YXMgY2FsbGVkOlwiO1xudmFyIERFTEFZX1JFTkRFUl9SRVRSSUVTX0xFRlQgPSBcIlJldHJpZXMgbGVmdDogXCI7XG52YXIgREVMQVlfUkVOREVSX1JFVFJZX1RPS0VOID0gXCItIFJlbmRlcmluZyB0aGUgZnJhbWUgd2lsbCBiZSByZXRyaWVkLlwiO1xudmFyIGRlZmF1bHRUaW1lb3V0ID0gMzAwMDA7XG52YXIgZGVsYXlSZW5kZXIgPSAobGFiZWwsIG9wdGlvbnMpID0+IHtcbiAgaWYgKHR5cGVvZiBsYWJlbCAhPT0gXCJzdHJpbmdcIiAmJiB0eXBlb2YgbGFiZWwgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgbGFiZWwgcGFyYW1ldGVyIG9mIGRlbGF5UmVuZGVyKCkgbXVzdCBiZSBhIHN0cmluZyBvciB1bmRlZmluZWQsIGdvdDogXCIgKyBKU09OLnN0cmluZ2lmeShsYWJlbCkpO1xuICB9XG4gIGNvbnN0IGhhbmRsZSA9IE1hdGgucmFuZG9tKCk7XG4gIGhhbmRsZXMucHVzaChoYW5kbGUpO1xuICBjb25zdCBjYWxsZWQgPSBFcnJvcigpLnN0YWNrPy5yZXBsYWNlKC9eRXJyb3IvZywgXCJcIikgPz8gXCJcIjtcbiAgaWYgKGdldFJlbW90aW9uRW52aXJvbm1lbnQoKS5pc1JlbmRlcmluZykge1xuICAgIGNvbnN0IHRpbWVvdXRUb1VzZSA9IChvcHRpb25zPy50aW1lb3V0SW5NaWxsaXNlY29uZHMgPz8gKHR5cGVvZiB3aW5kb3cgPT09IFwidW5kZWZpbmVkXCIgPyBkZWZhdWx0VGltZW91dCA6IHdpbmRvdy5yZW1vdGlvbl9wdXBwZXRlZXJUaW1lb3V0ID8/IGRlZmF1bHRUaW1lb3V0KSkgLSAyMDAwO1xuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICBjb25zdCByZXRyaWVzTGVmdCA9IChvcHRpb25zPy5yZXRyaWVzID8/IDApIC0gKHdpbmRvdy5yZW1vdGlvbl9hdHRlbXB0IC0gMSk7XG4gICAgICB3aW5kb3cucmVtb3Rpb25fZGVsYXlSZW5kZXJUaW1lb3V0c1toYW5kbGVdID0ge1xuICAgICAgICBsYWJlbDogbGFiZWwgPz8gbnVsbCxcbiAgICAgICAgdGltZW91dDogc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgY29uc3QgbWVzc2FnZSA9IFtcbiAgICAgICAgICAgIGBBIGRlbGF5UmVuZGVyKClgLFxuICAgICAgICAgICAgbGFiZWwgPyBgXCIke2xhYmVsfVwiYCA6IG51bGwsXG4gICAgICAgICAgICBgd2FzIGNhbGxlZCBidXQgbm90IGNsZWFyZWQgYWZ0ZXIgJHt0aW1lb3V0VG9Vc2V9bXMuIFNlZSBodHRwczovL3JlbW90aW9uLmRldi9kb2NzL3RpbWVvdXQgZm9yIGhlbHAuYCxcbiAgICAgICAgICAgIHJldHJpZXNMZWZ0ID4gMCA/IERFTEFZX1JFTkRFUl9SRVRSSUVTX0xFRlQgKyByZXRyaWVzTGVmdCA6IG51bGwsXG4gICAgICAgICAgICByZXRyaWVzTGVmdCA+IDAgPyBERUxBWV9SRU5ERVJfUkVUUllfVE9LRU4gOiBudWxsLFxuICAgICAgICAgICAgREVMQVlfUkVOREVSX0NBTExTVEFDS19UT0tFTixcbiAgICAgICAgICAgIGNhbGxlZFxuICAgICAgICAgIF0uZmlsdGVyKHRydXRoeSkuam9pbihcIiBcIik7XG4gICAgICAgICAgY2FuY2VsUmVuZGVyKEVycm9yKG1lc3NhZ2UpKTtcbiAgICAgICAgfSwgdGltZW91dFRvVXNlKVxuICAgICAgfTtcbiAgICB9XG4gIH1cbiAgaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICB3aW5kb3cucmVtb3Rpb25fcmVuZGVyUmVhZHkgPSBmYWxzZTtcbiAgfVxuICByZXR1cm4gaGFuZGxlO1xufTtcbnZhciBjb250aW51ZVJlbmRlciA9IChoYW5kbGUpID0+IHtcbiAgaWYgKHR5cGVvZiBoYW5kbGUgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiVGhlIGNvbnRpbnVlUmVuZGVyKCkgbWV0aG9kIG11c3QgYmUgY2FsbGVkIHdpdGggYSBwYXJhbWV0ZXIgdGhhdCBpcyB0aGUgcmV0dXJuIHZhbHVlIG9mIGRlbGF5UmVuZGVyKCkuIE5vIHZhbHVlIHdhcyBwYXNzZWQuXCIpO1xuICB9XG4gIGlmICh0eXBlb2YgaGFuZGxlICE9PSBcIm51bWJlclwiKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlRoZSBwYXJhbWV0ZXIgcGFzc2VkIGludG8gY29udGludWVSZW5kZXIoKSBtdXN0IGJlIHRoZSByZXR1cm4gdmFsdWUgb2YgZGVsYXlSZW5kZXIoKSB3aGljaCBpcyBhIG51bWJlci4gR290OiBcIiArIEpTT04uc3RyaW5naWZ5KGhhbmRsZSkpO1xuICB9XG4gIGhhbmRsZXMgPSBoYW5kbGVzLmZpbHRlcigoaCkgPT4ge1xuICAgIGlmIChoID09PSBoYW5kbGUpIHtcbiAgICAgIGlmIChnZXRSZW1vdGlvbkVudmlyb25tZW50KCkuaXNSZW5kZXJpbmcpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHdpbmRvdy5yZW1vdGlvbl9kZWxheVJlbmRlclRpbWVvdXRzW2hhbmRsZV0udGltZW91dCk7XG4gICAgICAgIGRlbGV0ZSB3aW5kb3cucmVtb3Rpb25fZGVsYXlSZW5kZXJUaW1lb3V0c1toYW5kbGVdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSk7XG4gIGlmIChoYW5kbGVzLmxlbmd0aCA9PT0gMCAmJiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgd2luZG93LnJlbW90aW9uX3JlbmRlclJlYWR5ID0gdHJ1ZTtcbiAgfVxufTtcblxuLy8gc3JjL2F1ZGlvL0F1ZGlvRm9yUmVuZGVyaW5nLnRzeFxuaW1wb3J0IHsganN4IGFzIGpzeDE3IH0gZnJvbSBcInJlYWN0L2pzeC1ydW50aW1lXCI7XG52YXIgQXVkaW9Gb3JSZW5kZXJpbmdSZWZGb3J3YXJkaW5nRnVuY3Rpb24gPSAocHJvcHMsIHJlZikgPT4ge1xuICBjb25zdCBhdWRpb1JlZiA9IHVzZVJlZjkobnVsbCk7XG4gIGNvbnN0IHtcbiAgICB2b2x1bWU6IHZvbHVtZVByb3AsXG4gICAgcGxheWJhY2tSYXRlLFxuICAgIGFsbG93QW1wbGlmaWNhdGlvbkR1cmluZ1JlbmRlcixcbiAgICBvbkR1cmF0aW9uLFxuICAgIHRvbmVGcmVxdWVuY3ksXG4gICAgX3JlbW90aW9uSW50ZXJuYWxOZWVkc0R1cmF0aW9uQ2FsY3VsYXRpb24sXG4gICAgX3JlbW90aW9uSW50ZXJuYWxOYXRpdmVMb29wUGFzc2VkLFxuICAgIGFjY2VwdGFibGVUaW1lU2hpZnRJblNlY29uZHMsXG4gICAgbmFtZSxcbiAgICBvbkVycm9yLFxuICAgIGRlbGF5UmVuZGVyUmV0cmllcyxcbiAgICBkZWxheVJlbmRlclRpbWVvdXRJbk1pbGxpc2Vjb25kcyxcbiAgICBsb29wVm9sdW1lQ3VydmVCZWhhdmlvcixcbiAgICBwYXVzZVdoZW5CdWZmZXJpbmcsXG4gICAgLi4ubmF0aXZlUHJvcHNcbiAgfSA9IHByb3BzO1xuICBjb25zdCBhYnNvbHV0ZUZyYW1lID0gdXNlVGltZWxpbmVQb3NpdGlvbigpO1xuICBjb25zdCB2b2x1bWVQcm9wRnJhbWUgPSB1c2VGcmFtZUZvclZvbHVtZVByb3AobG9vcFZvbHVtZUN1cnZlQmVoYXZpb3IgPz8gXCJyZXBlYXRcIik7XG4gIGNvbnN0IGZyYW1lID0gdXNlQ3VycmVudEZyYW1lKCk7XG4gIGNvbnN0IHNlcXVlbmNlQ29udGV4dCA9IHVzZUNvbnRleHQyMihTZXF1ZW5jZUNvbnRleHQpO1xuICBjb25zdCB7IHJlZ2lzdGVyUmVuZGVyQXNzZXQsIHVucmVnaXN0ZXJSZW5kZXJBc3NldCB9ID0gdXNlQ29udGV4dDIyKFJlbmRlckFzc2V0TWFuYWdlcik7XG4gIGNvbnN0IGlkID0gdXNlTWVtbzIxKCgpID0+IGBhdWRpby0ke3JhbmRvbShwcm9wcy5zcmMgPz8gXCJcIil9LSR7c2VxdWVuY2VDb250ZXh0Py5yZWxhdGl2ZUZyb219LSR7c2VxdWVuY2VDb250ZXh0Py5jdW11bGF0ZWRGcm9tfS0ke3NlcXVlbmNlQ29udGV4dD8uZHVyYXRpb25JbkZyYW1lc31gLCBbXG4gICAgcHJvcHMuc3JjLFxuICAgIHNlcXVlbmNlQ29udGV4dD8ucmVsYXRpdmVGcm9tLFxuICAgIHNlcXVlbmNlQ29udGV4dD8uY3VtdWxhdGVkRnJvbSxcbiAgICBzZXF1ZW5jZUNvbnRleHQ/LmR1cmF0aW9uSW5GcmFtZXNcbiAgXSk7XG4gIGNvbnN0IHZvbHVtZSA9IGV2YWx1YXRlVm9sdW1lKHtcbiAgICB2b2x1bWU6IHZvbHVtZVByb3AsXG4gICAgZnJhbWU6IHZvbHVtZVByb3BGcmFtZSxcbiAgICBtZWRpYVZvbHVtZTogMSxcbiAgICBhbGxvd0FtcGxpZmljYXRpb25EdXJpbmdSZW5kZXI6IGFsbG93QW1wbGlmaWNhdGlvbkR1cmluZ1JlbmRlciA/PyBmYWxzZVxuICB9KTtcbiAgdXNlSW1wZXJhdGl2ZUhhbmRsZTQocmVmLCAoKSA9PiB7XG4gICAgcmV0dXJuIGF1ZGlvUmVmLmN1cnJlbnQ7XG4gIH0sIFtdKTtcbiAgdXNlRWZmZWN0MTcoKCkgPT4ge1xuICAgIGlmICghcHJvcHMuc3JjKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBzcmMgcGFzc2VkXCIpO1xuICAgIH1cbiAgICBpZiAoIXdpbmRvdy5yZW1vdGlvbl9hdWRpb0VuYWJsZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHByb3BzLm11dGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh2b2x1bWUgPD0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICByZWdpc3RlclJlbmRlckFzc2V0KHtcbiAgICAgIHR5cGU6IFwiYXVkaW9cIixcbiAgICAgIHNyYzogZ2V0QWJzb2x1dGVTcmMocHJvcHMuc3JjKSxcbiAgICAgIGlkLFxuICAgICAgZnJhbWU6IGFic29sdXRlRnJhbWUsXG4gICAgICB2b2x1bWUsXG4gICAgICBtZWRpYUZyYW1lOiBmcmFtZSxcbiAgICAgIHBsYXliYWNrUmF0ZTogcHJvcHMucGxheWJhY2tSYXRlID8/IDEsXG4gICAgICBhbGxvd0FtcGxpZmljYXRpb25EdXJpbmdSZW5kZXI6IGFsbG93QW1wbGlmaWNhdGlvbkR1cmluZ1JlbmRlciA/PyBmYWxzZSxcbiAgICAgIHRvbmVGcmVxdWVuY3k6IHRvbmVGcmVxdWVuY3kgPz8gbnVsbCxcbiAgICAgIGF1ZGlvU3RhcnRGcmFtZTogTWF0aC5tYXgoMCwgLShzZXF1ZW5jZUNvbnRleHQ/LnJlbGF0aXZlRnJvbSA/PyAwKSlcbiAgICB9KTtcbiAgICByZXR1cm4gKCkgPT4gdW5yZWdpc3RlclJlbmRlckFzc2V0KGlkKTtcbiAgfSwgW1xuICAgIHByb3BzLm11dGVkLFxuICAgIHByb3BzLnNyYyxcbiAgICByZWdpc3RlclJlbmRlckFzc2V0LFxuICAgIGFic29sdXRlRnJhbWUsXG4gICAgaWQsXG4gICAgdW5yZWdpc3RlclJlbmRlckFzc2V0LFxuICAgIHZvbHVtZSxcbiAgICB2b2x1bWVQcm9wRnJhbWUsXG4gICAgZnJhbWUsXG4gICAgcGxheWJhY2tSYXRlLFxuICAgIHByb3BzLnBsYXliYWNrUmF0ZSxcbiAgICBhbGxvd0FtcGxpZmljYXRpb25EdXJpbmdSZW5kZXIsXG4gICAgdG9uZUZyZXF1ZW5jeSxcbiAgICBzZXF1ZW5jZUNvbnRleHQ/LnJlbGF0aXZlRnJvbVxuICBdKTtcbiAgY29uc3QgeyBzcmMgfSA9IHByb3BzO1xuICBjb25zdCBuZWVkc1RvUmVuZGVyQXVkaW9UYWcgPSByZWYgfHwgX3JlbW90aW9uSW50ZXJuYWxOZWVkc0R1cmF0aW9uQ2FsY3VsYXRpb247XG4gIHVzZUxheW91dEVmZmVjdDMoKCkgPT4ge1xuICAgIGlmICh3aW5kb3cucHJvY2Vzcz8uZW52Py5OT0RFX0VOViA9PT0gXCJ0ZXN0XCIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCFuZWVkc1RvUmVuZGVyQXVkaW9UYWcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgbmV3SGFuZGxlID0gZGVsYXlSZW5kZXIoXCJMb2FkaW5nIDxBdWRpbz4gZHVyYXRpb24gd2l0aCBzcmM9XCIgKyBzcmMsIHtcbiAgICAgIHJldHJpZXM6IGRlbGF5UmVuZGVyUmV0cmllcyA/PyB1bmRlZmluZWQsXG4gICAgICB0aW1lb3V0SW5NaWxsaXNlY29uZHM6IGRlbGF5UmVuZGVyVGltZW91dEluTWlsbGlzZWNvbmRzID8/IHVuZGVmaW5lZFxuICAgIH0pO1xuICAgIGNvbnN0IHsgY3VycmVudCB9ID0gYXVkaW9SZWY7XG4gICAgY29uc3QgZGlkTG9hZCA9ICgpID0+IHtcbiAgICAgIGlmIChjdXJyZW50Py5kdXJhdGlvbikge1xuICAgICAgICBvbkR1cmF0aW9uKGN1cnJlbnQuc3JjLCBjdXJyZW50LmR1cmF0aW9uKTtcbiAgICAgIH1cbiAgICAgIGNvbnRpbnVlUmVuZGVyKG5ld0hhbmRsZSk7XG4gICAgfTtcbiAgICBpZiAoY3VycmVudD8uZHVyYXRpb24pIHtcbiAgICAgIG9uRHVyYXRpb24oY3VycmVudC5zcmMsIGN1cnJlbnQuZHVyYXRpb24pO1xuICAgICAgY29udGludWVSZW5kZXIobmV3SGFuZGxlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY3VycmVudD8uYWRkRXZlbnRMaXN0ZW5lcihcImxvYWRlZG1ldGFkYXRhXCIsIGRpZExvYWQsIHsgb25jZTogdHJ1ZSB9KTtcbiAgICB9XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGN1cnJlbnQ/LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJsb2FkZWRtZXRhZGF0YVwiLCBkaWRMb2FkKTtcbiAgICAgIGNvbnRpbnVlUmVuZGVyKG5ld0hhbmRsZSk7XG4gICAgfTtcbiAgfSwgW1xuICAgIHNyYyxcbiAgICBvbkR1cmF0aW9uLFxuICAgIG5lZWRzVG9SZW5kZXJBdWRpb1RhZyxcbiAgICBkZWxheVJlbmRlclJldHJpZXMsXG4gICAgZGVsYXlSZW5kZXJUaW1lb3V0SW5NaWxsaXNlY29uZHNcbiAgXSk7XG4gIGlmICghbmVlZHNUb1JlbmRlckF1ZGlvVGFnKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBqc3gxNyhcImF1ZGlvXCIsIHtcbiAgICByZWY6IGF1ZGlvUmVmLFxuICAgIC4uLm5hdGl2ZVByb3BzXG4gIH0pO1xufTtcbnZhciBBdWRpb0ZvclJlbmRlcmluZyA9IGZvcndhcmRSZWY0KEF1ZGlvRm9yUmVuZGVyaW5nUmVmRm9yd2FyZGluZ0Z1bmN0aW9uKTtcblxuLy8gc3JjL2F1ZGlvL0F1ZGlvLnRzeFxuaW1wb3J0IHsganN4IGFzIGpzeDE4IH0gZnJvbSBcInJlYWN0L2pzeC1ydW50aW1lXCI7XG52YXIgQXVkaW9SZWZGb3J3YXJkaW5nRnVuY3Rpb24gPSAocHJvcHMsIHJlZikgPT4ge1xuICBjb25zdCBhdWRpb0NvbnRleHQgPSB1c2VDb250ZXh0MjMoU2hhcmVkQXVkaW9Db250ZXh0KTtcbiAgY29uc3Qge1xuICAgIHN0YXJ0RnJvbSxcbiAgICBlbmRBdCxcbiAgICBuYW1lLFxuICAgIHN0YWNrLFxuICAgIHBhdXNlV2hlbkJ1ZmZlcmluZyxcbiAgICBzaG93SW5UaW1lbGluZSxcbiAgICBfcmVtb3Rpb25EZWJ1Z1NlZWtpbmcsXG4gICAgLi4ub3RoZXJQcm9wc1xuICB9ID0gcHJvcHM7XG4gIGNvbnN0IHsgbG9vcCwgLi4ucHJvcHNPdGhlclRoYW5Mb29wIH0gPSBwcm9wcztcbiAgY29uc3QgeyBmcHMgfSA9IHVzZVZpZGVvQ29uZmlnKCk7XG4gIGNvbnN0IGVudmlyb25tZW50ID0gZ2V0UmVtb3Rpb25FbnZpcm9ubWVudCgpO1xuICBjb25zdCB7IGR1cmF0aW9ucywgc2V0RHVyYXRpb25zIH0gPSB1c2VDb250ZXh0MjMoRHVyYXRpb25zQ29udGV4dCk7XG4gIGlmICh0eXBlb2YgcHJvcHMuc3JjICE9PSBcInN0cmluZ1wiKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgVGhlIFxcYDxBdWRpbz5cXGAgdGFnIHJlcXVpcmVzIGEgc3RyaW5nIGZvciBcXGBzcmNcXGAsIGJ1dCBnb3QgJHtKU09OLnN0cmluZ2lmeShwcm9wcy5zcmMpfSBpbnN0ZWFkLmApO1xuICB9XG4gIGNvbnN0IHByZWxvYWRlZFNyYyA9IHVzZVByZWxvYWQocHJvcHMuc3JjKTtcbiAgY29uc3Qgb25FcnJvciA9IHVzZUNhbGxiYWNrOSgoZSkgPT4ge1xuICAgIGNvbnNvbGUubG9nKGUuY3VycmVudFRhcmdldC5lcnJvcik7XG4gICAgY29uc3QgZXJyTWVzc2FnZSA9IGBDb3VsZCBub3QgcGxheSBhdWRpbyB3aXRoIHNyYyAke3ByZWxvYWRlZFNyY306ICR7ZS5jdXJyZW50VGFyZ2V0LmVycm9yfS4gU2VlIGh0dHBzOi8vcmVtb3Rpb24uZGV2L2RvY3MvbWVkaWEtcGxheWJhY2stZXJyb3IgZm9yIGhlbHAuYDtcbiAgICBpZiAobG9vcCkge1xuICAgICAgY2FuY2VsUmVuZGVyKG5ldyBFcnJvcihlcnJNZXNzYWdlKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnNvbGUud2FybihlcnJNZXNzYWdlKTtcbiAgICB9XG4gIH0sIFtsb29wLCBwcmVsb2FkZWRTcmNdKTtcbiAgY29uc3Qgb25EdXJhdGlvbiA9IHVzZUNhbGxiYWNrOSgoc3JjLCBkdXJhdGlvbkluU2Vjb25kcykgPT4ge1xuICAgIHNldER1cmF0aW9ucyh7IHR5cGU6IFwiZ290LWR1cmF0aW9uXCIsIGR1cmF0aW9uSW5TZWNvbmRzLCBzcmMgfSk7XG4gIH0sIFtzZXREdXJhdGlvbnNdKTtcbiAgY29uc3QgZHVyYXRpb25GZXRjaGVkID0gZHVyYXRpb25zW2dldEFic29sdXRlU3JjKHByZWxvYWRlZFNyYyldID8/IGR1cmF0aW9uc1tnZXRBYnNvbHV0ZVNyYyhwcm9wcy5zcmMpXTtcbiAgaWYgKGxvb3AgJiYgZHVyYXRpb25GZXRjaGVkICE9PSB1bmRlZmluZWQpIHtcbiAgICBjb25zdCBkdXJhdGlvbiA9IGR1cmF0aW9uRmV0Y2hlZCAqIGZwcztcbiAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeDE4KExvb3AsIHtcbiAgICAgIGxheW91dDogXCJub25lXCIsXG4gICAgICBkdXJhdGlvbkluRnJhbWVzOiBjYWxjdWxhdGVMb29wRHVyYXRpb24oe1xuICAgICAgICBlbmRBdCxcbiAgICAgICAgbWVkaWFEdXJhdGlvbjogZHVyYXRpb24sXG4gICAgICAgIHBsYXliYWNrUmF0ZTogcHJvcHMucGxheWJhY2tSYXRlID8/IDEsXG4gICAgICAgIHN0YXJ0RnJvbVxuICAgICAgfSksXG4gICAgICBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIGpzeDE4KEF1ZGlvLCB7XG4gICAgICAgIC4uLnByb3BzT3RoZXJUaGFuTG9vcCxcbiAgICAgICAgcmVmLFxuICAgICAgICBfcmVtb3Rpb25JbnRlcm5hbE5hdGl2ZUxvb3BQYXNzZWQ6IHRydWVcbiAgICAgIH0pXG4gICAgfSk7XG4gIH1cbiAgaWYgKHR5cGVvZiBzdGFydEZyb20gIT09IFwidW5kZWZpbmVkXCIgfHwgdHlwZW9mIGVuZEF0ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgdmFsaWRhdGVTdGFydEZyb21Qcm9wcyhzdGFydEZyb20sIGVuZEF0KTtcbiAgICBjb25zdCBzdGFydEZyb21GcmFtZU5vID0gc3RhcnRGcm9tID8/IDA7XG4gICAgY29uc3QgZW5kQXRGcmFtZU5vID0gZW5kQXQgPz8gSW5maW5pdHk7XG4gICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBqc3gxOChTZXF1ZW5jZSwge1xuICAgICAgbGF5b3V0OiBcIm5vbmVcIixcbiAgICAgIGZyb206IDAgLSBzdGFydEZyb21GcmFtZU5vLFxuICAgICAgc2hvd0luVGltZWxpbmU6IGZhbHNlLFxuICAgICAgZHVyYXRpb25JbkZyYW1lczogZW5kQXRGcmFtZU5vLFxuICAgICAgbmFtZSxcbiAgICAgIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8ganN4MTgoQXVkaW8sIHtcbiAgICAgICAgX3JlbW90aW9uSW50ZXJuYWxOZWVkc0R1cmF0aW9uQ2FsY3VsYXRpb246IEJvb2xlYW4obG9vcCksXG4gICAgICAgIHBhdXNlV2hlbkJ1ZmZlcmluZzogcGF1c2VXaGVuQnVmZmVyaW5nID8/IGZhbHNlLFxuICAgICAgICAuLi5vdGhlclByb3BzLFxuICAgICAgICByZWZcbiAgICAgIH0pXG4gICAgfSk7XG4gIH1cbiAgdmFsaWRhdGVNZWRpYVByb3BzKHByb3BzLCBcIkF1ZGlvXCIpO1xuICBpZiAoZW52aXJvbm1lbnQuaXNSZW5kZXJpbmcpIHtcbiAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeDE4KEF1ZGlvRm9yUmVuZGVyaW5nLCB7XG4gICAgICBvbkR1cmF0aW9uLFxuICAgICAgLi4ucHJvcHMsXG4gICAgICByZWYsXG4gICAgICBvbkVycm9yLFxuICAgICAgX3JlbW90aW9uSW50ZXJuYWxOZWVkc0R1cmF0aW9uQ2FsY3VsYXRpb246IEJvb2xlYW4obG9vcClcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeDE4KEF1ZGlvRm9yUHJldmlldywge1xuICAgIF9yZW1vdGlvbkludGVybmFsTmF0aXZlTG9vcFBhc3NlZDogcHJvcHMuX3JlbW90aW9uSW50ZXJuYWxOYXRpdmVMb29wUGFzc2VkID8/IGZhbHNlLFxuICAgIF9yZW1vdGlvbkRlYnVnU2Vla2luZzogX3JlbW90aW9uRGVidWdTZWVraW5nID8/IGZhbHNlLFxuICAgIF9yZW1vdGlvbkludGVybmFsU3RhY2s6IHN0YWNrID8/IG51bGwsXG4gICAgc2hvdWxkUHJlTW91bnRBdWRpb1RhZ3M6IGF1ZGlvQ29udGV4dCAhPT0gbnVsbCAmJiBhdWRpb0NvbnRleHQubnVtYmVyT2ZBdWRpb1RhZ3MgPiAwLFxuICAgIC4uLnByb3BzLFxuICAgIHJlZixcbiAgICBvbkVycm9yLFxuICAgIG9uRHVyYXRpb24sXG4gICAgcGF1c2VXaGVuQnVmZmVyaW5nOiBwYXVzZVdoZW5CdWZmZXJpbmcgPz8gZmFsc2UsXG4gICAgX3JlbW90aW9uSW50ZXJuYWxOZWVkc0R1cmF0aW9uQ2FsY3VsYXRpb246IEJvb2xlYW4obG9vcCksXG4gICAgc2hvd0luVGltZWxpbmU6IHNob3dJblRpbWVsaW5lID8/IHRydWVcbiAgfSk7XG59O1xudmFyIEF1ZGlvID0gZm9yd2FyZFJlZjUoQXVkaW9SZWZGb3J3YXJkaW5nRnVuY3Rpb24pO1xuYWRkU2VxdWVuY2VTdGFja1RyYWNlcyhBdWRpbyk7XG4vLyBzcmMvQ29tcG9zaXRpb24udHN4XG5pbXBvcnQgeyBTdXNwZW5zZSwgdXNlQ29udGV4dCBhcyB1c2VDb250ZXh0MjUsIHVzZUVmZmVjdCBhcyB1c2VFZmZlY3QxOSwgdXNlTWVtbyBhcyB1c2VNZW1vMjQgfSBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7IGNyZWF0ZVBvcnRhbCB9IGZyb20gXCJyZWFjdC1kb21cIjtcblxuLy8gc3JjL0ZvbGRlci50c3hcbmltcG9ydCB7IGNyZWF0ZUNvbnRleHQgYXMgY3JlYXRlQ29udGV4dDE3LCB1c2VDb250ZXh0IGFzIHVzZUNvbnRleHQyNCwgdXNlRWZmZWN0IGFzIHVzZUVmZmVjdDE4LCB1c2VNZW1vIGFzIHVzZU1lbW8yMiB9IGZyb20gXCJyZWFjdFwiO1xuXG4vLyBzcmMvdmFsaWRhdGlvbi92YWxpZGF0ZS1mb2xkZXItbmFtZS50c1xudmFyIGdldFJlZ2V4ID0gKCkgPT4gL14oW2EtekEtWjAtOS1cXHU0RTAwLVxcdTlGRkZdKSskL2c7XG52YXIgaXNGb2xkZXJOYW1lVmFsaWQgPSAobmFtZSkgPT4gbmFtZS5tYXRjaChnZXRSZWdleCgpKTtcbnZhciB2YWxpZGF0ZUZvbGRlck5hbWUgPSAobmFtZSkgPT4ge1xuICBpZiAobmFtZSA9PT0gdW5kZWZpbmVkIHx8IG5hbWUgPT09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiWW91IG11c3QgcGFzcyBhIG5hbWUgdG8gYSA8Rm9sZGVyIC8+LlwiKTtcbiAgfVxuICBpZiAodHlwZW9mIG5hbWUgIT09IFwic3RyaW5nXCIpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBUaGUgXCJuYW1lXCIgeW91IHBhc3MgaW50byA8Rm9sZGVyIC8+IG11c3QgYmUgYSBzdHJpbmcuIEdvdDogJHt0eXBlb2YgbmFtZX1gKTtcbiAgfVxuICBpZiAoIWlzRm9sZGVyTmFtZVZhbGlkKG5hbWUpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBGb2xkZXIgbmFtZSBjYW4gb25seSBjb250YWluIGEteiwgQS1aLCAwLTkgYW5kIC0uIFlvdSBwYXNzZWQgJHtuYW1lfWApO1xuICB9XG59O1xudmFyIGludmFsaWRGb2xkZXJOYW1lRXJyb3JNZXNzYWdlID0gYEZvbGRlciBuYW1lIG11c3QgbWF0Y2ggJHtTdHJpbmcoZ2V0UmVnZXgoKSl9YDtcblxuLy8gc3JjL0ZvbGRlci50c3hcbmltcG9ydCB7IGpzeCBhcyBqc3gxOSB9IGZyb20gXCJyZWFjdC9qc3gtcnVudGltZVwiO1xudmFyIEZvbGRlckNvbnRleHQgPSBjcmVhdGVDb250ZXh0MTcoe1xuICBmb2xkZXJOYW1lOiBudWxsLFxuICBwYXJlbnROYW1lOiBudWxsXG59KTtcbnZhciBGb2xkZXIgPSAoe1xuICBuYW1lLFxuICBjaGlsZHJlblxufSkgPT4ge1xuICBjb25zdCBwYXJlbnQgPSB1c2VDb250ZXh0MjQoRm9sZGVyQ29udGV4dCk7XG4gIGNvbnN0IHsgcmVnaXN0ZXJGb2xkZXIsIHVucmVnaXN0ZXJGb2xkZXIgfSA9IHVzZUNvbnRleHQyNChDb21wb3NpdGlvbk1hbmFnZXIpO1xuICB2YWxpZGF0ZUZvbGRlck5hbWUobmFtZSk7XG4gIGNvbnN0IHBhcmVudE5hbWVBcnIgPSBbcGFyZW50LnBhcmVudE5hbWUsIHBhcmVudC5mb2xkZXJOYW1lXS5maWx0ZXIodHJ1dGh5KTtcbiAgY29uc3QgcGFyZW50TmFtZSA9IHBhcmVudE5hbWVBcnIubGVuZ3RoID09PSAwID8gbnVsbCA6IHBhcmVudE5hbWVBcnIuam9pbihcIi9cIik7XG4gIGNvbnN0IHZhbHVlID0gdXNlTWVtbzIyKCgpID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgZm9sZGVyTmFtZTogbmFtZSxcbiAgICAgIHBhcmVudE5hbWVcbiAgICB9O1xuICB9LCBbbmFtZSwgcGFyZW50TmFtZV0pO1xuICB1c2VFZmZlY3QxOCgoKSA9PiB7XG4gICAgcmVnaXN0ZXJGb2xkZXIobmFtZSwgcGFyZW50TmFtZSk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHVucmVnaXN0ZXJGb2xkZXIobmFtZSwgcGFyZW50TmFtZSk7XG4gICAgfTtcbiAgfSwgW25hbWUsIHBhcmVudC5mb2xkZXJOYW1lLCBwYXJlbnROYW1lLCByZWdpc3RlckZvbGRlciwgdW5yZWdpc3RlckZvbGRlcl0pO1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeDE5KEZvbGRlckNvbnRleHQuUHJvdmlkZXIsIHtcbiAgICB2YWx1ZSxcbiAgICBjaGlsZHJlblxuICB9KTtcbn07XG5cbi8vIHNyYy9sb2FkaW5nLWluZGljYXRvci50c3hcbmltcG9ydCB7IGpzeCBhcyBqc3gyMCwganN4cyBhcyBqc3hzMiB9IGZyb20gXCJyZWFjdC9qc3gtcnVudGltZVwiO1xudmFyIHJvdGF0ZSA9IHtcbiAgdHJhbnNmb3JtOiBgcm90YXRlKDkwZGVnKWBcbn07XG52YXIgSUNPTl9TSVpFID0gNDA7XG52YXIgbGFiZWwgPSB7XG4gIGNvbG9yOiBcIndoaXRlXCIsXG4gIGZvbnRTaXplOiAxNCxcbiAgZm9udEZhbWlseTogXCJzYW5zLXNlcmlmXCJcbn07XG52YXIgY29udGFpbmVyID0ge1xuICBqdXN0aWZ5Q29udGVudDogXCJjZW50ZXJcIixcbiAgYWxpZ25JdGVtczogXCJjZW50ZXJcIlxufTtcbnZhciBMb2FkaW5nID0gKCkgPT4ge1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeHMyKEFic29sdXRlRmlsbCwge1xuICAgIHN0eWxlOiBjb250YWluZXIsXG4gICAgaWQ6IFwicmVtb3Rpb24tY29tcC1sb2FkaW5nXCIsXG4gICAgY2hpbGRyZW46IFtcbiAgICAgIC8qIEBfX1BVUkVfXyAqLyBqc3gyMChcInN0eWxlXCIsIHtcbiAgICAgICAgdHlwZTogXCJ0ZXh0L2Nzc1wiLFxuICAgICAgICBjaGlsZHJlbjogYFxuXHRcdFx0XHRAa2V5ZnJhbWVzIGFuaW0ge1xuXHRcdFx0XHRcdGZyb20ge1xuXHRcdFx0XHRcdFx0b3BhY2l0eTogMFxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR0byB7XG5cdFx0XHRcdFx0XHRvcGFjaXR5OiAxXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdCNyZW1vdGlvbi1jb21wLWxvYWRpbmcge1xuXHRcdFx0XHRcdGFuaW1hdGlvbjogYW5pbSAycztcblx0XHRcdFx0XHRhbmltYXRpb24tZmlsbC1tb2RlOiBmb3J3YXJkcztcblx0XHRcdFx0fVxuXHRcdFx0YFxuICAgICAgfSksXG4gICAgICAvKiBAX19QVVJFX18gKi8ganN4MjAoXCJzdmdcIiwge1xuICAgICAgICB3aWR0aDogSUNPTl9TSVpFLFxuICAgICAgICBoZWlnaHQ6IElDT05fU0laRSxcbiAgICAgICAgdmlld0JveDogXCItMTAwIC0xMDAgNDAwIDQwMFwiLFxuICAgICAgICBzdHlsZTogcm90YXRlLFxuICAgICAgICBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIGpzeDIwKFwicGF0aFwiLCB7XG4gICAgICAgICAgZmlsbDogXCIjNTU1XCIsXG4gICAgICAgICAgc3Ryb2tlOiBcIiM1NTVcIixcbiAgICAgICAgICBzdHJva2VXaWR0aDogXCIxMDBcIixcbiAgICAgICAgICBzdHJva2VMaW5lam9pbjogXCJyb3VuZFwiLFxuICAgICAgICAgIGQ6IFwiTSAyIDE3MiBhIDE5NiAxMDAgMCAwIDAgMTk1IDUgQSAxOTYgMjQwIDAgMCAwIDEwMCAyLjI1OSBBIDE5NiAyNDAgMCAwIDAgMiAxNzIgelwiXG4gICAgICAgIH0pXG4gICAgICB9KSxcbiAgICAgIC8qIEBfX1BVUkVfXyAqLyBqc3hzMihcInBcIiwge1xuICAgICAgICBzdHlsZTogbGFiZWwsXG4gICAgICAgIGNoaWxkcmVuOiBbXG4gICAgICAgICAgXCJSZXNvbHZpbmcgXCIsXG4gICAgICAgICAgXCI8U3VzcGVuc2U+XCIsXG4gICAgICAgICAgXCIuLi5cIlxuICAgICAgICBdXG4gICAgICB9KVxuICAgIF1cbiAgfSk7XG59O1xuXG4vLyBzcmMvcG9ydGFsLW5vZGUudHNcbnZhciBfcG9ydGFsTm9kZSA9IG51bGw7XG52YXIgcG9ydGFsTm9kZSA9ICgpID0+IHtcbiAgaWYgKCFfcG9ydGFsTm9kZSkge1xuICAgIGlmICh0eXBlb2YgZG9jdW1lbnQgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlRyaWVkIHRvIGNhbGwgYW4gQVBJIHRoYXQgb25seSB3b3JrcyBpbiB0aGUgYnJvd3NlciBmcm9tIG91dHNpZGUgdGhlIGJyb3dzZXJcIik7XG4gICAgfVxuICAgIF9wb3J0YWxOb2RlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICBfcG9ydGFsTm9kZS5zdHlsZS5wb3NpdGlvbiA9IFwiYWJzb2x1dGVcIjtcbiAgICBfcG9ydGFsTm9kZS5zdHlsZS50b3AgPSBcIjBweFwiO1xuICAgIF9wb3J0YWxOb2RlLnN0eWxlLmxlZnQgPSBcIjBweFwiO1xuICAgIF9wb3J0YWxOb2RlLnN0eWxlLnJpZ2h0ID0gXCIwcHhcIjtcbiAgICBfcG9ydGFsTm9kZS5zdHlsZS5ib3R0b20gPSBcIjBweFwiO1xuICAgIF9wb3J0YWxOb2RlLnN0eWxlLndpZHRoID0gXCIxMDAlXCI7XG4gICAgX3BvcnRhbE5vZGUuc3R5bGUuaGVpZ2h0ID0gXCIxMDAlXCI7XG4gICAgX3BvcnRhbE5vZGUuc3R5bGUuZGlzcGxheSA9IFwiZmxleFwiO1xuICAgIF9wb3J0YWxOb2RlLnN0eWxlLmZsZXhEaXJlY3Rpb24gPSBcImNvbHVtblwiO1xuICAgIGNvbnN0IGNvbnRhaW5lck5vZGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgIGNvbnRhaW5lck5vZGUuc3R5bGUucG9zaXRpb24gPSBcImZpeGVkXCI7XG4gICAgY29udGFpbmVyTm9kZS5zdHlsZS50b3AgPSAtOTk5OTk5ICsgXCJweFwiO1xuICAgIGNvbnRhaW5lck5vZGUuYXBwZW5kQ2hpbGQoX3BvcnRhbE5vZGUpO1xuICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoY29udGFpbmVyTm9kZSk7XG4gIH1cbiAgcmV0dXJuIF9wb3J0YWxOb2RlO1xufTtcblxuLy8gc3JjL3VzZS1sYXp5LWNvbXBvbmVudC50c1xuaW1wb3J0IFJlYWN0MTYsIHsgdXNlTWVtbyBhcyB1c2VNZW1vMjMgfSBmcm9tIFwicmVhY3RcIjtcbnZhciB1c2VMYXp5Q29tcG9uZW50ID0gKGNvbXBQcm9wcykgPT4ge1xuICBjb25zdCBsYXp5ID0gdXNlTWVtbzIzKCgpID0+IHtcbiAgICBpZiAoXCJsYXp5Q29tcG9uZW50XCIgaW4gY29tcFByb3BzICYmIHR5cGVvZiBjb21wUHJvcHMubGF6eUNvbXBvbmVudCAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIFJlYWN0MTYubGF6eShjb21wUHJvcHMubGF6eUNvbXBvbmVudCk7XG4gICAgfVxuICAgIGlmIChcImNvbXBvbmVudFwiIGluIGNvbXBQcm9wcykge1xuICAgICAgaWYgKHR5cGVvZiBkb2N1bWVudCA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICByZXR1cm4gY29tcFByb3BzLmNvbXBvbmVudDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBSZWFjdDE2LmxhenkoKCkgPT4gUHJvbWlzZS5yZXNvbHZlKHsgZGVmYXVsdDogY29tcFByb3BzLmNvbXBvbmVudCB9KSk7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihcIllvdSBtdXN0IHBhc3MgZWl0aGVyICdjb21wb25lbnQnIG9yICdsYXp5Q29tcG9uZW50J1wiKTtcbiAgfSwgW2NvbXBQcm9wcy5jb21wb25lbnQsIGNvbXBQcm9wcy5sYXp5Q29tcG9uZW50XSk7XG4gIHJldHVybiBsYXp5O1xufTtcblxuLy8gc3JjL3ZhbGlkYXRpb24vdmFsaWRhdGUtY29tcG9zaXRpb24taWQudHNcbnZhciBnZXRSZWdleDIgPSAoKSA9PiAvXihbYS16QS1aMC05LVxcdTRFMDAtXFx1OUZGRl0pKyQvZztcbnZhciBpc0NvbXBvc2l0aW9uSWRWYWxpZCA9IChpZCkgPT4gaWQubWF0Y2goZ2V0UmVnZXgyKCkpO1xudmFyIHZhbGlkYXRlQ29tcG9zaXRpb25JZCA9IChpZCkgPT4ge1xuICBpZiAoIWlzQ29tcG9zaXRpb25JZFZhbGlkKGlkKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgQ29tcG9zaXRpb24gaWQgY2FuIG9ubHkgY29udGFpbiBhLXosIEEtWiwgMC05LCBDSksgY2hhcmFjdGVycyBhbmQgLS4gWW91IHBhc3NlZCAke2lkfWApO1xuICB9XG59O1xudmFyIGludmFsaWRDb21wb3NpdGlvbkVycm9yTWVzc2FnZSA9IGBDb21wb3NpdGlvbiBJRCBtdXN0IG1hdGNoICR7U3RyaW5nKGdldFJlZ2V4MigpKX1gO1xuXG4vLyBzcmMvdmFsaWRhdGlvbi92YWxpZGF0ZS1kZWZhdWx0LXByb3BzLnRzXG52YXIgdmFsaWRhdGVEZWZhdWx0QW5kSW5wdXRQcm9wcyA9IChkZWZhdWx0UHJvcHMsIG5hbWUsIGNvbXBvc2l0aW9uSWQpID0+IHtcbiAgaWYgKCFkZWZhdWx0UHJvcHMpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKHR5cGVvZiBkZWZhdWx0UHJvcHMgIT09IFwib2JqZWN0XCIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFwiJHtuYW1lfVwiIG11c3QgYmUgYW4gb2JqZWN0LCBidXQgeW91IHBhc3NlZCBhIHZhbHVlIG9mIHR5cGUgJHt0eXBlb2YgZGVmYXVsdFByb3BzfWApO1xuICB9XG4gIGlmIChBcnJheS5pc0FycmF5KGRlZmF1bHRQcm9wcykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFwiJHtuYW1lfVwiIG11c3QgYmUgYW4gb2JqZWN0LCBhbiBhcnJheSB3YXMgcGFzc2VkICR7Y29tcG9zaXRpb25JZCA/IGBmb3IgY29tcG9zaXRpb24gXCIke2NvbXBvc2l0aW9uSWR9XCJgIDogXCJcIn1gKTtcbiAgfVxufTtcblxuLy8gc3JjL0NvbXBvc2l0aW9uLnRzeFxuaW1wb3J0IHsganN4IGFzIGpzeDIxIH0gZnJvbSBcInJlYWN0L2pzeC1ydW50aW1lXCI7XG52YXIgQ2xpcENvbXBvc2l0aW9uID0gKHsgY2hpbGRyZW4gfSkgPT4ge1xuICBjb25zdCB7IGNsaXBSZWdpb24gfSA9IHVzZUNvbnRleHQyNShOYXRpdmVMYXllcnNDb250ZXh0KTtcbiAgY29uc3Qgc3R5bGUgPSB1c2VNZW1vMjQoKCkgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICBkaXNwbGF5OiBcImZsZXhcIixcbiAgICAgIGZsZXhEaXJlY3Rpb246IFwicm93XCIsXG4gICAgICBvcGFjaXR5OiBjbGlwUmVnaW9uID09PSBcImhpZGVcIiA/IDAgOiAxLFxuICAgICAgY2xpcFBhdGg6IGNsaXBSZWdpb24gJiYgY2xpcFJlZ2lvbiAhPT0gXCJoaWRlXCIgPyBgcG9seWdvbigke2NsaXBSZWdpb24ueH1weCAke2NsaXBSZWdpb24ueX1weCwgJHtjbGlwUmVnaW9uLnh9cHggJHtjbGlwUmVnaW9uLmhlaWdodCArIGNsaXBSZWdpb24ueX1weCwgJHtjbGlwUmVnaW9uLndpZHRoICsgY2xpcFJlZ2lvbi54fXB4ICR7Y2xpcFJlZ2lvbi5oZWlnaHQgKyBjbGlwUmVnaW9uLnl9cHgsICR7Y2xpcFJlZ2lvbi53aWR0aCArIGNsaXBSZWdpb24ueH1weCAke2NsaXBSZWdpb24ueX1weClgIDogdW5kZWZpbmVkXG4gICAgfTtcbiAgfSwgW2NsaXBSZWdpb25dKTtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBqc3gyMShBYnNvbHV0ZUZpbGwsIHtcbiAgICBzdHlsZSxcbiAgICBjaGlsZHJlblxuICB9KTtcbn07XG52YXIgRmFsbGJhY2sgPSAoKSA9PiB7XG4gIHVzZUVmZmVjdDE5KCgpID0+IHtcbiAgICBjb25zdCBmYWxsYmFjayA9IGRlbGF5UmVuZGVyKFwiV2FpdGluZyBmb3IgUm9vdCBjb21wb25lbnQgdG8gdW5zdXNwZW5kXCIpO1xuICAgIHJldHVybiAoKSA9PiBjb250aW51ZVJlbmRlcihmYWxsYmFjayk7XG4gIH0sIFtdKTtcbiAgcmV0dXJuIG51bGw7XG59O1xudmFyIENvbXBvc2l0aW9uID0gKHtcbiAgd2lkdGgsXG4gIGhlaWdodCxcbiAgZnBzLFxuICBkdXJhdGlvbkluRnJhbWVzLFxuICBpZCxcbiAgZGVmYXVsdFByb3BzLFxuICBzY2hlbWEsXG4gIC4uLmNvbXBQcm9wc1xufSkgPT4ge1xuICBjb25zdCB7IHJlZ2lzdGVyQ29tcG9zaXRpb24sIHVucmVnaXN0ZXJDb21wb3NpdGlvbiB9ID0gdXNlQ29udGV4dDI1KENvbXBvc2l0aW9uTWFuYWdlcik7XG4gIGNvbnN0IHZpZGVvID0gdXNlVmlkZW8oKTtcbiAgY29uc3QgbGF6eSA9IHVzZUxhenlDb21wb25lbnQoY29tcFByb3BzKTtcbiAgY29uc3Qgbm9uY2UgPSB1c2VOb25jZSgpO1xuICBjb25zdCBpc1BsYXllciA9IHVzZUlzUGxheWVyKCk7XG4gIGNvbnN0IGVudmlyb25tZW50ID0gZ2V0UmVtb3Rpb25FbnZpcm9ubWVudCgpO1xuICBjb25zdCBjYW5Vc2VDb21wb3NpdGlvbiA9IHVzZUNvbnRleHQyNShDYW5Vc2VSZW1vdGlvbkhvb2tzKTtcbiAgaWYgKGNhblVzZUNvbXBvc2l0aW9uKSB7XG4gICAgaWYgKGlzUGxheWVyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCI8Q29tcG9zaXRpb24+IHdhcyBtb3VudGVkIGluc2lkZSB0aGUgYGNvbXBvbmVudGAgdGhhdCB3YXMgcGFzc2VkIHRvIHRoZSA8UGxheWVyPi4gU2VlIGh0dHBzOi8vcmVtb3Rpb24uZGV2L2RvY3Mvd3JvbmctY29tcG9zaXRpb24tbW91bnQgZm9yIGhlbHAuXCIpO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoXCI8Q29tcG9zaXRpb24+IG1vdW50ZWQgaW5zaWRlIGFub3RoZXIgY29tcG9zaXRpb24uIFNlZSBodHRwczovL3JlbW90aW9uLmRldi9kb2NzL3dyb25nLWNvbXBvc2l0aW9uLW1vdW50IGZvciBoZWxwLlwiKTtcbiAgfVxuICBjb25zdCB7IGZvbGRlck5hbWUsIHBhcmVudE5hbWUgfSA9IHVzZUNvbnRleHQyNShGb2xkZXJDb250ZXh0KTtcbiAgdXNlRWZmZWN0MTkoKCkgPT4ge1xuICAgIGlmICghaWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIGlkIGZvciBjb21wb3NpdGlvbiBwYXNzZWQuXCIpO1xuICAgIH1cbiAgICB2YWxpZGF0ZUNvbXBvc2l0aW9uSWQoaWQpO1xuICAgIHZhbGlkYXRlRGVmYXVsdEFuZElucHV0UHJvcHMoZGVmYXVsdFByb3BzLCBcImRlZmF1bHRQcm9wc1wiLCBpZCk7XG4gICAgcmVnaXN0ZXJDb21wb3NpdGlvbih7XG4gICAgICBkdXJhdGlvbkluRnJhbWVzOiBkdXJhdGlvbkluRnJhbWVzID8/IHVuZGVmaW5lZCxcbiAgICAgIGZwczogZnBzID8/IHVuZGVmaW5lZCxcbiAgICAgIGhlaWdodDogaGVpZ2h0ID8/IHVuZGVmaW5lZCxcbiAgICAgIHdpZHRoOiB3aWR0aCA/PyB1bmRlZmluZWQsXG4gICAgICBpZCxcbiAgICAgIGZvbGRlck5hbWUsXG4gICAgICBjb21wb25lbnQ6IGxhenksXG4gICAgICBkZWZhdWx0UHJvcHM6IHNlcmlhbGl6ZVRoZW5EZXNlcmlhbGl6ZUluU3R1ZGlvKGRlZmF1bHRQcm9wcyA/PyB7fSksXG4gICAgICBub25jZSxcbiAgICAgIHBhcmVudEZvbGRlck5hbWU6IHBhcmVudE5hbWUsXG4gICAgICBzY2hlbWE6IHNjaGVtYSA/PyBudWxsLFxuICAgICAgY2FsY3VsYXRlTWV0YWRhdGE6IGNvbXBQcm9wcy5jYWxjdWxhdGVNZXRhZGF0YSA/PyBudWxsXG4gICAgfSk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHVucmVnaXN0ZXJDb21wb3NpdGlvbihpZCk7XG4gICAgfTtcbiAgfSwgW1xuICAgIGR1cmF0aW9uSW5GcmFtZXMsXG4gICAgZnBzLFxuICAgIGhlaWdodCxcbiAgICBsYXp5LFxuICAgIGlkLFxuICAgIGZvbGRlck5hbWUsXG4gICAgZGVmYXVsdFByb3BzLFxuICAgIHJlZ2lzdGVyQ29tcG9zaXRpb24sXG4gICAgdW5yZWdpc3RlckNvbXBvc2l0aW9uLFxuICAgIHdpZHRoLFxuICAgIG5vbmNlLFxuICAgIHBhcmVudE5hbWUsXG4gICAgc2NoZW1hLFxuICAgIGNvbXBQcm9wcy5jYWxjdWxhdGVNZXRhZGF0YVxuICBdKTtcbiAgY29uc3QgcmVzb2x2ZWQgPSB1c2VSZXNvbHZlZFZpZGVvQ29uZmlnKGlkKTtcbiAgaWYgKGVudmlyb25tZW50LmlzU3R1ZGlvICYmIHZpZGVvICYmIHZpZGVvLmNvbXBvbmVudCA9PT0gbGF6eSkge1xuICAgIGNvbnN0IENvbXAgPSBsYXp5O1xuICAgIGlmIChyZXNvbHZlZCA9PT0gbnVsbCB8fCByZXNvbHZlZC50eXBlICE9PSBcInN1Y2Nlc3NcIikge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVQb3J0YWwoLyogQF9fUFVSRV9fICovIGpzeDIxKENsaXBDb21wb3NpdGlvbiwge1xuICAgICAgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBqc3gyMShDYW5Vc2VSZW1vdGlvbkhvb2tzUHJvdmlkZXIsIHtcbiAgICAgICAgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBqc3gyMShTdXNwZW5zZSwge1xuICAgICAgICAgIGZhbGxiYWNrOiAvKiBAX19QVVJFX18gKi8ganN4MjEoTG9hZGluZywge30pLFxuICAgICAgICAgIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8ganN4MjEoQ29tcCwge1xuICAgICAgICAgICAgLi4ucmVzb2x2ZWQucmVzdWx0LnByb3BzID8/IHt9XG4gICAgICAgICAgfSlcbiAgICAgICAgfSlcbiAgICAgIH0pXG4gICAgfSksIHBvcnRhbE5vZGUoKSk7XG4gIH1cbiAgaWYgKGVudmlyb25tZW50LmlzUmVuZGVyaW5nICYmIHZpZGVvICYmIHZpZGVvLmNvbXBvbmVudCA9PT0gbGF6eSkge1xuICAgIGNvbnN0IENvbXAgPSBsYXp5O1xuICAgIGlmIChyZXNvbHZlZCA9PT0gbnVsbCB8fCByZXNvbHZlZC50eXBlICE9PSBcInN1Y2Nlc3NcIikge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVQb3J0YWwoLyogQF9fUFVSRV9fICovIGpzeDIxKENhblVzZVJlbW90aW9uSG9va3NQcm92aWRlciwge1xuICAgICAgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBqc3gyMShTdXNwZW5zZSwge1xuICAgICAgICBmYWxsYmFjazogLyogQF9fUFVSRV9fICovIGpzeDIxKEZhbGxiYWNrLCB7fSksXG4gICAgICAgIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8ganN4MjEoQ29tcCwge1xuICAgICAgICAgIC4uLnJlc29sdmVkLnJlc3VsdC5wcm9wcyA/PyB7fVxuICAgICAgICB9KVxuICAgICAgfSlcbiAgICB9KSwgcG9ydGFsTm9kZSgpKTtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn07XG4vLyBzcmMvQ29tcG9zaXRpb25NYW5hZ2VyLnRzeFxuaW1wb3J0IFJlYWN0MTgsIHtcbiAgdXNlQ2FsbGJhY2sgYXMgdXNlQ2FsbGJhY2sxMCxcbiAgdXNlSW1wZXJhdGl2ZUhhbmRsZSBhcyB1c2VJbXBlcmF0aXZlSGFuZGxlNSxcbiAgdXNlTWVtbyBhcyB1c2VNZW1vMjUsXG4gIHVzZVJlZiBhcyB1c2VSZWYxMCxcbiAgdXNlU3RhdGUgYXMgdXNlU3RhdGUxNVxufSBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7IGpzeCBhcyBqc3gyMiB9IGZyb20gXCJyZWFjdC9qc3gtcnVudGltZVwiO1xudmFyIGNvbXBvc2l0aW9uc1JlZiA9IFJlYWN0MTguY3JlYXRlUmVmKCk7XG52YXIgQ29tcG9zaXRpb25NYW5hZ2VyUHJvdmlkZXIgPSAoeyBjaGlsZHJlbiwgbnVtYmVyT2ZBdWRpb1RhZ3MgfSkgPT4ge1xuICBjb25zdCBbY29tcG9zaXRpb25zLCBzZXRDb21wb3NpdGlvbnNdID0gdXNlU3RhdGUxNShbXSk7XG4gIGNvbnN0IGN1cnJlbnRjb21wb3NpdGlvbnNSZWYgPSB1c2VSZWYxMChjb21wb3NpdGlvbnMpO1xuICBjb25zdCBbZm9sZGVycywgc2V0Rm9sZGVyc10gPSB1c2VTdGF0ZTE1KFtdKTtcbiAgY29uc3QgW2NhbnZhc0NvbnRlbnQsIHNldENhbnZhc0NvbnRlbnRdID0gdXNlU3RhdGUxNShudWxsKTtcbiAgY29uc3QgW2N1cnJlbnRDb21wb3NpdGlvbk1ldGFkYXRhLCBzZXRDdXJyZW50Q29tcG9zaXRpb25NZXRhZGF0YV0gPSB1c2VTdGF0ZTE1KG51bGwpO1xuICBjb25zdCB1cGRhdGVDb21wb3NpdGlvbnMgPSB1c2VDYWxsYmFjazEwKCh1cGRhdGVDb21wcykgPT4ge1xuICAgIHNldENvbXBvc2l0aW9ucygoY29tcHMpID0+IHtcbiAgICAgIGNvbnN0IHVwZGF0ZWQgPSB1cGRhdGVDb21wcyhjb21wcyk7XG4gICAgICBjdXJyZW50Y29tcG9zaXRpb25zUmVmLmN1cnJlbnQgPSB1cGRhdGVkO1xuICAgICAgcmV0dXJuIHVwZGF0ZWQ7XG4gICAgfSk7XG4gIH0sIFtdKTtcbiAgY29uc3QgcmVnaXN0ZXJDb21wb3NpdGlvbiA9IHVzZUNhbGxiYWNrMTAoKGNvbXApID0+IHtcbiAgICB1cGRhdGVDb21wb3NpdGlvbnMoKGNvbXBzKSA9PiB7XG4gICAgICBpZiAoY29tcHMuZmluZCgoYykgPT4gYy5pZCA9PT0gY29tcC5pZCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBNdWx0aXBsZSBjb21wb3NpdGlvbiB3aXRoIGlkICR7Y29tcC5pZH0gYXJlIHJlZ2lzdGVyZWQuYCk7XG4gICAgICB9XG4gICAgICBjb25zdCB2YWx1ZSA9IFsuLi5jb21wcywgY29tcF0uc2xpY2UoKS5zb3J0KChhLCBiKSA9PiBhLm5vbmNlIC0gYi5ub25jZSk7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfSk7XG4gIH0sIFt1cGRhdGVDb21wb3NpdGlvbnNdKTtcbiAgY29uc3QgdW5yZWdpc3RlckNvbXBvc2l0aW9uID0gdXNlQ2FsbGJhY2sxMCgoaWQpID0+IHtcbiAgICBzZXRDb21wb3NpdGlvbnMoKGNvbXBzKSA9PiB7XG4gICAgICByZXR1cm4gY29tcHMuZmlsdGVyKChjKSA9PiBjLmlkICE9PSBpZCk7XG4gICAgfSk7XG4gIH0sIFtdKTtcbiAgY29uc3QgcmVnaXN0ZXJGb2xkZXIgPSB1c2VDYWxsYmFjazEwKChuYW1lLCBwYXJlbnQpID0+IHtcbiAgICBzZXRGb2xkZXJzKChwcmV2Rm9sZGVycykgPT4ge1xuICAgICAgcmV0dXJuIFtcbiAgICAgICAgLi4ucHJldkZvbGRlcnMsXG4gICAgICAgIHtcbiAgICAgICAgICBuYW1lLFxuICAgICAgICAgIHBhcmVudFxuICAgICAgICB9XG4gICAgICBdO1xuICAgIH0pO1xuICB9LCBbXSk7XG4gIGNvbnN0IHVucmVnaXN0ZXJGb2xkZXIgPSB1c2VDYWxsYmFjazEwKChuYW1lLCBwYXJlbnQpID0+IHtcbiAgICBzZXRGb2xkZXJzKChwcmV2Rm9sZGVycykgPT4ge1xuICAgICAgcmV0dXJuIHByZXZGb2xkZXJzLmZpbHRlcigocCkgPT4gIShwLm5hbWUgPT09IG5hbWUgJiYgcC5wYXJlbnQgPT09IHBhcmVudCkpO1xuICAgIH0pO1xuICB9LCBbXSk7XG4gIHVzZUltcGVyYXRpdmVIYW5kbGU1KGNvbXBvc2l0aW9uc1JlZiwgKCkgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICBnZXRDb21wb3NpdGlvbnM6ICgpID0+IGN1cnJlbnRjb21wb3NpdGlvbnNSZWYuY3VycmVudFxuICAgIH07XG4gIH0sIFtdKTtcbiAgY29uc3QgY29tcG9zaXRpb24gPSBjb21wb3NpdGlvbnMuZmluZCgoYykgPT4gY2FudmFzQ29udGVudD8udHlwZSA9PT0gXCJjb21wb3NpdGlvblwiID8gYy5pZCA9PT0gY2FudmFzQ29udGVudC5jb21wb3NpdGlvbklkIDogbnVsbCk7XG4gIGNvbnN0IHVwZGF0ZUNvbXBvc2l0aW9uRGVmYXVsdFByb3BzID0gdXNlQ2FsbGJhY2sxMCgoaWQsIG5ld0RlZmF1bHRQcm9wcykgPT4ge1xuICAgIHNldENvbXBvc2l0aW9ucygoY29tcHMpID0+IHtcbiAgICAgIGNvbnN0IHVwZGF0ZWQgPSBjb21wcy5tYXAoKGMpID0+IHtcbiAgICAgICAgaWYgKGMuaWQgPT09IGlkKSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLmMsXG4gICAgICAgICAgICBkZWZhdWx0UHJvcHM6IG5ld0RlZmF1bHRQcm9wc1xuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGM7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiB1cGRhdGVkO1xuICAgIH0pO1xuICB9LCBbXSk7XG4gIGNvbnN0IGNvbnRleHRWYWx1ZSA9IHVzZU1lbW8yNSgoKSA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNvbXBvc2l0aW9ucyxcbiAgICAgIHJlZ2lzdGVyQ29tcG9zaXRpb24sXG4gICAgICB1bnJlZ2lzdGVyQ29tcG9zaXRpb24sXG4gICAgICBmb2xkZXJzLFxuICAgICAgcmVnaXN0ZXJGb2xkZXIsXG4gICAgICB1bnJlZ2lzdGVyRm9sZGVyLFxuICAgICAgY3VycmVudENvbXBvc2l0aW9uTWV0YWRhdGEsXG4gICAgICBzZXRDdXJyZW50Q29tcG9zaXRpb25NZXRhZGF0YSxcbiAgICAgIGNhbnZhc0NvbnRlbnQsXG4gICAgICBzZXRDYW52YXNDb250ZW50LFxuICAgICAgdXBkYXRlQ29tcG9zaXRpb25EZWZhdWx0UHJvcHNcbiAgICB9O1xuICB9LCBbXG4gICAgY29tcG9zaXRpb25zLFxuICAgIHJlZ2lzdGVyQ29tcG9zaXRpb24sXG4gICAgdW5yZWdpc3RlckNvbXBvc2l0aW9uLFxuICAgIGZvbGRlcnMsXG4gICAgcmVnaXN0ZXJGb2xkZXIsXG4gICAgdW5yZWdpc3RlckZvbGRlcixcbiAgICBjdXJyZW50Q29tcG9zaXRpb25NZXRhZGF0YSxcbiAgICBjYW52YXNDb250ZW50LFxuICAgIHVwZGF0ZUNvbXBvc2l0aW9uRGVmYXVsdFByb3BzXG4gIF0pO1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeDIyKENvbXBvc2l0aW9uTWFuYWdlci5Qcm92aWRlciwge1xuICAgIHZhbHVlOiBjb250ZXh0VmFsdWUsXG4gICAgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBqc3gyMihTZXF1ZW5jZU1hbmFnZXJQcm92aWRlciwge1xuICAgICAgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBqc3gyMihSZW5kZXJBc3NldE1hbmFnZXJQcm92aWRlciwge1xuICAgICAgICBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIGpzeDIyKFJlc29sdmVDb21wb3NpdGlvbkNvbmZpZywge1xuICAgICAgICAgIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8ganN4MjIoU2hhcmVkQXVkaW9Db250ZXh0UHJvdmlkZXIsIHtcbiAgICAgICAgICAgIG51bWJlck9mQXVkaW9UYWdzLFxuICAgICAgICAgICAgY29tcG9uZW50OiBjb21wb3NpdGlvbj8uY29tcG9uZW50ID8/IG51bGwsXG4gICAgICAgICAgICBjaGlsZHJlblxuICAgICAgICAgIH0pXG4gICAgICAgIH0pXG4gICAgICB9KVxuICAgIH0pXG4gIH0pO1xufTtcbi8vIHNyYy9iZXppZXIudHNcbmZ1bmN0aW9uIGEoYUExLCBhQTIpIHtcbiAgcmV0dXJuIDEgLSAzICogYUEyICsgMyAqIGFBMTtcbn1cbmZ1bmN0aW9uIGIoYUExLCBhQTIpIHtcbiAgcmV0dXJuIDMgKiBhQTIgLSA2ICogYUExO1xufVxuZnVuY3Rpb24gYyhhQTEpIHtcbiAgcmV0dXJuIDMgKiBhQTE7XG59XG5mdW5jdGlvbiBjYWxjQmV6aWVyKGFULCBhQTEsIGFBMikge1xuICByZXR1cm4gKChhKGFBMSwgYUEyKSAqIGFUICsgYihhQTEsIGFBMikpICogYVQgKyBjKGFBMSkpICogYVQ7XG59XG5mdW5jdGlvbiBnZXRTbG9wZShhVCwgYUExLCBhQTIpIHtcbiAgcmV0dXJuIDMgKiBhKGFBMSwgYUEyKSAqIGFUICogYVQgKyAyICogYihhQTEsIGFBMikgKiBhVCArIGMoYUExKTtcbn1cbmZ1bmN0aW9uIGJpbmFyeVN1YmRpdmlkZSh7XG4gIGFYLFxuICBfYUEsXG4gIF9hQixcbiAgbVgxLFxuICBtWDJcbn0pIHtcbiAgbGV0IGN1cnJlbnRYO1xuICBsZXQgY3VycmVudFQ7XG4gIGxldCBpID0gMDtcbiAgbGV0IGFBID0gX2FBO1xuICBsZXQgYUIgPSBfYUI7XG4gIGRvIHtcbiAgICBjdXJyZW50VCA9IGFBICsgKGFCIC0gYUEpIC8gMjtcbiAgICBjdXJyZW50WCA9IGNhbGNCZXppZXIoY3VycmVudFQsIG1YMSwgbVgyKSAtIGFYO1xuICAgIGlmIChjdXJyZW50WCA+IDApIHtcbiAgICAgIGFCID0gY3VycmVudFQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFBID0gY3VycmVudFQ7XG4gICAgfVxuICB9IHdoaWxlIChNYXRoLmFicyhjdXJyZW50WCkgPiBTVUJESVZJU0lPTl9QUkVDSVNJT04gJiYgKytpIDwgU1VCRElWSVNJT05fTUFYX0lURVJBVElPTlMpO1xuICByZXR1cm4gY3VycmVudFQ7XG59XG5mdW5jdGlvbiBuZXd0b25SYXBoc29uSXRlcmF0ZShhWCwgX2FHdWVzc1QsIG1YMSwgbVgyKSB7XG4gIGxldCBhR3Vlc3NUID0gX2FHdWVzc1Q7XG4gIGZvciAobGV0IGkgPSAwO2kgPCBORVdUT05fSVRFUkFUSU9OUzsgKytpKSB7XG4gICAgY29uc3QgY3VycmVudFNsb3BlID0gZ2V0U2xvcGUoYUd1ZXNzVCwgbVgxLCBtWDIpO1xuICAgIGlmIChjdXJyZW50U2xvcGUgPT09IDApIHtcbiAgICAgIHJldHVybiBhR3Vlc3NUO1xuICAgIH1cbiAgICBjb25zdCBjdXJyZW50WCA9IGNhbGNCZXppZXIoYUd1ZXNzVCwgbVgxLCBtWDIpIC0gYVg7XG4gICAgYUd1ZXNzVCAtPSBjdXJyZW50WCAvIGN1cnJlbnRTbG9wZTtcbiAgfVxuICByZXR1cm4gYUd1ZXNzVDtcbn1cbmZ1bmN0aW9uIGJlemllcihtWDEsIG1ZMSwgbVgyLCBtWTIpIHtcbiAgaWYgKCEobVgxID49IDAgJiYgbVgxIDw9IDEgJiYgbVgyID49IDAgJiYgbVgyIDw9IDEpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiYmV6aWVyIHggdmFsdWVzIG11c3QgYmUgaW4gWzAsIDFdIHJhbmdlXCIpO1xuICB9XG4gIGNvbnN0IHNhbXBsZVZhbHVlcyA9IGZsb2F0MzJBcnJheVN1cHBvcnRlZCA/IG5ldyBGbG9hdDMyQXJyYXkoa1NwbGluZVRhYmxlU2l6ZSkgOiBuZXcgQXJyYXkoa1NwbGluZVRhYmxlU2l6ZSk7XG4gIGlmIChtWDEgIT09IG1ZMSB8fCBtWDIgIT09IG1ZMikge1xuICAgIGZvciAobGV0IGkgPSAwO2kgPCBrU3BsaW5lVGFibGVTaXplOyArK2kpIHtcbiAgICAgIHNhbXBsZVZhbHVlc1tpXSA9IGNhbGNCZXppZXIoaSAqIGtTYW1wbGVTdGVwU2l6ZSwgbVgxLCBtWDIpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBnZXRURm9yWChhWCkge1xuICAgIGxldCBpbnRlcnZhbFN0YXJ0ID0gMDtcbiAgICBsZXQgY3VycmVudFNhbXBsZSA9IDE7XG4gICAgY29uc3QgbGFzdFNhbXBsZSA9IGtTcGxpbmVUYWJsZVNpemUgLSAxO1xuICAgIGZvciAoO2N1cnJlbnRTYW1wbGUgIT09IGxhc3RTYW1wbGUgJiYgc2FtcGxlVmFsdWVzW2N1cnJlbnRTYW1wbGVdIDw9IGFYOyArK2N1cnJlbnRTYW1wbGUpIHtcbiAgICAgIGludGVydmFsU3RhcnQgKz0ga1NhbXBsZVN0ZXBTaXplO1xuICAgIH1cbiAgICAtLWN1cnJlbnRTYW1wbGU7XG4gICAgY29uc3QgZGlzdCA9IChhWCAtIHNhbXBsZVZhbHVlc1tjdXJyZW50U2FtcGxlXSkgLyAoc2FtcGxlVmFsdWVzW2N1cnJlbnRTYW1wbGUgKyAxXSAtIHNhbXBsZVZhbHVlc1tjdXJyZW50U2FtcGxlXSk7XG4gICAgY29uc3QgZ3Vlc3NGb3JUID0gaW50ZXJ2YWxTdGFydCArIGRpc3QgKiBrU2FtcGxlU3RlcFNpemU7XG4gICAgY29uc3QgaW5pdGlhbFNsb3BlID0gZ2V0U2xvcGUoZ3Vlc3NGb3JULCBtWDEsIG1YMik7XG4gICAgaWYgKGluaXRpYWxTbG9wZSA+PSBORVdUT05fTUlOX1NMT1BFKSB7XG4gICAgICByZXR1cm4gbmV3dG9uUmFwaHNvbkl0ZXJhdGUoYVgsIGd1ZXNzRm9yVCwgbVgxLCBtWDIpO1xuICAgIH1cbiAgICBpZiAoaW5pdGlhbFNsb3BlID09PSAwKSB7XG4gICAgICByZXR1cm4gZ3Vlc3NGb3JUO1xuICAgIH1cbiAgICByZXR1cm4gYmluYXJ5U3ViZGl2aWRlKHtcbiAgICAgIGFYLFxuICAgICAgX2FBOiBpbnRlcnZhbFN0YXJ0LFxuICAgICAgX2FCOiBpbnRlcnZhbFN0YXJ0ICsga1NhbXBsZVN0ZXBTaXplLFxuICAgICAgbVgxLFxuICAgICAgbVgyXG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIGZ1bmN0aW9uKHgpIHtcbiAgICBpZiAobVgxID09PSBtWTEgJiYgbVgyID09PSBtWTIpIHtcbiAgICAgIHJldHVybiB4O1xuICAgIH1cbiAgICBpZiAoeCA9PT0gMCkge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIGlmICh4ID09PSAxKSB7XG4gICAgICByZXR1cm4gMTtcbiAgICB9XG4gICAgcmV0dXJuIGNhbGNCZXppZXIoZ2V0VEZvclgoeCksIG1ZMSwgbVkyKTtcbiAgfTtcbn1cbnZhciBORVdUT05fSVRFUkFUSU9OUyA9IDQ7XG52YXIgTkVXVE9OX01JTl9TTE9QRSA9IDAuMDAxO1xudmFyIFNVQkRJVklTSU9OX1BSRUNJU0lPTiA9IDAuMDAwMDAwMTtcbnZhciBTVUJESVZJU0lPTl9NQVhfSVRFUkFUSU9OUyA9IDEwO1xudmFyIGtTcGxpbmVUYWJsZVNpemUgPSAxMTtcbnZhciBrU2FtcGxlU3RlcFNpemUgPSAxIC8gKGtTcGxpbmVUYWJsZVNpemUgLSAxKTtcbnZhciBmbG9hdDMyQXJyYXlTdXBwb3J0ZWQgPSB0eXBlb2YgRmxvYXQzMkFycmF5ID09PSBcImZ1bmN0aW9uXCI7XG5cbi8vIHNyYy9lYXNpbmcudHNcbmNsYXNzIEVhc2luZyB7XG4gIHN0YXRpYyBzdGVwMChuKSB7XG4gICAgcmV0dXJuIG4gPiAwID8gMSA6IDA7XG4gIH1cbiAgc3RhdGljIHN0ZXAxKG4pIHtcbiAgICByZXR1cm4gbiA+PSAxID8gMSA6IDA7XG4gIH1cbiAgc3RhdGljIGxpbmVhcih0KSB7XG4gICAgcmV0dXJuIHQ7XG4gIH1cbiAgc3RhdGljIGVhc2UodCkge1xuICAgIHJldHVybiBFYXNpbmcuYmV6aWVyKDAuNDIsIDAsIDEsIDEpKHQpO1xuICB9XG4gIHN0YXRpYyBxdWFkKHQpIHtcbiAgICByZXR1cm4gdCAqIHQ7XG4gIH1cbiAgc3RhdGljIGN1YmljKHQpIHtcbiAgICByZXR1cm4gdCAqIHQgKiB0O1xuICB9XG4gIHN0YXRpYyBwb2x5KG4pIHtcbiAgICByZXR1cm4gKHQpID0+IHQgKiogbjtcbiAgfVxuICBzdGF0aWMgc2luKHQpIHtcbiAgICByZXR1cm4gMSAtIE1hdGguY29zKHQgKiBNYXRoLlBJIC8gMik7XG4gIH1cbiAgc3RhdGljIGNpcmNsZSh0KSB7XG4gICAgcmV0dXJuIDEgLSBNYXRoLnNxcnQoMSAtIHQgKiB0KTtcbiAgfVxuICBzdGF0aWMgZXhwKHQpIHtcbiAgICByZXR1cm4gMiAqKiAoMTAgKiAodCAtIDEpKTtcbiAgfVxuICBzdGF0aWMgZWxhc3RpYyhib3VuY2luZXNzID0gMSkge1xuICAgIGNvbnN0IHAgPSBib3VuY2luZXNzICogTWF0aC5QSTtcbiAgICByZXR1cm4gKHQpID0+IDEgLSBNYXRoLmNvcyh0ICogTWF0aC5QSSAvIDIpICoqIDMgKiBNYXRoLmNvcyh0ICogcCk7XG4gIH1cbiAgc3RhdGljIGJhY2socyA9IDEuNzAxNTgpIHtcbiAgICByZXR1cm4gKHQpID0+IHQgKiB0ICogKChzICsgMSkgKiB0IC0gcyk7XG4gIH1cbiAgc3RhdGljIGJvdW5jZSh0KSB7XG4gICAgaWYgKHQgPCAxIC8gMi43NSkge1xuICAgICAgcmV0dXJuIDcuNTYyNSAqIHQgKiB0O1xuICAgIH1cbiAgICBpZiAodCA8IDIgLyAyLjc1KSB7XG4gICAgICBjb25zdCB0Ml8gPSB0IC0gMS41IC8gMi43NTtcbiAgICAgIHJldHVybiA3LjU2MjUgKiB0Ml8gKiB0Ml8gKyAwLjc1O1xuICAgIH1cbiAgICBpZiAodCA8IDIuNSAvIDIuNzUpIHtcbiAgICAgIGNvbnN0IHQyXyA9IHQgLSAyLjI1IC8gMi43NTtcbiAgICAgIHJldHVybiA3LjU2MjUgKiB0Ml8gKiB0Ml8gKyAwLjkzNzU7XG4gICAgfVxuICAgIGNvbnN0IHQyID0gdCAtIDIuNjI1IC8gMi43NTtcbiAgICByZXR1cm4gNy41NjI1ICogdDIgKiB0MiArIDAuOTg0Mzc1O1xuICB9XG4gIHN0YXRpYyBiZXppZXIoeDEsIHkxLCB4MiwgeTIpIHtcbiAgICByZXR1cm4gYmV6aWVyKHgxLCB5MSwgeDIsIHkyKTtcbiAgfVxuICBzdGF0aWMgaW4oZWFzaW5nKSB7XG4gICAgcmV0dXJuIGVhc2luZztcbiAgfVxuICBzdGF0aWMgb3V0KGVhc2luZykge1xuICAgIHJldHVybiAodCkgPT4gMSAtIGVhc2luZygxIC0gdCk7XG4gIH1cbiAgc3RhdGljIGluT3V0KGVhc2luZykge1xuICAgIHJldHVybiAodCkgPT4ge1xuICAgICAgaWYgKHQgPCAwLjUpIHtcbiAgICAgICAgcmV0dXJuIGVhc2luZyh0ICogMikgLyAyO1xuICAgICAgfVxuICAgICAgcmV0dXJuIDEgLSBlYXNpbmcoKDEgLSB0KSAqIDIpIC8gMjtcbiAgICB9O1xuICB9XG59XG4vLyBzcmMvdjUtZmxhZy50c1xudmFyIEVOQUJMRV9WNV9CUkVBS0lOR19DSEFOR0VTID0gZmFsc2U7XG5cbi8vIHNyYy9nZXQtc3RhdGljLWZpbGVzLnRzXG52YXIgd2FybmVkU2VydmVyID0gZmFsc2U7XG52YXIgd2FybmVkUGxheWVyID0gZmFsc2U7XG52YXIgd2FyblNlcnZlck9uY2UgPSAoKSA9PiB7XG4gIGlmICh3YXJuZWRTZXJ2ZXIpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgd2FybmVkU2VydmVyID0gdHJ1ZTtcbiAgY29uc29sZS53YXJuKFwiQ2FsbGVkIGdldFN0YXRpY0ZpbGVzKCkgb24gdGhlIHNlcnZlci4gVGhlIEFQSSBpcyBvbmx5IGF2YWlsYWJsZSBpbiB0aGUgYnJvd3Nlci4gQW4gZW1wdHkgYXJyYXkgd2FzIHJldHVybmVkLlwiKTtcbn07XG52YXIgd2FyblBsYXllck9uY2UgPSAoKSA9PiB7XG4gIGlmICh3YXJuZWRQbGF5ZXIpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgd2FybmVkUGxheWVyID0gdHJ1ZTtcbiAgY29uc29sZS53YXJuKFwiQ2FsbGVkIGdldFN0YXRpY0ZpbGVzKCkgd2hpbGUgdXNpbmcgdGhlIFJlbW90aW9uIFBsYXllci4gVGhlIEFQSSBpcyBvbmx5IGF2YWlsYWJsZSB3aGlsZSB1c2luZyB0aGUgUmVtb3Rpb24gU3R1ZGlvLiBBbiBlbXB0eSBhcnJheSB3YXMgcmV0dXJuZWQuXCIpO1xufTtcbnZhciBnZXRTdGF0aWNGaWxlcyA9ICgpID0+IHtcbiAgaWYgKEVOQUJMRV9WNV9CUkVBS0lOR19DSEFOR0VTKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiZ2V0U3RhdGljRmlsZXMoKSBoYXMgbW92ZWQgaW50byB0aGUgYEByZW1vdGlvbi9zdHVkaW9gIHBhY2thZ2UuIFVwZGF0ZSB5b3VyIGltcG9ydHMuXCIpO1xuICB9XG4gIGlmICh0eXBlb2YgZG9jdW1lbnQgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICB3YXJuU2VydmVyT25jZSgpO1xuICAgIHJldHVybiBbXTtcbiAgfVxuICBpZiAod2luZG93LnJlbW90aW9uX2lzUGxheWVyKSB7XG4gICAgd2FyblBsYXllck9uY2UoKTtcbiAgICByZXR1cm4gW107XG4gIH1cbiAgcmV0dXJuIHdpbmRvdy5yZW1vdGlvbl9zdGF0aWNGaWxlcztcbn07XG4vLyBzcmMvSUZyYW1lLnRzeFxuaW1wb3J0IHsgZm9yd2FyZFJlZiBhcyBmb3J3YXJkUmVmNiwgdXNlQ2FsbGJhY2sgYXMgdXNlQ2FsbGJhY2sxMSwgdXNlU3RhdGUgYXMgdXNlU3RhdGUxNiB9IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHsganN4IGFzIGpzeDIzIH0gZnJvbSBcInJlYWN0L2pzeC1ydW50aW1lXCI7XG52YXIgSUZyYW1lUmVmRm9yd2FyZGluZyA9ICh7XG4gIG9uTG9hZCxcbiAgb25FcnJvcixcbiAgZGVsYXlSZW5kZXJSZXRyaWVzLFxuICBkZWxheVJlbmRlclRpbWVvdXRJbk1pbGxpc2Vjb25kcyxcbiAgLi4ucHJvcHMyXG59LCByZWYpID0+IHtcbiAgY29uc3QgW2hhbmRsZV0gPSB1c2VTdGF0ZTE2KCgpID0+IGRlbGF5UmVuZGVyKGBMb2FkaW5nIDxJRnJhbWU+IHdpdGggc291cmNlICR7cHJvcHMyLnNyY31gLCB7XG4gICAgcmV0cmllczogZGVsYXlSZW5kZXJSZXRyaWVzID8/IHVuZGVmaW5lZCxcbiAgICB0aW1lb3V0SW5NaWxsaXNlY29uZHM6IGRlbGF5UmVuZGVyVGltZW91dEluTWlsbGlzZWNvbmRzID8/IHVuZGVmaW5lZFxuICB9KSk7XG4gIGNvbnN0IGRpZExvYWQgPSB1c2VDYWxsYmFjazExKChlKSA9PiB7XG4gICAgY29udGludWVSZW5kZXIoaGFuZGxlKTtcbiAgICBvbkxvYWQ/LihlKTtcbiAgfSwgW2hhbmRsZSwgb25Mb2FkXSk7XG4gIGNvbnN0IGRpZEdldEVycm9yID0gdXNlQ2FsbGJhY2sxMSgoZSkgPT4ge1xuICAgIGNvbnRpbnVlUmVuZGVyKGhhbmRsZSk7XG4gICAgaWYgKG9uRXJyb3IpIHtcbiAgICAgIG9uRXJyb3IoZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBsb2FkaW5nIGlmcmFtZTpcIiwgZSwgXCJIYW5kbGUgdGhlIGV2ZW50IHVzaW5nIHRoZSBvbkVycm9yKCkgcHJvcCB0byBtYWtlIHRoaXMgbWVzc2FnZSBkaXNhcHBlYXIuXCIpO1xuICAgIH1cbiAgfSwgW2hhbmRsZSwgb25FcnJvcl0pO1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeDIzKFwiaWZyYW1lXCIsIHtcbiAgICAuLi5wcm9wczIsXG4gICAgcmVmLFxuICAgIG9uRXJyb3I6IGRpZEdldEVycm9yLFxuICAgIG9uTG9hZDogZGlkTG9hZFxuICB9KTtcbn07XG52YXIgSUZyYW1lID0gZm9yd2FyZFJlZjYoSUZyYW1lUmVmRm9yd2FyZGluZyk7XG4vLyBzcmMvSW1nLnRzeFxuaW1wb3J0IHtcbiAgZm9yd2FyZFJlZiBhcyBmb3J3YXJkUmVmNyxcbiAgdXNlQ2FsbGJhY2sgYXMgdXNlQ2FsbGJhY2sxMixcbiAgdXNlQ29udGV4dCBhcyB1c2VDb250ZXh0MjYsXG4gIHVzZUltcGVyYXRpdmVIYW5kbGUgYXMgdXNlSW1wZXJhdGl2ZUhhbmRsZTYsXG4gIHVzZUxheW91dEVmZmVjdCBhcyB1c2VMYXlvdXRFZmZlY3Q0LFxuICB1c2VSZWYgYXMgdXNlUmVmMTFcbn0gZnJvbSBcInJlYWN0XCI7XG5mdW5jdGlvbiBleHBvbmVudGlhbEJhY2tvZmYoZXJyb3JDb3VudCkge1xuICByZXR1cm4gMTAwMCAqIDIgKiogKGVycm9yQ291bnQgLSAxKTtcbn1cbmltcG9ydCB7IGpzeCBhcyBqc3gyNCB9IGZyb20gXCJyZWFjdC9qc3gtcnVudGltZVwiO1xudmFyIEltZ1JlZkZvcndhcmRpbmcgPSAoe1xuICBvbkVycm9yLFxuICBtYXhSZXRyaWVzID0gMixcbiAgc3JjLFxuICBwYXVzZVdoZW5Mb2FkaW5nLFxuICBkZWxheVJlbmRlclJldHJpZXMsXG4gIGRlbGF5UmVuZGVyVGltZW91dEluTWlsbGlzZWNvbmRzLFxuICBvbkltYWdlRnJhbWUsXG4gIC4uLnByb3BzMlxufSwgcmVmKSA9PiB7XG4gIGNvbnN0IGltYWdlUmVmID0gdXNlUmVmMTEobnVsbCk7XG4gIGNvbnN0IGVycm9ycyA9IHVzZVJlZjExKHt9KTtcbiAgY29uc3QgeyBkZWxheVBsYXliYWNrIH0gPSB1c2VCdWZmZXJTdGF0ZSgpO1xuICBjb25zdCBzZXF1ZW5jZUNvbnRleHQgPSB1c2VDb250ZXh0MjYoU2VxdWVuY2VDb250ZXh0KTtcbiAgaWYgKCFzcmMpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIFwic3JjXCIgcHJvcCB3YXMgcGFzc2VkIHRvIDxJbWc+LicpO1xuICB9XG4gIHVzZUltcGVyYXRpdmVIYW5kbGU2KHJlZiwgKCkgPT4ge1xuICAgIHJldHVybiBpbWFnZVJlZi5jdXJyZW50O1xuICB9LCBbXSk7XG4gIGNvbnN0IGFjdHVhbFNyYyA9IHVzZVByZWxvYWQoc3JjKTtcbiAgY29uc3QgcmV0cnlJbiA9IHVzZUNhbGxiYWNrMTIoKHRpbWVvdXQpID0+IHtcbiAgICBpZiAoIWltYWdlUmVmLmN1cnJlbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgY3VycmVudFNyYyA9IGltYWdlUmVmLmN1cnJlbnQuc3JjO1xuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgaWYgKCFpbWFnZVJlZi5jdXJyZW50KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG5ld1NyYyA9IGltYWdlUmVmLmN1cnJlbnQ/LnNyYztcbiAgICAgIGlmIChuZXdTcmMgIT09IGN1cnJlbnRTcmMpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaW1hZ2VSZWYuY3VycmVudC5yZW1vdmVBdHRyaWJ1dGUoXCJzcmNcIik7XG4gICAgICBpbWFnZVJlZi5jdXJyZW50LnNldEF0dHJpYnV0ZShcInNyY1wiLCBuZXdTcmMpO1xuICAgIH0sIHRpbWVvdXQpO1xuICB9LCBbXSk7XG4gIGNvbnN0IGRpZEdldEVycm9yID0gdXNlQ2FsbGJhY2sxMigoZSkgPT4ge1xuICAgIGlmICghZXJyb3JzLmN1cnJlbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZXJyb3JzLmN1cnJlbnRbaW1hZ2VSZWYuY3VycmVudD8uc3JjXSA9IChlcnJvcnMuY3VycmVudFtpbWFnZVJlZi5jdXJyZW50Py5zcmNdID8/IDApICsgMTtcbiAgICBpZiAob25FcnJvciAmJiAoZXJyb3JzLmN1cnJlbnRbaW1hZ2VSZWYuY3VycmVudD8uc3JjXSA/PyAwKSA+IG1heFJldHJpZXMpIHtcbiAgICAgIG9uRXJyb3IoZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICgoZXJyb3JzLmN1cnJlbnRbaW1hZ2VSZWYuY3VycmVudD8uc3JjXSA/PyAwKSA8PSBtYXhSZXRyaWVzKSB7XG4gICAgICBjb25zdCBiYWNrb2ZmID0gZXhwb25lbnRpYWxCYWNrb2ZmKGVycm9ycy5jdXJyZW50W2ltYWdlUmVmLmN1cnJlbnQ/LnNyY10gPz8gMCk7XG4gICAgICBjb25zb2xlLndhcm4oYENvdWxkIG5vdCBsb2FkIGltYWdlIHdpdGggc291cmNlICR7aW1hZ2VSZWYuY3VycmVudD8uc3JjfSwgcmV0cnlpbmcgYWdhaW4gaW4gJHtiYWNrb2ZmfW1zYCk7XG4gICAgICByZXRyeUluKGJhY2tvZmYpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjYW5jZWxSZW5kZXIoXCJFcnJvciBsb2FkaW5nIGltYWdlIHdpdGggc3JjOiBcIiArIGltYWdlUmVmLmN1cnJlbnQ/LnNyYyk7XG4gIH0sIFttYXhSZXRyaWVzLCBvbkVycm9yLCByZXRyeUluXSk7XG4gIGlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgY29uc3QgaXNQcmVtb3VudGluZyA9IEJvb2xlYW4oc2VxdWVuY2VDb250ZXh0Py5wcmVtb3VudGluZyk7XG4gICAgdXNlTGF5b3V0RWZmZWN0NCgoKSA9PiB7XG4gICAgICBpZiAod2luZG93LnByb2Nlc3M/LmVudj8uTk9ERV9FTlYgPT09IFwidGVzdFwiKSB7XG4gICAgICAgIGlmIChpbWFnZVJlZi5jdXJyZW50KSB7XG4gICAgICAgICAgaW1hZ2VSZWYuY3VycmVudC5zcmMgPSBhY3R1YWxTcmM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgbmV3SGFuZGxlID0gZGVsYXlSZW5kZXIoXCJMb2FkaW5nIDxJbWc+IHdpdGggc3JjPVwiICsgYWN0dWFsU3JjLCB7XG4gICAgICAgIHJldHJpZXM6IGRlbGF5UmVuZGVyUmV0cmllcyA/PyB1bmRlZmluZWQsXG4gICAgICAgIHRpbWVvdXRJbk1pbGxpc2Vjb25kczogZGVsYXlSZW5kZXJUaW1lb3V0SW5NaWxsaXNlY29uZHMgPz8gdW5kZWZpbmVkXG4gICAgICB9KTtcbiAgICAgIGNvbnN0IHVuYmxvY2sgPSBwYXVzZVdoZW5Mb2FkaW5nICYmICFpc1ByZW1vdW50aW5nID8gZGVsYXlQbGF5YmFjaygpLnVuYmxvY2sgOiAoKSA9PiB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH07XG4gICAgICBjb25zdCB7IGN1cnJlbnQgfSA9IGltYWdlUmVmO1xuICAgICAgbGV0IHVubW91bnRlZCA9IGZhbHNlO1xuICAgICAgY29uc3Qgb25Db21wbGV0ZSA9ICgpID0+IHtcbiAgICAgICAgaWYgKHVubW91bnRlZCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKGVycm9ycy5jdXJyZW50W2ltYWdlUmVmLmN1cnJlbnQ/LnNyY10gPz8gMCkgPiAwKSB7XG4gICAgICAgICAgZGVsZXRlIGVycm9ycy5jdXJyZW50W2ltYWdlUmVmLmN1cnJlbnQ/LnNyY107XG4gICAgICAgICAgY29uc29sZS5pbmZvKGBSZXRyeSBzdWNjZXNzZnVsIC0gJHtpbWFnZVJlZi5jdXJyZW50Py5zcmN9IGlzIG5vdyBsb2FkZWRgKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY3VycmVudCkge1xuICAgICAgICAgIGN1cnJlbnQuc3JjID0gYWN0dWFsU3JjO1xuICAgICAgICAgIG9uSW1hZ2VGcmFtZT8uKGN1cnJlbnQpO1xuICAgICAgICB9XG4gICAgICAgIHVuYmxvY2soKTtcbiAgICAgICAgY29udGludWVSZW5kZXIobmV3SGFuZGxlKTtcbiAgICAgIH07XG4gICAgICBjb25zdCBuZXdJbWcgPSBuZXcgSW1hZ2U7XG4gICAgICBuZXdJbWcuc3JjID0gYWN0dWFsU3JjO1xuICAgICAgbmV3SW1nLmRlY29kZSgpLnRoZW4ob25Db21wbGV0ZSkuY2F0Y2goKGVycikgPT4ge1xuICAgICAgICBjb25zb2xlLndhcm4oZXJyKTtcbiAgICAgICAgaWYgKG5ld0ltZy5jb21wbGV0ZSkge1xuICAgICAgICAgIG9uQ29tcGxldGUoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBuZXdJbWcuYWRkRXZlbnRMaXN0ZW5lcihcImxvYWRcIiwgb25Db21wbGV0ZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgdW5tb3VudGVkID0gdHJ1ZTtcbiAgICAgICAgbmV3SW1nLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJsb2FkXCIsIG9uQ29tcGxldGUpO1xuICAgICAgICB1bmJsb2NrKCk7XG4gICAgICAgIGNvbnRpbnVlUmVuZGVyKG5ld0hhbmRsZSk7XG4gICAgICB9O1xuICAgIH0sIFtcbiAgICAgIGFjdHVhbFNyYyxcbiAgICAgIGRlbGF5UGxheWJhY2ssXG4gICAgICBkZWxheVJlbmRlclJldHJpZXMsXG4gICAgICBkZWxheVJlbmRlclRpbWVvdXRJbk1pbGxpc2Vjb25kcyxcbiAgICAgIHBhdXNlV2hlbkxvYWRpbmcsXG4gICAgICBpc1ByZW1vdW50aW5nLFxuICAgICAgb25JbWFnZUZyYW1lXG4gICAgXSk7XG4gIH1cbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBqc3gyNChcImltZ1wiLCB7XG4gICAgLi4ucHJvcHMyLFxuICAgIHJlZjogaW1hZ2VSZWYsXG4gICAgb25FcnJvcjogZGlkR2V0RXJyb3JcbiAgfSk7XG59O1xudmFyIEltZyA9IGZvcndhcmRSZWY3KEltZ1JlZkZvcndhcmRpbmcpO1xuLy8gc3JjL2RlZmF1bHQtY3NzLnRzXG52YXIgZXhwb3J0c19kZWZhdWx0X2NzcyA9IHt9O1xuX19leHBvcnQoZXhwb3J0c19kZWZhdWx0X2Nzcywge1xuICBtYWtlRGVmYXVsdFByZXZpZXdDU1M6ICgpID0+IG1ha2VEZWZhdWx0UHJldmlld0NTUyxcbiAgaW5qZWN0Q1NTOiAoKSA9PiBpbmplY3RDU1MsXG4gIE9GRlRIUkVBRF9WSURFT19DTEFTU19OQU1FOiAoKSA9PiBPRkZUSFJFQURfVklERU9fQ0xBU1NfTkFNRVxufSk7XG52YXIgaW5qZWN0ZWQgPSB7fTtcbnZhciBpbmplY3RDU1MgPSAoY3NzKSA9PiB7XG4gIGlmICh0eXBlb2YgZG9jdW1lbnQgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKGluamVjdGVkW2Nzc10pIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgaGVhZCA9IGRvY3VtZW50LmhlYWQgfHwgZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJoZWFkXCIpWzBdO1xuICBjb25zdCBzdHlsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzdHlsZVwiKTtcbiAgc3R5bGUuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY3NzKSk7XG4gIGhlYWQucHJlcGVuZChzdHlsZSk7XG4gIGluamVjdGVkW2Nzc10gPSB0cnVlO1xufTtcbnZhciBPRkZUSFJFQURfVklERU9fQ0xBU1NfTkFNRSA9IFwiX19yZW1vdGlvbl9vZmZ0aHJlYWR2aWRlb1wiO1xudmFyIG1ha2VEZWZhdWx0UHJldmlld0NTUyA9IChzY29wZSwgYmFja2dyb3VuZENvbG9yKSA9PiB7XG4gIGlmICghc2NvcGUpIHtcbiAgICByZXR1cm4gYFxuICAgICoge1xuICAgICAgYm94LXNpemluZzogYm9yZGVyLWJveDtcbiAgICB9XG4gICAgYm9keSB7XG4gICAgICBtYXJnaW46IDA7XG5cdCAgICBiYWNrZ3JvdW5kLWNvbG9yOiAke2JhY2tncm91bmRDb2xvcn07XG4gICAgfVxuICAgIC4ke09GRlRIUkVBRF9WSURFT19DTEFTU19OQU1FfSB7XG4gICAgICBvYmplY3QtZml0OiBjb250YWluO1xuICAgIH1cbiAgICBgO1xuICB9XG4gIHJldHVybiBgXG4gICAgJHtzY29wZX0gKiB7XG4gICAgICBib3gtc2l6aW5nOiBib3JkZXItYm94O1xuICAgIH1cbiAgICAke3Njb3BlfSAqOi13ZWJraXQtZnVsbC1zY3JlZW4ge1xuICAgICAgd2lkdGg6IDEwMCU7XG4gICAgICBoZWlnaHQ6IDEwMCU7XG4gICAgfVxuICAgICR7c2NvcGV9IC4ke09GRlRIUkVBRF9WSURFT19DTEFTU19OQU1FfSB7XG4gICAgICBvYmplY3QtZml0OiBjb250YWluO1xuICAgIH1cbiAgYDtcbn07XG5cbi8vIHNyYy9nZXQtcHJldmlldy1kb20tZWxlbWVudC50c1xudmFyIFJFTU9USU9OX1NUVURJT19DT05UQUlORVJfRUxFTUVOVCA9IFwiX19yZW1vdGlvbi1zdHVkaW8tY29udGFpbmVyXCI7XG52YXIgZ2V0UHJldmlld0RvbUVsZW1lbnQgPSAoKSA9PiB7XG4gIHJldHVybiBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChSRU1PVElPTl9TVFVESU9fQ09OVEFJTkVSX0VMRU1FTlQpO1xufTtcblxuLy8gc3JjL3JlZ2lzdGVyLXJvb3QudHNcbnZhciBSb290ID0gbnVsbDtcbnZhciBsaXN0ZW5lcnMgPSBbXTtcbnZhciByZWdpc3RlclJvb3QgPSAoY29tcCkgPT4ge1xuICBpZiAoIWNvbXApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFlvdSBtdXN0IHBhc3MgYSBSZWFjdCBjb21wb25lbnQgdG8gcmVnaXN0ZXJSb290KCksIGJ1dCAke0pTT04uc3RyaW5naWZ5KGNvbXApfSB3YXMgcGFzc2VkLmApO1xuICB9XG4gIGlmIChSb290KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwicmVnaXN0ZXJSb290KCkgd2FzIGNhbGxlZCBtb3JlIHRoYW4gb25jZS5cIik7XG4gIH1cbiAgUm9vdCA9IGNvbXA7XG4gIGxpc3RlbmVycy5mb3JFYWNoKChsKSA9PiB7XG4gICAgbChjb21wKTtcbiAgfSk7XG59O1xudmFyIGdldFJvb3QgPSAoKSA9PiB7XG4gIHJldHVybiBSb290O1xufTtcbnZhciB3YWl0Rm9yUm9vdCA9IChmbikgPT4ge1xuICBpZiAoUm9vdCkge1xuICAgIGZuKFJvb3QpO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICByZXR1cm47XG4gICAgfTtcbiAgfVxuICBsaXN0ZW5lcnMucHVzaChmbik7XG4gIHJldHVybiAoKSA9PiB7XG4gICAgbGlzdGVuZXJzID0gbGlzdGVuZXJzLmZpbHRlcigobCkgPT4gbCAhPT0gZm4pO1xuICB9O1xufTtcblxuLy8gc3JjL1JlbW90aW9uUm9vdC50c3hcbmltcG9ydCB7XG4gIHVzZUVmZmVjdCBhcyB1c2VFZmZlY3QyMCxcbiAgdXNlTGF5b3V0RWZmZWN0IGFzIHVzZUxheW91dEVmZmVjdDUsXG4gIHVzZU1lbW8gYXMgdXNlTWVtbzI2LFxuICB1c2VSZWYgYXMgdXNlUmVmMTIsXG4gIHVzZVN0YXRlIGFzIHVzZVN0YXRlMTdcbn0gZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgeyBqc3ggYXMganN4MjUgfSBmcm9tIFwicmVhY3QvanN4LXJ1bnRpbWVcIjtcbnZhciBSZW1vdGlvblJvb3QgPSAoeyBjaGlsZHJlbiwgbnVtYmVyT2ZBdWRpb1RhZ3MgfSkgPT4ge1xuICBjb25zdCBbcmVtb3Rpb25Sb290SWRdID0gdXNlU3RhdGUxNygoKSA9PiBTdHJpbmcocmFuZG9tKG51bGwpKSk7XG4gIGNvbnN0IFtmcmFtZSwgc2V0RnJhbWVdID0gdXNlU3RhdGUxNygoKSA9PiBnZXRJbml0aWFsRnJhbWVTdGF0ZSgpKTtcbiAgY29uc3QgW3BsYXlpbmcsIHNldFBsYXlpbmddID0gdXNlU3RhdGUxNyhmYWxzZSk7XG4gIGNvbnN0IGltcGVyYXRpdmVQbGF5aW5nID0gdXNlUmVmMTIoZmFsc2UpO1xuICBjb25zdCBbZmFzdFJlZnJlc2hlcywgc2V0RmFzdFJlZnJlc2hlc10gPSB1c2VTdGF0ZTE3KDApO1xuICBjb25zdCBbcGxheWJhY2tSYXRlLCBzZXRQbGF5YmFja1JhdGVdID0gdXNlU3RhdGUxNygxKTtcbiAgY29uc3QgYXVkaW9BbmRWaWRlb1RhZ3MgPSB1c2VSZWYxMihbXSk7XG4gIGlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgdXNlTGF5b3V0RWZmZWN0NSgoKSA9PiB7XG4gICAgICB3aW5kb3cucmVtb3Rpb25fc2V0RnJhbWUgPSAoZiwgY29tcG9zaXRpb24sIGF0dGVtcHQpID0+IHtcbiAgICAgICAgd2luZG93LnJlbW90aW9uX2F0dGVtcHQgPSBhdHRlbXB0O1xuICAgICAgICBjb25zdCBpZCA9IGRlbGF5UmVuZGVyKGBTZXR0aW5nIHRoZSBjdXJyZW50IGZyYW1lIHRvICR7Zn1gKTtcbiAgICAgICAgbGV0IGFzeW5jVXBkYXRlID0gdHJ1ZTtcbiAgICAgICAgc2V0RnJhbWUoKHMpID0+IHtcbiAgICAgICAgICBjb25zdCBjdXJyZW50RnJhbWUgPSBzW2NvbXBvc2l0aW9uXSA/PyB3aW5kb3cucmVtb3Rpb25faW5pdGlhbEZyYW1lO1xuICAgICAgICAgIGlmIChjdXJyZW50RnJhbWUgPT09IGYpIHtcbiAgICAgICAgICAgIGFzeW5jVXBkYXRlID0gZmFsc2U7XG4gICAgICAgICAgICByZXR1cm4gcztcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLnMsXG4gICAgICAgICAgICBbY29tcG9zaXRpb25dOiBmXG4gICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChhc3luY1VwZGF0ZSkge1xuICAgICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiBjb250aW51ZVJlbmRlcihpZCkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnRpbnVlUmVuZGVyKGlkKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHdpbmRvdy5yZW1vdGlvbl9pc1BsYXllciA9IGZhbHNlO1xuICAgIH0sIFtdKTtcbiAgfVxuICBjb25zdCB0aW1lbGluZUNvbnRleHRWYWx1ZSA9IHVzZU1lbW8yNigoKSA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGZyYW1lLFxuICAgICAgcGxheWluZyxcbiAgICAgIGltcGVyYXRpdmVQbGF5aW5nLFxuICAgICAgcm9vdElkOiByZW1vdGlvblJvb3RJZCxcbiAgICAgIHBsYXliYWNrUmF0ZSxcbiAgICAgIHNldFBsYXliYWNrUmF0ZSxcbiAgICAgIGF1ZGlvQW5kVmlkZW9UYWdzXG4gICAgfTtcbiAgfSwgW2ZyYW1lLCBwbGF5YmFja1JhdGUsIHBsYXlpbmcsIHJlbW90aW9uUm9vdElkXSk7XG4gIGNvbnN0IHNldFRpbWVsaW5lQ29udGV4dFZhbHVlID0gdXNlTWVtbzI2KCgpID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgc2V0RnJhbWUsXG4gICAgICBzZXRQbGF5aW5nXG4gICAgfTtcbiAgfSwgW10pO1xuICBjb25zdCBub25jZUNvbnRleHQgPSB1c2VNZW1vMjYoKCkgPT4ge1xuICAgIGxldCBjb3VudGVyID0gMDtcbiAgICByZXR1cm4ge1xuICAgICAgZ2V0Tm9uY2U6ICgpID0+IGNvdW50ZXIrKyxcbiAgICAgIGZhc3RSZWZyZXNoZXNcbiAgICB9O1xuICB9LCBbZmFzdFJlZnJlc2hlc10pO1xuICB1c2VFZmZlY3QyMCgoKSA9PiB7XG4gICAgaWYgKHR5cGVvZiBfX3dlYnBhY2tfbW9kdWxlX18gIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIGlmIChfX3dlYnBhY2tfbW9kdWxlX18uaG90KSB7XG4gICAgICAgIF9fd2VicGFja19tb2R1bGVfXy5ob3QuYWRkU3RhdHVzSGFuZGxlcigoc3RhdHVzKSA9PiB7XG4gICAgICAgICAgaWYgKHN0YXR1cyA9PT0gXCJpZGxlXCIpIHtcbiAgICAgICAgICAgIHNldEZhc3RSZWZyZXNoZXMoKGkpID0+IGkgKyAxKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfSwgW10pO1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeDI1KE5vbmNlQ29udGV4dC5Qcm92aWRlciwge1xuICAgIHZhbHVlOiBub25jZUNvbnRleHQsXG4gICAgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBqc3gyNShUaW1lbGluZUNvbnRleHQuUHJvdmlkZXIsIHtcbiAgICAgIHZhbHVlOiB0aW1lbGluZUNvbnRleHRWYWx1ZSxcbiAgICAgIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8ganN4MjUoU2V0VGltZWxpbmVDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgICAgIHZhbHVlOiBzZXRUaW1lbGluZUNvbnRleHRWYWx1ZSxcbiAgICAgICAgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBqc3gyNShFZGl0b3JQcm9wc1Byb3ZpZGVyLCB7XG4gICAgICAgICAgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBqc3gyNShQcmVmZXRjaFByb3ZpZGVyLCB7XG4gICAgICAgICAgICBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIGpzeDI1KE5hdGl2ZUxheWVyc1Byb3ZpZGVyLCB7XG4gICAgICAgICAgICAgIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8ganN4MjUoQ29tcG9zaXRpb25NYW5hZ2VyUHJvdmlkZXIsIHtcbiAgICAgICAgICAgICAgICBudW1iZXJPZkF1ZGlvVGFncyxcbiAgICAgICAgICAgICAgICBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIGpzeDI1KER1cmF0aW9uc0NvbnRleHRQcm92aWRlciwge1xuICAgICAgICAgICAgICAgICAgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBqc3gyNShCdWZmZXJpbmdQcm92aWRlciwge1xuICAgICAgICAgICAgICAgICAgICBjaGlsZHJlblxuICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICB9KVxuICAgICAgICB9KVxuICAgICAgfSlcbiAgICB9KVxuICB9KTtcbn07XG5cbi8vIHNyYy9zZXR1cC1lbnYtdmFyaWFibGVzLnRzXG52YXIgZ2V0RW52VmFyaWFibGVzID0gKCkgPT4ge1xuICBpZiAoZ2V0UmVtb3Rpb25FbnZpcm9ubWVudCgpLmlzUmVuZGVyaW5nKSB7XG4gICAgY29uc3QgcGFyYW0gPSB3aW5kb3cucmVtb3Rpb25fZW52VmFyaWFibGVzO1xuICAgIGlmICghcGFyYW0pIHtcbiAgICAgIHJldHVybiB7fTtcbiAgICB9XG4gICAgcmV0dXJuIHsgLi4uSlNPTi5wYXJzZShwYXJhbSksIE5PREVfRU5WOiBcInByb2R1Y3Rpb25cIiB9O1xuICB9XG4gIGlmIChmYWxzZSkge1xuICB9XG4gIHJldHVybiB7XG4gICAgTk9ERV9FTlY6IFwicHJvZHVjdGlvblwiXG4gIH07XG59O1xudmFyIHNldHVwRW52VmFyaWFibGVzID0gKCkgPT4ge1xuICBjb25zdCBlbnYgPSBnZXRFbnZWYXJpYWJsZXMoKTtcbiAgaWYgKCF3aW5kb3cucHJvY2Vzcykge1xuICAgIHdpbmRvdy5wcm9jZXNzID0ge307XG4gIH1cbiAgaWYgKCF3aW5kb3cucHJvY2Vzcy5lbnYpIHtcbiAgICB3aW5kb3cucHJvY2Vzcy5lbnYgPSB7fTtcbiAgfVxuICBPYmplY3Qua2V5cyhlbnYpLmZvckVhY2goKGtleSkgPT4ge1xuICAgIHdpbmRvdy5wcm9jZXNzLmVudltrZXldID0gZW52W2tleV07XG4gIH0pO1xufTtcblxuLy8gc3JjL3VzZS1jdXJyZW50LXNjYWxlLnRzXG5pbXBvcnQgUmVhY3QyMiwgeyBjcmVhdGVDb250ZXh0IGFzIGNyZWF0ZUNvbnRleHQxOCB9IGZyb20gXCJyZWFjdFwiO1xudmFyIEN1cnJlbnRTY2FsZUNvbnRleHQgPSBSZWFjdDIyLmNyZWF0ZUNvbnRleHQobnVsbCk7XG52YXIgUHJldmlld1NpemVDb250ZXh0ID0gY3JlYXRlQ29udGV4dDE4KHtcbiAgc2V0U2l6ZTogKCkgPT4ge1xuICAgIHJldHVybjtcbiAgfSxcbiAgc2l6ZTogeyBzaXplOiBcImF1dG9cIiwgdHJhbnNsYXRpb246IHsgeDogMCwgeTogMCB9IH1cbn0pO1xudmFyIGNhbGN1bGF0ZVNjYWxlID0gKHtcbiAgY2FudmFzU2l6ZSxcbiAgY29tcG9zaXRpb25IZWlnaHQsXG4gIGNvbXBvc2l0aW9uV2lkdGgsXG4gIHByZXZpZXdTaXplXG59KSA9PiB7XG4gIGNvbnN0IGhlaWdodFJhdGlvID0gY2FudmFzU2l6ZS5oZWlnaHQgLyBjb21wb3NpdGlvbkhlaWdodDtcbiAgY29uc3Qgd2lkdGhSYXRpbyA9IGNhbnZhc1NpemUud2lkdGggLyBjb21wb3NpdGlvbldpZHRoO1xuICBjb25zdCByYXRpbyA9IE1hdGgubWluKGhlaWdodFJhdGlvLCB3aWR0aFJhdGlvKTtcbiAgcmV0dXJuIHByZXZpZXdTaXplID09PSBcImF1dG9cIiA/IHJhdGlvIDogTnVtYmVyKHByZXZpZXdTaXplKTtcbn07XG52YXIgdXNlQ3VycmVudFNjYWxlID0gKG9wdGlvbnMpID0+IHtcbiAgY29uc3QgaGFzQ29udGV4dCA9IFJlYWN0MjIudXNlQ29udGV4dChDdXJyZW50U2NhbGVDb250ZXh0KTtcbiAgY29uc3Qgem9vbUNvbnRleHQgPSBSZWFjdDIyLnVzZUNvbnRleHQoUHJldmlld1NpemVDb250ZXh0KTtcbiAgY29uc3QgY29uZmlnID0gdXNlVW5zYWZlVmlkZW9Db25maWcoKTtcbiAgaWYgKGhhc0NvbnRleHQgPT09IG51bGwgfHwgY29uZmlnID09PSBudWxsIHx8IHpvb21Db250ZXh0ID09PSBudWxsKSB7XG4gICAgaWYgKG9wdGlvbnM/LmRvbnRUaHJvd0lmT3V0c2lkZU9mUmVtb3Rpb24pIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH1cbiAgICBpZiAoZ2V0UmVtb3Rpb25FbnZpcm9ubWVudCgpLmlzUmVuZGVyaW5nKSB7XG4gICAgICByZXR1cm4gMTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKFtcbiAgICAgIFwidXNlQ3VycmVudFNjYWxlKCkgd2FzIGNhbGxlZCBvdXRzaWRlIG9mIGEgUmVtb3Rpb24gY29udGV4dC5cIixcbiAgICAgIFwiVGhpcyBob29rIGNhbiBvbmx5IGJlIGNhbGxlZCBpbiBhIGNvbXBvbmVudCB0aGF0IGlzIGJlaW5nIHJlbmRlcmVkIGJ5IFJlbW90aW9uLlwiLFxuICAgICAgXCJJZiB5b3Ugd2FudCB0byB0aGlzIGhvb2sgdG8gcmV0dXJuIDEgb3V0c2lkZSBvZiBSZW1vdGlvbiwgcGFzcyB7ZG9udFRocm93SWZPdXRzaWRlT2ZSZW1vdGlvbjogdHJ1ZX0gYXMgYW4gb3B0aW9uLlwiLFxuICAgICAgXCJJZiB5b3UgdGhpbmsgeW91IGNhbGxlZCB0aGlzIGhvb2sgaW4gYSBSZW1vdGlvbiBjb21wb25lbnQsIG1ha2Ugc3VyZSBhbGwgdmVyc2lvbnMgb2YgUmVtb3Rpb24gYXJlIGFsaWduZWQuXCJcbiAgICBdLmpvaW4oXCJcXG5cIikpO1xuICB9XG4gIGlmIChoYXNDb250ZXh0LnR5cGUgPT09IFwic2NhbGVcIikge1xuICAgIHJldHVybiBoYXNDb250ZXh0LnNjYWxlO1xuICB9XG4gIHJldHVybiBjYWxjdWxhdGVTY2FsZSh7XG4gICAgY2FudmFzU2l6ZTogaGFzQ29udGV4dC5jYW52YXNTaXplLFxuICAgIGNvbXBvc2l0aW9uSGVpZ2h0OiBjb25maWcuaGVpZ2h0LFxuICAgIGNvbXBvc2l0aW9uV2lkdGg6IGNvbmZpZy53aWR0aCxcbiAgICBwcmV2aWV3U2l6ZTogem9vbUNvbnRleHQuc2l6ZS5zaXplXG4gIH0pO1xufTtcblxuLy8gc3JjL3dhdGNoLXN0YXRpYy1maWxlLnRzXG52YXIgV0FUQ0hfUkVNT1RJT05fU1RBVElDX0ZJTEVTID0gXCJyZW1vdGlvbl9zdGF0aWNGaWxlc0NoYW5nZWRcIjtcbnZhciB3YXRjaFN0YXRpY0ZpbGUgPSAoZmlsZU5hbWUsIGNhbGxiYWNrKSA9PiB7XG4gIGlmIChFTkFCTEVfVjVfQlJFQUtJTkdfQ0hBTkdFUykge1xuICAgIHRocm93IG5ldyBFcnJvcihcIndhdGNoU3RhdGljRmlsZSgpIGhhcyBtb3ZlZCBpbnRvIHRoZSBgQHJlbW90aW9uL3N0dWRpb2AgcGFja2FnZS4gVXBkYXRlIHlvdXIgaW1wb3J0cy5cIik7XG4gIH1cbiAgaWYgKCFnZXRSZW1vdGlvbkVudmlyb25tZW50KCkuaXNTdHVkaW8pIHtcbiAgICBjb25zb2xlLndhcm4oXCJUaGUgQVBJIGlzIG9ubHkgYXZhaWxhYmxlIHdoaWxlIHVzaW5nIHRoZSBSZW1vdGlvbiBTdHVkaW8uXCIpO1xuICAgIHJldHVybiB7IGNhbmNlbDogKCkgPT4ge1xuICAgICAgcmV0dXJuO1xuICAgIH0gfTtcbiAgfVxuICBjb25zdCB3aXRob3V0U3RhdGljQmFzZSA9IGZpbGVOYW1lLnN0YXJ0c1dpdGgod2luZG93LnJlbW90aW9uX3N0YXRpY0Jhc2UpID8gZmlsZU5hbWUucmVwbGFjZSh3aW5kb3cucmVtb3Rpb25fc3RhdGljQmFzZSwgXCJcIikgOiBmaWxlTmFtZTtcbiAgY29uc3Qgd2l0aG91dExlYWRpbmdTbGFzaCA9IHdpdGhvdXRTdGF0aWNCYXNlLnN0YXJ0c1dpdGgoXCIvXCIpID8gd2l0aG91dFN0YXRpY0Jhc2Uuc2xpY2UoMSkgOiB3aXRob3V0U3RhdGljQmFzZTtcbiAgbGV0IHByZXZGaWxlRGF0YSA9IHdpbmRvdy5yZW1vdGlvbl9zdGF0aWNGaWxlcy5maW5kKChmaWxlKSA9PiBmaWxlLm5hbWUgPT09IHdpdGhvdXRMZWFkaW5nU2xhc2gpO1xuICBjb25zdCBjaGVja0ZpbGUgPSAoZXZlbnQpID0+IHtcbiAgICBjb25zdCBzdGF0aWNGaWxlcyA9IGV2ZW50LmRldGFpbC5maWxlcztcbiAgICBjb25zdCBuZXdGaWxlRGF0YSA9IHN0YXRpY0ZpbGVzLmZpbmQoKGZpbGUpID0+IGZpbGUubmFtZSA9PT0gd2l0aG91dExlYWRpbmdTbGFzaCk7XG4gICAgaWYgKCFuZXdGaWxlRGF0YSkge1xuICAgICAgaWYgKHByZXZGaWxlRGF0YSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNhbGxiYWNrKG51bGwpO1xuICAgICAgfVxuICAgICAgcHJldkZpbGVEYXRhID0gdW5kZWZpbmVkO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAocHJldkZpbGVEYXRhID09PSB1bmRlZmluZWQgfHwgcHJldkZpbGVEYXRhLmxhc3RNb2RpZmllZCAhPT0gbmV3RmlsZURhdGEubGFzdE1vZGlmaWVkKSB7XG4gICAgICBjYWxsYmFjayhuZXdGaWxlRGF0YSk7XG4gICAgICBwcmV2RmlsZURhdGEgPSBuZXdGaWxlRGF0YTtcbiAgICB9XG4gIH07XG4gIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFdBVENIX1JFTU9USU9OX1NUQVRJQ19GSUxFUywgY2hlY2tGaWxlKTtcbiAgY29uc3QgY2FuY2VsID0gKCkgPT4ge1xuICAgIHJldHVybiB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihXQVRDSF9SRU1PVElPTl9TVEFUSUNfRklMRVMsIGNoZWNrRmlsZSk7XG4gIH07XG4gIHJldHVybiB7IGNhbmNlbCB9O1xufTtcblxuLy8gc3JjL3dyYXAtcmVtb3Rpb24tY29udGV4dC50c3hcbmltcG9ydCBSZWFjdDIzLCB7IHVzZU1lbW8gYXMgdXNlTWVtbzI3IH0gZnJvbSBcInJlYWN0XCI7XG5mdW5jdGlvbiB1c2VSZW1vdGlvbkNvbnRleHRzKCkge1xuICBjb25zdCBjb21wb3NpdGlvbk1hbmFnZXJDdHggPSBSZWFjdDIzLnVzZUNvbnRleHQoQ29tcG9zaXRpb25NYW5hZ2VyKTtcbiAgY29uc3QgdGltZWxpbmVDb250ZXh0ID0gUmVhY3QyMy51c2VDb250ZXh0KFRpbWVsaW5lQ29udGV4dCk7XG4gIGNvbnN0IHNldFRpbWVsaW5lQ29udGV4dCA9IFJlYWN0MjMudXNlQ29udGV4dChTZXRUaW1lbGluZUNvbnRleHQpO1xuICBjb25zdCBzZXF1ZW5jZUNvbnRleHQgPSBSZWFjdDIzLnVzZUNvbnRleHQoU2VxdWVuY2VDb250ZXh0KTtcbiAgY29uc3Qgbm9uY2VDb250ZXh0ID0gUmVhY3QyMy51c2VDb250ZXh0KE5vbmNlQ29udGV4dCk7XG4gIGNvbnN0IGNhblVzZVJlbW90aW9uSG9va3NDb250ZXh0ID0gUmVhY3QyMy51c2VDb250ZXh0KENhblVzZVJlbW90aW9uSG9va3MpO1xuICBjb25zdCBuYXRpdmVMYXllcnNDb250ZXh0ID0gUmVhY3QyMy51c2VDb250ZXh0KE5hdGl2ZUxheWVyc0NvbnRleHQpO1xuICBjb25zdCBwcmVsb2FkQ29udGV4dCA9IFJlYWN0MjMudXNlQ29udGV4dChQcmVsb2FkQ29udGV4dCk7XG4gIGNvbnN0IHJlc29sdmVDb21wb3NpdGlvbkNvbnRleHQgPSBSZWFjdDIzLnVzZUNvbnRleHQoUmVzb2x2ZUNvbXBvc2l0aW9uQ29udGV4dCk7XG4gIGNvbnN0IHJlbmRlckFzc2V0TWFuYWdlckNvbnRleHQgPSBSZWFjdDIzLnVzZUNvbnRleHQoUmVuZGVyQXNzZXRNYW5hZ2VyKTtcbiAgY29uc3Qgc2VxdWVuY2VNYW5hZ2VyQ29udGV4dCA9IFJlYWN0MjMudXNlQ29udGV4dChTZXF1ZW5jZU1hbmFnZXIpO1xuICBjb25zdCBidWZmZXJNYW5hZ2VyQ29udGV4dCA9IFJlYWN0MjMudXNlQ29udGV4dChCdWZmZXJpbmdDb250ZXh0UmVhY3QpO1xuICByZXR1cm4gdXNlTWVtbzI3KCgpID0+ICh7XG4gICAgY29tcG9zaXRpb25NYW5hZ2VyQ3R4LFxuICAgIHRpbWVsaW5lQ29udGV4dCxcbiAgICBzZXRUaW1lbGluZUNvbnRleHQsXG4gICAgc2VxdWVuY2VDb250ZXh0LFxuICAgIG5vbmNlQ29udGV4dCxcbiAgICBjYW5Vc2VSZW1vdGlvbkhvb2tzQ29udGV4dCxcbiAgICBuYXRpdmVMYXllcnNDb250ZXh0LFxuICAgIHByZWxvYWRDb250ZXh0LFxuICAgIHJlc29sdmVDb21wb3NpdGlvbkNvbnRleHQsXG4gICAgcmVuZGVyQXNzZXRNYW5hZ2VyQ29udGV4dCxcbiAgICBzZXF1ZW5jZU1hbmFnZXJDb250ZXh0LFxuICAgIGJ1ZmZlck1hbmFnZXJDb250ZXh0XG4gIH0pLCBbXG4gICAgY29tcG9zaXRpb25NYW5hZ2VyQ3R4LFxuICAgIG5vbmNlQ29udGV4dCxcbiAgICBzZXF1ZW5jZUNvbnRleHQsXG4gICAgc2V0VGltZWxpbmVDb250ZXh0LFxuICAgIHRpbWVsaW5lQ29udGV4dCxcbiAgICBjYW5Vc2VSZW1vdGlvbkhvb2tzQ29udGV4dCxcbiAgICBuYXRpdmVMYXllcnNDb250ZXh0LFxuICAgIHByZWxvYWRDb250ZXh0LFxuICAgIHJlc29sdmVDb21wb3NpdGlvbkNvbnRleHQsXG4gICAgcmVuZGVyQXNzZXRNYW5hZ2VyQ29udGV4dCxcbiAgICBzZXF1ZW5jZU1hbmFnZXJDb250ZXh0LFxuICAgIGJ1ZmZlck1hbmFnZXJDb250ZXh0XG4gIF0pO1xufVxuaW1wb3J0IHsganN4IGFzIGpzeDI2IH0gZnJvbSBcInJlYWN0L2pzeC1ydW50aW1lXCI7XG52YXIgUmVtb3Rpb25Db250ZXh0UHJvdmlkZXIgPSAocHJvcHMyKSA9PiB7XG4gIGNvbnN0IHsgY2hpbGRyZW4sIGNvbnRleHRzIH0gPSBwcm9wczI7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8ganN4MjYoQ2FuVXNlUmVtb3Rpb25Ib29rcy5Qcm92aWRlciwge1xuICAgIHZhbHVlOiBjb250ZXh0cy5jYW5Vc2VSZW1vdGlvbkhvb2tzQ29udGV4dCxcbiAgICBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIGpzeDI2KE5vbmNlQ29udGV4dC5Qcm92aWRlciwge1xuICAgICAgdmFsdWU6IGNvbnRleHRzLm5vbmNlQ29udGV4dCxcbiAgICAgIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8ganN4MjYoTmF0aXZlTGF5ZXJzQ29udGV4dC5Qcm92aWRlciwge1xuICAgICAgICB2YWx1ZTogY29udGV4dHMubmF0aXZlTGF5ZXJzQ29udGV4dCxcbiAgICAgICAgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBqc3gyNihQcmVsb2FkQ29udGV4dC5Qcm92aWRlciwge1xuICAgICAgICAgIHZhbHVlOiBjb250ZXh0cy5wcmVsb2FkQ29udGV4dCxcbiAgICAgICAgICBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIGpzeDI2KENvbXBvc2l0aW9uTWFuYWdlci5Qcm92aWRlciwge1xuICAgICAgICAgICAgdmFsdWU6IGNvbnRleHRzLmNvbXBvc2l0aW9uTWFuYWdlckN0eCxcbiAgICAgICAgICAgIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8ganN4MjYoU2VxdWVuY2VNYW5hZ2VyLlByb3ZpZGVyLCB7XG4gICAgICAgICAgICAgIHZhbHVlOiBjb250ZXh0cy5zZXF1ZW5jZU1hbmFnZXJDb250ZXh0LFxuICAgICAgICAgICAgICBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIGpzeDI2KFJlbmRlckFzc2V0TWFuYWdlci5Qcm92aWRlciwge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBjb250ZXh0cy5yZW5kZXJBc3NldE1hbmFnZXJDb250ZXh0LFxuICAgICAgICAgICAgICAgIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8ganN4MjYoUmVzb2x2ZUNvbXBvc2l0aW9uQ29udGV4dC5Qcm92aWRlciwge1xuICAgICAgICAgICAgICAgICAgdmFsdWU6IGNvbnRleHRzLnJlc29sdmVDb21wb3NpdGlvbkNvbnRleHQsXG4gICAgICAgICAgICAgICAgICBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIGpzeDI2KFRpbWVsaW5lQ29udGV4dC5Qcm92aWRlciwge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogY29udGV4dHMudGltZWxpbmVDb250ZXh0LFxuICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIGpzeDI2KFNldFRpbWVsaW5lQ29udGV4dC5Qcm92aWRlciwge1xuICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBjb250ZXh0cy5zZXRUaW1lbGluZUNvbnRleHQsXG4gICAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBqc3gyNihTZXF1ZW5jZUNvbnRleHQuUHJvdmlkZXIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBjb250ZXh0cy5zZXF1ZW5jZUNvbnRleHQsXG4gICAgICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIGpzeDI2KEJ1ZmZlcmluZ0NvbnRleHRSZWFjdC5Qcm92aWRlciwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogY29udGV4dHMuYnVmZmVyTWFuYWdlckNvbnRleHQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuXG4gICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9KVxuICAgICAgICAgIH0pXG4gICAgICAgIH0pXG4gICAgICB9KVxuICAgIH0pXG4gIH0pO1xufTtcblxuLy8gc3JjL2ludGVybmFscy50c1xudmFyIEludGVybmFscyA9IHtcbiAgdXNlVW5zYWZlVmlkZW9Db25maWcsXG4gIFRpbWVsaW5lOiBleHBvcnRzX3RpbWVsaW5lX3Bvc2l0aW9uX3N0YXRlLFxuICBDb21wb3NpdGlvbk1hbmFnZXIsXG4gIFNlcXVlbmNlTWFuYWdlcixcbiAgU2VxdWVuY2VWaXNpYmlsaXR5VG9nZ2xlQ29udGV4dCxcbiAgUmVtb3Rpb25Sb290LFxuICB1c2VWaWRlbyxcbiAgZ2V0Um9vdCxcbiAgdXNlTWVkaWFWb2x1bWVTdGF0ZSxcbiAgdXNlTWVkaWFNdXRlZFN0YXRlLFxuICB1c2VMYXp5Q29tcG9uZW50LFxuICB0cnV0aHksXG4gIFNlcXVlbmNlQ29udGV4dCxcbiAgdXNlUmVtb3Rpb25Db250ZXh0cyxcbiAgUmVtb3Rpb25Db250ZXh0UHJvdmlkZXIsXG4gIENTU1V0aWxzOiBleHBvcnRzX2RlZmF1bHRfY3NzLFxuICBzZXR1cEVudlZhcmlhYmxlcyxcbiAgTWVkaWFWb2x1bWVDb250ZXh0LFxuICBTZXRNZWRpYVZvbHVtZUNvbnRleHQsXG4gIGdldFJlbW90aW9uRW52aXJvbm1lbnQsXG4gIFNoYXJlZEF1ZGlvQ29udGV4dCxcbiAgU2hhcmVkQXVkaW9Db250ZXh0UHJvdmlkZXIsXG4gIGludmFsaWRDb21wb3NpdGlvbkVycm9yTWVzc2FnZSxcbiAgaXNDb21wb3NpdGlvbklkVmFsaWQsXG4gIGdldFByZXZpZXdEb21FbGVtZW50LFxuICBjb21wb3NpdGlvbnNSZWYsXG4gIHBvcnRhbE5vZGUsXG4gIHdhaXRGb3JSb290LFxuICBDYW5Vc2VSZW1vdGlvbkhvb2tzUHJvdmlkZXIsXG4gIENhblVzZVJlbW90aW9uSG9va3MsXG4gIFByZWZldGNoUHJvdmlkZXIsXG4gIER1cmF0aW9uc0NvbnRleHRQcm92aWRlcixcbiAgSXNQbGF5ZXJDb250ZXh0UHJvdmlkZXIsXG4gIHVzZUlzUGxheWVyLFxuICBFZGl0b3JQcm9wc1Byb3ZpZGVyLFxuICBFZGl0b3JQcm9wc0NvbnRleHQsXG4gIHVzZVByZWxvYWQsXG4gIE5vbmNlQ29udGV4dCxcbiAgcmVzb2x2ZVZpZGVvQ29uZmlnLFxuICB1c2VSZXNvbHZlZFZpZGVvQ29uZmlnLFxuICByZXNvbHZlQ29tcG9zaXRpb25zUmVmLFxuICBSZXNvbHZlQ29tcG9zaXRpb25Db25maWcsXG4gIFJFTU9USU9OX1NUVURJT19DT05UQUlORVJfRUxFTUVOVCxcbiAgUmVuZGVyQXNzZXRNYW5hZ2VyLFxuICBwZXJzaXN0Q3VycmVudEZyYW1lLFxuICB1c2VUaW1lbGluZVNldEZyYW1lLFxuICBOYXRpdmVMYXllcnNQcm92aWRlcixcbiAgQ2xpcENvbXBvc2l0aW9uLFxuICBpc0lvc1NhZmFyaSxcbiAgV0FUQ0hfUkVNT1RJT05fU1RBVElDX0ZJTEVTLFxuICBhZGRTZXF1ZW5jZVN0YWNrVHJhY2VzLFxuICB1c2VNZWRpYVN0YXJ0c0F0LFxuICBCdWZmZXJpbmdQcm92aWRlcixcbiAgQnVmZmVyaW5nQ29udGV4dFJlYWN0LFxuICBlbmFibGVTZXF1ZW5jZVN0YWNrVHJhY2VzLFxuICBDdXJyZW50U2NhbGVDb250ZXh0LFxuICBQcmV2aWV3U2l6ZUNvbnRleHQsXG4gIGNhbGN1bGF0ZVNjYWxlLFxuICBlZGl0b3JQcm9wc1Byb3ZpZGVyUmVmLFxuICBQUk9QU19VUERBVEVEX0VYVEVSTkFMTFksXG4gIHZhbGlkYXRlUmVuZGVyQXNzZXRcbn07XG4vLyBzcmMvaW50ZXJwb2xhdGUtY29sb3JzLnRzXG5mdW5jdGlvbiBjYWxsKC4uLmFyZ3MpIHtcbiAgcmV0dXJuIFwiXFxcXChcXFxccyooXCIgKyBhcmdzLmpvaW4oXCIpXFxcXHMqLFxcXFxzKihcIikgKyBcIilcXFxccypcXFxcKVwiO1xufVxuZnVuY3Rpb24gZ2V0TWF0Y2hlcnMoKSB7XG4gIGNvbnN0IGNhY2hlZE1hdGNoZXJzID0ge1xuICAgIHJnYjogdW5kZWZpbmVkLFxuICAgIHJnYmE6IHVuZGVmaW5lZCxcbiAgICBoc2w6IHVuZGVmaW5lZCxcbiAgICBoc2xhOiB1bmRlZmluZWQsXG4gICAgaGV4MzogdW5kZWZpbmVkLFxuICAgIGhleDQ6IHVuZGVmaW5lZCxcbiAgICBoZXg1OiB1bmRlZmluZWQsXG4gICAgaGV4NjogdW5kZWZpbmVkLFxuICAgIGhleDg6IHVuZGVmaW5lZFxuICB9O1xuICBpZiAoY2FjaGVkTWF0Y2hlcnMucmdiID09PSB1bmRlZmluZWQpIHtcbiAgICBjYWNoZWRNYXRjaGVycy5yZ2IgPSBuZXcgUmVnRXhwKFwicmdiXCIgKyBjYWxsKE5VTUJFUiwgTlVNQkVSLCBOVU1CRVIpKTtcbiAgICBjYWNoZWRNYXRjaGVycy5yZ2JhID0gbmV3IFJlZ0V4cChcInJnYmFcIiArIGNhbGwoTlVNQkVSLCBOVU1CRVIsIE5VTUJFUiwgTlVNQkVSKSk7XG4gICAgY2FjaGVkTWF0Y2hlcnMuaHNsID0gbmV3IFJlZ0V4cChcImhzbFwiICsgY2FsbChOVU1CRVIsIFBFUkNFTlRBR0UsIFBFUkNFTlRBR0UpKTtcbiAgICBjYWNoZWRNYXRjaGVycy5oc2xhID0gbmV3IFJlZ0V4cChcImhzbGFcIiArIGNhbGwoTlVNQkVSLCBQRVJDRU5UQUdFLCBQRVJDRU5UQUdFLCBOVU1CRVIpKTtcbiAgICBjYWNoZWRNYXRjaGVycy5oZXgzID0gL14jKFswLTlhLWZBLUZdezF9KShbMC05YS1mQS1GXXsxfSkoWzAtOWEtZkEtRl17MX0pJC87XG4gICAgY2FjaGVkTWF0Y2hlcnMuaGV4NCA9IC9eIyhbMC05YS1mQS1GXXsxfSkoWzAtOWEtZkEtRl17MX0pKFswLTlhLWZBLUZdezF9KShbMC05YS1mQS1GXXsxfSkkLztcbiAgICBjYWNoZWRNYXRjaGVycy5oZXg2ID0gL14jKFswLTlhLWZBLUZdezZ9KSQvO1xuICAgIGNhY2hlZE1hdGNoZXJzLmhleDggPSAvXiMoWzAtOWEtZkEtRl17OH0pJC87XG4gIH1cbiAgcmV0dXJuIGNhY2hlZE1hdGNoZXJzO1xufVxuZnVuY3Rpb24gaHVlMnJnYihwLCBxLCB0KSB7XG4gIGlmICh0IDwgMCkge1xuICAgIHQgKz0gMTtcbiAgfVxuICBpZiAodCA+IDEpIHtcbiAgICB0IC09IDE7XG4gIH1cbiAgaWYgKHQgPCAxIC8gNikge1xuICAgIHJldHVybiBwICsgKHEgLSBwKSAqIDYgKiB0O1xuICB9XG4gIGlmICh0IDwgMSAvIDIpIHtcbiAgICByZXR1cm4gcTtcbiAgfVxuICBpZiAodCA8IDIgLyAzKSB7XG4gICAgcmV0dXJuIHAgKyAocSAtIHApICogKDIgLyAzIC0gdCkgKiA2O1xuICB9XG4gIHJldHVybiBwO1xufVxuZnVuY3Rpb24gaHNsVG9SZ2IoaCwgcywgbCkge1xuICBjb25zdCBxID0gbCA8IDAuNSA/IGwgKiAoMSArIHMpIDogbCArIHMgLSBsICogcztcbiAgY29uc3QgcCA9IDIgKiBsIC0gcTtcbiAgY29uc3QgciA9IGh1ZTJyZ2IocCwgcSwgaCArIDEgLyAzKTtcbiAgY29uc3QgZyA9IGh1ZTJyZ2IocCwgcSwgaCk7XG4gIGNvbnN0IGIyID0gaHVlMnJnYihwLCBxLCBoIC0gMSAvIDMpO1xuICByZXR1cm4gTWF0aC5yb3VuZChyICogMjU1KSA8PCAyNCB8IE1hdGgucm91bmQoZyAqIDI1NSkgPDwgMTYgfCBNYXRoLnJvdW5kKGIyICogMjU1KSA8PCA4O1xufVxuZnVuY3Rpb24gcGFyc2UyNTUoc3RyKSB7XG4gIGNvbnN0IGludCA9IE51bWJlci5wYXJzZUludChzdHIsIDEwKTtcbiAgaWYgKGludCA8IDApIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuICBpZiAoaW50ID4gMjU1KSB7XG4gICAgcmV0dXJuIDI1NTtcbiAgfVxuICByZXR1cm4gaW50O1xufVxuZnVuY3Rpb24gcGFyc2UzNjAoc3RyKSB7XG4gIGNvbnN0IGludCA9IE51bWJlci5wYXJzZUZsb2F0KHN0cik7XG4gIHJldHVybiAoaW50ICUgMzYwICsgMzYwKSAlIDM2MCAvIDM2MDtcbn1cbmZ1bmN0aW9uIHBhcnNlMShzdHIpIHtcbiAgY29uc3QgbnVtID0gTnVtYmVyLnBhcnNlRmxvYXQoc3RyKTtcbiAgaWYgKG51bSA8IDApIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuICBpZiAobnVtID4gMSkge1xuICAgIHJldHVybiAyNTU7XG4gIH1cbiAgcmV0dXJuIE1hdGgucm91bmQobnVtICogMjU1KTtcbn1cbmZ1bmN0aW9uIHBhcnNlUGVyY2VudGFnZShzdHIpIHtcbiAgY29uc3QgaW50ID0gTnVtYmVyLnBhcnNlRmxvYXQoc3RyKTtcbiAgaWYgKGludCA8IDApIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuICBpZiAoaW50ID4gMTAwKSB7XG4gICAgcmV0dXJuIDE7XG4gIH1cbiAgcmV0dXJuIGludCAvIDEwMDtcbn1cbmZ1bmN0aW9uIG5vcm1hbGl6ZUNvbG9yKGNvbG9yKSB7XG4gIGNvbnN0IG1hdGNoZXJzID0gZ2V0TWF0Y2hlcnMoKTtcbiAgbGV0IG1hdGNoO1xuICBpZiAobWF0Y2hlcnMuaGV4Nikge1xuICAgIGlmIChtYXRjaCA9IG1hdGNoZXJzLmhleDYuZXhlYyhjb2xvcikpIHtcbiAgICAgIHJldHVybiBOdW1iZXIucGFyc2VJbnQobWF0Y2hbMV0gKyBcImZmXCIsIDE2KSA+Pj4gMDtcbiAgICB9XG4gIH1cbiAgaWYgKGNvbG9yTmFtZXNbY29sb3JdICE9PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gY29sb3JOYW1lc1tjb2xvcl07XG4gIH1cbiAgaWYgKG1hdGNoZXJzLnJnYikge1xuICAgIGlmIChtYXRjaCA9IG1hdGNoZXJzLnJnYi5leGVjKGNvbG9yKSkge1xuICAgICAgcmV0dXJuIChwYXJzZTI1NShtYXRjaFsxXSkgPDwgMjQgfCBwYXJzZTI1NShtYXRjaFsyXSkgPDwgMTYgfCBwYXJzZTI1NShtYXRjaFszXSkgPDwgOCB8IDI1NSkgPj4+IDA7XG4gICAgfVxuICB9XG4gIGlmIChtYXRjaGVycy5yZ2JhKSB7XG4gICAgaWYgKG1hdGNoID0gbWF0Y2hlcnMucmdiYS5leGVjKGNvbG9yKSkge1xuICAgICAgcmV0dXJuIChwYXJzZTI1NShtYXRjaFsxXSkgPDwgMjQgfCBwYXJzZTI1NShtYXRjaFsyXSkgPDwgMTYgfCBwYXJzZTI1NShtYXRjaFszXSkgPDwgOCB8IHBhcnNlMShtYXRjaFs0XSkpID4+PiAwO1xuICAgIH1cbiAgfVxuICBpZiAobWF0Y2hlcnMuaGV4Mykge1xuICAgIGlmIChtYXRjaCA9IG1hdGNoZXJzLmhleDMuZXhlYyhjb2xvcikpIHtcbiAgICAgIHJldHVybiBOdW1iZXIucGFyc2VJbnQobWF0Y2hbMV0gKyBtYXRjaFsxXSArIG1hdGNoWzJdICsgbWF0Y2hbMl0gKyBtYXRjaFszXSArIG1hdGNoWzNdICsgXCJmZlwiLCAxNikgPj4+IDA7XG4gICAgfVxuICB9XG4gIGlmIChtYXRjaGVycy5oZXg4KSB7XG4gICAgaWYgKG1hdGNoID0gbWF0Y2hlcnMuaGV4OC5leGVjKGNvbG9yKSkge1xuICAgICAgcmV0dXJuIE51bWJlci5wYXJzZUludChtYXRjaFsxXSwgMTYpID4+PiAwO1xuICAgIH1cbiAgfVxuICBpZiAobWF0Y2hlcnMuaGV4NCkge1xuICAgIGlmIChtYXRjaCA9IG1hdGNoZXJzLmhleDQuZXhlYyhjb2xvcikpIHtcbiAgICAgIHJldHVybiBOdW1iZXIucGFyc2VJbnQobWF0Y2hbMV0gKyBtYXRjaFsxXSArIG1hdGNoWzJdICsgbWF0Y2hbMl0gKyBtYXRjaFszXSArIG1hdGNoWzNdICsgbWF0Y2hbNF0gKyBtYXRjaFs0XSwgMTYpID4+PiAwO1xuICAgIH1cbiAgfVxuICBpZiAobWF0Y2hlcnMuaHNsKSB7XG4gICAgaWYgKG1hdGNoID0gbWF0Y2hlcnMuaHNsLmV4ZWMoY29sb3IpKSB7XG4gICAgICByZXR1cm4gKGhzbFRvUmdiKHBhcnNlMzYwKG1hdGNoWzFdKSwgcGFyc2VQZXJjZW50YWdlKG1hdGNoWzJdKSwgcGFyc2VQZXJjZW50YWdlKG1hdGNoWzNdKSkgfCAyNTUpID4+PiAwO1xuICAgIH1cbiAgfVxuICBpZiAobWF0Y2hlcnMuaHNsYSkge1xuICAgIGlmIChtYXRjaCA9IG1hdGNoZXJzLmhzbGEuZXhlYyhjb2xvcikpIHtcbiAgICAgIHJldHVybiAoaHNsVG9SZ2IocGFyc2UzNjAobWF0Y2hbMV0pLCBwYXJzZVBlcmNlbnRhZ2UobWF0Y2hbMl0pLCBwYXJzZVBlcmNlbnRhZ2UobWF0Y2hbM10pKSB8IHBhcnNlMShtYXRjaFs0XSkpID4+PiAwO1xuICAgIH1cbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgY29sb3Igc3RyaW5nICR7Y29sb3J9IHByb3ZpZGVkYCk7XG59XG5mdW5jdGlvbiBwcm9jZXNzQ29sb3IoY29sb3IpIHtcbiAgY29uc3Qgbm9ybWFsaXplZENvbG9yID0gbm9ybWFsaXplQ29sb3IoY29sb3IpO1xuICByZXR1cm4gKG5vcm1hbGl6ZWRDb2xvciA8PCAyNCB8IG5vcm1hbGl6ZWRDb2xvciA+Pj4gOCkgPj4+IDA7XG59XG52YXIgTlVNQkVSID0gXCJbLStdP1xcXFxkKlxcXFwuP1xcXFxkK1wiO1xudmFyIFBFUkNFTlRBR0UgPSBOVU1CRVIgKyBcIiVcIjtcbnZhciBjb2xvck5hbWVzID0ge1xuICB0cmFuc3BhcmVudDogMCxcbiAgYWxpY2VibHVlOiA0MDQyODUwMzAzLFxuICBhbnRpcXVld2hpdGU6IDQyMDk3NjAyNTUsXG4gIGFxdWE6IDE2Nzc3MjE1LFxuICBhcXVhbWFyaW5lOiAyMTQ3NDcyNjM5LFxuICBhenVyZTogNDA0MzMwOTA1NSxcbiAgYmVpZ2U6IDQxMjY1MzA4MTUsXG4gIGJpc3F1ZTogNDI5MzE4MjcxOSxcbiAgYmxhY2s6IDI1NSxcbiAgYmxhbmNoZWRhbG1vbmQ6IDQyOTM2NDM3NzUsXG4gIGJsdWU6IDY1NTM1LFxuICBibHVldmlvbGV0OiAyMzE4MTMxOTY3LFxuICBicm93bjogMjc3MTAwNDE1OSxcbiAgYnVybHl3b29kOiAzNzM2NjM1MzkxLFxuICBidXJudHNpZW5uYTogMzkzNDE1MDE0MyxcbiAgY2FkZXRibHVlOiAxNjA0MjMxNDIzLFxuICBjaGFydHJldXNlOiAyMTQ3NDE4MzY3LFxuICBjaG9jb2xhdGU6IDM1MzAxMDQ1NzUsXG4gIGNvcmFsOiA0Mjg2NTMzODg3LFxuICBjb3JuZmxvd2VyYmx1ZTogMTY4NzU0NzM5MSxcbiAgY29ybnNpbGs6IDQyOTQ0OTk1ODMsXG4gIGNyaW1zb246IDM2OTIzMTM4NTUsXG4gIGN5YW46IDE2Nzc3MjE1LFxuICBkYXJrYmx1ZTogMzU4MzksXG4gIGRhcmtjeWFuOiA5MTQ1MzQzLFxuICBkYXJrZ29sZGVucm9kOiAzMDk1NzkyNjM5LFxuICBkYXJrZ3JheTogMjg0NjQ2ODYwNyxcbiAgZGFya2dyZWVuOiA2NTUzODU1LFxuICBkYXJrZ3JleTogMjg0NjQ2ODYwNyxcbiAgZGFya2toYWtpOiAzMTgyOTE0NTU5LFxuICBkYXJrbWFnZW50YTogMjMzMjA2ODg2MyxcbiAgZGFya29saXZlZ3JlZW46IDE0MzMwODc5OTksXG4gIGRhcmtvcmFuZ2U6IDQyODczNjUzNzUsXG4gIGRhcmtvcmNoaWQ6IDI1NzAyNDMzMjcsXG4gIGRhcmtyZWQ6IDIzMzIwMzMyNzksXG4gIGRhcmtzYWxtb246IDM5MTg5NTMyMTUsXG4gIGRhcmtzZWFncmVlbjogMjQxMTQ5OTUxOSxcbiAgZGFya3NsYXRlYmx1ZTogMTIxMTk5MzA4NyxcbiAgZGFya3NsYXRlZ3JheTogNzkzNzI2OTc1LFxuICBkYXJrc2xhdGVncmV5OiA3OTM3MjY5NzUsXG4gIGRhcmt0dXJxdW9pc2U6IDEzNTU0MTc1LFxuICBkYXJrdmlvbGV0OiAyNDgzMDgyMjM5LFxuICBkZWVwcGluazogNDI3OTUzODY4NyxcbiAgZGVlcHNreWJsdWU6IDEyNTgyOTExLFxuICBkaW1ncmF5OiAxNzY4NTE2MDk1LFxuICBkaW1ncmV5OiAxNzY4NTE2MDk1LFxuICBkb2RnZXJibHVlOiA1MTI4MTkxOTksXG4gIGZpcmVicmljazogMjk4ODU4MTYzMSxcbiAgZmxvcmFsd2hpdGU6IDQyOTQ2MzU3NzUsXG4gIGZvcmVzdGdyZWVuOiA1Nzk1NDM4MDcsXG4gIGZ1Y2hzaWE6IDQyNzgyNTU2MTUsXG4gIGdhaW5zYm9ybzogMzcwNTQ2MjAxNSxcbiAgZ2hvc3R3aGl0ZTogNDE3NzA2ODAzMSxcbiAgZ29sZDogNDI5MjI4MDU3NSxcbiAgZ29sZGVucm9kOiAzNjY4MjU0OTc1LFxuICBncmF5OiAyMTU1OTA1Mjc5LFxuICBncmVlbjogODM4ODg2MyxcbiAgZ3JlZW55ZWxsb3c6IDI5MTkxODIzMzUsXG4gIGdyZXk6IDIxNTU5MDUyNzksXG4gIGhvbmV5ZGV3OiA0MDQzMzA1MjE1LFxuICBob3RwaW5rOiA0Mjg1MTE3Njk1LFxuICBpbmRpYW5yZWQ6IDM0NDUzODIzOTksXG4gIGluZGlnbzogMTI1ODMyNDczNSxcbiAgaXZvcnk6IDQyOTQ5NjM0NTUsXG4gIGtoYWtpOiA0MDQxNjQxMjE1LFxuICBsYXZlbmRlcjogMzg3Mzg5NzIxNSxcbiAgbGF2ZW5kZXJibHVzaDogNDI5Mzk4MTY5NSxcbiAgbGF3bmdyZWVuOiAyMDk2ODkwMTExLFxuICBsZW1vbmNoaWZmb246IDQyOTQ2MjY4MTUsXG4gIGxpZ2h0Ymx1ZTogMjkxNjY3MzI3OSxcbiAgbGlnaHRjb3JhbDogNDAzNDk1MzQ3MSxcbiAgbGlnaHRjeWFuOiAzNzc0ODczNTk5LFxuICBsaWdodGdvbGRlbnJvZHllbGxvdzogNDIxMDc0MjAxNSxcbiAgbGlnaHRncmF5OiAzNTUzODc0OTQzLFxuICBsaWdodGdyZWVuOiAyNDMxNTUzNzkxLFxuICBsaWdodGdyZXk6IDM1NTM4NzQ5NDMsXG4gIGxpZ2h0cGluazogNDI5MDE2NzI5NSxcbiAgbGlnaHRzYWxtb246IDQyODg3MDczMjcsXG4gIGxpZ2h0c2VhZ3JlZW46IDU0ODU4MDA5NSxcbiAgbGlnaHRza3libHVlOiAyMjc4NDg4ODMxLFxuICBsaWdodHNsYXRlZ3JheTogMjAwNTQ0MTAyMyxcbiAgbGlnaHRzbGF0ZWdyZXk6IDIwMDU0NDEwMjMsXG4gIGxpZ2h0c3RlZWxibHVlOiAyOTY1NjkyMTU5LFxuICBsaWdodHllbGxvdzogNDI5NDk1OTM1OSxcbiAgbGltZTogMTY3MTE5MzUsXG4gIGxpbWVncmVlbjogODUyMzA4NzM1LFxuICBsaW5lbjogNDIxMDA5MTc3NSxcbiAgbWFnZW50YTogNDI3ODI1NTYxNSxcbiAgbWFyb29uOiAyMTQ3NDgzOTAzLFxuICBtZWRpdW1hcXVhbWFyaW5lOiAxNzI0NzU0Njg3LFxuICBtZWRpdW1ibHVlOiA1MjczNSxcbiAgbWVkaXVtb3JjaGlkOiAzMTI2MTg3MDA3LFxuICBtZWRpdW1wdXJwbGU6IDI0NzM2NDcxMDMsXG4gIG1lZGl1bXNlYWdyZWVuOiAxMDE4MzkzMDg3LFxuICBtZWRpdW1zbGF0ZWJsdWU6IDIwNzA0NzQ0OTUsXG4gIG1lZGl1bXNwcmluZ2dyZWVuOiAxNjQyMzY3OSxcbiAgbWVkaXVtdHVycXVvaXNlOiAxMjIxNzA5MDU1LFxuICBtZWRpdW12aW9sZXRyZWQ6IDMzNDAwNzY1NDMsXG4gIG1pZG5pZ2h0Ymx1ZTogNDIxMDk3NzI3LFxuICBtaW50Y3JlYW06IDQxMjcxOTM4NTUsXG4gIG1pc3R5cm9zZTogNDI5MzE5MDE0MyxcbiAgbW9jY2FzaW46IDQyOTMxNzg4NzksXG4gIG5hdmFqb3doaXRlOiA0MjkyNzgzNjE1LFxuICBuYXZ5OiAzMzAyMyxcbiAgb2xkbGFjZTogNDI2MDc1MTEwMyxcbiAgb2xpdmU6IDIxNTU4NzI1MTEsXG4gIG9saXZlZHJhYjogMTgwNDQ3NzQzOSxcbiAgb3JhbmdlOiA0Mjg5MDAzNzc1LFxuICBvcmFuZ2VyZWQ6IDQyODI3MTIzMTksXG4gIG9yY2hpZDogMzY2NDgyODE1OSxcbiAgcGFsZWdvbGRlbnJvZDogNDAwODIyNTUzNSxcbiAgcGFsZWdyZWVuOiAyNTY2NjI1NTM1LFxuICBwYWxldHVycXVvaXNlOiAyOTUxNjcxNTUxLFxuICBwYWxldmlvbGV0cmVkOiAzNjgxNTg4MjIzLFxuICBwYXBheWF3aGlwOiA0MjkzOTA3OTY3LFxuICBwZWFjaHB1ZmY6IDQyOTI1MjQ1NDMsXG4gIHBlcnU6IDM0NDgwNjE5NTEsXG4gIHBpbms6IDQyOTA4MjUyMTUsXG4gIHBsdW06IDM3MTgzMDczMjcsXG4gIHBvd2RlcmJsdWU6IDI5Njc1MjkyMTUsXG4gIHB1cnBsZTogMjE0NzUxNjY3MSxcbiAgcmViZWNjYXB1cnBsZTogMTcxNDY1Nzc5MSxcbiAgcmVkOiA0Mjc4MTkwMzM1LFxuICByb3N5YnJvd246IDMxNjM1MjUxMTksXG4gIHJveWFsYmx1ZTogMTA5NzQ1ODE3NSxcbiAgc2FkZGxlYnJvd246IDIzMzY1NjAxMjcsXG4gIHNhbG1vbjogNDIwMjcyMjA0NyxcbiAgc2FuZHlicm93bjogNDEwNDQxMzQzOSxcbiAgc2VhZ3JlZW46IDc4MDg4Mzk2NyxcbiAgc2Vhc2hlbGw6IDQyOTQzMDc1ODMsXG4gIHNpZW5uYTogMjY4OTc0MDI4NyxcbiAgc2lsdmVyOiAzMjMzODU3NzkxLFxuICBza3libHVlOiAyMjc4NDg0OTkxLFxuICBzbGF0ZWJsdWU6IDE3ODQzMzU4NzEsXG4gIHNsYXRlZ3JheTogMTg4NzQ3MzkxOSxcbiAgc2xhdGVncmV5OiAxODg3NDczOTE5LFxuICBzbm93OiA0Mjk0NjM4MzM1LFxuICBzcHJpbmdncmVlbjogMTY3NDQ0NDcsXG4gIHN0ZWVsYmx1ZTogMTE4Mjk3MTEzNSxcbiAgdGFuOiAzNTM1MDQ3OTM1LFxuICB0ZWFsOiA4NDIxNjMxLFxuICB0aGlzdGxlOiAzNjM2NDUxNTgzLFxuICB0b21hdG86IDQyODQ2OTY1NzUsXG4gIHR1cnF1b2lzZTogMTA4ODQ3NTM5MSxcbiAgdmlvbGV0OiA0MDAxNTU4MjcxLFxuICB3aGVhdDogNDEyNTAxMjk5MSxcbiAgd2hpdGU6IDQyOTQ5NjcyOTUsXG4gIHdoaXRlc21va2U6IDQxMjY1MzcyMTUsXG4gIHllbGxvdzogNDI5NDkwMjAxNSxcbiAgeWVsbG93Z3JlZW46IDI1OTcxMzkxOTlcbn07XG52YXIgb3BhY2l0eSA9IChjMikgPT4ge1xuICByZXR1cm4gKGMyID4+IDI0ICYgMjU1KSAvIDI1NTtcbn07XG52YXIgcmVkID0gKGMyKSA9PiB7XG4gIHJldHVybiBjMiA+PiAxNiAmIDI1NTtcbn07XG52YXIgZ3JlZW4gPSAoYzIpID0+IHtcbiAgcmV0dXJuIGMyID4+IDggJiAyNTU7XG59O1xudmFyIGJsdWUgPSAoYzIpID0+IHtcbiAgcmV0dXJuIGMyICYgMjU1O1xufTtcbnZhciByZ2JhQ29sb3IgPSAociwgZywgYjIsIGFscGhhKSA9PiB7XG4gIHJldHVybiBgcmdiYSgke3J9LCAke2d9LCAke2IyfSwgJHthbHBoYX0pYDtcbn07XG52YXIgaW50ZXJwb2xhdGVDb2xvcnNSR0IgPSAodmFsdWUsIGlucHV0UmFuZ2UsIGNvbG9ycykgPT4ge1xuICBjb25zdCBbciwgZywgYjIsIGEyXSA9IFtyZWQsIGdyZWVuLCBibHVlLCBvcGFjaXR5XS5tYXAoKGYpID0+IHtcbiAgICBjb25zdCB1bnJvdW5kZWQgPSBpbnRlcnBvbGF0ZSh2YWx1ZSwgaW5wdXRSYW5nZSwgY29sb3JzLm1hcCgoYzIpID0+IGYoYzIpKSwge1xuICAgICAgZXh0cmFwb2xhdGVMZWZ0OiBcImNsYW1wXCIsXG4gICAgICBleHRyYXBvbGF0ZVJpZ2h0OiBcImNsYW1wXCJcbiAgICB9KTtcbiAgICBpZiAoZiA9PT0gb3BhY2l0eSkge1xuICAgICAgcmV0dXJuIE51bWJlcih1bnJvdW5kZWQudG9GaXhlZCgzKSk7XG4gICAgfVxuICAgIHJldHVybiBNYXRoLnJvdW5kKHVucm91bmRlZCk7XG4gIH0pO1xuICByZXR1cm4gcmdiYUNvbG9yKHIsIGcsIGIyLCBhMik7XG59O1xudmFyIGludGVycG9sYXRlQ29sb3JzID0gKGlucHV0LCBpbnB1dFJhbmdlLCBvdXRwdXRSYW5nZSkgPT4ge1xuICBpZiAodHlwZW9mIGlucHV0ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImlucHV0IGNhbiBub3QgYmUgdW5kZWZpbmVkXCIpO1xuICB9XG4gIGlmICh0eXBlb2YgaW5wdXRSYW5nZSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJpbnB1dFJhbmdlIGNhbiBub3QgYmUgdW5kZWZpbmVkXCIpO1xuICB9XG4gIGlmICh0eXBlb2Ygb3V0cHV0UmFuZ2UgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwib3V0cHV0UmFuZ2UgY2FuIG5vdCBiZSB1bmRlZmluZWRcIik7XG4gIH1cbiAgaWYgKGlucHV0UmFuZ2UubGVuZ3RoICE9PSBvdXRwdXRSYW5nZS5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiaW5wdXRSYW5nZSAoXCIgKyBpbnB1dFJhbmdlLmxlbmd0aCArIFwiIHZhbHVlcyBwcm92aWRlZCkgYW5kIG91dHB1dFJhbmdlIChcIiArIG91dHB1dFJhbmdlLmxlbmd0aCArIFwiIHZhbHVlcyBwcm92aWRlZCkgbXVzdCBoYXZlIHRoZSBzYW1lIGxlbmd0aFwiKTtcbiAgfVxuICBjb25zdCBwcm9jZXNzZWRPdXRwdXRSYW5nZSA9IG91dHB1dFJhbmdlLm1hcCgoYzIpID0+IHByb2Nlc3NDb2xvcihjMikpO1xuICByZXR1cm4gaW50ZXJwb2xhdGVDb2xvcnNSR0IoaW5wdXQsIGlucHV0UmFuZ2UsIHByb2Nlc3NlZE91dHB1dFJhbmdlKTtcbn07XG4vLyBzcmMvdmFsaWRhdGUtZnJhbWUudHNcbnZhciB2YWxpZGF0ZUZyYW1lID0gKHtcbiAgYWxsb3dGbG9hdHMsXG4gIGR1cmF0aW9uSW5GcmFtZXMsXG4gIGZyYW1lXG59KSA9PiB7XG4gIGlmICh0eXBlb2YgZnJhbWUgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBBcmd1bWVudCBtaXNzaW5nIGZvciBwYXJhbWV0ZXIgXCJmcmFtZVwiYCk7XG4gIH1cbiAgaWYgKHR5cGVvZiBmcmFtZSAhPT0gXCJudW1iZXJcIikge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYEFyZ3VtZW50IHBhc3NlZCBmb3IgXCJmcmFtZVwiIGlzIG5vdCBhIG51bWJlcjogJHtmcmFtZX1gKTtcbiAgfVxuICBpZiAoIU51bWJlci5pc0Zpbml0ZShmcmFtZSkpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgRnJhbWUgJHtmcmFtZX0gaXMgbm90IGZpbml0ZWApO1xuICB9XG4gIGlmIChmcmFtZSAlIDEgIT09IDAgJiYgIWFsbG93RmxvYXRzKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYEFyZ3VtZW50IGZvciBmcmFtZSBtdXN0IGJlIGFuIGludGVnZXIsIGJ1dCBnb3QgJHtmcmFtZX1gKTtcbiAgfVxuICBpZiAoZnJhbWUgPCAwICYmIGZyYW1lIDwgLWR1cmF0aW9uSW5GcmFtZXMpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgQ2Fubm90IHVzZSBmcmFtZSAke2ZyYW1lfTogRHVyYXRpb24gb2YgY29tcG9zaXRpb24gaXMgJHtkdXJhdGlvbkluRnJhbWVzfSwgdGhlcmVmb3JlIHRoZSBsb3dlc3QgZnJhbWUgdGhhdCBjYW4gYmUgcmVuZGVyZWQgaXMgJHstZHVyYXRpb25JbkZyYW1lc31gKTtcbiAgfVxuICBpZiAoZnJhbWUgPiBkdXJhdGlvbkluRnJhbWVzIC0gMSkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGBDYW5ub3QgdXNlIGZyYW1lICR7ZnJhbWV9OiBEdXJhdGlvbiBvZiBjb21wb3NpdGlvbiBpcyAke2R1cmF0aW9uSW5GcmFtZXN9LCB0aGVyZWZvcmUgdGhlIGhpZ2hlc3QgZnJhbWUgdGhhdCBjYW4gYmUgcmVuZGVyZWQgaXMgJHtkdXJhdGlvbkluRnJhbWVzIC0gMX1gKTtcbiAgfVxufTtcblxuLy8gc3JjL3ZpZGVvL29mZnRocmVhZC12aWRlby1zb3VyY2UudHNcbnZhciBnZXRPZmZ0aHJlYWRWaWRlb1NvdXJjZSA9ICh7XG4gIHNyYyxcbiAgdHJhbnNwYXJlbnQsXG4gIGN1cnJlbnRUaW1lLFxuICB0b25lTWFwcGVkXG59KSA9PiB7XG4gIHJldHVybiBgaHR0cDovL2xvY2FsaG9zdDoke3dpbmRvdy5yZW1vdGlvbl9wcm94eVBvcnR9L3Byb3h5P3NyYz0ke2VuY29kZVVSSUNvbXBvbmVudChnZXRBYnNvbHV0ZVNyYyhzcmMpKX0mdGltZT0ke2VuY29kZVVSSUNvbXBvbmVudChjdXJyZW50VGltZSl9JnRyYW5zcGFyZW50PSR7U3RyaW5nKHRyYW5zcGFyZW50KX0mdG9uZU1hcHBlZD0ke1N0cmluZyh0b25lTWFwcGVkKX1gO1xufTtcbi8vIHNyYy9zZXJpZXMvaW5kZXgudHN4XG5pbXBvcnQgeyBDaGlsZHJlbiwgZm9yd2FyZFJlZiBhcyBmb3J3YXJkUmVmOCwgdXNlTWVtbyBhcyB1c2VNZW1vMjggfSBmcm9tIFwicmVhY3RcIjtcblxuLy8gc3JjL3Nlcmllcy9mbGF0dGVuLWNoaWxkcmVuLnRzeFxuaW1wb3J0IFJlYWN0MjQgZnJvbSBcInJlYWN0XCI7XG52YXIgZmxhdHRlbkNoaWxkcmVuID0gKGNoaWxkcmVuKSA9PiB7XG4gIGNvbnN0IGNoaWxkcmVuQXJyYXkgPSBSZWFjdDI0LkNoaWxkcmVuLnRvQXJyYXkoY2hpbGRyZW4pO1xuICByZXR1cm4gY2hpbGRyZW5BcnJheS5yZWR1Y2UoKGZsYXRDaGlsZHJlbiwgY2hpbGQpID0+IHtcbiAgICBpZiAoY2hpbGQudHlwZSA9PT0gUmVhY3QyNC5GcmFnbWVudCkge1xuICAgICAgcmV0dXJuIGZsYXRDaGlsZHJlbi5jb25jYXQoZmxhdHRlbkNoaWxkcmVuKGNoaWxkLnByb3BzLmNoaWxkcmVuKSk7XG4gICAgfVxuICAgIGZsYXRDaGlsZHJlbi5wdXNoKGNoaWxkKTtcbiAgICByZXR1cm4gZmxhdENoaWxkcmVuO1xuICB9LCBbXSk7XG59O1xuXG4vLyBzcmMvc2VyaWVzL2lzLWluc2lkZS1zZXJpZXMudHN4XG5pbXBvcnQgUmVhY3QyNSwgeyBjcmVhdGVDb250ZXh0IGFzIGNyZWF0ZUNvbnRleHQxOSB9IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHsganN4IGFzIGpzeDI3IH0gZnJvbSBcInJlYWN0L2pzeC1ydW50aW1lXCI7XG52YXIgSXNJbnNpZGVTZXJpZXNDb250ZXh0ID0gY3JlYXRlQ29udGV4dDE5KGZhbHNlKTtcbnZhciBJc0luc2lkZVNlcmllc0NvbnRhaW5lciA9ICh7IGNoaWxkcmVuIH0pID0+IHtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBqc3gyNyhJc0luc2lkZVNlcmllc0NvbnRleHQuUHJvdmlkZXIsIHtcbiAgICB2YWx1ZTogdHJ1ZSxcbiAgICBjaGlsZHJlblxuICB9KTtcbn07XG52YXIgSXNOb3RJbnNpZGVTZXJpZXNQcm92aWRlciA9ICh7IGNoaWxkcmVuIH0pID0+IHtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBqc3gyNyhJc0luc2lkZVNlcmllc0NvbnRleHQuUHJvdmlkZXIsIHtcbiAgICB2YWx1ZTogZmFsc2UsXG4gICAgY2hpbGRyZW5cbiAgfSk7XG59O1xudmFyIHVzZVJlcXVpcmVUb0JlSW5zaWRlU2VyaWVzID0gKCkgPT4ge1xuICBjb25zdCBpc0luc2lkZVNlcmllcyA9IFJlYWN0MjUudXNlQ29udGV4dChJc0luc2lkZVNlcmllc0NvbnRleHQpO1xuICBpZiAoIWlzSW5zaWRlU2VyaWVzKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiVGhpcyBjb21wb25lbnQgbXVzdCBiZSBpbnNpZGUgYSA8U2VyaWVzIC8+IGNvbXBvbmVudC5cIik7XG4gIH1cbn07XG5cbi8vIHNyYy9zZXJpZXMvaW5kZXgudHN4XG5pbXBvcnQgeyBqc3ggYXMganN4MjggfSBmcm9tIFwicmVhY3QvanN4LXJ1bnRpbWVcIjtcbnZhciBTZXJpZXNTZXF1ZW5jZVJlZkZvcndhcmRpbmdGdW5jdGlvbiA9ICh7IGNoaWxkcmVuIH0sIF9yZWYpID0+IHtcbiAgdXNlUmVxdWlyZVRvQmVJbnNpZGVTZXJpZXMoKTtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBqc3gyOChJc05vdEluc2lkZVNlcmllc1Byb3ZpZGVyLCB7XG4gICAgY2hpbGRyZW5cbiAgfSk7XG59O1xudmFyIFNlcmllc1NlcXVlbmNlID0gZm9yd2FyZFJlZjgoU2VyaWVzU2VxdWVuY2VSZWZGb3J3YXJkaW5nRnVuY3Rpb24pO1xudmFyIFNlcmllcyA9IChwcm9wczIpID0+IHtcbiAgY29uc3QgY2hpbGRyZW5WYWx1ZSA9IHVzZU1lbW8yOCgoKSA9PiB7XG4gICAgbGV0IHN0YXJ0RnJhbWUgPSAwO1xuICAgIGNvbnN0IGZsYXR0ZW5lZENoaWxkcmVuID0gZmxhdHRlbkNoaWxkcmVuKHByb3BzMi5jaGlsZHJlbik7XG4gICAgcmV0dXJuIENoaWxkcmVuLm1hcChmbGF0dGVuZWRDaGlsZHJlbiwgKGNoaWxkLCBpKSA9PiB7XG4gICAgICBjb25zdCBjYXN0ZWRDaGlsZCA9IGNoaWxkO1xuICAgICAgaWYgKHR5cGVvZiBjYXN0ZWRDaGlsZCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBpZiAoY2FzdGVkQ2hpbGQudHJpbSgpID09PSBcIlwiKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgVGhlIDxTZXJpZXMgLz4gY29tcG9uZW50IG9ubHkgYWNjZXB0cyBhIGxpc3Qgb2YgPFNlcmllcy5TZXF1ZW5jZSAvPiBjb21wb25lbnRzIGFzIGl0cyBjaGlsZHJlbiwgYnV0IHlvdSBwYXNzZWQgYSBzdHJpbmcgXCIke2Nhc3RlZENoaWxkfVwiYCk7XG4gICAgICB9XG4gICAgICBpZiAoY2FzdGVkQ2hpbGQudHlwZSAhPT0gU2VyaWVzU2VxdWVuY2UpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgVGhlIDxTZXJpZXMgLz4gY29tcG9uZW50IG9ubHkgYWNjZXB0cyBhIGxpc3Qgb2YgPFNlcmllcy5TZXF1ZW5jZSAvPiBjb21wb25lbnRzIGFzIGl0cyBjaGlsZHJlbiwgYnV0IGdvdCAke2Nhc3RlZENoaWxkfSBpbnN0ZWFkYCk7XG4gICAgICB9XG4gICAgICBjb25zdCBkZWJ1Z0luZm8gPSBgaW5kZXggPSAke2l9LCBkdXJhdGlvbiA9ICR7Y2FzdGVkQ2hpbGQucHJvcHMuZHVyYXRpb25JbkZyYW1lc31gO1xuICAgICAgaWYgKCFjYXN0ZWRDaGlsZD8ucHJvcHMuY2hpbGRyZW4pIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgQSA8U2VyaWVzLlNlcXVlbmNlIC8+IGNvbXBvbmVudCAoJHtkZWJ1Z0luZm99KSB3YXMgZGV0ZWN0ZWQgdG8gbm90IGhhdmUgYW55IGNoaWxkcmVuLiBEZWxldGUgaXQgdG8gZml4IHRoaXMgZXJyb3IuYCk7XG4gICAgICB9XG4gICAgICBjb25zdCBkdXJhdGlvbkluRnJhbWVzUHJvcCA9IGNhc3RlZENoaWxkLnByb3BzLmR1cmF0aW9uSW5GcmFtZXM7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGR1cmF0aW9uSW5GcmFtZXMsXG4gICAgICAgIGNoaWxkcmVuOiBfY2hpbGRyZW4sXG4gICAgICAgIGZyb20sXG4gICAgICAgIG5hbWUsXG4gICAgICAgIC4uLnBhc3NlZFByb3BzXG4gICAgICB9ID0gY2FzdGVkQ2hpbGQucHJvcHM7XG4gICAgICBpZiAoaSAhPT0gZmxhdHRlbmVkQ2hpbGRyZW4ubGVuZ3RoIC0gMSB8fCBkdXJhdGlvbkluRnJhbWVzUHJvcCAhPT0gSW5maW5pdHkpIHtcbiAgICAgICAgdmFsaWRhdGVEdXJhdGlvbkluRnJhbWVzKGR1cmF0aW9uSW5GcmFtZXNQcm9wLCB7XG4gICAgICAgICAgY29tcG9uZW50OiBgb2YgYSA8U2VyaWVzLlNlcXVlbmNlIC8+IGNvbXBvbmVudGAsXG4gICAgICAgICAgYWxsb3dGbG9hdHM6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBjb25zdCBvZmZzZXQgPSBjYXN0ZWRDaGlsZC5wcm9wcy5vZmZzZXQgPz8gMDtcbiAgICAgIGlmIChOdW1iZXIuaXNOYU4ob2Zmc2V0KSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBUaGUgXCJvZmZzZXRcIiBwcm9wZXJ0eSBvZiBhIDxTZXJpZXMuU2VxdWVuY2UgLz4gbXVzdCBub3QgYmUgTmFOLCBidXQgZ290IE5hTiAoJHtkZWJ1Z0luZm99KS5gKTtcbiAgICAgIH1cbiAgICAgIGlmICghTnVtYmVyLmlzRmluaXRlKG9mZnNldCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgVGhlIFwib2Zmc2V0XCIgcHJvcGVydHkgb2YgYSA8U2VyaWVzLlNlcXVlbmNlIC8+IG11c3QgYmUgZmluaXRlLCBidXQgZ290ICR7b2Zmc2V0fSAoJHtkZWJ1Z0luZm99KS5gKTtcbiAgICAgIH1cbiAgICAgIGlmIChvZmZzZXQgJSAxICE9PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFRoZSBcIm9mZnNldFwiIHByb3BlcnR5IG9mIGEgPFNlcmllcy5TZXF1ZW5jZSAvPiBtdXN0IGJlIGZpbml0ZSwgYnV0IGdvdCAke29mZnNldH0gKCR7ZGVidWdJbmZvfSkuYCk7XG4gICAgICB9XG4gICAgICBjb25zdCBjdXJyZW50U3RhcnRGcmFtZSA9IHN0YXJ0RnJhbWUgKyBvZmZzZXQ7XG4gICAgICBzdGFydEZyYW1lICs9IGR1cmF0aW9uSW5GcmFtZXNQcm9wICsgb2Zmc2V0O1xuICAgICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBqc3gyOChTZXF1ZW5jZSwge1xuICAgICAgICBuYW1lOiBuYW1lIHx8IFwiPFNlcmllcy5TZXF1ZW5jZT5cIixcbiAgICAgICAgZnJvbTogY3VycmVudFN0YXJ0RnJhbWUsXG4gICAgICAgIGR1cmF0aW9uSW5GcmFtZXM6IGR1cmF0aW9uSW5GcmFtZXNQcm9wLFxuICAgICAgICAuLi5wYXNzZWRQcm9wcyxcbiAgICAgICAgcmVmOiBjYXN0ZWRDaGlsZC5yZWYsXG4gICAgICAgIGNoaWxkcmVuOiBjaGlsZFxuICAgICAgfSk7XG4gICAgfSk7XG4gIH0sIFtwcm9wczIuY2hpbGRyZW5dKTtcbiAgaWYgKEVOQUJMRV9WNV9CUkVBS0lOR19DSEFOR0VTKSB7XG4gICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBqc3gyOChJc0luc2lkZVNlcmllc0NvbnRhaW5lciwge1xuICAgICAgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBqc3gyOChTZXF1ZW5jZSwge1xuICAgICAgICAuLi5wcm9wczIsXG4gICAgICAgIGNoaWxkcmVuOiBjaGlsZHJlblZhbHVlXG4gICAgICB9KVxuICAgIH0pO1xuICB9XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8ganN4MjgoSXNJbnNpZGVTZXJpZXNDb250YWluZXIsIHtcbiAgICBjaGlsZHJlbjogY2hpbGRyZW5WYWx1ZVxuICB9KTtcbn07XG5TZXJpZXMuU2VxdWVuY2UgPSBTZXJpZXNTZXF1ZW5jZTtcbmFkZFNlcXVlbmNlU3RhY2tUcmFjZXMoU2VyaWVzU2VxdWVuY2UpO1xuLy8gc3JjL3ZhbGlkYXRpb24vdmFsaWRhdGlvbi1zcHJpbmctZHVyYXRpb24udHNcbnZhciB2YWxpZGF0ZVNwcmluZ0R1cmF0aW9uID0gKGR1cikgPT4ge1xuICBpZiAodHlwZW9mIGR1ciA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAodHlwZW9mIGR1ciAhPT0gXCJudW1iZXJcIikge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYEEgXCJkdXJhdGlvblwiIG9mIGEgc3ByaW5nIG11c3QgYmUgYSBcIm51bWJlclwiIGJ1dCBpcyBcIiR7dHlwZW9mIGR1cn1cImApO1xuICB9XG4gIGlmIChOdW1iZXIuaXNOYU4oZHVyKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0EgXCJkdXJhdGlvblwiIG9mIGEgc3ByaW5nIGlzIE5hTiwgd2hpY2ggaXQgbXVzdCBub3QgYmUnKTtcbiAgfVxuICBpZiAoIU51bWJlci5pc0Zpbml0ZShkdXIpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQSBcImR1cmF0aW9uXCIgb2YgYSBzcHJpbmcgbXVzdCBiZSBmaW5pdGUsIGJ1dCBpcyAnICsgZHVyKTtcbiAgfVxuICBpZiAoZHVyIDw9IDApIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBIFwiZHVyYXRpb25cIiBvZiBhIHNwcmluZyBtdXN0IGJlIHBvc2l0aXZlLCBidXQgaXMgJyArIGR1cik7XG4gIH1cbn07XG5cbi8vIHNyYy9zcHJpbmcvc3ByaW5nLXV0aWxzLnRzXG5mdW5jdGlvbiBhZHZhbmNlKHtcbiAgYW5pbWF0aW9uLFxuICBub3csXG4gIGNvbmZpZ1xufSkge1xuICBjb25zdCB7IHRvVmFsdWUsIGxhc3RUaW1lc3RhbXAsIGN1cnJlbnQsIHZlbG9jaXR5IH0gPSBhbmltYXRpb247XG4gIGNvbnN0IGRlbHRhVGltZSA9IE1hdGgubWluKG5vdyAtIGxhc3RUaW1lc3RhbXAsIDY0KTtcbiAgaWYgKGNvbmZpZy5kYW1waW5nIDw9IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJTcHJpbmcgZGFtcGluZyBtdXN0IGJlIGdyZWF0ZXIgdGhhbiAwLCBvdGhlcndpc2UgdGhlIHNwcmluZygpIGFuaW1hdGlvbiB3aWxsIG5ldmVyIGVuZCwgY2F1c2luZyBhbiBpbmZpbml0ZSBsb29wLlwiKTtcbiAgfVxuICBjb25zdCBjMiA9IGNvbmZpZy5kYW1waW5nO1xuICBjb25zdCBtID0gY29uZmlnLm1hc3M7XG4gIGNvbnN0IGsgPSBjb25maWcuc3RpZmZuZXNzO1xuICBjb25zdCBjYWNoZUtleSA9IFtcbiAgICB0b1ZhbHVlLFxuICAgIGxhc3RUaW1lc3RhbXAsXG4gICAgY3VycmVudCxcbiAgICB2ZWxvY2l0eSxcbiAgICBjMixcbiAgICBtLFxuICAgIGssXG4gICAgbm93XG4gIF0uam9pbihcIi1cIik7XG4gIGlmIChhZHZhbmNlQ2FjaGVbY2FjaGVLZXldKSB7XG4gICAgcmV0dXJuIGFkdmFuY2VDYWNoZVtjYWNoZUtleV07XG4gIH1cbiAgY29uc3QgdjAgPSAtdmVsb2NpdHk7XG4gIGNvbnN0IHgwID0gdG9WYWx1ZSAtIGN1cnJlbnQ7XG4gIGNvbnN0IHpldGEgPSBjMiAvICgyICogTWF0aC5zcXJ0KGsgKiBtKSk7XG4gIGNvbnN0IG9tZWdhMCA9IE1hdGguc3FydChrIC8gbSk7XG4gIGNvbnN0IG9tZWdhMSA9IG9tZWdhMCAqIE1hdGguc3FydCgxIC0gemV0YSAqKiAyKTtcbiAgY29uc3QgdCA9IGRlbHRhVGltZSAvIDEwMDA7XG4gIGNvbnN0IHNpbjEgPSBNYXRoLnNpbihvbWVnYTEgKiB0KTtcbiAgY29uc3QgY29zMSA9IE1hdGguY29zKG9tZWdhMSAqIHQpO1xuICBjb25zdCB1bmRlckRhbXBlZEVudmVsb3BlID0gTWF0aC5leHAoLXpldGEgKiBvbWVnYTAgKiB0KTtcbiAgY29uc3QgdW5kZXJEYW1wZWRGcmFnMSA9IHVuZGVyRGFtcGVkRW52ZWxvcGUgKiAoc2luMSAqICgodjAgKyB6ZXRhICogb21lZ2EwICogeDApIC8gb21lZ2ExKSArIHgwICogY29zMSk7XG4gIGNvbnN0IHVuZGVyRGFtcGVkUG9zaXRpb24gPSB0b1ZhbHVlIC0gdW5kZXJEYW1wZWRGcmFnMTtcbiAgY29uc3QgdW5kZXJEYW1wZWRWZWxvY2l0eSA9IHpldGEgKiBvbWVnYTAgKiB1bmRlckRhbXBlZEZyYWcxIC0gdW5kZXJEYW1wZWRFbnZlbG9wZSAqIChjb3MxICogKHYwICsgemV0YSAqIG9tZWdhMCAqIHgwKSAtIG9tZWdhMSAqIHgwICogc2luMSk7XG4gIGNvbnN0IGNyaXRpY2FsbHlEYW1wZWRFbnZlbG9wZSA9IE1hdGguZXhwKC1vbWVnYTAgKiB0KTtcbiAgY29uc3QgY3JpdGljYWxseURhbXBlZFBvc2l0aW9uID0gdG9WYWx1ZSAtIGNyaXRpY2FsbHlEYW1wZWRFbnZlbG9wZSAqICh4MCArICh2MCArIG9tZWdhMCAqIHgwKSAqIHQpO1xuICBjb25zdCBjcml0aWNhbGx5RGFtcGVkVmVsb2NpdHkgPSBjcml0aWNhbGx5RGFtcGVkRW52ZWxvcGUgKiAodjAgKiAodCAqIG9tZWdhMCAtIDEpICsgdCAqIHgwICogb21lZ2EwICogb21lZ2EwKTtcbiAgY29uc3QgYW5pbWF0aW9uTm9kZSA9IHtcbiAgICB0b1ZhbHVlLFxuICAgIHByZXZQb3NpdGlvbjogY3VycmVudCxcbiAgICBsYXN0VGltZXN0YW1wOiBub3csXG4gICAgY3VycmVudDogemV0YSA8IDEgPyB1bmRlckRhbXBlZFBvc2l0aW9uIDogY3JpdGljYWxseURhbXBlZFBvc2l0aW9uLFxuICAgIHZlbG9jaXR5OiB6ZXRhIDwgMSA/IHVuZGVyRGFtcGVkVmVsb2NpdHkgOiBjcml0aWNhbGx5RGFtcGVkVmVsb2NpdHlcbiAgfTtcbiAgYWR2YW5jZUNhY2hlW2NhY2hlS2V5XSA9IGFuaW1hdGlvbk5vZGU7XG4gIHJldHVybiBhbmltYXRpb25Ob2RlO1xufVxuZnVuY3Rpb24gc3ByaW5nQ2FsY3VsYXRpb24oe1xuICBmcmFtZSxcbiAgZnBzLFxuICBjb25maWcgPSB7fVxufSkge1xuICBjb25zdCBmcm9tID0gMDtcbiAgY29uc3QgdG8gPSAxO1xuICBjb25zdCBjYWNoZUtleSA9IFtcbiAgICBmcmFtZSxcbiAgICBmcHMsXG4gICAgY29uZmlnLmRhbXBpbmcsXG4gICAgY29uZmlnLm1hc3MsXG4gICAgY29uZmlnLm92ZXJzaG9vdENsYW1waW5nLFxuICAgIGNvbmZpZy5zdGlmZm5lc3NcbiAgXS5qb2luKFwiLVwiKTtcbiAgaWYgKGNhbGN1bGF0aW9uQ2FjaGVbY2FjaGVLZXldKSB7XG4gICAgcmV0dXJuIGNhbGN1bGF0aW9uQ2FjaGVbY2FjaGVLZXldO1xuICB9XG4gIGxldCBhbmltYXRpb24gPSB7XG4gICAgbGFzdFRpbWVzdGFtcDogMCxcbiAgICBjdXJyZW50OiBmcm9tLFxuICAgIHRvVmFsdWU6IHRvLFxuICAgIHZlbG9jaXR5OiAwLFxuICAgIHByZXZQb3NpdGlvbjogMFxuICB9O1xuICBjb25zdCBmcmFtZUNsYW1wZWQgPSBNYXRoLm1heCgwLCBmcmFtZSk7XG4gIGNvbnN0IHVuZXZlblJlc3QgPSBmcmFtZUNsYW1wZWQgJSAxO1xuICBmb3IgKGxldCBmID0gMDtmIDw9IE1hdGguZmxvb3IoZnJhbWVDbGFtcGVkKTsgZisrKSB7XG4gICAgaWYgKGYgPT09IE1hdGguZmxvb3IoZnJhbWVDbGFtcGVkKSkge1xuICAgICAgZiArPSB1bmV2ZW5SZXN0O1xuICAgIH1cbiAgICBjb25zdCB0aW1lID0gZiAvIGZwcyAqIDEwMDA7XG4gICAgYW5pbWF0aW9uID0gYWR2YW5jZSh7XG4gICAgICBhbmltYXRpb24sXG4gICAgICBub3c6IHRpbWUsXG4gICAgICBjb25maWc6IHtcbiAgICAgICAgLi4uZGVmYXVsdFNwcmluZ0NvbmZpZyxcbiAgICAgICAgLi4uY29uZmlnXG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgY2FsY3VsYXRpb25DYWNoZVtjYWNoZUtleV0gPSBhbmltYXRpb247XG4gIHJldHVybiBhbmltYXRpb247XG59XG52YXIgZGVmYXVsdFNwcmluZ0NvbmZpZyA9IHtcbiAgZGFtcGluZzogMTAsXG4gIG1hc3M6IDEsXG4gIHN0aWZmbmVzczogMTAwLFxuICBvdmVyc2hvb3RDbGFtcGluZzogZmFsc2Vcbn07XG52YXIgYWR2YW5jZUNhY2hlID0ge307XG52YXIgY2FsY3VsYXRpb25DYWNoZSA9IHt9O1xuXG4vLyBzcmMvc3ByaW5nL21lYXN1cmUtc3ByaW5nLnRzXG5mdW5jdGlvbiBtZWFzdXJlU3ByaW5nKHtcbiAgZnBzLFxuICBjb25maWcgPSB7fSxcbiAgdGhyZXNob2xkID0gMC4wMDVcbn0pIHtcbiAgaWYgKHR5cGVvZiB0aHJlc2hvbGQgIT09IFwibnVtYmVyXCIpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGB0aHJlc2hvbGQgbXVzdCBiZSBhIG51bWJlciwgZ290ICR7dGhyZXNob2xkfSBvZiB0eXBlICR7dHlwZW9mIHRocmVzaG9sZH1gKTtcbiAgfVxuICBpZiAodGhyZXNob2xkID09PSAwKSB7XG4gICAgcmV0dXJuIEluZmluaXR5O1xuICB9XG4gIGlmICh0aHJlc2hvbGQgPT09IDEpIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuICBpZiAoaXNOYU4odGhyZXNob2xkKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJUaHJlc2hvbGQgaXMgTmFOXCIpO1xuICB9XG4gIGlmICghTnVtYmVyLmlzRmluaXRlKHRocmVzaG9sZCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiVGhyZXNob2xkIGlzIG5vdCBmaW5pdGVcIik7XG4gIH1cbiAgaWYgKHRocmVzaG9sZCA8IDApIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiVGhyZXNob2xkIGlzIGJlbG93IDBcIik7XG4gIH1cbiAgY29uc3QgY2FjaGVLZXkgPSBbXG4gICAgZnBzLFxuICAgIGNvbmZpZy5kYW1waW5nLFxuICAgIGNvbmZpZy5tYXNzLFxuICAgIGNvbmZpZy5vdmVyc2hvb3RDbGFtcGluZyxcbiAgICBjb25maWcuc3RpZmZuZXNzLFxuICAgIHRocmVzaG9sZFxuICBdLmpvaW4oXCItXCIpO1xuICBpZiAoY2FjaGUuaGFzKGNhY2hlS2V5KSkge1xuICAgIHJldHVybiBjYWNoZS5nZXQoY2FjaGVLZXkpO1xuICB9XG4gIHZhbGlkYXRlRnBzKGZwcywgXCJ0byB0aGUgbWVhc3VyZVNwcmluZygpIGZ1bmN0aW9uXCIsIGZhbHNlKTtcbiAgbGV0IGZyYW1lID0gMDtcbiAgbGV0IGZpbmlzaGVkRnJhbWUgPSAwO1xuICBjb25zdCBjYWxjID0gKCkgPT4ge1xuICAgIHJldHVybiBzcHJpbmdDYWxjdWxhdGlvbih7XG4gICAgICBmcHMsXG4gICAgICBmcmFtZSxcbiAgICAgIGNvbmZpZ1xuICAgIH0pO1xuICB9O1xuICBsZXQgYW5pbWF0aW9uID0gY2FsYygpO1xuICBjb25zdCBjYWxjRGlmZmVyZW5jZSA9ICgpID0+IHtcbiAgICByZXR1cm4gTWF0aC5hYnMoYW5pbWF0aW9uLmN1cnJlbnQgLSBhbmltYXRpb24udG9WYWx1ZSk7XG4gIH07XG4gIGxldCBkaWZmZXJlbmNlID0gY2FsY0RpZmZlcmVuY2UoKTtcbiAgd2hpbGUgKGRpZmZlcmVuY2UgPj0gdGhyZXNob2xkKSB7XG4gICAgZnJhbWUrKztcbiAgICBhbmltYXRpb24gPSBjYWxjKCk7XG4gICAgZGlmZmVyZW5jZSA9IGNhbGNEaWZmZXJlbmNlKCk7XG4gIH1cbiAgZmluaXNoZWRGcmFtZSA9IGZyYW1lO1xuICBmb3IgKGxldCBpID0gMDtpIDwgMjA7IGkrKykge1xuICAgIGZyYW1lKys7XG4gICAgYW5pbWF0aW9uID0gY2FsYygpO1xuICAgIGRpZmZlcmVuY2UgPSBjYWxjRGlmZmVyZW5jZSgpO1xuICAgIGlmIChkaWZmZXJlbmNlID49IHRocmVzaG9sZCkge1xuICAgICAgaSA9IDA7XG4gICAgICBmaW5pc2hlZEZyYW1lID0gZnJhbWUgKyAxO1xuICAgIH1cbiAgfVxuICBjYWNoZS5zZXQoY2FjaGVLZXksIGZpbmlzaGVkRnJhbWUpO1xuICByZXR1cm4gZmluaXNoZWRGcmFtZTtcbn1cbnZhciBjYWNoZSA9IG5ldyBNYXA7XG5cbi8vIHNyYy9zcHJpbmcvaW5kZXgudHNcbmZ1bmN0aW9uIHNwcmluZyh7XG4gIGZyYW1lOiBwYXNzZWRGcmFtZSxcbiAgZnBzLFxuICBjb25maWcgPSB7fSxcbiAgZnJvbSA9IDAsXG4gIHRvID0gMSxcbiAgZHVyYXRpb25JbkZyYW1lczogcGFzc2VkRHVyYXRpb25JbkZyYW1lcyxcbiAgZHVyYXRpb25SZXN0VGhyZXNob2xkLFxuICBkZWxheSA9IDAsXG4gIHJldmVyc2UgPSBmYWxzZVxufSkge1xuICB2YWxpZGF0ZVNwcmluZ0R1cmF0aW9uKHBhc3NlZER1cmF0aW9uSW5GcmFtZXMpO1xuICB2YWxpZGF0ZUZyYW1lKHtcbiAgICBmcmFtZTogcGFzc2VkRnJhbWUsXG4gICAgZHVyYXRpb25JbkZyYW1lczogSW5maW5pdHksXG4gICAgYWxsb3dGbG9hdHM6IHRydWVcbiAgfSk7XG4gIHZhbGlkYXRlRnBzKGZwcywgXCJ0byBzcHJpbmcoKVwiLCBmYWxzZSk7XG4gIGNvbnN0IG5lZWRzVG9DYWxjdWxhdGVOYXR1cmFsRHVyYXRpb24gPSByZXZlcnNlIHx8IHR5cGVvZiBwYXNzZWREdXJhdGlvbkluRnJhbWVzICE9PSBcInVuZGVmaW5lZFwiO1xuICBjb25zdCBuYXR1cmFsRHVyYXRpb24gPSBuZWVkc1RvQ2FsY3VsYXRlTmF0dXJhbER1cmF0aW9uID8gbWVhc3VyZVNwcmluZyh7XG4gICAgZnBzLFxuICAgIGNvbmZpZyxcbiAgICB0aHJlc2hvbGQ6IGR1cmF0aW9uUmVzdFRocmVzaG9sZFxuICB9KSA6IHVuZGVmaW5lZDtcbiAgY29uc3QgbmF0dXJhbER1cmF0aW9uR2V0dGVyID0gbmVlZHNUb0NhbGN1bGF0ZU5hdHVyYWxEdXJhdGlvbiA/IHtcbiAgICBnZXQ6ICgpID0+IG5hdHVyYWxEdXJhdGlvblxuICB9IDoge1xuICAgIGdldDogKCkgPT4ge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZGlkIG5vdCBjYWxjdWxhdGUgbmF0dXJhbCBkdXJhdGlvbiwgdGhpcyBpcyBhbiBlcnJvciB3aXRoIFJlbW90aW9uLiBQbGVhc2UgcmVwb3J0XCIpO1xuICAgIH1cbiAgfTtcbiAgY29uc3QgcmV2ZXJzZVByb2Nlc3NlZCA9IHJldmVyc2UgPyAocGFzc2VkRHVyYXRpb25JbkZyYW1lcyA/PyBuYXR1cmFsRHVyYXRpb25HZXR0ZXIuZ2V0KCkpIC0gcGFzc2VkRnJhbWUgOiBwYXNzZWRGcmFtZTtcbiAgY29uc3QgZGVsYXlQcm9jZXNzZWQgPSByZXZlcnNlUHJvY2Vzc2VkICsgKHJldmVyc2UgPyBkZWxheSA6IC1kZWxheSk7XG4gIGNvbnN0IGR1cmF0aW9uUHJvY2Vzc2VkID0gcGFzc2VkRHVyYXRpb25JbkZyYW1lcyA9PT0gdW5kZWZpbmVkID8gZGVsYXlQcm9jZXNzZWQgOiBkZWxheVByb2Nlc3NlZCAvIChwYXNzZWREdXJhdGlvbkluRnJhbWVzIC8gbmF0dXJhbER1cmF0aW9uR2V0dGVyLmdldCgpKTtcbiAgaWYgKHBhc3NlZER1cmF0aW9uSW5GcmFtZXMgJiYgZGVsYXlQcm9jZXNzZWQgPiBwYXNzZWREdXJhdGlvbkluRnJhbWVzKSB7XG4gICAgcmV0dXJuIHRvO1xuICB9XG4gIGNvbnN0IHNwciA9IHNwcmluZ0NhbGN1bGF0aW9uKHtcbiAgICBmcHMsXG4gICAgZnJhbWU6IGR1cmF0aW9uUHJvY2Vzc2VkLFxuICAgIGNvbmZpZ1xuICB9KTtcbiAgY29uc3QgaW5uZXIyID0gY29uZmlnLm92ZXJzaG9vdENsYW1waW5nID8gdG8gPj0gZnJvbSA/IE1hdGgubWluKHNwci5jdXJyZW50LCB0bykgOiBNYXRoLm1heChzcHIuY3VycmVudCwgdG8pIDogc3ByLmN1cnJlbnQ7XG4gIGNvbnN0IGludGVycG9sYXRlZCA9IGZyb20gPT09IDAgJiYgdG8gPT09IDEgPyBpbm5lcjIgOiBpbnRlcnBvbGF0ZShpbm5lcjIsIFswLCAxXSwgW2Zyb20sIHRvXSk7XG4gIHJldHVybiBpbnRlcnBvbGF0ZWQ7XG59XG4vLyBzcmMvU3RpbGwudHN4XG5pbXBvcnQgUmVhY3QyNyBmcm9tIFwicmVhY3RcIjtcbnZhciBTdGlsbCA9IChwcm9wczIpID0+IHtcbiAgY29uc3QgbmV3UHJvcHMgPSB7XG4gICAgLi4ucHJvcHMyLFxuICAgIGR1cmF0aW9uSW5GcmFtZXM6IDEsXG4gICAgZnBzOiAxXG4gIH07XG4gIHJldHVybiBSZWFjdDI3LmNyZWF0ZUVsZW1lbnQoQ29tcG9zaXRpb24sIG5ld1Byb3BzKTtcbn07XG4vLyBzcmMvdmlkZW8vT2ZmdGhyZWFkVmlkZW8udHN4XG5pbXBvcnQgeyB1c2VDYWxsYmFjayBhcyB1c2VDYWxsYmFjazE0IH0gZnJvbSBcInJlYWN0XCI7XG5cbi8vIHNyYy92aWRlby9PZmZ0aHJlYWRWaWRlb0ZvclJlbmRlcmluZy50c3hcbmltcG9ydCB7XG4gIHVzZUNhbGxiYWNrIGFzIHVzZUNhbGxiYWNrMTMsXG4gIHVzZUNvbnRleHQgYXMgdXNlQ29udGV4dDI3LFxuICB1c2VFZmZlY3QgYXMgdXNlRWZmZWN0MjEsXG4gIHVzZUxheW91dEVmZmVjdCBhcyB1c2VMYXlvdXRFZmZlY3Q2LFxuICB1c2VNZW1vIGFzIHVzZU1lbW8yOSxcbiAgdXNlU3RhdGUgYXMgdXNlU3RhdGUxOFxufSBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7IGpzeCBhcyBqc3gyOSB9IGZyb20gXCJyZWFjdC9qc3gtcnVudGltZVwiO1xudmFyIE9mZnRocmVhZFZpZGVvRm9yUmVuZGVyaW5nID0gKHtcbiAgb25FcnJvcixcbiAgdm9sdW1lOiB2b2x1bWVQcm9wLFxuICBwbGF5YmFja1JhdGUsXG4gIHNyYyxcbiAgbXV0ZWQsXG4gIGFsbG93QW1wbGlmaWNhdGlvbkR1cmluZ1JlbmRlcixcbiAgdHJhbnNwYXJlbnQgPSBmYWxzZSxcbiAgdG9uZU1hcHBlZCA9IHRydWUsXG4gIHRvbmVGcmVxdWVuY3ksXG4gIG5hbWUsXG4gIGxvb3BWb2x1bWVDdXJ2ZUJlaGF2aW9yLFxuICBkZWxheVJlbmRlclJldHJpZXMsXG4gIGRlbGF5UmVuZGVyVGltZW91dEluTWlsbGlzZWNvbmRzLFxuICBvblZpZGVvRnJhbWUsXG4gIC4uLnByb3BzMlxufSkgPT4ge1xuICBjb25zdCBhYnNvbHV0ZUZyYW1lID0gdXNlVGltZWxpbmVQb3NpdGlvbigpO1xuICBjb25zdCBmcmFtZSA9IHVzZUN1cnJlbnRGcmFtZSgpO1xuICBjb25zdCB2b2x1bWVQcm9wc0ZyYW1lID0gdXNlRnJhbWVGb3JWb2x1bWVQcm9wKGxvb3BWb2x1bWVDdXJ2ZUJlaGF2aW9yID8/IFwicmVwZWF0XCIpO1xuICBjb25zdCB2aWRlb0NvbmZpZyA9IHVzZVVuc2FmZVZpZGVvQ29uZmlnKCk7XG4gIGNvbnN0IHNlcXVlbmNlQ29udGV4dCA9IHVzZUNvbnRleHQyNyhTZXF1ZW5jZUNvbnRleHQpO1xuICBjb25zdCBtZWRpYVN0YXJ0c0F0ID0gdXNlTWVkaWFTdGFydHNBdCgpO1xuICBjb25zdCB7IHJlZ2lzdGVyUmVuZGVyQXNzZXQsIHVucmVnaXN0ZXJSZW5kZXJBc3NldCB9ID0gdXNlQ29udGV4dDI3KFJlbmRlckFzc2V0TWFuYWdlcik7XG4gIGlmICghc3JjKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIk5vIGBzcmNgIHdhcyBwYXNzZWQgdG8gPE9mZnRocmVhZFZpZGVvPi5cIik7XG4gIH1cbiAgY29uc3QgaWQgPSB1c2VNZW1vMjkoKCkgPT4gYG9mZnRocmVhZHZpZGVvLSR7cmFuZG9tKHNyYyA/PyBcIlwiKX0tJHtzZXF1ZW5jZUNvbnRleHQ/LmN1bXVsYXRlZEZyb219LSR7c2VxdWVuY2VDb250ZXh0Py5yZWxhdGl2ZUZyb219LSR7c2VxdWVuY2VDb250ZXh0Py5kdXJhdGlvbkluRnJhbWVzfWAsIFtcbiAgICBzcmMsXG4gICAgc2VxdWVuY2VDb250ZXh0Py5jdW11bGF0ZWRGcm9tLFxuICAgIHNlcXVlbmNlQ29udGV4dD8ucmVsYXRpdmVGcm9tLFxuICAgIHNlcXVlbmNlQ29udGV4dD8uZHVyYXRpb25JbkZyYW1lc1xuICBdKTtcbiAgaWYgKCF2aWRlb0NvbmZpZykge1xuICAgIHRocm93IG5ldyBFcnJvcihcIk5vIHZpZGVvIGNvbmZpZyBmb3VuZFwiKTtcbiAgfVxuICBjb25zdCB2b2x1bWUgPSBldmFsdWF0ZVZvbHVtZSh7XG4gICAgdm9sdW1lOiB2b2x1bWVQcm9wLFxuICAgIGZyYW1lOiB2b2x1bWVQcm9wc0ZyYW1lLFxuICAgIG1lZGlhVm9sdW1lOiAxLFxuICAgIGFsbG93QW1wbGlmaWNhdGlvbkR1cmluZ1JlbmRlcjogYWxsb3dBbXBsaWZpY2F0aW9uRHVyaW5nUmVuZGVyID8/IGZhbHNlXG4gIH0pO1xuICB1c2VFZmZlY3QyMSgoKSA9PiB7XG4gICAgaWYgKCFzcmMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIHNyYyBwYXNzZWRcIik7XG4gICAgfVxuICAgIGlmICghd2luZG93LnJlbW90aW9uX2F1ZGlvRW5hYmxlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAobXV0ZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHZvbHVtZSA8PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHJlZ2lzdGVyUmVuZGVyQXNzZXQoe1xuICAgICAgdHlwZTogXCJ2aWRlb1wiLFxuICAgICAgc3JjOiBnZXRBYnNvbHV0ZVNyYyhzcmMpLFxuICAgICAgaWQsXG4gICAgICBmcmFtZTogYWJzb2x1dGVGcmFtZSxcbiAgICAgIHZvbHVtZSxcbiAgICAgIG1lZGlhRnJhbWU6IGZyYW1lLFxuICAgICAgcGxheWJhY2tSYXRlOiBwbGF5YmFja1JhdGUgPz8gMSxcbiAgICAgIGFsbG93QW1wbGlmaWNhdGlvbkR1cmluZ1JlbmRlcjogYWxsb3dBbXBsaWZpY2F0aW9uRHVyaW5nUmVuZGVyID8/IGZhbHNlLFxuICAgICAgdG9uZUZyZXF1ZW5jeTogdG9uZUZyZXF1ZW5jeSA/PyBudWxsLFxuICAgICAgYXVkaW9TdGFydEZyYW1lOiBNYXRoLm1heCgwLCAtKHNlcXVlbmNlQ29udGV4dD8ucmVsYXRpdmVGcm9tID8/IDApKVxuICAgIH0pO1xuICAgIHJldHVybiAoKSA9PiB1bnJlZ2lzdGVyUmVuZGVyQXNzZXQoaWQpO1xuICB9LCBbXG4gICAgbXV0ZWQsXG4gICAgc3JjLFxuICAgIHJlZ2lzdGVyUmVuZGVyQXNzZXQsXG4gICAgaWQsXG4gICAgdW5yZWdpc3RlclJlbmRlckFzc2V0LFxuICAgIHZvbHVtZSxcbiAgICBmcmFtZSxcbiAgICBhYnNvbHV0ZUZyYW1lLFxuICAgIHBsYXliYWNrUmF0ZSxcbiAgICBhbGxvd0FtcGxpZmljYXRpb25EdXJpbmdSZW5kZXIsXG4gICAgdG9uZUZyZXF1ZW5jeSxcbiAgICBzZXF1ZW5jZUNvbnRleHQ/LnJlbGF0aXZlRnJvbVxuICBdKTtcbiAgY29uc3QgY3VycmVudFRpbWUgPSB1c2VNZW1vMjkoKCkgPT4ge1xuICAgIHJldHVybiBnZXRFeHBlY3RlZE1lZGlhRnJhbWVVbmNvcnJlY3RlZCh7XG4gICAgICBmcmFtZSxcbiAgICAgIHBsYXliYWNrUmF0ZTogcGxheWJhY2tSYXRlIHx8IDEsXG4gICAgICBzdGFydEZyb206IC1tZWRpYVN0YXJ0c0F0XG4gICAgfSkgLyB2aWRlb0NvbmZpZy5mcHM7XG4gIH0sIFtmcmFtZSwgbWVkaWFTdGFydHNBdCwgcGxheWJhY2tSYXRlLCB2aWRlb0NvbmZpZy5mcHNdKTtcbiAgY29uc3QgYWN0dWFsU3JjID0gdXNlTWVtbzI5KCgpID0+IHtcbiAgICByZXR1cm4gZ2V0T2ZmdGhyZWFkVmlkZW9Tb3VyY2Uoe1xuICAgICAgc3JjLFxuICAgICAgY3VycmVudFRpbWUsXG4gICAgICB0cmFuc3BhcmVudCxcbiAgICAgIHRvbmVNYXBwZWRcbiAgICB9KTtcbiAgfSwgW3RvbmVNYXBwZWQsIGN1cnJlbnRUaW1lLCBzcmMsIHRyYW5zcGFyZW50XSk7XG4gIGNvbnN0IFtpbWFnZVNyYywgc2V0SW1hZ2VTcmNdID0gdXNlU3RhdGUxOChudWxsKTtcbiAgdXNlTGF5b3V0RWZmZWN0NigoKSA9PiB7XG4gICAgaWYgKCF3aW5kb3cucmVtb3Rpb25fdmlkZW9FbmFibGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGNsZWFudXAgPSBbXTtcbiAgICBzZXRJbWFnZVNyYyhudWxsKTtcbiAgICBjb25zdCBjb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcjtcbiAgICBjb25zdCBuZXdIYW5kbGUgPSBkZWxheVJlbmRlcihgRmV0Y2hpbmcgJHthY3R1YWxTcmN9IGZyb20gc2VydmVyYCwge1xuICAgICAgcmV0cmllczogZGVsYXlSZW5kZXJSZXRyaWVzID8/IHVuZGVmaW5lZCxcbiAgICAgIHRpbWVvdXRJbk1pbGxpc2Vjb25kczogZGVsYXlSZW5kZXJUaW1lb3V0SW5NaWxsaXNlY29uZHMgPz8gdW5kZWZpbmVkXG4gICAgfSk7XG4gICAgY29uc3QgZXhlY3V0ZSA9IGFzeW5jICgpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IGZldGNoKGFjdHVhbFNyYywge1xuICAgICAgICAgIHNpZ25hbDogY29udHJvbGxlci5zaWduYWxcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChyZXMuc3RhdHVzICE9PSAyMDApIHtcbiAgICAgICAgICBpZiAocmVzLnN0YXR1cyA9PT0gNTAwKSB7XG4gICAgICAgICAgICBjb25zdCBqc29uID0gYXdhaXQgcmVzLmpzb24oKTtcbiAgICAgICAgICAgIGlmIChqc29uLmVycm9yKSB7XG4gICAgICAgICAgICAgIGNvbnN0IGNsZWFuZWRVcEVycm9yTWVzc2FnZSA9IGpzb24uZXJyb3IucmVwbGFjZSgvXkVycm9yOiAvLCBcIlwiKTtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGNsZWFuZWRVcEVycm9yTWVzc2FnZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgU2VydmVyIHJldHVybmVkIHN0YXR1cyAke3Jlcy5zdGF0dXN9IHdoaWxlIGZldGNoaW5nICR7YWN0dWFsU3JjfWApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGJsb2IgPSBhd2FpdCByZXMuYmxvYigpO1xuICAgICAgICBjb25zdCB1cmwgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKGJsb2IpO1xuICAgICAgICBjbGVhbnVwLnB1c2goKCkgPT4gVVJMLnJldm9rZU9iamVjdFVSTCh1cmwpKTtcbiAgICAgICAgc2V0SW1hZ2VTcmMoe1xuICAgICAgICAgIHNyYzogdXJsLFxuICAgICAgICAgIGhhbmRsZTogbmV3SGFuZGxlXG4gICAgICAgIH0pO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGlmIChlcnIubWVzc2FnZS5pbmNsdWRlcyhcImFib3J0ZWRcIikpIHtcbiAgICAgICAgICBjb250aW51ZVJlbmRlcihuZXdIYW5kbGUpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29udHJvbGxlci5zaWduYWwuYWJvcnRlZCkge1xuICAgICAgICAgIGNvbnRpbnVlUmVuZGVyKG5ld0hhbmRsZSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlcnIubWVzc2FnZS5pbmNsdWRlcyhcIkZhaWxlZCB0byBmZXRjaFwiKSkge1xuICAgICAgICAgIGVyciA9IG5ldyBFcnJvcihgRmFpbGVkIHRvIGZldGNoICR7YWN0dWFsU3JjfS4gVGhpcyBjb3VsZCBiZSBjYXVzZWQgYnkgQ2hyb21lIHJlamVjdGluZyB0aGUgcmVxdWVzdCBiZWNhdXNlIHRoZSBkaXNrIHNwYWNlIGlzIGxvdy4gQ29uc2lkZXIgaW5jcmVhc2luZyB0aGUgZGlzayBzaXplIG9mIHlvdXIgZW52aXJvbm1lbnQuYCwgeyBjYXVzZTogZXJyIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvbkVycm9yKSB7XG4gICAgICAgICAgb25FcnJvcihlcnIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNhbmNlbFJlbmRlcihlcnIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICBleGVjdXRlKCk7XG4gICAgY2xlYW51cC5wdXNoKCgpID0+IHtcbiAgICAgIGlmIChjb250cm9sbGVyLnNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnRyb2xsZXIuYWJvcnQoKTtcbiAgICB9KTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgY2xlYW51cC5mb3JFYWNoKChjMikgPT4gYzIoKSk7XG4gICAgfTtcbiAgfSwgW1xuICAgIGFjdHVhbFNyYyxcbiAgICBkZWxheVJlbmRlclJldHJpZXMsXG4gICAgZGVsYXlSZW5kZXJUaW1lb3V0SW5NaWxsaXNlY29uZHMsXG4gICAgb25FcnJvclxuICBdKTtcbiAgY29uc3Qgb25FcnIgPSB1c2VDYWxsYmFjazEzKCgpID0+IHtcbiAgICBpZiAob25FcnJvcikge1xuICAgICAgb25FcnJvcj8uKG5ldyBFcnJvcihcIkZhaWxlZCB0byBsb2FkIGltYWdlIHdpdGggc3JjIFwiICsgaW1hZ2VTcmMpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY2FuY2VsUmVuZGVyKFwiRmFpbGVkIHRvIGxvYWQgaW1hZ2Ugd2l0aCBzcmMgXCIgKyBpbWFnZVNyYyk7XG4gICAgfVxuICB9LCBbaW1hZ2VTcmMsIG9uRXJyb3JdKTtcbiAgY29uc3QgY2xhc3NOYW1lID0gdXNlTWVtbzI5KCgpID0+IHtcbiAgICByZXR1cm4gW09GRlRIUkVBRF9WSURFT19DTEFTU19OQU1FLCBwcm9wczIuY2xhc3NOYW1lXS5maWx0ZXIodHJ1dGh5KS5qb2luKFwiIFwiKTtcbiAgfSwgW3Byb3BzMi5jbGFzc05hbWVdKTtcbiAgY29uc3Qgb25JbWFnZUZyYW1lID0gdXNlQ2FsbGJhY2sxMygoaW1nKSA9PiB7XG4gICAgaWYgKG9uVmlkZW9GcmFtZSkge1xuICAgICAgb25WaWRlb0ZyYW1lKGltZyk7XG4gICAgfVxuICB9LCBbb25WaWRlb0ZyYW1lXSk7XG4gIGlmICghaW1hZ2VTcmMgfHwgIXdpbmRvdy5yZW1vdGlvbl92aWRlb0VuYWJsZWQpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBjb250aW51ZVJlbmRlcihpbWFnZVNyYy5oYW5kbGUpO1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeDI5KEltZywge1xuICAgIHNyYzogaW1hZ2VTcmMuc3JjLFxuICAgIGNsYXNzTmFtZSxcbiAgICBkZWxheVJlbmRlclJldHJpZXMsXG4gICAgZGVsYXlSZW5kZXJUaW1lb3V0SW5NaWxsaXNlY29uZHMsXG4gICAgb25JbWFnZUZyYW1lLFxuICAgIC4uLnByb3BzMixcbiAgICBvbkVycm9yOiBvbkVyclxuICB9KTtcbn07XG5cbi8vIHNyYy92aWRlby9WaWRlb0ZvclByZXZpZXcudHN4XG5pbXBvcnQge1xuICBmb3J3YXJkUmVmIGFzIGZvcndhcmRSZWY5LFxuICB1c2VDb250ZXh0IGFzIHVzZUNvbnRleHQyOCxcbiAgdXNlRWZmZWN0IGFzIHVzZUVmZmVjdDIzLFxuICB1c2VJbXBlcmF0aXZlSGFuZGxlIGFzIHVzZUltcGVyYXRpdmVIYW5kbGU3LFxuICB1c2VNZW1vIGFzIHVzZU1lbW8zMCxcbiAgdXNlUmVmIGFzIHVzZVJlZjEzLFxuICB1c2VTdGF0ZSBhcyB1c2VTdGF0ZTE5XG59IGZyb20gXCJyZWFjdFwiO1xuXG4vLyBzcmMvdmlkZW8vZW1pdC12aWRlby1mcmFtZS50c1xuaW1wb3J0IHsgdXNlRWZmZWN0IGFzIHVzZUVmZmVjdDIyIH0gZnJvbSBcInJlYWN0XCI7XG52YXIgdXNlRW1pdFZpZGVvRnJhbWUgPSAoe1xuICByZWYsXG4gIG9uVmlkZW9GcmFtZVxufSkgPT4ge1xuICB1c2VFZmZlY3QyMigoKSA9PiB7XG4gICAgY29uc3QgeyBjdXJyZW50IH0gPSByZWY7XG4gICAgaWYgKCFjdXJyZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghb25WaWRlb0ZyYW1lKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGxldCBoYW5kbGUgPSAwO1xuICAgIGNvbnN0IGNhbGxiYWNrID0gKCkgPT4ge1xuICAgICAgaWYgKCFyZWYuY3VycmVudCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBvblZpZGVvRnJhbWUocmVmLmN1cnJlbnQpO1xuICAgICAgaGFuZGxlID0gcmVmLmN1cnJlbnQucmVxdWVzdFZpZGVvRnJhbWVDYWxsYmFjayhjYWxsYmFjayk7XG4gICAgfTtcbiAgICBjYWxsYmFjaygpO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBjdXJyZW50LmNhbmNlbFZpZGVvRnJhbWVDYWxsYmFjayhoYW5kbGUpO1xuICAgIH07XG4gIH0sIFtvblZpZGVvRnJhbWUsIHJlZl0pO1xufTtcblxuLy8gc3JjL3ZpZGVvL1ZpZGVvRm9yUHJldmlldy50c3hcbmltcG9ydCB7IGpzeCBhcyBqc3gzMCB9IGZyb20gXCJyZWFjdC9qc3gtcnVudGltZVwiO1xudmFyIFZpZGVvRm9yRGV2ZWxvcG1lbnRSZWZGb3J3YXJkaW5nRnVuY3Rpb24gPSAocHJvcHMyLCByZWYpID0+IHtcbiAgY29uc3QgdmlkZW9SZWYgPSB1c2VSZWYxMyhudWxsKTtcbiAgY29uc3Qge1xuICAgIHZvbHVtZSxcbiAgICBtdXRlZCxcbiAgICBwbGF5YmFja1JhdGUsXG4gICAgb25seVdhcm5Gb3JNZWRpYVNlZWtpbmdFcnJvcixcbiAgICBzcmMsXG4gICAgb25EdXJhdGlvbixcbiAgICBhY2NlcHRhYmxlVGltZVNoaWZ0LFxuICAgIGFjY2VwdGFibGVUaW1lU2hpZnRJblNlY29uZHMsXG4gICAgdG9uZUZyZXF1ZW5jeSxcbiAgICBuYW1lLFxuICAgIF9yZW1vdGlvbkludGVybmFsTmF0aXZlTG9vcFBhc3NlZCxcbiAgICBfcmVtb3Rpb25JbnRlcm5hbFN0YWNrLFxuICAgIF9yZW1vdGlvbkRlYnVnU2Vla2luZyxcbiAgICBzdHlsZSxcbiAgICBwYXVzZVdoZW5CdWZmZXJpbmcsXG4gICAgc2hvd0luVGltZWxpbmUsXG4gICAgbG9vcFZvbHVtZUN1cnZlQmVoYXZpb3IsXG4gICAgb25FcnJvcixcbiAgICBvbkF1dG9QbGF5RXJyb3IsXG4gICAgb25WaWRlb0ZyYW1lLFxuICAgIGNyb3NzT3JpZ2luLFxuICAgIC4uLm5hdGl2ZVByb3BzXG4gIH0gPSBwcm9wczI7XG4gIGNvbnN0IHZvbHVtZVByb3BGcmFtZSA9IHVzZUZyYW1lRm9yVm9sdW1lUHJvcChsb29wVm9sdW1lQ3VydmVCZWhhdmlvciA/PyBcInJlcGVhdFwiKTtcbiAgY29uc3QgeyBmcHMsIGR1cmF0aW9uSW5GcmFtZXMgfSA9IHVzZVZpZGVvQ29uZmlnKCk7XG4gIGNvbnN0IHBhcmVudFNlcXVlbmNlID0gdXNlQ29udGV4dDI4KFNlcXVlbmNlQ29udGV4dCk7XG4gIGNvbnN0IHsgaGlkZGVuIH0gPSB1c2VDb250ZXh0MjgoU2VxdWVuY2VWaXNpYmlsaXR5VG9nZ2xlQ29udGV4dCk7XG4gIGNvbnN0IFt0aW1lbGluZUlkXSA9IHVzZVN0YXRlMTkoKCkgPT4gU3RyaW5nKE1hdGgucmFuZG9tKCkpKTtcbiAgY29uc3QgaXNTZXF1ZW5jZUhpZGRlbiA9IGhpZGRlblt0aW1lbGluZUlkXSA/PyBmYWxzZTtcbiAgaWYgKHR5cGVvZiBhY2NlcHRhYmxlVGltZVNoaWZ0ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiYWNjZXB0YWJsZVRpbWVTaGlmdCBoYXMgYmVlbiByZW1vdmVkLiBVc2UgYWNjZXB0YWJsZVRpbWVTaGlmdEluU2Vjb25kcyBpbnN0ZWFkLlwiKTtcbiAgfVxuICBjb25zdCBhY3R1YWxWb2x1bWUgPSB1c2VNZWRpYVRhZ1ZvbHVtZSh2aWRlb1JlZik7XG4gIGNvbnN0IFttZWRpYVZvbHVtZV0gPSB1c2VNZWRpYVZvbHVtZVN0YXRlKCk7XG4gIGNvbnN0IFttZWRpYU11dGVkXSA9IHVzZU1lZGlhTXV0ZWRTdGF0ZSgpO1xuICB1c2VNZWRpYUluVGltZWxpbmUoe1xuICAgIG1lZGlhUmVmOiB2aWRlb1JlZixcbiAgICB2b2x1bWUsXG4gICAgbWVkaWFWb2x1bWUsXG4gICAgbWVkaWFUeXBlOiBcInZpZGVvXCIsXG4gICAgc3JjLFxuICAgIHBsYXliYWNrUmF0ZTogcHJvcHMyLnBsYXliYWNrUmF0ZSA/PyAxLFxuICAgIGRpc3BsYXlOYW1lOiBuYW1lID8/IG51bGwsXG4gICAgaWQ6IHRpbWVsaW5lSWQsXG4gICAgc3RhY2s6IF9yZW1vdGlvbkludGVybmFsU3RhY2ssXG4gICAgc2hvd0luVGltZWxpbmUsXG4gICAgcHJlbW91bnREaXNwbGF5OiBudWxsLFxuICAgIG9uQXV0b1BsYXlFcnJvcjogb25BdXRvUGxheUVycm9yID8/IG51bGxcbiAgfSk7XG4gIHVzZVN5bmNWb2x1bWVXaXRoTWVkaWFUYWcoe1xuICAgIHZvbHVtZVByb3BGcmFtZSxcbiAgICBhY3R1YWxWb2x1bWUsXG4gICAgdm9sdW1lLFxuICAgIG1lZGlhVm9sdW1lLFxuICAgIG1lZGlhUmVmOiB2aWRlb1JlZlxuICB9KTtcbiAgdXNlTWVkaWFQbGF5YmFjayh7XG4gICAgbWVkaWFSZWY6IHZpZGVvUmVmLFxuICAgIHNyYyxcbiAgICBtZWRpYVR5cGU6IFwidmlkZW9cIixcbiAgICBwbGF5YmFja1JhdGU6IHByb3BzMi5wbGF5YmFja1JhdGUgPz8gMSxcbiAgICBvbmx5V2FybkZvck1lZGlhU2Vla2luZ0Vycm9yLFxuICAgIGFjY2VwdGFibGVUaW1lc2hpZnQ6IGFjY2VwdGFibGVUaW1lU2hpZnRJblNlY29uZHMgPz8gREVGQVVMVF9BQ0NFUFRBQkxFX1RJTUVTSElGVCxcbiAgICBpc1ByZW1vdW50aW5nOiBCb29sZWFuKHBhcmVudFNlcXVlbmNlPy5wcmVtb3VudGluZyksXG4gICAgcGF1c2VXaGVuQnVmZmVyaW5nLFxuICAgIGRlYnVnU2Vla2luZzogX3JlbW90aW9uRGVidWdTZWVraW5nLFxuICAgIG9uQXV0b1BsYXlFcnJvcjogb25BdXRvUGxheUVycm9yID8/IG51bGxcbiAgfSk7XG4gIGNvbnN0IGFjdHVhbEZyb20gPSBwYXJlbnRTZXF1ZW5jZSA/IHBhcmVudFNlcXVlbmNlLnJlbGF0aXZlRnJvbSA6IDA7XG4gIGNvbnN0IGR1cmF0aW9uID0gcGFyZW50U2VxdWVuY2UgPyBNYXRoLm1pbihwYXJlbnRTZXF1ZW5jZS5kdXJhdGlvbkluRnJhbWVzLCBkdXJhdGlvbkluRnJhbWVzKSA6IGR1cmF0aW9uSW5GcmFtZXM7XG4gIGNvbnN0IGFjdHVhbFNyYyA9IHVzZUFwcGVuZFZpZGVvRnJhZ21lbnQoe1xuICAgIGFjdHVhbFNyYzogdXNlUHJlbG9hZChzcmMpLFxuICAgIGFjdHVhbEZyb20sXG4gICAgZHVyYXRpb24sXG4gICAgZnBzXG4gIH0pO1xuICB1c2VJbXBlcmF0aXZlSGFuZGxlNyhyZWYsICgpID0+IHtcbiAgICByZXR1cm4gdmlkZW9SZWYuY3VycmVudDtcbiAgfSwgW10pO1xuICB1c2VFZmZlY3QyMygoKSA9PiB7XG4gICAgY29uc3QgeyBjdXJyZW50IH0gPSB2aWRlb1JlZjtcbiAgICBpZiAoIWN1cnJlbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgZXJyb3JIYW5kbGVyID0gKCkgPT4ge1xuICAgICAgaWYgKGN1cnJlbnQuZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIG9jY3VycmVkIGluIHZpZGVvXCIsIGN1cnJlbnQ/LmVycm9yKTtcbiAgICAgICAgaWYgKG9uRXJyb3IpIHtcbiAgICAgICAgICBjb25zdCBlcnIgPSBuZXcgRXJyb3IoYENvZGUgJHtjdXJyZW50LmVycm9yLmNvZGV9OiAke2N1cnJlbnQuZXJyb3IubWVzc2FnZX1gKTtcbiAgICAgICAgICBvbkVycm9yKGVycik7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVGhlIGJyb3dzZXIgdGhyZXcgYW4gZXJyb3Igd2hpbGUgcGxheWluZyB0aGUgdmlkZW8gJHtzcmN9OiBDb2RlICR7Y3VycmVudC5lcnJvci5jb2RlfSAtICR7Y3VycmVudD8uZXJyb3I/Lm1lc3NhZ2V9LiBTZWUgaHR0cHM6Ly9yZW1vdGlvbi5kZXYvZG9jcy9tZWRpYS1wbGF5YmFjay1lcnJvciBmb3IgaGVscC4gUGFzcyBhbiBvbkVycm9yKCkgcHJvcCB0byBoYW5kbGUgdGhlIGVycm9yLmApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKG9uRXJyb3IpIHtcbiAgICAgICAgICBjb25zdCBlcnIgPSBuZXcgRXJyb3IoYFRoZSBicm93c2VyIHRocmV3IGFuIGVycm9yIHdoaWxlIHBsYXlpbmcgdGhlIHZpZGVvICR7c3JjfWApO1xuICAgICAgICAgIG9uRXJyb3IoZXJyKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIGJyb3dzZXIgdGhyZXcgYW4gZXJyb3Igd2hpbGUgcGxheWluZyB0aGUgdmlkZW9cIik7XG4gICAgICB9XG4gICAgfTtcbiAgICBjdXJyZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJlcnJvclwiLCBlcnJvckhhbmRsZXIsIHsgb25jZTogdHJ1ZSB9KTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgY3VycmVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwiZXJyb3JcIiwgZXJyb3JIYW5kbGVyKTtcbiAgICB9O1xuICB9LCBbb25FcnJvciwgc3JjXSk7XG4gIGNvbnN0IGN1cnJlbnRPbkR1cmF0aW9uQ2FsbGJhY2sgPSB1c2VSZWYxMygpO1xuICBjdXJyZW50T25EdXJhdGlvbkNhbGxiYWNrLmN1cnJlbnQgPSBvbkR1cmF0aW9uO1xuICB1c2VFbWl0VmlkZW9GcmFtZSh7IHJlZjogdmlkZW9SZWYsIG9uVmlkZW9GcmFtZSB9KTtcbiAgdXNlRWZmZWN0MjMoKCkgPT4ge1xuICAgIGNvbnN0IHsgY3VycmVudCB9ID0gdmlkZW9SZWY7XG4gICAgaWYgKCFjdXJyZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChjdXJyZW50LmR1cmF0aW9uKSB7XG4gICAgICBjdXJyZW50T25EdXJhdGlvbkNhbGxiYWNrLmN1cnJlbnQ/LihzcmMsIGN1cnJlbnQuZHVyYXRpb24pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBvbkxvYWRlZE1ldGFkYXRhID0gKCkgPT4ge1xuICAgICAgY3VycmVudE9uRHVyYXRpb25DYWxsYmFjay5jdXJyZW50Py4oc3JjLCBjdXJyZW50LmR1cmF0aW9uKTtcbiAgICB9O1xuICAgIGN1cnJlbnQuYWRkRXZlbnRMaXN0ZW5lcihcImxvYWRlZG1ldGFkYXRhXCIsIG9uTG9hZGVkTWV0YWRhdGEpO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBjdXJyZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJsb2FkZWRtZXRhZGF0YVwiLCBvbkxvYWRlZE1ldGFkYXRhKTtcbiAgICB9O1xuICB9LCBbc3JjXSk7XG4gIHVzZUVmZmVjdDIzKCgpID0+IHtcbiAgICBjb25zdCB7IGN1cnJlbnQgfSA9IHZpZGVvUmVmO1xuICAgIGlmICghY3VycmVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoaXNJb3NTYWZhcmkoKSkge1xuICAgICAgY3VycmVudC5wcmVsb2FkID0gXCJtZXRhZGF0YVwiO1xuICAgIH0gZWxzZSB7XG4gICAgICBjdXJyZW50LnByZWxvYWQgPSBcImF1dG9cIjtcbiAgICB9XG4gIH0sIFtdKTtcbiAgY29uc3QgYWN0dWFsU3R5bGUgPSB1c2VNZW1vMzAoKCkgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICAuLi5zdHlsZSxcbiAgICAgIG9wYWNpdHk6IGlzU2VxdWVuY2VIaWRkZW4gPyAwIDogc3R5bGU/Lm9wYWNpdHkgPz8gMVxuICAgIH07XG4gIH0sIFtpc1NlcXVlbmNlSGlkZGVuLCBzdHlsZV0pO1xuICBjb25zdCBjcm9zc09yaWdpblZhbHVlID0gY3Jvc3NPcmlnaW4gPz8gKG9uVmlkZW9GcmFtZSA/IFwiYW5vbnltb3VzXCIgOiB1bmRlZmluZWQpO1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeDMwKFwidmlkZW9cIiwge1xuICAgIHJlZjogdmlkZW9SZWYsXG4gICAgbXV0ZWQ6IG11dGVkIHx8IG1lZGlhTXV0ZWQsXG4gICAgcGxheXNJbmxpbmU6IHRydWUsXG4gICAgc3JjOiBhY3R1YWxTcmMsXG4gICAgbG9vcDogX3JlbW90aW9uSW50ZXJuYWxOYXRpdmVMb29wUGFzc2VkLFxuICAgIHN0eWxlOiBhY3R1YWxTdHlsZSxcbiAgICBkaXNhYmxlUmVtb3RlUGxheWJhY2s6IHRydWUsXG4gICAgY3Jvc3NPcmlnaW46IGNyb3NzT3JpZ2luVmFsdWUsXG4gICAgLi4ubmF0aXZlUHJvcHNcbiAgfSk7XG59O1xudmFyIFZpZGVvRm9yUHJldmlldyA9IGZvcndhcmRSZWY5KFZpZGVvRm9yRGV2ZWxvcG1lbnRSZWZGb3J3YXJkaW5nRnVuY3Rpb24pO1xuXG4vLyBzcmMvdmlkZW8vT2ZmdGhyZWFkVmlkZW8udHN4XG5pbXBvcnQgeyBqc3ggYXMganN4MzEgfSBmcm9tIFwicmVhY3QvanN4LXJ1bnRpbWVcIjtcbnZhciBPZmZ0aHJlYWRWaWRlbyA9IChwcm9wczIpID0+IHtcbiAgY29uc3Qge1xuICAgIHN0YXJ0RnJvbSxcbiAgICBlbmRBdCxcbiAgICBuYW1lLFxuICAgIHBhdXNlV2hlbkJ1ZmZlcmluZyxcbiAgICBzdGFjayxcbiAgICBzaG93SW5UaW1lbGluZSxcbiAgICAuLi5vdGhlclByb3BzXG4gIH0gPSBwcm9wczI7XG4gIGNvbnN0IGVudmlyb25tZW50ID0gZ2V0UmVtb3Rpb25FbnZpcm9ubWVudCgpO1xuICBjb25zdCBvbkR1cmF0aW9uID0gdXNlQ2FsbGJhY2sxNCgoKSA9PiB7XG4gICAgcmV0dXJuO1xuICB9LCBbXSk7XG4gIGlmICh0eXBlb2YgcHJvcHMyLnNyYyAhPT0gXCJzdHJpbmdcIikge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFRoZSBcXGA8T2ZmdGhyZWFkVmlkZW8+XFxgIHRhZyByZXF1aXJlcyBhIHN0cmluZyBmb3IgXFxgc3JjXFxgLCBidXQgZ290ICR7SlNPTi5zdHJpbmdpZnkocHJvcHMyLnNyYyl9IGluc3RlYWQuYCk7XG4gIH1cbiAgaWYgKHByb3BzMi5pbWFnZUZvcm1hdCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFRoZSBcXGA8T2ZmdGhyZWFkVmlkZW8+XFxgIHRhZyBkb2VzIG5vIGxvbmdlciBhY2NlcHQgXFxgaW1hZ2VGb3JtYXRcXGAuIFVzZSB0aGUgXFxgdHJhbnNwYXJlbnRcXGAgcHJvcCBpZiB5b3Ugd2FudCB0byByZW5kZXIgYSB0cmFuc3BhcmVudCB2aWRlby5gKTtcbiAgfVxuICBpZiAodHlwZW9mIHN0YXJ0RnJvbSAhPT0gXCJ1bmRlZmluZWRcIiB8fCB0eXBlb2YgZW5kQXQgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICB2YWxpZGF0ZVN0YXJ0RnJvbVByb3BzKHN0YXJ0RnJvbSwgZW5kQXQpO1xuICAgIGNvbnN0IHN0YXJ0RnJvbUZyYW1lTm8gPSBzdGFydEZyb20gPz8gMDtcbiAgICBjb25zdCBlbmRBdEZyYW1lTm8gPSBlbmRBdCA/PyBJbmZpbml0eTtcbiAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeDMxKFNlcXVlbmNlLCB7XG4gICAgICBsYXlvdXQ6IFwibm9uZVwiLFxuICAgICAgZnJvbTogMCAtIHN0YXJ0RnJvbUZyYW1lTm8sXG4gICAgICBzaG93SW5UaW1lbGluZTogZmFsc2UsXG4gICAgICBkdXJhdGlvbkluRnJhbWVzOiBlbmRBdEZyYW1lTm8sXG4gICAgICBuYW1lLFxuICAgICAgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBqc3gzMShPZmZ0aHJlYWRWaWRlbywge1xuICAgICAgICBwYXVzZVdoZW5CdWZmZXJpbmc6IHBhdXNlV2hlbkJ1ZmZlcmluZyA/PyBmYWxzZSxcbiAgICAgICAgLi4ub3RoZXJQcm9wc1xuICAgICAgfSlcbiAgICB9KTtcbiAgfVxuICB2YWxpZGF0ZU1lZGlhUHJvcHMocHJvcHMyLCBcIlZpZGVvXCIpO1xuICBpZiAoZW52aXJvbm1lbnQuaXNSZW5kZXJpbmcpIHtcbiAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeDMxKE9mZnRocmVhZFZpZGVvRm9yUmVuZGVyaW5nLCB7XG4gICAgICAuLi5vdGhlclByb3BzXG4gICAgfSk7XG4gIH1cbiAgY29uc3Qge1xuICAgIHRyYW5zcGFyZW50LFxuICAgIHRvbmVNYXBwZWQsXG4gICAgX3JlbW90aW9uRGVidWdTZWVraW5nLFxuICAgIG9uQXV0b1BsYXlFcnJvcixcbiAgICBvblZpZGVvRnJhbWUsXG4gICAgY3Jvc3NPcmlnaW4sXG4gICAgLi4ud2l0aG91dFRyYW5zcGFyZW50XG4gIH0gPSBvdGhlclByb3BzO1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeDMxKFZpZGVvRm9yUHJldmlldywge1xuICAgIF9yZW1vdGlvbkludGVybmFsU3RhY2s6IHN0YWNrID8/IG51bGwsXG4gICAgX3JlbW90aW9uSW50ZXJuYWxOYXRpdmVMb29wUGFzc2VkOiBmYWxzZSxcbiAgICBfcmVtb3Rpb25EZWJ1Z1NlZWtpbmc6IF9yZW1vdGlvbkRlYnVnU2Vla2luZyA/PyBmYWxzZSxcbiAgICBvbkR1cmF0aW9uLFxuICAgIG9ubHlXYXJuRm9yTWVkaWFTZWVraW5nRXJyb3I6IHRydWUsXG4gICAgcGF1c2VXaGVuQnVmZmVyaW5nOiBwYXVzZVdoZW5CdWZmZXJpbmcgPz8gZmFsc2UsXG4gICAgc2hvd0luVGltZWxpbmU6IHNob3dJblRpbWVsaW5lID8/IHRydWUsXG4gICAgb25BdXRvUGxheUVycm9yOiBvbkF1dG9QbGF5RXJyb3IgPz8gdW5kZWZpbmVkLFxuICAgIG9uVmlkZW9GcmFtZTogb25WaWRlb0ZyYW1lID8/IG51bGwsXG4gICAgY3Jvc3NPcmlnaW4sXG4gICAgLi4ud2l0aG91dFRyYW5zcGFyZW50XG4gIH0pO1xufTtcbi8vIHNyYy92aWRlby9WaWRlby50c3hcbmltcG9ydCB7IGZvcndhcmRSZWYgYXMgZm9yd2FyZFJlZjExLCB1c2VDYWxsYmFjayBhcyB1c2VDYWxsYmFjazE1LCB1c2VDb250ZXh0IGFzIHVzZUNvbnRleHQzMCB9IGZyb20gXCJyZWFjdFwiO1xuXG4vLyBzcmMvdmlkZW8vVmlkZW9Gb3JSZW5kZXJpbmcudHN4XG5pbXBvcnQge1xuICBmb3J3YXJkUmVmIGFzIGZvcndhcmRSZWYxMCxcbiAgdXNlQ29udGV4dCBhcyB1c2VDb250ZXh0MjksXG4gIHVzZUVmZmVjdCBhcyB1c2VFZmZlY3QyNCxcbiAgdXNlSW1wZXJhdGl2ZUhhbmRsZSBhcyB1c2VJbXBlcmF0aXZlSGFuZGxlOCxcbiAgdXNlTGF5b3V0RWZmZWN0IGFzIHVzZUxheW91dEVmZmVjdDcsXG4gIHVzZU1lbW8gYXMgdXNlTWVtbzMxLFxuICB1c2VSZWYgYXMgdXNlUmVmMTRcbn0gZnJvbSBcInJlYWN0XCI7XG5cbi8vIHNyYy92aWRlby9zZWVrLXVudGlsLXJpZ2h0LnRzXG52YXIgcm91bmRUbzZDb21tYXMgPSAobnVtKSA9PiB7XG4gIHJldHVybiBNYXRoLnJvdW5kKG51bSAqIDFlNSkgLyAxZTU7XG59O1xudmFyIHNlZWtUb1RpbWUgPSAoZWxlbWVudCwgZGVzaXJlZFRpbWUpID0+IHtcbiAgZWxlbWVudC5jdXJyZW50VGltZSA9IGRlc2lyZWRUaW1lO1xuICBsZXQgY2FuY2VsO1xuICBsZXQgY2FuY2VsU2Vla2VkID0gbnVsbDtcbiAgY29uc3QgcHJvbSA9IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgY2FuY2VsID0gZWxlbWVudC5yZXF1ZXN0VmlkZW9GcmFtZUNhbGxiYWNrKChub3csIG1ldGFkYXRhKSA9PiB7XG4gICAgICBjb25zdCBkaXNwbGF5SW4gPSBtZXRhZGF0YS5leHBlY3RlZERpc3BsYXlUaW1lIC0gbm93O1xuICAgICAgaWYgKGRpc3BsYXlJbiA8PSAwKSB7XG4gICAgICAgIHJlc29sdmUobWV0YWRhdGEubWVkaWFUaW1lKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIHJlc29sdmUobWV0YWRhdGEubWVkaWFUaW1lKTtcbiAgICAgIH0sIGRpc3BsYXlJbiArIDE1MCk7XG4gICAgfSk7XG4gIH0pO1xuICBjb25zdCB3YWl0Rm9yU2Vla2VkRXZlbnQgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgIGNvbnN0IG9uRG9uZSA9ICgpID0+IHtcbiAgICAgIHJlc29sdmUoKTtcbiAgICB9O1xuICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcInNlZWtlZFwiLCBvbkRvbmUsIHtcbiAgICAgIG9uY2U6IHRydWVcbiAgICB9KTtcbiAgICBjYW5jZWxTZWVrZWQgPSAoKSA9PiB7XG4gICAgICBlbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJzZWVrZWRcIiwgb25Eb25lKTtcbiAgICB9O1xuICB9KTtcbiAgcmV0dXJuIHtcbiAgICB3YWl0OiBQcm9taXNlLmFsbChbcHJvbSwgd2FpdEZvclNlZWtlZEV2ZW50XSkudGhlbigoW3RpbWVdKSA9PiB0aW1lKSxcbiAgICBjYW5jZWw6ICgpID0+IHtcbiAgICAgIGNhbmNlbFNlZWtlZD8uKCk7XG4gICAgICBlbGVtZW50LmNhbmNlbFZpZGVvRnJhbWVDYWxsYmFjayhjYW5jZWwpO1xuICAgIH1cbiAgfTtcbn07XG52YXIgc2Vla1RvVGltZU11bHRpcGxlVW50aWxSaWdodCA9IChlbGVtZW50LCBkZXNpcmVkVGltZSwgZnBzKSA9PiB7XG4gIGNvbnN0IHRocmVzaG9sZCA9IDEgLyBmcHMgLyAyO1xuICBsZXQgY3VycmVudENhbmNlbCA9ICgpID0+IHtcbiAgICByZXR1cm47XG4gIH07XG4gIGlmIChOdW1iZXIuaXNGaW5pdGUoZWxlbWVudC5kdXJhdGlvbikgJiYgZWxlbWVudC5jdXJyZW50VGltZSA+PSBlbGVtZW50LmR1cmF0aW9uICYmIGRlc2lyZWRUaW1lID49IGVsZW1lbnQuZHVyYXRpb24pIHtcbiAgICByZXR1cm4ge1xuICAgICAgcHJvbTogUHJvbWlzZS5yZXNvbHZlKCksXG4gICAgICBjYW5jZWw6ICgpID0+IHtcbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIGNvbnN0IHByb20gPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgY29uc3QgZmlyc3RTZWVrID0gc2Vla1RvVGltZShlbGVtZW50LCBkZXNpcmVkVGltZSArIHRocmVzaG9sZCk7XG4gICAgZmlyc3RTZWVrLndhaXQudGhlbigoc2Vla2VkVG8pID0+IHtcbiAgICAgIGNvbnN0IGRpZmZlcmVuY2UgPSBNYXRoLmFicyhkZXNpcmVkVGltZSAtIHNlZWtlZFRvKTtcbiAgICAgIGlmIChkaWZmZXJlbmNlIDw9IHRocmVzaG9sZCkge1xuICAgICAgICByZXR1cm4gcmVzb2x2ZSgpO1xuICAgICAgfVxuICAgICAgY29uc3Qgc2lnbiA9IGRlc2lyZWRUaW1lID4gc2Vla2VkVG8gPyAxIDogLTE7XG4gICAgICBjb25zdCBuZXdTZWVrID0gc2Vla1RvVGltZShlbGVtZW50LCBzZWVrZWRUbyArIHRocmVzaG9sZCAqIHNpZ24pO1xuICAgICAgY3VycmVudENhbmNlbCA9IG5ld1NlZWsuY2FuY2VsO1xuICAgICAgbmV3U2Vlay53YWl0LnRoZW4oKG5ld1RpbWUpID0+IHtcbiAgICAgICAgY29uc3QgbmV3RGlmZmVyZW5jZSA9IE1hdGguYWJzKGRlc2lyZWRUaW1lIC0gbmV3VGltZSk7XG4gICAgICAgIGlmIChyb3VuZFRvNkNvbW1hcyhuZXdEaWZmZXJlbmNlKSA8PSByb3VuZFRvNkNvbW1hcyh0aHJlc2hvbGQpKSB7XG4gICAgICAgICAgcmV0dXJuIHJlc29sdmUoKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0aGlyZFNlZWsgPSBzZWVrVG9UaW1lKGVsZW1lbnQsIGRlc2lyZWRUaW1lICsgdGhyZXNob2xkKTtcbiAgICAgICAgY3VycmVudENhbmNlbCA9IHRoaXJkU2Vlay5jYW5jZWw7XG4gICAgICAgIHJldHVybiB0aGlyZFNlZWsud2FpdC50aGVuKCgpID0+IHtcbiAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgIH0pLmNhdGNoKChlcnIpID0+IHtcbiAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgfSk7XG4gICAgICB9KS5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gICAgY3VycmVudENhbmNlbCA9IGZpcnN0U2Vlay5jYW5jZWw7XG4gIH0pO1xuICByZXR1cm4ge1xuICAgIHByb20sXG4gICAgY2FuY2VsOiAoKSA9PiB7XG4gICAgICBjdXJyZW50Q2FuY2VsKCk7XG4gICAgfVxuICB9O1xufTtcblxuLy8gc3JjL3ZpZGVvL1ZpZGVvRm9yUmVuZGVyaW5nLnRzeFxuaW1wb3J0IHsganN4IGFzIGpzeDMyIH0gZnJvbSBcInJlYWN0L2pzeC1ydW50aW1lXCI7XG52YXIgVmlkZW9Gb3JSZW5kZXJpbmdGb3J3YXJkRnVuY3Rpb24gPSAoe1xuICBvbkVycm9yLFxuICB2b2x1bWU6IHZvbHVtZVByb3AsXG4gIGFsbG93QW1wbGlmaWNhdGlvbkR1cmluZ1JlbmRlcixcbiAgcGxheWJhY2tSYXRlLFxuICBvbkR1cmF0aW9uLFxuICB0b25lRnJlcXVlbmN5LFxuICBuYW1lLFxuICBhY2NlcHRhYmxlVGltZVNoaWZ0SW5TZWNvbmRzLFxuICBkZWxheVJlbmRlclJldHJpZXMsXG4gIGRlbGF5UmVuZGVyVGltZW91dEluTWlsbGlzZWNvbmRzLFxuICBsb29wVm9sdW1lQ3VydmVCZWhhdmlvcixcbiAgLi4ucHJvcHMyXG59LCByZWYpID0+IHtcbiAgY29uc3QgYWJzb2x1dGVGcmFtZSA9IHVzZVRpbWVsaW5lUG9zaXRpb24oKTtcbiAgY29uc3QgZnJhbWUgPSB1c2VDdXJyZW50RnJhbWUoKTtcbiAgY29uc3Qgdm9sdW1lUHJvcHNGcmFtZSA9IHVzZUZyYW1lRm9yVm9sdW1lUHJvcChsb29wVm9sdW1lQ3VydmVCZWhhdmlvciA/PyBcInJlcGVhdFwiKTtcbiAgY29uc3QgdmlkZW9Db25maWcgPSB1c2VVbnNhZmVWaWRlb0NvbmZpZygpO1xuICBjb25zdCB2aWRlb1JlZiA9IHVzZVJlZjE0KG51bGwpO1xuICBjb25zdCBzZXF1ZW5jZUNvbnRleHQgPSB1c2VDb250ZXh0MjkoU2VxdWVuY2VDb250ZXh0KTtcbiAgY29uc3QgbWVkaWFTdGFydHNBdCA9IHVzZU1lZGlhU3RhcnRzQXQoKTtcbiAgY29uc3QgZW52aXJvbm1lbnQgPSBnZXRSZW1vdGlvbkVudmlyb25tZW50KCk7XG4gIGNvbnN0IHsgcmVnaXN0ZXJSZW5kZXJBc3NldCwgdW5yZWdpc3RlclJlbmRlckFzc2V0IH0gPSB1c2VDb250ZXh0MjkoUmVuZGVyQXNzZXRNYW5hZ2VyKTtcbiAgY29uc3QgaWQgPSB1c2VNZW1vMzEoKCkgPT4gYHZpZGVvLSR7cmFuZG9tKHByb3BzMi5zcmMgPz8gXCJcIil9LSR7c2VxdWVuY2VDb250ZXh0Py5jdW11bGF0ZWRGcm9tfS0ke3NlcXVlbmNlQ29udGV4dD8ucmVsYXRpdmVGcm9tfS0ke3NlcXVlbmNlQ29udGV4dD8uZHVyYXRpb25JbkZyYW1lc31gLCBbXG4gICAgcHJvcHMyLnNyYyxcbiAgICBzZXF1ZW5jZUNvbnRleHQ/LmN1bXVsYXRlZEZyb20sXG4gICAgc2VxdWVuY2VDb250ZXh0Py5yZWxhdGl2ZUZyb20sXG4gICAgc2VxdWVuY2VDb250ZXh0Py5kdXJhdGlvbkluRnJhbWVzXG4gIF0pO1xuICBpZiAoIXZpZGVvQ29uZmlnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gdmlkZW8gY29uZmlnIGZvdW5kXCIpO1xuICB9XG4gIGNvbnN0IHZvbHVtZSA9IGV2YWx1YXRlVm9sdW1lKHtcbiAgICB2b2x1bWU6IHZvbHVtZVByb3AsXG4gICAgZnJhbWU6IHZvbHVtZVByb3BzRnJhbWUsXG4gICAgbWVkaWFWb2x1bWU6IDEsXG4gICAgYWxsb3dBbXBsaWZpY2F0aW9uRHVyaW5nUmVuZGVyOiBhbGxvd0FtcGxpZmljYXRpb25EdXJpbmdSZW5kZXIgPz8gZmFsc2VcbiAgfSk7XG4gIHVzZUVmZmVjdDI0KCgpID0+IHtcbiAgICBpZiAoIXByb3BzMi5zcmMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIHNyYyBwYXNzZWRcIik7XG4gICAgfVxuICAgIGlmIChwcm9wczIubXV0ZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHZvbHVtZSA8PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghd2luZG93LnJlbW90aW9uX2F1ZGlvRW5hYmxlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICByZWdpc3RlclJlbmRlckFzc2V0KHtcbiAgICAgIHR5cGU6IFwidmlkZW9cIixcbiAgICAgIHNyYzogZ2V0QWJzb2x1dGVTcmMocHJvcHMyLnNyYyksXG4gICAgICBpZCxcbiAgICAgIGZyYW1lOiBhYnNvbHV0ZUZyYW1lLFxuICAgICAgdm9sdW1lLFxuICAgICAgbWVkaWFGcmFtZTogZnJhbWUsXG4gICAgICBwbGF5YmFja1JhdGU6IHBsYXliYWNrUmF0ZSA/PyAxLFxuICAgICAgYWxsb3dBbXBsaWZpY2F0aW9uRHVyaW5nUmVuZGVyOiBhbGxvd0FtcGxpZmljYXRpb25EdXJpbmdSZW5kZXIgPz8gZmFsc2UsXG4gICAgICB0b25lRnJlcXVlbmN5OiB0b25lRnJlcXVlbmN5ID8/IG51bGwsXG4gICAgICBhdWRpb1N0YXJ0RnJhbWU6IE1hdGgubWF4KDAsIC0oc2VxdWVuY2VDb250ZXh0Py5yZWxhdGl2ZUZyb20gPz8gMCkpXG4gICAgfSk7XG4gICAgcmV0dXJuICgpID0+IHVucmVnaXN0ZXJSZW5kZXJBc3NldChpZCk7XG4gIH0sIFtcbiAgICBwcm9wczIubXV0ZWQsXG4gICAgcHJvcHMyLnNyYyxcbiAgICByZWdpc3RlclJlbmRlckFzc2V0LFxuICAgIGlkLFxuICAgIHVucmVnaXN0ZXJSZW5kZXJBc3NldCxcbiAgICB2b2x1bWUsXG4gICAgZnJhbWUsXG4gICAgYWJzb2x1dGVGcmFtZSxcbiAgICBwbGF5YmFja1JhdGUsXG4gICAgYWxsb3dBbXBsaWZpY2F0aW9uRHVyaW5nUmVuZGVyLFxuICAgIHRvbmVGcmVxdWVuY3ksXG4gICAgc2VxdWVuY2VDb250ZXh0Py5yZWxhdGl2ZUZyb21cbiAgXSk7XG4gIHVzZUltcGVyYXRpdmVIYW5kbGU4KHJlZiwgKCkgPT4ge1xuICAgIHJldHVybiB2aWRlb1JlZi5jdXJyZW50O1xuICB9LCBbXSk7XG4gIHVzZUVmZmVjdDI0KCgpID0+IHtcbiAgICBpZiAoIXdpbmRvdy5yZW1vdGlvbl92aWRlb0VuYWJsZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgeyBjdXJyZW50IH0gPSB2aWRlb1JlZjtcbiAgICBpZiAoIWN1cnJlbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgY3VycmVudFRpbWUgPSBnZXRNZWRpYVRpbWUoe1xuICAgICAgZnJhbWUsXG4gICAgICBwbGF5YmFja1JhdGU6IHBsYXliYWNrUmF0ZSB8fCAxLFxuICAgICAgc3RhcnRGcm9tOiAtbWVkaWFTdGFydHNBdCxcbiAgICAgIGZwczogdmlkZW9Db25maWcuZnBzXG4gICAgfSk7XG4gICAgY29uc3QgaGFuZGxlID0gZGVsYXlSZW5kZXIoYFJlbmRlcmluZyA8VmlkZW8gLz4gd2l0aCBzcmM9XCIke3Byb3BzMi5zcmN9XCJgLCB7XG4gICAgICByZXRyaWVzOiBkZWxheVJlbmRlclJldHJpZXMgPz8gdW5kZWZpbmVkLFxuICAgICAgdGltZW91dEluTWlsbGlzZWNvbmRzOiBkZWxheVJlbmRlclRpbWVvdXRJbk1pbGxpc2Vjb25kcyA/PyB1bmRlZmluZWRcbiAgICB9KTtcbiAgICBpZiAod2luZG93LnByb2Nlc3M/LmVudj8uTk9ERV9FTlYgPT09IFwidGVzdFwiKSB7XG4gICAgICBjb250aW51ZVJlbmRlcihoYW5kbGUpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoaXNBcHByb3hpbWF0ZWx5VGhlU2FtZShjdXJyZW50LmN1cnJlbnRUaW1lLCBjdXJyZW50VGltZSkpIHtcbiAgICAgIGlmIChjdXJyZW50LnJlYWR5U3RhdGUgPj0gMikge1xuICAgICAgICBjb250aW51ZVJlbmRlcihoYW5kbGUpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBsb2FkZWREYXRhSGFuZGxlciA9ICgpID0+IHtcbiAgICAgICAgY29udGludWVSZW5kZXIoaGFuZGxlKTtcbiAgICAgIH07XG4gICAgICBjdXJyZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJsb2FkZWRkYXRhXCIsIGxvYWRlZERhdGFIYW5kbGVyLCB7IG9uY2U6IHRydWUgfSk7XG4gICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICBjdXJyZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJsb2FkZWRkYXRhXCIsIGxvYWRlZERhdGFIYW5kbGVyKTtcbiAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IGVuZGVkSGFuZGxlciA9ICgpID0+IHtcbiAgICAgIGNvbnRpbnVlUmVuZGVyKGhhbmRsZSk7XG4gICAgfTtcbiAgICBjb25zdCBzZWVrMiA9IHNlZWtUb1RpbWVNdWx0aXBsZVVudGlsUmlnaHQoY3VycmVudCwgY3VycmVudFRpbWUsIHZpZGVvQ29uZmlnLmZwcyk7XG4gICAgc2VlazIucHJvbS50aGVuKCgpID0+IHtcbiAgICAgIGNvbnRpbnVlUmVuZGVyKGhhbmRsZSk7XG4gICAgfSk7XG4gICAgY3VycmVudC5hZGRFdmVudExpc3RlbmVyKFwiZW5kZWRcIiwgZW5kZWRIYW5kbGVyLCB7IG9uY2U6IHRydWUgfSk7XG4gICAgY29uc3QgZXJyb3JIYW5kbGVyID0gKCkgPT4ge1xuICAgICAgaWYgKGN1cnJlbnQ/LmVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBvY2N1cnJlZCBpbiB2aWRlb1wiLCBjdXJyZW50Py5lcnJvcik7XG4gICAgICAgIGlmIChvbkVycm9yKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVGhlIGJyb3dzZXIgdGhyZXcgYW4gZXJyb3Igd2hpbGUgcGxheWluZyB0aGUgdmlkZW8gJHtwcm9wczIuc3JjfTogQ29kZSAke2N1cnJlbnQuZXJyb3IuY29kZX0gLSAke2N1cnJlbnQ/LmVycm9yPy5tZXNzYWdlfS4gU2VlIGh0dHBzOi8vcmVtb3Rpb24uZGV2L2RvY3MvbWVkaWEtcGxheWJhY2stZXJyb3IgZm9yIGhlbHAuIFBhc3MgYW4gb25FcnJvcigpIHByb3AgdG8gaGFuZGxlIHRoZSBlcnJvci5gKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSBicm93c2VyIHRocmV3IGFuIGVycm9yXCIpO1xuICAgICAgfVxuICAgIH07XG4gICAgY3VycmVudC5hZGRFdmVudExpc3RlbmVyKFwiZXJyb3JcIiwgZXJyb3JIYW5kbGVyLCB7IG9uY2U6IHRydWUgfSk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHNlZWsyLmNhbmNlbCgpO1xuICAgICAgY3VycmVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwiZW5kZWRcIiwgZW5kZWRIYW5kbGVyKTtcbiAgICAgIGN1cnJlbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImVycm9yXCIsIGVycm9ySGFuZGxlcik7XG4gICAgICBjb250aW51ZVJlbmRlcihoYW5kbGUpO1xuICAgIH07XG4gIH0sIFtcbiAgICB2b2x1bWVQcm9wc0ZyYW1lLFxuICAgIHByb3BzMi5zcmMsXG4gICAgcGxheWJhY2tSYXRlLFxuICAgIHZpZGVvQ29uZmlnLmZwcyxcbiAgICBmcmFtZSxcbiAgICBtZWRpYVN0YXJ0c0F0LFxuICAgIG9uRXJyb3IsXG4gICAgZGVsYXlSZW5kZXJSZXRyaWVzLFxuICAgIGRlbGF5UmVuZGVyVGltZW91dEluTWlsbGlzZWNvbmRzXG4gIF0pO1xuICBjb25zdCB7IHNyYyB9ID0gcHJvcHMyO1xuICBpZiAoZW52aXJvbm1lbnQuaXNSZW5kZXJpbmcpIHtcbiAgICB1c2VMYXlvdXRFZmZlY3Q3KCgpID0+IHtcbiAgICAgIGlmICh3aW5kb3cucHJvY2Vzcz8uZW52Py5OT0RFX0VOViA9PT0gXCJ0ZXN0XCIpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgbmV3SGFuZGxlID0gZGVsYXlSZW5kZXIoXCJMb2FkaW5nIDxWaWRlbz4gZHVyYXRpb24gd2l0aCBzcmM9XCIgKyBzcmMsIHtcbiAgICAgICAgcmV0cmllczogZGVsYXlSZW5kZXJSZXRyaWVzID8/IHVuZGVmaW5lZCxcbiAgICAgICAgdGltZW91dEluTWlsbGlzZWNvbmRzOiBkZWxheVJlbmRlclRpbWVvdXRJbk1pbGxpc2Vjb25kcyA/PyB1bmRlZmluZWRcbiAgICAgIH0pO1xuICAgICAgY29uc3QgeyBjdXJyZW50IH0gPSB2aWRlb1JlZjtcbiAgICAgIGNvbnN0IGRpZExvYWQgPSAoKSA9PiB7XG4gICAgICAgIGlmIChjdXJyZW50Py5kdXJhdGlvbikge1xuICAgICAgICAgIG9uRHVyYXRpb24oc3JjLCBjdXJyZW50LmR1cmF0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICBjb250aW51ZVJlbmRlcihuZXdIYW5kbGUpO1xuICAgICAgfTtcbiAgICAgIGlmIChjdXJyZW50Py5kdXJhdGlvbikge1xuICAgICAgICBvbkR1cmF0aW9uKHNyYywgY3VycmVudC5kdXJhdGlvbik7XG4gICAgICAgIGNvbnRpbnVlUmVuZGVyKG5ld0hhbmRsZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjdXJyZW50Py5hZGRFdmVudExpc3RlbmVyKFwibG9hZGVkbWV0YWRhdGFcIiwgZGlkTG9hZCwgeyBvbmNlOiB0cnVlIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgY3VycmVudD8ucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImxvYWRlZG1ldGFkYXRhXCIsIGRpZExvYWQpO1xuICAgICAgICBjb250aW51ZVJlbmRlcihuZXdIYW5kbGUpO1xuICAgICAgfTtcbiAgICB9LCBbc3JjLCBvbkR1cmF0aW9uLCBkZWxheVJlbmRlclJldHJpZXMsIGRlbGF5UmVuZGVyVGltZW91dEluTWlsbGlzZWNvbmRzXSk7XG4gIH1cbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBqc3gzMihcInZpZGVvXCIsIHtcbiAgICByZWY6IHZpZGVvUmVmLFxuICAgIC4uLnByb3BzMlxuICB9KTtcbn07XG52YXIgVmlkZW9Gb3JSZW5kZXJpbmcgPSBmb3J3YXJkUmVmMTAoVmlkZW9Gb3JSZW5kZXJpbmdGb3J3YXJkRnVuY3Rpb24pO1xuXG4vLyBzcmMvdmlkZW8vVmlkZW8udHN4XG5pbXBvcnQgeyBqc3ggYXMganN4MzMgfSBmcm9tIFwicmVhY3QvanN4LXJ1bnRpbWVcIjtcbnZhciBWaWRlb0ZvcndhcmRpbmdGdW5jdGlvbiA9IChwcm9wczIsIHJlZikgPT4ge1xuICBjb25zdCB7XG4gICAgc3RhcnRGcm9tLFxuICAgIGVuZEF0LFxuICAgIG5hbWUsXG4gICAgcGF1c2VXaGVuQnVmZmVyaW5nLFxuICAgIHN0YWNrLFxuICAgIF9yZW1vdGlvbkludGVybmFsTmF0aXZlTG9vcFBhc3NlZCxcbiAgICBzaG93SW5UaW1lbGluZSxcbiAgICBvbkF1dG9QbGF5RXJyb3IsXG4gICAgLi4ub3RoZXJQcm9wc1xuICB9ID0gcHJvcHMyO1xuICBjb25zdCB7IGxvb3AsIF9yZW1vdGlvbkRlYnVnU2Vla2luZywgLi4ucHJvcHNPdGhlclRoYW5Mb29wIH0gPSBwcm9wczI7XG4gIGNvbnN0IHsgZnBzIH0gPSB1c2VWaWRlb0NvbmZpZygpO1xuICBjb25zdCBlbnZpcm9ubWVudCA9IGdldFJlbW90aW9uRW52aXJvbm1lbnQoKTtcbiAgY29uc3QgeyBkdXJhdGlvbnMsIHNldER1cmF0aW9ucyB9ID0gdXNlQ29udGV4dDMwKER1cmF0aW9uc0NvbnRleHQpO1xuICBpZiAodHlwZW9mIHJlZiA9PT0gXCJzdHJpbmdcIikge1xuICAgIHRocm93IG5ldyBFcnJvcihcInN0cmluZyByZWZzIGFyZSBub3Qgc3VwcG9ydGVkXCIpO1xuICB9XG4gIGlmICh0eXBlb2YgcHJvcHMyLnNyYyAhPT0gXCJzdHJpbmdcIikge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFRoZSBcXGA8VmlkZW8+XFxgIHRhZyByZXF1aXJlcyBhIHN0cmluZyBmb3IgXFxgc3JjXFxgLCBidXQgZ290ICR7SlNPTi5zdHJpbmdpZnkocHJvcHMyLnNyYyl9IGluc3RlYWQuYCk7XG4gIH1cbiAgY29uc3QgcHJlbG9hZGVkU3JjID0gdXNlUHJlbG9hZChwcm9wczIuc3JjKTtcbiAgY29uc3Qgb25EdXJhdGlvbiA9IHVzZUNhbGxiYWNrMTUoKHNyYywgZHVyYXRpb25JblNlY29uZHMpID0+IHtcbiAgICBzZXREdXJhdGlvbnMoeyB0eXBlOiBcImdvdC1kdXJhdGlvblwiLCBkdXJhdGlvbkluU2Vjb25kcywgc3JjIH0pO1xuICB9LCBbc2V0RHVyYXRpb25zXSk7XG4gIGNvbnN0IG9uVmlkZW9GcmFtZSA9IHVzZUNhbGxiYWNrMTUoKCkgPT4ge1xuICB9LCBbXSk7XG4gIGNvbnN0IGR1cmF0aW9uRmV0Y2hlZCA9IGR1cmF0aW9uc1tnZXRBYnNvbHV0ZVNyYyhwcmVsb2FkZWRTcmMpXSA/PyBkdXJhdGlvbnNbZ2V0QWJzb2x1dGVTcmMocHJvcHMyLnNyYyldO1xuICBpZiAobG9vcCAmJiBkdXJhdGlvbkZldGNoZWQgIT09IHVuZGVmaW5lZCkge1xuICAgIGNvbnN0IG1lZGlhRHVyYXRpb24gPSBkdXJhdGlvbkZldGNoZWQgKiBmcHM7XG4gICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBqc3gzMyhMb29wLCB7XG4gICAgICBkdXJhdGlvbkluRnJhbWVzOiBjYWxjdWxhdGVMb29wRHVyYXRpb24oe1xuICAgICAgICBlbmRBdCxcbiAgICAgICAgbWVkaWFEdXJhdGlvbixcbiAgICAgICAgcGxheWJhY2tSYXRlOiBwcm9wczIucGxheWJhY2tSYXRlID8/IDEsXG4gICAgICAgIHN0YXJ0RnJvbVxuICAgICAgfSksXG4gICAgICBsYXlvdXQ6IFwibm9uZVwiLFxuICAgICAgbmFtZSxcbiAgICAgIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8ganN4MzMoVmlkZW8sIHtcbiAgICAgICAgLi4ucHJvcHNPdGhlclRoYW5Mb29wLFxuICAgICAgICByZWYsXG4gICAgICAgIF9yZW1vdGlvbkludGVybmFsTmF0aXZlTG9vcFBhc3NlZDogdHJ1ZVxuICAgICAgfSlcbiAgICB9KTtcbiAgfVxuICBpZiAodHlwZW9mIHN0YXJ0RnJvbSAhPT0gXCJ1bmRlZmluZWRcIiB8fCB0eXBlb2YgZW5kQXQgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICB2YWxpZGF0ZVN0YXJ0RnJvbVByb3BzKHN0YXJ0RnJvbSwgZW5kQXQpO1xuICAgIGNvbnN0IHN0YXJ0RnJvbUZyYW1lTm8gPSBzdGFydEZyb20gPz8gMDtcbiAgICBjb25zdCBlbmRBdEZyYW1lTm8gPSBlbmRBdCA/PyBJbmZpbml0eTtcbiAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeDMzKFNlcXVlbmNlLCB7XG4gICAgICBsYXlvdXQ6IFwibm9uZVwiLFxuICAgICAgZnJvbTogMCAtIHN0YXJ0RnJvbUZyYW1lTm8sXG4gICAgICBzaG93SW5UaW1lbGluZTogZmFsc2UsXG4gICAgICBkdXJhdGlvbkluRnJhbWVzOiBlbmRBdEZyYW1lTm8sXG4gICAgICBuYW1lLFxuICAgICAgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBqc3gzMyhWaWRlbywge1xuICAgICAgICBwYXVzZVdoZW5CdWZmZXJpbmc6IHBhdXNlV2hlbkJ1ZmZlcmluZyA/PyBmYWxzZSxcbiAgICAgICAgLi4ub3RoZXJQcm9wcyxcbiAgICAgICAgcmVmXG4gICAgICB9KVxuICAgIH0pO1xuICB9XG4gIHZhbGlkYXRlTWVkaWFQcm9wcyhwcm9wczIsIFwiVmlkZW9cIik7XG4gIGlmIChlbnZpcm9ubWVudC5pc1JlbmRlcmluZykge1xuICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8ganN4MzMoVmlkZW9Gb3JSZW5kZXJpbmcsIHtcbiAgICAgIG9uRHVyYXRpb24sXG4gICAgICBvblZpZGVvRnJhbWU6IG9uVmlkZW9GcmFtZSA/PyBudWxsLFxuICAgICAgLi4ub3RoZXJQcm9wcyxcbiAgICAgIHJlZlxuICAgIH0pO1xuICB9XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8ganN4MzMoVmlkZW9Gb3JQcmV2aWV3LCB7XG4gICAgb25seVdhcm5Gb3JNZWRpYVNlZWtpbmdFcnJvcjogZmFsc2UsXG4gICAgLi4ub3RoZXJQcm9wcyxcbiAgICByZWYsXG4gICAgb25WaWRlb0ZyYW1lOiBudWxsLFxuICAgIHBhdXNlV2hlbkJ1ZmZlcmluZzogcGF1c2VXaGVuQnVmZmVyaW5nID8/IGZhbHNlLFxuICAgIG9uRHVyYXRpb24sXG4gICAgX3JlbW90aW9uSW50ZXJuYWxTdGFjazogc3RhY2sgPz8gbnVsbCxcbiAgICBfcmVtb3Rpb25JbnRlcm5hbE5hdGl2ZUxvb3BQYXNzZWQ6IF9yZW1vdGlvbkludGVybmFsTmF0aXZlTG9vcFBhc3NlZCA/PyBmYWxzZSxcbiAgICBfcmVtb3Rpb25EZWJ1Z1NlZWtpbmc6IF9yZW1vdGlvbkRlYnVnU2Vla2luZyA/PyBmYWxzZSxcbiAgICBzaG93SW5UaW1lbGluZTogc2hvd0luVGltZWxpbmUgPz8gdHJ1ZSxcbiAgICBvbkF1dG9QbGF5RXJyb3I6IG9uQXV0b1BsYXlFcnJvciA/PyB1bmRlZmluZWRcbiAgfSk7XG59O1xudmFyIFZpZGVvID0gZm9yd2FyZFJlZjExKFZpZGVvRm9yd2FyZGluZ0Z1bmN0aW9uKTtcbmFkZFNlcXVlbmNlU3RhY2tUcmFjZXMoVmlkZW8pO1xuLy8gc3JjL2luZGV4LnRzXG5jaGVja011bHRpcGxlUmVtb3Rpb25WZXJzaW9ucygpO1xudmFyIEV4cGVyaW1lbnRhbCA9IHtcbiAgQ2xpcHBlcixcbiAgTnVsbCxcbiAgdXNlSXNQbGF5ZXJcbn07XG52YXIgcHJveHlPYmogPSB7fTtcbnZhciBDb25maWcgPSBuZXcgUHJveHkocHJveHlPYmosIHtcbiAgZ2V0KF8sIHByb3ApIHtcbiAgICBpZiAocHJvcCA9PT0gXCJCdW5kbGluZ1wiIHx8IHByb3AgPT09IFwiUmVuZGVyaW5nXCIgfHwgcHJvcCA9PT0gXCJMb2dcIiB8fCBwcm9wID09PSBcIlB1cHBldGVlclwiIHx8IHByb3AgPT09IFwiT3V0cHV0XCIpIHtcbiAgICAgIHJldHVybiBDb25maWc7XG4gICAgfVxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBjb25zb2xlLndhcm4oXCJcXHUyNkEwXFx1RkUwRiAgVGhlIENMSSBjb25maWd1cmF0aW9uIGhhcyBiZWVuIGV4dHJhY3RlZCBmcm9tIFJlbW90aW9uIENvcmUuXCIpO1xuICAgICAgY29uc29sZS53YXJuKFwiVXBkYXRlIHRoZSBpbXBvcnQgZnJvbSB0aGUgY29uZmlnIGZpbGU6XCIpO1xuICAgICAgY29uc29sZS53YXJuKCk7XG4gICAgICBjb25zb2xlLndhcm4oXCItIERlbGV0ZTpcIik7XG4gICAgICBjb25zb2xlLndhcm4oJ2ltcG9ydCB7Q29uZmlnfSBmcm9tIFwicmVtb3Rpb25cIjsnKTtcbiAgICAgIGNvbnNvbGUud2FybihcIisgUmVwbGFjZTpcIik7XG4gICAgICBjb25zb2xlLndhcm4oJ2ltcG9ydCB7Q29uZmlnfSBmcm9tIFwiQHJlbW90aW9uL2NsaS9jb25maWdcIjsnKTtcbiAgICAgIGNvbnNvbGUud2FybigpO1xuICAgICAgY29uc29sZS53YXJuKFwiRm9yIG1vcmUgaW5mb3JtYXRpb24sIHNlZSBodHRwczovL3d3dy5yZW1vdGlvbi5kZXYvZG9jcy80LTAtbWlncmF0aW9uLlwiKTtcbiAgICAgIHByb2Nlc3MuZXhpdCgxKTtcbiAgICB9O1xuICB9XG59KTtcbmFkZFNlcXVlbmNlU3RhY2tUcmFjZXMoU2VxdWVuY2UpO1xuZXhwb3J0IHtcbiAgd2F0Y2hTdGF0aWNGaWxlLFxuICB1c2VWaWRlb0NvbmZpZyxcbiAgdXNlQ3VycmVudFNjYWxlLFxuICB1c2VDdXJyZW50RnJhbWUsXG4gIHVzZUJ1ZmZlclN0YXRlLFxuICBzdGF0aWNGaWxlLFxuICBzcHJpbmcsXG4gIHJlZ2lzdGVyUm9vdCxcbiAgcmFuZG9tLFxuICBwcmVmZXRjaCxcbiAgbWVhc3VyZVNwcmluZyxcbiAgaW50ZXJwb2xhdGVDb2xvcnMsXG4gIGludGVycG9sYXRlLFxuICBnZXRTdGF0aWNGaWxlcyxcbiAgZ2V0UmVtb3Rpb25FbnZpcm9ubWVudCxcbiAgZ2V0SW5wdXRQcm9wcyxcbiAgZGVsYXlSZW5kZXIsXG4gIGNvbnRpbnVlUmVuZGVyLFxuICBjYW5jZWxSZW5kZXIsXG4gIFZpZGVvLFxuICBWRVJTSU9OLFxuICBTdGlsbCxcbiAgU2VyaWVzLFxuICBTZXF1ZW5jZSxcbiAgT2ZmdGhyZWFkVmlkZW8sXG4gIExvb3AsXG4gIEludGVybmFscyxcbiAgSW1nLFxuICBJRnJhbWUsXG4gIEZyZWV6ZSxcbiAgRm9sZGVyQ29udGV4dCxcbiAgRm9sZGVyLFxuICBFeHBlcmltZW50YWwsXG4gIEVhc2luZyxcbiAgQ29uZmlnLFxuICBDb21wb3NpdGlvbixcbiAgQXVkaW8sXG4gIEFydGlmYWN0LFxuICBBYnNvbHV0ZUZpbGxcbn07XG4iXSwibmFtZXMiOlsiX19kZWZQcm9wIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJfX2V4cG9ydCIsInRhcmdldCIsImFsbCIsIm5hbWUiLCJnZXQiLCJlbnVtZXJhYmxlIiwiY29uZmlndXJhYmxlIiwic2V0IiwibmV3VmFsdWUiLCJjcmVhdGVDb250ZXh0IiwiZXJyIiwiRXJyb3IiLCJqb2luIiwidXNlQ29udGV4dCIsInVzZUVmZmVjdCIsImNyZWF0ZUNvbnRleHQyIiwidXNlTGF5b3V0RWZmZWN0IiwidXNlTWVtbyIsInVzZVN0YXRlIiwianN4IiwiTmF0aXZlTGF5ZXJzQ29udGV4dCIsInNldENsaXBSZWdpb24iLCJjbGlwUmVnaW9uIiwiTmF0aXZlTGF5ZXJzUHJvdmlkZXIiLCJjaGlsZHJlbiIsImNvbnRleHQiLCJ3aW5kb3ciLCJyZW1vdGlvbl9nZXRDbGlwUmVnaW9uIiwiUHJvdmlkZXIiLCJ2YWx1ZSIsIkNsaXBwZXIiLCJoZWlnaHQiLCJ3aWR0aCIsIngiLCJ5IiwiYyIsIlJlYWN0IiwiZ2V0Tm9kZUVudlN0cmluZyIsImdldEVudlN0cmluZyIsImdldFJlbW90aW9uRW52aXJvbm1lbnQiLCJpc1BsYXllciIsInJlbW90aW9uX2lzUGxheWVyIiwiaXNSZW5kZXJpbmciLCJwcm9jZXNzIiwiZW52IiwicmVtb3Rpb25fcHVwcGV0ZWVyVGltZW91dCIsImlzU3R1ZGlvIiwicmVtb3Rpb25faXNTdHVkaW8iLCJvcmlnaW5hbENyZWF0ZUVsZW1lbnQiLCJjcmVhdGVFbGVtZW50IiwiY29tcG9uZW50c1RvQWRkU3RhY2tzVG8iLCJlbmFibGVTZXF1ZW5jZVN0YWNrVHJhY2VzIiwicHJveHkiLCJQcm94eSIsImFwcGx5IiwidGhpc0FyZyIsImFyZ0FycmF5IiwiaW5jbHVkZXMiLCJmaXJzdCIsInByb3BzIiwicmVzdCIsIm5ld1Byb3BzIiwic3RhY2siLCJSZWZsZWN0IiwiYWRkU2VxdWVuY2VTdGFja1RyYWNlcyIsImNvbXBvbmVudCIsInB1c2giLCJjcmVhdGVDb250ZXh0MyIsInVzZUNvbnRleHQyIiwianN4MiIsIklzUGxheWVyQ29udGV4dCIsIklzUGxheWVyQ29udGV4dFByb3ZpZGVyIiwidXNlSXNQbGF5ZXIiLCJ0cnV0aHkiLCJCb29sZWFuIiwiVkVSU0lPTiIsImNoZWNrTXVsdGlwbGVSZW1vdGlvblZlcnNpb25zIiwiZ2xvYmFsVGhpcyIsImFscmVhZHlJbXBvcnRlZCIsInJlbW90aW9uX2ltcG9ydGVkIiwiVHlwZUVycm9yIiwiZmlsdGVyIiwidXNlQ29udGV4dDMiLCJ1c2VFZmZlY3QyIiwiTnVsbCIsImZvcndhcmRSZWYiLCJmb3J3YXJkUmVmMiIsInVzZUNvbnRleHQxMiIsInVzZUVmZmVjdDUiLCJ1c2VNZW1vMTAiLCJ1c2VTdGF0ZTUiLCJ1c2VNZW1vMiIsImpzeDMiLCJBYnNvbHV0ZUZpbGxSZWZGb3J3YXJkaW5nIiwicmVmIiwic3R5bGUiLCJvdGhlciIsImFjdHVhbFN0eWxlIiwicG9zaXRpb24iLCJ0b3AiLCJsZWZ0IiwicmlnaHQiLCJib3R0b20iLCJkaXNwbGF5IiwiZmxleERpcmVjdGlvbiIsIkFic29sdXRlRmlsbCIsImNyZWF0ZUNvbnRleHQ0IiwiU2VxdWVuY2VDb250ZXh0IiwiUmVhY3QzIiwidXNlQ2FsbGJhY2siLCJ1c2VNZW1vMyIsInVzZVN0YXRlMiIsImpzeDQiLCJTZXF1ZW5jZU1hbmFnZXIiLCJyZWdpc3RlclNlcXVlbmNlIiwidW5yZWdpc3RlclNlcXVlbmNlIiwic2VxdWVuY2VzIiwiU2VxdWVuY2VWaXNpYmlsaXR5VG9nZ2xlQ29udGV4dCIsImhpZGRlbiIsInNldEhpZGRlbiIsIlNlcXVlbmNlTWFuYWdlclByb3ZpZGVyIiwic2V0U2VxdWVuY2VzIiwic2VxIiwic2VxcyIsInMiLCJpZCIsInNlcXVlbmNlQ29udGV4dCIsImhpZGRlbkNvbnRleHQiLCJjcmVhdGVDb250ZXh0NSIsInVzZUNvbnRleHQ0IiwidXNlRWZmZWN0MyIsInVzZVJlZiIsInVzZVN0YXRlMyIsIk5vbmNlQ29udGV4dCIsImdldE5vbmNlIiwiZmFzdFJlZnJlc2hlcyIsInVzZU5vbmNlIiwibm9uY2UiLCJzZXROb25jZSIsImxhc3RDb250ZXh0IiwiY3VycmVudCIsImV4cG9ydHNfdGltZWxpbmVfcG9zaXRpb25fc3RhdGUiLCJ1c2VUaW1lbGluZVNldEZyYW1lIiwidXNlVGltZWxpbmVQb3NpdGlvbiIsInVzZVBsYXlpbmdTdGF0ZSIsInBlcnNpc3RDdXJyZW50RnJhbWUiLCJnZXRJbml0aWFsRnJhbWVTdGF0ZSIsImdldEZyYW1lRm9yQ29tcG9zaXRpb24iLCJUaW1lbGluZUNvbnRleHQiLCJTZXRUaW1lbGluZUNvbnRleHQiLCJjcmVhdGVDb250ZXh0OSIsInVzZUNvbnRleHQ3IiwidXNlTWVtbzciLCJ1c2VDb250ZXh0NiIsInVzZU1lbW82IiwiY3JlYXRlQ29udGV4dDYiLCJDb21wb3NpdGlvbk1hbmFnZXIiLCJjb21wb3NpdGlvbnMiLCJyZWdpc3RlckNvbXBvc2l0aW9uIiwidW5yZWdpc3RlckNvbXBvc2l0aW9uIiwicmVnaXN0ZXJGb2xkZXIiLCJ1bnJlZ2lzdGVyRm9sZGVyIiwic2V0Q3VycmVudENvbXBvc2l0aW9uTWV0YWRhdGEiLCJ1cGRhdGVDb21wb3NpdGlvbkRlZmF1bHRQcm9wcyIsImZvbGRlcnMiLCJjdXJyZW50Q29tcG9zaXRpb25NZXRhZGF0YSIsImNhbnZhc0NvbnRlbnQiLCJzZXRDYW52YXNDb250ZW50IiwiY3JlYXRlQ29udGV4dDgiLCJjcmVhdGVSZWYiLCJ1c2VDYWxsYmFjazMiLCJ1c2VDb250ZXh0NSIsInVzZUVmZmVjdDQiLCJ1c2VJbXBlcmF0aXZlSGFuZGxlIiwidXNlSW1wZXJhdGl2ZUhhbmRsZTIiLCJ1c2VNZW1vNSIsInVzZVN0YXRlNCIsIlJlYWN0NCIsImNyZWF0ZUNvbnRleHQ3IiwidXNlQ2FsbGJhY2syIiwidXNlTWVtbzQiLCJqc3g1IiwiRWRpdG9yUHJvcHNDb250ZXh0IiwidXBkYXRlUHJvcHMiLCJyZXNldFVuc2F2ZWQiLCJlZGl0b3JQcm9wc1Byb3ZpZGVyUmVmIiwiRWRpdG9yUHJvcHNQcm92aWRlciIsInNldFByb3BzIiwiZGVmYXVsdFByb3BzIiwicHJldiIsImdldFByb3BzIiwiY3R4IiwicHJvYmxlbWF0aWNDaGFyYWN0ZXJzIiwiZGlkV2FybiIsIndhcm5PbmNlIiwibWVzc2FnZSIsImNvbnNvbGUiLCJ3YXJuIiwiaW5jbHVkZXNIZXhPZlVuc2FmZUNoYXIiLCJwYXRoIiwia2V5Iiwia2V5cyIsImNvbnRhaW5zSGV4IiwiaGV4Q29kZSIsInRyaW1MZWFkaW5nU2xhc2giLCJzdGFydHNXaXRoIiwic3Vic3RyaW5nIiwiaW5uZXIiLCJyZW1vdGlvbl9zdGF0aWNCYXNlIiwiZW5jb2RlQnlTcGxpdHRpbmciLCJzcGxpdEJ5U2xhc2giLCJzcGxpdCIsImVuY29kZWRBcnJheSIsIm1hcCIsImVsZW1lbnQiLCJlbmNvZGVVUklDb21wb25lbnQiLCJtZXJnZWQiLCJzdGF0aWNGaWxlIiwiaW5jbHVkZXNIZXgiLCJwcmVwcm9jZXNzZWQiLCJwcmVwYXJzZWQiLCJEQVRFX1RPS0VOIiwiRklMRV9UT0tFTiIsInNlcmlhbGl6ZUpTT05XaXRoRGF0ZSIsImRhdGEiLCJpbmRlbnQiLCJzdGF0aWNCYXNlIiwiY3VzdG9tRGF0ZVVzZWQiLCJjdXN0b21GaWxlVXNlZCIsIm1hcFVzZWQiLCJzZXRVc2VkIiwic2VyaWFsaXplZFN0cmluZyIsIkpTT04iLCJzdHJpbmdpZnkiLCJpdGVtIiwiRGF0ZSIsInRvSVNPU3RyaW5nIiwiTWFwIiwiU2V0IiwicmVwbGFjZSIsImRlc2VyaWFsaXplSlNPTldpdGhDdXN0b21GaWVsZHMiLCJwYXJzZSIsIl8iLCJzZXJpYWxpemVUaGVuRGVzZXJpYWxpemVJblN0dWRpbyIsImRpZFdhcm5TU1JJbXBvcnQiLCJ3YXJuT25jZVNTUkltcG9ydCIsImdldElucHV0UHJvcHMiLCJwYXJhbSIsInJlbW90aW9uX2lucHV0UHJvcHMiLCJwYXJzZWQiLCJ2YWxpZENvZGVjcyIsInZhbGlkYXRlRGVmYXVsdENvZGVjIiwiZGVmYXVsdENvZGVjIiwibG9jYXRpb24iLCJ2YWxpZGF0ZURpbWVuc2lvbiIsImFtb3VudCIsIm5hbWVPZlByb3AiLCJpc05hTiIsIk51bWJlciIsImlzRmluaXRlIiwidmFsaWRhdGVEdXJhdGlvbkluRnJhbWVzIiwiZHVyYXRpb25JbkZyYW1lcyIsIm9wdGlvbnMiLCJhbGxvd0Zsb2F0cyIsInZhbGlkYXRlRnBzIiwiZnBzIiwiaXNHaWYiLCJ2YWxpZGF0ZUNhbGN1bGF0ZWQiLCJjYWxjdWxhdGVkIiwiY29tcG9zaXRpb25JZCIsImNvbXBvc2l0aW9uRnBzIiwiY29tcG9zaXRpb25IZWlnaHQiLCJjb21wb3NpdGlvbldpZHRoIiwiY29tcG9zaXRpb25EdXJhdGlvbkluRnJhbWVzIiwiY2FsY3VsYXRlTWV0YWRhdGFFcnJvckxvY2F0aW9uIiwiZGVmYXVsdEVycm9yTG9jYXRpb24iLCJ1bmRlZmluZWQiLCJyZXNvbHZlVmlkZW9Db25maWciLCJjYWxjdWxhdGVNZXRhZGF0YSIsInNpZ25hbCIsIm9yaWdpbmFsUHJvcHMiLCJjYWxjdWxhdGVkUHJvbSIsImFib3J0U2lnbmFsIiwidGhlbiIsInJlc29sdmVWaWRlb0NvbmZpZ09yQ2F0Y2giLCJwYXJhbXMiLCJwcm9taXNlT3JSZXR1cm5WYWx1ZSIsInR5cGUiLCJyZXN1bHQiLCJlcnJvciIsImpzeDYiLCJSZXNvbHZlQ29tcG9zaXRpb25Db250ZXh0IiwicmVzb2x2ZUNvbXBvc2l0aW9uc1JlZiIsIm5lZWRzUmVzb2x1dGlvbiIsImNvbXBvc2l0aW9uIiwiUFJPUFNfVVBEQVRFRF9FWFRFUk5BTExZIiwiUmVzb2x2ZUNvbXBvc2l0aW9uQ29uZmlnIiwiY3VycmVudFJlbmRlck1vZGFsQ29tcG9zaXRpb24iLCJzZXRDdXJyZW50UmVuZGVyTW9kYWxDb21wb3NpdGlvbiIsInNlbGVjdGVkQ29tcG9zaXRpb24iLCJmaW5kIiwicmVuZGVyTW9kYWxDb21wb3NpdGlvbiIsImFsbEVkaXRvclByb3BzIiwiaW5wdXRQcm9wcyIsInJlc29sdmVkQ29uZmlncyIsInNldFJlc29sdmVkQ29uZmlncyIsInNlbGVjdGVkRWRpdG9yUHJvcHMiLCJyZW5kZXJNb2RhbFByb3BzIiwiaGFzUmVzb2x1dGlvbiIsImRvUmVzb2x1dGlvbiIsImNvbWJpbmVkUHJvcHMiLCJjb250cm9sbGVyIiwiQWJvcnRDb250cm9sbGVyIiwiciIsInByb21Pck5vdCIsImFib3J0ZWQiLCJjYXRjaCIsImN1cnJlbnRDb21wb3NpdGlvbiIsInJlbG9hZEN1cnJlbnRseVNlbGVjdGVkQ29tcG9zaXRpb24iLCJlZGl0b3JQcm9wcyIsImlzVGhlU2FtZSIsImN1cnJlbnREZWZhdWx0UHJvcHMiLCJjYW5SZXNvbHZlIiwic2hvdWxkSWdub3JlVXBkYXRlIiwicmVtb3Rpb25faWdub3JlRmFzdFJlZnJlc2hVcGRhdGUiLCJhYm9ydCIsImRpc3BhdGNoRXZlbnQiLCJDdXN0b21FdmVudCIsInJlc29sdmVkQ29uZmlnc0luY2x1ZGluZ1N0YXRpY09uZXMiLCJzdGF0aWNDb21wcyIsInJlZHVjZSIsImFjYyIsImN1cnIiLCJ1c2VSZXNvbHZlZFZpZGVvQ29uZmlnIiwicHJlZmVycmVkQ29tcG9zaXRpb25JZCIsInVzZVZpZGVvIiwic2VsZWN0ZWQiLCJyZXNvbHZlZCIsImZyYW1lIiwicGxheWluZyIsInBsYXliYWNrUmF0ZSIsInJvb3RJZCIsImltcGVyYXRpdmVQbGF5aW5nIiwic2V0UGxheWJhY2tSYXRlIiwiYXVkaW9BbmRWaWRlb1RhZ3MiLCJzZXRGcmFtZSIsInNldFBsYXlpbmciLCJtYWtlS2V5IiwidGltZSIsImxvY2FsU3RvcmFnZSIsInNldEl0ZW0iLCJnZXRJdGVtIiwib2JqIiwicmVtb3Rpb25faW5pdGlhbEZyYW1lIiwidmlkZW9Db25maWciLCJzdGF0ZSIsInVuY2xhbXBlZCIsIk1hdGgiLCJtaW4iLCJ1c2VDb250ZXh0OSIsImNyZWF0ZUNvbnRleHQxMCIsImpzeDciLCJDYW5Vc2VSZW1vdGlvbkhvb2tzIiwiQ2FuVXNlUmVtb3Rpb25Ib29rc1Byb3ZpZGVyIiwidXNlQ29udGV4dDgiLCJ1c2VNZW1vOCIsInVzZVVuc2FmZVZpZGVvQ29uZmlnIiwiY3R4V2lkdGgiLCJjdHhIZWlnaHQiLCJjdHhEdXJhdGlvbiIsInZpZGVvIiwidXNlVmlkZW9Db25maWciLCJ1c2VDb250ZXh0MTEiLCJ1c2VNZW1vOSIsInVzZUNvbnRleHQxMCIsInVzZUN1cnJlbnRGcmFtZSIsImNhblVzZVJlbW90aW9uSG9va3MiLCJjb250ZXh0T2Zmc2V0IiwiY3VtdWxhdGVkRnJvbSIsInJlbGF0aXZlRnJvbSIsImpzeDgiLCJGcmVlemUiLCJmcmFtZVRvRnJlZXplIiwiYWN0aXZlIiwiaXNBY3RpdmUiLCJ0aW1lbGluZUNvbnRleHQiLCJ0aW1lbGluZVZhbHVlIiwianN4OSIsIlJlZ3VsYXJTZXF1ZW5jZVJlZkZvcndhcmRpbmdGdW5jdGlvbiIsImZyb20iLCJJbmZpbml0eSIsInNob3dJblRpbWVsaW5lIiwiX3JlbW90aW9uSW50ZXJuYWxMb29wRGlzcGxheSIsImxvb3BEaXNwbGF5IiwiX3JlbW90aW9uSW50ZXJuYWxTdGFjayIsIl9yZW1vdGlvbkludGVybmFsUHJlbW91bnREaXNwbGF5IiwicHJlbW91bnREaXNwbGF5IiwibGF5b3V0IiwiU3RyaW5nIiwicmFuZG9tIiwicGFyZW50U2VxdWVuY2UiLCJhYnNvbHV0ZUZyYW1lIiwicGFyZW50U2VxdWVuY2VEdXJhdGlvbiIsImFjdHVhbER1cmF0aW9uSW5GcmFtZXMiLCJtYXgiLCJwcmVtb3VudGluZyIsIl9yZW1vdGlvbkludGVybmFsSXNQcmVtb3VudGluZyIsImNvbnRleHRWYWx1ZSIsInBhcmVudEZyb20iLCJ0aW1lbGluZUNsaXBOYW1lIiwiZHVyYXRpb24iLCJkaXNwbGF5TmFtZSIsInBhcmVudCIsImVuZFRocmVzaG9sZCIsImNlaWwiLCJjb250ZW50Iiwic3R5bGVJZlRoZXJlIiwiZGVmYXVsdFN0eWxlIiwiaXNTZXF1ZW5jZUhpZGRlbiIsImNsYXNzTmFtZSIsIlJlZ3VsYXJTZXF1ZW5jZSIsIlByZW1vdW50ZWRTZXF1ZW5jZVJlZkZvcndhcmRpbmdGdW5jdGlvbiIsInBhc3NlZFN0eWxlIiwicHJlbW91bnRGb3IiLCJvdGhlclByb3BzIiwicHJlbW91bnRpbmdBY3RpdmUiLCJvcGFjaXR5IiwicG9pbnRlckV2ZW50cyIsIlNlcXVlbmNlIiwiUHJlbW91bnRlZFNlcXVlbmNlIiwiU2VxdWVuY2VSZWZGb3J3YXJkaW5nRnVuY3Rpb24iLCJ1c2VDb250ZXh0MTMiLCJ1c2VFZmZlY3Q2IiwidXNlU3RhdGU3IiwiY3JlYXRlQ29udGV4dDExIiwidXNlQ2FsbGJhY2s0IiwidXNlTGF5b3V0RWZmZWN0MiIsInVzZU1lbW8xMSIsInVzZVN0YXRlNiIsInZhbGlkYXRlQXJ0aWZhY3RGaWxlbmFtZSIsImZpbGVuYW1lIiwidHJpbSIsIm1hdGNoIiwidmFsaWRhdGVDb250ZW50IiwiVWludDhBcnJheSIsInZhbGlkYXRlUmVuZGVyQXNzZXQiLCJhcnRpZmFjdCIsImpzeDEwIiwiUmVuZGVyQXNzZXRNYW5hZ2VyIiwicmVnaXN0ZXJSZW5kZXJBc3NldCIsInVucmVnaXN0ZXJSZW5kZXJBc3NldCIsInJlbmRlckFzc2V0cyIsIlJlbmRlckFzc2V0TWFuYWdlclByb3ZpZGVyIiwic2V0UmVuZGVyQXNzZXRzIiwicmVuZGVyQXNzZXQiLCJhc3NldHMiLCJhc3N0cyIsImEiLCJyZW1vdGlvbl9jb2xsZWN0QXNzZXRzIiwiQXJ0aWZhY3QiLCJidG9hIiwiVGV4dERlY29kZXIiLCJkZWNvZGUiLCJiaW5hcnkiLCJmb3J3YXJkUmVmNSIsInVzZUNhbGxiYWNrOSIsInVzZUNvbnRleHQyMyIsImdldEFic29sdXRlU3JjIiwicmVsYXRpdmVTcmMiLCJVUkwiLCJvcmlnaW4iLCJocmVmIiwiY2FsY3VsYXRlTG9vcER1cmF0aW9uIiwiZW5kQXQiLCJtZWRpYUR1cmF0aW9uIiwic3RhcnRGcm9tIiwiYWN0dWFsRHVyYXRpb24iLCJmbG9vciIsImNhbmNlbFJlbmRlciIsImlzRXJyb3JMaWtlIiwicmVtb3Rpb25fY2FuY2VsbGVkRXJyb3IiLCJSZWFjdDgiLCJjcmVhdGVDb250ZXh0MTIiLCJ1c2VNZW1vMTIiLCJqc3gxMSIsIkxvb3BDb250ZXh0IiwidXNlTG9vcCIsIkxvb3AiLCJ0aW1lcyIsImN1cnJlbnRGcmFtZSIsImNvbXBEdXJhdGlvbiIsIm1heFRpbWVzIiwiYWN0dWFsVGltZXMiLCJtYXhGcmFtZSIsIml0ZXJhdGlvbiIsInN0YXJ0IiwibnVtYmVyT2ZUaW1lcyIsInN0YXJ0T2Zmc2V0IiwibG9vcENvbnRleHQiLCJ1c2VDb250ZXh0MTQiLCJjcmVhdGVDb250ZXh0MTMiLCJ1c2VFZmZlY3Q3IiwidXNlU3RhdGU4IiwianN4MTIiLCJQcmVsb2FkQ29udGV4dCIsInByZWxvYWRzIiwidXBkYXRlcnMiLCJzZXRQcmVsb2FkcyIsInVwZGF0ZXIiLCJmb3JFYWNoIiwidSIsIlByZWZldGNoUHJvdmlkZXIiLCJfcHJlbG9hZHMiLCJfc2V0UHJlbG9hZHMiLCJ1cGRhdGVyRnVuY3Rpb24iLCJ1c2VQcmVsb2FkIiwic3JjIiwicHJlbG9hZHMyIiwiYmxvYlRvQmFzZTY0IiwiYmxvYiIsInJlYWRlciIsIkZpbGVSZWFkZXIiLCJQcm9taXNlIiwicmVzb2x2ZSIsInJlamVjdCIsIm9ubG9hZCIsImRhdGFVcmwiLCJvbmVycm9yIiwicmVhZEFzRGF0YVVSTCIsImdldEJsb2JGcm9tUmVhZGVyIiwiY29udGVudFR5cGUiLCJjb250ZW50TGVuZ3RoIiwib25Qcm9ncmVzcyIsInJlY2VpdmVkTGVuZ3RoIiwiY2h1bmtzIiwiZG9uZSIsInJlYWQiLCJsZW5ndGgiLCJsb2FkZWRCeXRlcyIsInRvdGFsQnl0ZXMiLCJjaHVua3NBbGwiLCJjaHVuayIsIkJsb2IiLCJwcmVmZXRjaCIsIm1ldGhvZCIsImZyZWUiLCJ3YWl0VW50aWxEb25lIiwiY2FuY2VsZWQiLCJvYmplY3RVcmwiLCJyZXMiLCJyZWoiLCJjYW5CZUFib3J0ZWQiLCJmZXRjaCIsIm9rIiwic3RhdHVzIiwiaGVhZGVyQ29udGVudFR5cGUiLCJoZWFkZXJzIiwiaGFzUHJvcGVyQ29udGVudFR5cGUiLCJib2R5IiwiZ2V0UmVhZGVyIiwicGFyc2VJbnQiLCJidWYiLCJhY3R1YWxCbG9iIiwiY3JlYXRlT2JqZWN0VVJMIiwidXJsIiwicCIsInJldm9rZU9iamVjdFVSTCIsImNvcHkiLCJlIiwidmFsaWRhdGVNZWRpYVByb3BzIiwidm9sdW1lIiwidmFsaWRhdGVTdGFydEZyb21Qcm9wcyIsImNyZWF0ZUNvbnRleHQxNCIsInVzZU1lbW8xMyIsInVzZVJlZHVjZXIiLCJqc3gxMyIsImR1cmF0aW9uUmVkdWNlciIsImFjdGlvbiIsImFic29sdXRlU3JjIiwiZHVyYXRpb25JblNlY29uZHMiLCJEdXJhdGlvbnNDb250ZXh0IiwiZHVyYXRpb25zIiwic2V0RHVyYXRpb25zIiwiRHVyYXRpb25zQ29udGV4dFByb3ZpZGVyIiwiZm9yd2FyZFJlZjMiLCJ1c2VDb250ZXh0MjEiLCJ1c2VFZmZlY3QxNiIsInVzZUltcGVyYXRpdmVIYW5kbGUzIiwidXNlTWVtbzIwIiwidXNlUmVmOCIsInVzZVN0YXRlMTQiLCJtdWxiZXJyeTMyIiwidCIsImltdWwiLCJoYXNoQ29kZSIsInN0ciIsImkiLCJjaHIiLCJoYXNoIiwiY2hhckNvZGVBdCIsInNlZWQiLCJkdW1teSIsInVzZUNvbnRleHQxNiIsInVzZUVmZmVjdDgiLCJ1c2VNZW1vMTQiLCJ1c2VTdGF0ZTkiLCJ1c2VDb250ZXh0MTUiLCJ1c2VNZWRpYVN0YXJ0c0F0Iiwic3RhcnRzQXQiLCJ1c2VGcmFtZUZvclZvbHVtZVByb3AiLCJiZWhhdmlvciIsImxvb3AiLCJnZXRBc3NldERpc3BsYXlOYW1lIiwidGVzdCIsInNwbGl0dGVkIiwiZmxhdCIsInBsYXlBbmRIYW5kbGVOb3RBbGxvd2VkRXJyb3IiLCJtZWRpYVJlZiIsIm1lZGlhVHlwZSIsIm9uQXV0b1BsYXlFcnJvciIsInByb20iLCJwbGF5IiwibG9nIiwibXV0ZWQiLCJldmFsdWF0ZVZvbHVtZSIsIm1lZGlhVm9sdW1lIiwiYWxsb3dBbXBsaWZpY2F0aW9uRHVyaW5nUmVuZGVyIiwibWF4Vm9sdW1lIiwiZXZhbHVhdGVkIiwiZGlkV2FybjIiLCJ3YXJuT25jZTIiLCJ1c2VNZWRpYUluVGltZWxpbmUiLCJhY3R1YWxGcm9tIiwiaW5pdGlhbFZvbHVtZSIsImRvZXNWb2x1bWVDaGFuZ2UiLCJ2b2x1bWVzIiwiQXJyYXkiLCJmaWxsIiwiTk9ERV9FTlYiLCJzdGFydE1lZGlhRnJvbSIsInRhZyIsInVzZUNhbGxiYWNrNyIsInVzZUNvbnRleHQxOCIsInVzZUVmZmVjdDEyIiwidXNlUmVmNiIsInVzZUNhbGxiYWNrNiIsInVzZU1lbW8xNyIsInVzZVJlZjMiLCJ1c2VDb250ZXh0MTciLCJ1c2VNZW1vMTYiLCJSZWFjdDExIiwidXNlQ2FsbGJhY2s1IiwidXNlRWZmZWN0OSIsInVzZU1lbW8xNSIsInVzZVJlZjIiLCJ1c2VTdGF0ZTEwIiwianN4MTQiLCJ1c2VCdWZmZXJNYW5hZ2VyIiwiYmxvY2tzIiwic2V0QmxvY2tzIiwib25CdWZmZXJpbmdDYWxsYmFja3MiLCJzZXRPbkJ1ZmZlcmluZ0NhbGxiYWNrcyIsIm9uUmVzdW1lQ2FsbGJhY2tzIiwic2V0T25SZXN1bWVDYWxsYmFja3MiLCJidWZmZXJpbmciLCJhZGRCbG9jayIsImJsb2NrIiwiYiIsInVuYmxvY2siLCJuZXdBcnIiLCJieCIsImxpc3RlbkZvckJ1ZmZlcmluZyIsImNhbGxiYWNrIiwicmVtb3ZlIiwiY2IiLCJsaXN0ZW5Gb3JSZXN1bWUiLCJCdWZmZXJpbmdDb250ZXh0UmVhY3QiLCJCdWZmZXJpbmdQcm92aWRlciIsImJ1ZmZlck1hbmFnZXIiLCJ1c2VJc1BsYXllckJ1ZmZlcmluZyIsImlzQnVmZmVyaW5nIiwic2V0SXNCdWZmZXJpbmciLCJvbkJ1ZmZlciIsIm9uUmVzdW1lIiwidXNlQnVmZmVyU3RhdGUiLCJidWZmZXIiLCJkZWxheVBsYXliYWNrIiwidXNlQnVmZmVyVW50aWxGaXJzdEZyYW1lIiwib25WYXJpYWJsZUZwc1ZpZGVvRGV0ZWN0ZWQiLCJwYXVzZVdoZW5CdWZmZXJpbmciLCJidWZmZXJpbmdSZWYiLCJidWZmZXJVbnRpbEZpcnN0RnJhbWUiLCJyZXF1ZXN0ZWRUaW1lIiwicmVxdWVzdFZpZGVvRnJhbWVDYWxsYmFjayIsInBsYXliYWNrIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsIm9uY2UiLCJvbkVuZGVkT3JQYXVzZU9yQ2FuUGxheSIsImluZm8iLCJkaWZmZXJlbmNlRnJvbVJlcXVlc3RlZCIsImFicyIsIm1lZGlhVGltZSIsImFkZEV2ZW50TGlzdGVuZXIiLCJ1c2VFZmZlY3QxMCIsInVzZVN0YXRlMTEiLCJ1c2VNZWRpYUJ1ZmZlcmluZyIsInNob3VsZEJ1ZmZlciIsImlzUHJlbW91bnRpbmciLCJjbGVhbnVwRm5zIiwiY2xlYW51cCIsImZuIiwib25XYWl0aW5nIiwib25DYW5QbGF5IiwiaW5pdCIsIm9uRXJyb3IiLCJyZWFkeVN0YXRlIiwiSEFWRV9GVVRVUkVfREFUQSIsIm5hdmlnYXRvciIsInVzZXJBZ2VudCIsImxvYWQiLCJ1c2VFZmZlY3QxMSIsInVzZVJlZjQiLCJ1c2VSZXF1ZXN0VmlkZW9DYWxsYmFja1RpbWUiLCJsYXN0U2VlayIsImN1cnJlbnRUaW1lIiwidmlkZW9UYWciLCJjYW5jZWwiLCJyZXF1ZXN0IiwiZGlmZmVyZW5jZSIsImRpZmZlcmVuY2VUb0xhc3RTZWVrIiwiY2FuY2VsVmlkZW9GcmFtZUNhbGxiYWNrIiwiaW50ZXJwb2xhdGVGdW5jdGlvbiIsImlucHV0IiwiaW5wdXRSYW5nZSIsIm91dHB1dFJhbmdlIiwiZXh0cmFwb2xhdGVMZWZ0IiwiZXh0cmFwb2xhdGVSaWdodCIsImVhc2luZyIsImlucHV0TWluIiwiaW5wdXRNYXgiLCJvdXRwdXRNaW4iLCJvdXRwdXRNYXgiLCJyYW5nZSIsImZpbmRSYW5nZSIsImNoZWNrVmFsaWRJbnB1dFJhbmdlIiwiYXJyIiwiY2hlY2tJbmZpbml0ZVJhbmdlIiwiaW50ZXJwb2xhdGUiLCJudW0iLCJnZXRFeHBlY3RlZE1lZGlhRnJhbWVVbmNvcnJlY3RlZCIsImdldE1lZGlhVGltZSIsImV4cGVjdGVkRnJhbWUiLCJtc1BlckZyYW1lIiwidXNlUmVmNSIsInRvU2Vjb25kcyIsInJvdW5kIiwiaXNJb3NTYWZhcmkiLCJpc0lwYWRJUG9kSVBob25lIiwiaXNBcHBsZVdlYktpdCIsImlzSU9TU2FmYXJpQW5kQmxvYiIsImFjdHVhbFNyYyIsImdldFZpZGVvRnJhZ21lbnRTdGFydCIsImdldFZpZGVvRnJhZ21lbnRFbmQiLCJhcHBlbmRWaWRlb0ZyYWdtZW50IiwiZXhpc3RpbmdIYXNoIiwid2l0aFN0YXJ0SGFzaCIsImlzU3Vic2V0T2ZEdXJhdGlvbiIsInByZXZTdGFydEZyb20iLCJuZXdTdGFydEZyb20iLCJwcmV2RHVyYXRpb24iLCJuZXdEdXJhdGlvbiIsInByZXZpb3VzRnJvbSIsIm5ld0Zyb20iLCJwcmV2aW91c0VuZCIsIm5ld0VuZCIsInVzZUFwcGVuZFZpZGVvRnJhZ21lbnQiLCJpbml0aWFsQWN0dWFsU3JjIiwiaW5pdGlhbEFjdHVhbEZyb20iLCJpbml0aWFsRHVyYXRpb24iLCJhY3R1YWxGcm9tUmVmIiwiYXBwZW5kZWQiLCJhbHJlYWR5V2FybmVkIiwid2FybkFib3V0Tm9uU2Vla2FibGVNZWRpYSIsInNlZWthYmxlIiwiZW5kIiwibXNnIiwiREVGQVVMVF9BQ0NFUFRBQkxFX1RJTUVTSElGVCIsInNlZWsiLCJ0aW1lVG9TZXQiLCJ0b0ZpeGVkIiwidXNlTWVkaWFQbGF5YmFjayIsImxvY2FsUGxheWJhY2tSYXRlIiwib25seVdhcm5Gb3JNZWRpYVNlZWtpbmdFcnJvciIsImFjY2VwdGFibGVUaW1lc2hpZnQiLCJkZWJ1Z1NlZWtpbmciLCJnbG9iYWxQbGF5YmFja1JhdGUiLCJtZWRpYVN0YXJ0c0F0IiwibGFzdFNlZWtEdWVUb1NoaWZ0IiwiaXNWYXJpYWJsZUZwc1ZpZGVvTWFwIiwiZGVzaXJlZFVuY2xhbXBlZFRpbWUiLCJpc01lZGlhVGFnQnVmZmVyaW5nIiwiYWNjZXB0YWJsZVRpbWVTaGlmdEJ1dExlc3NUaGFuRHVyYXRpb24iLCJpc1BsYXllckJ1ZmZlcmluZyIsInBhdXNlIiwiaXNNZWRpYVRhZ0J1ZmZlcmluZ09yU3RhbGxlZCIsInRhZ05hbWUiLCJwbGF5YmFja1JhdGVUb1NldCIsInNob3VsZEJlVGltZSIsIm1lZGlhVGFnVGltZSIsInJ2Y1RpbWUiLCJpc1ZhcmlhYmxlRnBzVmlkZW8iLCJ0aW1lU2hpZnRNZWRpYVRhZyIsInRpbWVTaGlmdFJ2Y1RhZyIsInRpbWVTaGlmdCIsInBhdXNlZCIsImlzVGltZSIsInNlZWtUaHJlc2hvbGQiLCJtYWtlc1NlbnNlVG9TZWVrIiwiaXNTb21ldGhpbmdFbHNlQnVmZmVyaW5nIiwiZW5kZWQiLCJ1c2VFZmZlY3QxMyIsInVzZVN0YXRlMTIiLCJ1c2VNZWRpYVRhZ1ZvbHVtZSIsImFjdHVhbFZvbHVtZSIsInNldEFjdHVhbFZvbHVtZSIsIm9uQ2hhbmdlIiwidXNlRWZmZWN0MTQiLCJGTE9BVElOR19QT0lOVF9FUlJPUl9USFJFU0hPTEQiLCJpc0FwcHJveGltYXRlbHlUaGVTYW1lIiwibnVtMSIsIm51bTIiLCJ1c2VTeW5jVm9sdW1lV2l0aE1lZGlhVGFnIiwidm9sdW1lUHJvcEZyYW1lIiwidXNlclByZWZlcnJlZFZvbHVtZSIsImNyZWF0ZUNvbnRleHQxNSIsInVzZUNvbnRleHQxOSIsInVzZU1lbW8xOCIsIk1lZGlhVm9sdW1lQ29udGV4dCIsIm1lZGlhTXV0ZWQiLCJTZXRNZWRpYVZvbHVtZUNvbnRleHQiLCJzZXRNZWRpYU11dGVkIiwic2V0TWVkaWFWb2x1bWUiLCJ1c2VNZWRpYVZvbHVtZVN0YXRlIiwidXNlTWVkaWFNdXRlZFN0YXRlIiwiUmVhY3QxMiIsImNyZWF0ZUNvbnRleHQxNiIsImNyZWF0ZVJlZjIiLCJ1c2VDYWxsYmFjazgiLCJ1c2VDb250ZXh0MjAiLCJ1c2VFZmZlY3QxNSIsInVzZU1lbW8xOSIsInVzZVJlZjciLCJ1c2VTdGF0ZTEzIiwianN4MTUiLCJqc3hzIiwiRU1QVFlfQVVESU8iLCJjb21wYXJlUHJvcHMiLCJvYmoxIiwib2JqMiIsImtleXNBIiwic29ydCIsImtleXNCIiwiZGlkUHJvcENoYW5nZSIsIm5ld1Byb3AiLCJwcmV2UHJvcCIsInRvU3RyaW5nIiwiU2hhcmVkQXVkaW9Db250ZXh0IiwiU2hhcmVkQXVkaW9Db250ZXh0UHJvdmlkZXIiLCJudW1iZXJPZkF1ZGlvVGFncyIsImF1ZGlvcyIsImluaXRpYWxOdW1iZXJPZkF1ZGlvVGFncyIsInJlZnMiLCJ0YWtlbkF1ZGlvcyIsInJlcmVuZGVyQXVkaW9zIiwicmVnaXN0ZXJBdWRpbyIsImF1ZCIsImF1ZGlvSWQiLCJmb3VuZCIsImZpcnN0RnJlZUF1ZGlvIiwiZmluZEluZGV4IiwiY2xvbmVkIiwibmV3RWxlbSIsImVsIiwidW5yZWdpc3RlckF1ZGlvIiwiaW5kZXgiLCJ1cGRhdGVBdWRpbyIsImNoYW5nZWQiLCJwcmV2QSIsInBsYXlBbGxBdWRpb3MiLCJyZXNldEF1ZGlvIiwicHJlbG9hZCIsInVzZVNoYXJlZEF1ZGlvIiwiZWxlbSIsImVmZmVjdFRvVXNlIiwidXNlSW5zZXJ0aW9uRWZmZWN0IiwiZG9jdW1lbnQiLCJqc3gxNiIsIkF1ZGlvRm9yRGV2ZWxvcG1lbnRGb3J3YXJkUmVmRnVuY3Rpb24iLCJpbml0aWFsU2hvdWxkUHJlTW91bnRBdWRpb0VsZW1lbnRzIiwic2hvdWxkUHJlTW91bnRBdWRpb1RhZ3MiLCJvbkR1cmF0aW9uIiwiYWNjZXB0YWJsZVRpbWVTaGlmdEluU2Vjb25kcyIsIl9yZW1vdGlvbkludGVybmFsTmVlZHNEdXJhdGlvbkNhbGN1bGF0aW9uIiwiX3JlbW90aW9uSW50ZXJuYWxOYXRpdmVMb29wUGFzc2VkIiwiX3JlbW90aW9uRGVidWdTZWVraW5nIiwibG9vcFZvbHVtZUN1cnZlQmVoYXZpb3IiLCJuYXRpdmVQcm9wcyIsInByZWxvYWRlZFNyYyIsInRpbWVsaW5lSWQiLCJwcm9wc1RvUGFzcyIsImF1ZGlvUmVmIiwiY3VycmVudE9uRHVyYXRpb25DYWxsYmFjayIsIm9uTG9hZGVkTWV0YWRhdGEiLCJBdWRpb0ZvclByZXZpZXciLCJmb3J3YXJkUmVmNCIsInVzZUNvbnRleHQyMiIsInVzZUVmZmVjdDE3IiwidXNlSW1wZXJhdGl2ZUhhbmRsZTQiLCJ1c2VMYXlvdXRFZmZlY3QzIiwidXNlTWVtbzIxIiwidXNlUmVmOSIsInJlbW90aW9uX3JlbmRlclJlYWR5IiwiaGFuZGxlcyIsInJlbW90aW9uX2RlbGF5UmVuZGVyVGltZW91dHMiLCJERUxBWV9SRU5ERVJfQ0FMTFNUQUNLX1RPS0VOIiwiREVMQVlfUkVOREVSX1JFVFJJRVNfTEVGVCIsIkRFTEFZX1JFTkRFUl9SRVRSWV9UT0tFTiIsImRlZmF1bHRUaW1lb3V0IiwiZGVsYXlSZW5kZXIiLCJsYWJlbCIsImhhbmRsZSIsImNhbGxlZCIsInRpbWVvdXRUb1VzZSIsInRpbWVvdXRJbk1pbGxpc2Vjb25kcyIsInJldHJpZXNMZWZ0IiwicmV0cmllcyIsInJlbW90aW9uX2F0dGVtcHQiLCJ0aW1lb3V0Iiwic2V0VGltZW91dCIsImNvbnRpbnVlUmVuZGVyIiwiaCIsImNsZWFyVGltZW91dCIsImpzeDE3IiwiQXVkaW9Gb3JSZW5kZXJpbmdSZWZGb3J3YXJkaW5nRnVuY3Rpb24iLCJ2b2x1bWVQcm9wIiwidG9uZUZyZXF1ZW5jeSIsImRlbGF5UmVuZGVyUmV0cmllcyIsImRlbGF5UmVuZGVyVGltZW91dEluTWlsbGlzZWNvbmRzIiwicmVtb3Rpb25fYXVkaW9FbmFibGVkIiwibWVkaWFGcmFtZSIsImF1ZGlvU3RhcnRGcmFtZSIsIm5lZWRzVG9SZW5kZXJBdWRpb1RhZyIsIm5ld0hhbmRsZSIsImRpZExvYWQiLCJBdWRpb0ZvclJlbmRlcmluZyIsImpzeDE4IiwiQXVkaW9SZWZGb3J3YXJkaW5nRnVuY3Rpb24iLCJhdWRpb0NvbnRleHQiLCJwcm9wc090aGVyVGhhbkxvb3AiLCJlbnZpcm9ubWVudCIsImN1cnJlbnRUYXJnZXQiLCJlcnJNZXNzYWdlIiwiZHVyYXRpb25GZXRjaGVkIiwiQXVkaW8iLCJzdGFydEZyb21GcmFtZU5vIiwiZW5kQXRGcmFtZU5vIiwiU3VzcGVuc2UiLCJ1c2VDb250ZXh0MjUiLCJ1c2VFZmZlY3QxOSIsInVzZU1lbW8yNCIsImNyZWF0ZVBvcnRhbCIsImNyZWF0ZUNvbnRleHQxNyIsInVzZUNvbnRleHQyNCIsInVzZUVmZmVjdDE4IiwidXNlTWVtbzIyIiwiZ2V0UmVnZXgiLCJpc0ZvbGRlck5hbWVWYWxpZCIsInZhbGlkYXRlRm9sZGVyTmFtZSIsImludmFsaWRGb2xkZXJOYW1lRXJyb3JNZXNzYWdlIiwianN4MTkiLCJGb2xkZXJDb250ZXh0IiwiZm9sZGVyTmFtZSIsInBhcmVudE5hbWUiLCJGb2xkZXIiLCJwYXJlbnROYW1lQXJyIiwianN4MjAiLCJqc3hzMiIsInJvdGF0ZSIsInRyYW5zZm9ybSIsIklDT05fU0laRSIsImNvbG9yIiwiZm9udFNpemUiLCJmb250RmFtaWx5IiwiY29udGFpbmVyIiwianVzdGlmeUNvbnRlbnQiLCJhbGlnbkl0ZW1zIiwiTG9hZGluZyIsInZpZXdCb3giLCJzdHJva2UiLCJzdHJva2VXaWR0aCIsInN0cm9rZUxpbmVqb2luIiwiZCIsIl9wb3J0YWxOb2RlIiwicG9ydGFsTm9kZSIsImNvbnRhaW5lck5vZGUiLCJhcHBlbmRDaGlsZCIsIlJlYWN0MTYiLCJ1c2VNZW1vMjMiLCJ1c2VMYXp5Q29tcG9uZW50IiwiY29tcFByb3BzIiwibGF6eSIsImxhenlDb21wb25lbnQiLCJkZWZhdWx0IiwiZ2V0UmVnZXgyIiwiaXNDb21wb3NpdGlvbklkVmFsaWQiLCJ2YWxpZGF0ZUNvbXBvc2l0aW9uSWQiLCJpbnZhbGlkQ29tcG9zaXRpb25FcnJvck1lc3NhZ2UiLCJ2YWxpZGF0ZURlZmF1bHRBbmRJbnB1dFByb3BzIiwiaXNBcnJheSIsImpzeDIxIiwiQ2xpcENvbXBvc2l0aW9uIiwiY2xpcFBhdGgiLCJGYWxsYmFjayIsImZhbGxiYWNrIiwiQ29tcG9zaXRpb24iLCJzY2hlbWEiLCJjYW5Vc2VDb21wb3NpdGlvbiIsInBhcmVudEZvbGRlck5hbWUiLCJDb21wIiwiUmVhY3QxOCIsInVzZUNhbGxiYWNrMTAiLCJ1c2VJbXBlcmF0aXZlSGFuZGxlNSIsInVzZU1lbW8yNSIsInVzZVJlZjEwIiwidXNlU3RhdGUxNSIsImpzeDIyIiwiY29tcG9zaXRpb25zUmVmIiwiQ29tcG9zaXRpb25NYW5hZ2VyUHJvdmlkZXIiLCJzZXRDb21wb3NpdGlvbnMiLCJjdXJyZW50Y29tcG9zaXRpb25zUmVmIiwic2V0Rm9sZGVycyIsInVwZGF0ZUNvbXBvc2l0aW9ucyIsInVwZGF0ZUNvbXBzIiwiY29tcHMiLCJ1cGRhdGVkIiwiY29tcCIsInNsaWNlIiwicHJldkZvbGRlcnMiLCJnZXRDb21wb3NpdGlvbnMiLCJuZXdEZWZhdWx0UHJvcHMiLCJhQTEiLCJhQTIiLCJjYWxjQmV6aWVyIiwiYVQiLCJnZXRTbG9wZSIsImJpbmFyeVN1YmRpdmlkZSIsImFYIiwiX2FBIiwiX2FCIiwibVgxIiwibVgyIiwiY3VycmVudFgiLCJjdXJyZW50VCIsImFBIiwiYUIiLCJTVUJESVZJU0lPTl9QUkVDSVNJT04iLCJTVUJESVZJU0lPTl9NQVhfSVRFUkFUSU9OUyIsIm5ld3RvblJhcGhzb25JdGVyYXRlIiwiX2FHdWVzc1QiLCJhR3Vlc3NUIiwiTkVXVE9OX0lURVJBVElPTlMiLCJjdXJyZW50U2xvcGUiLCJiZXppZXIiLCJtWTEiLCJtWTIiLCJzYW1wbGVWYWx1ZXMiLCJmbG9hdDMyQXJyYXlTdXBwb3J0ZWQiLCJGbG9hdDMyQXJyYXkiLCJrU3BsaW5lVGFibGVTaXplIiwia1NhbXBsZVN0ZXBTaXplIiwiZ2V0VEZvclgiLCJpbnRlcnZhbFN0YXJ0IiwiY3VycmVudFNhbXBsZSIsImxhc3RTYW1wbGUiLCJkaXN0IiwiZ3Vlc3NGb3JUIiwiaW5pdGlhbFNsb3BlIiwiTkVXVE9OX01JTl9TTE9QRSIsIkVhc2luZyIsInN0ZXAwIiwibiIsInN0ZXAxIiwibGluZWFyIiwiZWFzZSIsInF1YWQiLCJjdWJpYyIsInBvbHkiLCJzaW4iLCJjb3MiLCJQSSIsImNpcmNsZSIsInNxcnQiLCJleHAiLCJlbGFzdGljIiwiYm91bmNpbmVzcyIsImJhY2siLCJib3VuY2UiLCJ0Ml8iLCJ0MiIsIngxIiwieTEiLCJ4MiIsInkyIiwiaW4iLCJvdXQiLCJpbk91dCIsIkVOQUJMRV9WNV9CUkVBS0lOR19DSEFOR0VTIiwid2FybmVkU2VydmVyIiwid2FybmVkUGxheWVyIiwid2FyblNlcnZlck9uY2UiLCJ3YXJuUGxheWVyT25jZSIsImdldFN0YXRpY0ZpbGVzIiwicmVtb3Rpb25fc3RhdGljRmlsZXMiLCJmb3J3YXJkUmVmNiIsInVzZUNhbGxiYWNrMTEiLCJ1c2VTdGF0ZTE2IiwianN4MjMiLCJJRnJhbWVSZWZGb3J3YXJkaW5nIiwib25Mb2FkIiwicHJvcHMyIiwiZGlkR2V0RXJyb3IiLCJJRnJhbWUiLCJmb3J3YXJkUmVmNyIsInVzZUNhbGxiYWNrMTIiLCJ1c2VDb250ZXh0MjYiLCJ1c2VJbXBlcmF0aXZlSGFuZGxlNiIsInVzZUxheW91dEVmZmVjdDQiLCJ1c2VSZWYxMSIsImV4cG9uZW50aWFsQmFja29mZiIsImVycm9yQ291bnQiLCJqc3gyNCIsIkltZ1JlZkZvcndhcmRpbmciLCJtYXhSZXRyaWVzIiwicGF1c2VXaGVuTG9hZGluZyIsIm9uSW1hZ2VGcmFtZSIsImltYWdlUmVmIiwiZXJyb3JzIiwicmV0cnlJbiIsImN1cnJlbnRTcmMiLCJuZXdTcmMiLCJyZW1vdmVBdHRyaWJ1dGUiLCJzZXRBdHRyaWJ1dGUiLCJiYWNrb2ZmIiwidW5tb3VudGVkIiwib25Db21wbGV0ZSIsIm5ld0ltZyIsIkltYWdlIiwiY29tcGxldGUiLCJJbWciLCJleHBvcnRzX2RlZmF1bHRfY3NzIiwibWFrZURlZmF1bHRQcmV2aWV3Q1NTIiwiaW5qZWN0Q1NTIiwiT0ZGVEhSRUFEX1ZJREVPX0NMQVNTX05BTUUiLCJpbmplY3RlZCIsImNzcyIsImhlYWQiLCJnZXRFbGVtZW50c0J5VGFnTmFtZSIsImNyZWF0ZVRleHROb2RlIiwicHJlcGVuZCIsInNjb3BlIiwiYmFja2dyb3VuZENvbG9yIiwiUkVNT1RJT05fU1RVRElPX0NPTlRBSU5FUl9FTEVNRU5UIiwiZ2V0UHJldmlld0RvbUVsZW1lbnQiLCJnZXRFbGVtZW50QnlJZCIsIlJvb3QiLCJsaXN0ZW5lcnMiLCJyZWdpc3RlclJvb3QiLCJsIiwiZ2V0Um9vdCIsIndhaXRGb3JSb290IiwidXNlRWZmZWN0MjAiLCJ1c2VMYXlvdXRFZmZlY3Q1IiwidXNlTWVtbzI2IiwidXNlUmVmMTIiLCJ1c2VTdGF0ZTE3IiwianN4MjUiLCJSZW1vdGlvblJvb3QiLCJyZW1vdGlvblJvb3RJZCIsInNldEZhc3RSZWZyZXNoZXMiLCJyZW1vdGlvbl9zZXRGcmFtZSIsImYiLCJhdHRlbXB0IiwiYXN5bmNVcGRhdGUiLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJ0aW1lbGluZUNvbnRleHRWYWx1ZSIsInNldFRpbWVsaW5lQ29udGV4dFZhbHVlIiwibm9uY2VDb250ZXh0IiwiY291bnRlciIsIl9fd2VicGFja19tb2R1bGVfXyIsImhvdCIsImFkZFN0YXR1c0hhbmRsZXIiLCJnZXRFbnZWYXJpYWJsZXMiLCJyZW1vdGlvbl9lbnZWYXJpYWJsZXMiLCJzZXR1cEVudlZhcmlhYmxlcyIsIlJlYWN0MjIiLCJjcmVhdGVDb250ZXh0MTgiLCJDdXJyZW50U2NhbGVDb250ZXh0IiwiUHJldmlld1NpemVDb250ZXh0Iiwic2V0U2l6ZSIsInNpemUiLCJ0cmFuc2xhdGlvbiIsImNhbGN1bGF0ZVNjYWxlIiwiY2FudmFzU2l6ZSIsInByZXZpZXdTaXplIiwiaGVpZ2h0UmF0aW8iLCJ3aWR0aFJhdGlvIiwicmF0aW8iLCJ1c2VDdXJyZW50U2NhbGUiLCJoYXNDb250ZXh0Iiwiem9vbUNvbnRleHQiLCJjb25maWciLCJkb250VGhyb3dJZk91dHNpZGVPZlJlbW90aW9uIiwic2NhbGUiLCJXQVRDSF9SRU1PVElPTl9TVEFUSUNfRklMRVMiLCJ3YXRjaFN0YXRpY0ZpbGUiLCJmaWxlTmFtZSIsIndpdGhvdXRTdGF0aWNCYXNlIiwid2l0aG91dExlYWRpbmdTbGFzaCIsInByZXZGaWxlRGF0YSIsImZpbGUiLCJjaGVja0ZpbGUiLCJldmVudCIsInN0YXRpY0ZpbGVzIiwiZGV0YWlsIiwiZmlsZXMiLCJuZXdGaWxlRGF0YSIsImxhc3RNb2RpZmllZCIsIlJlYWN0MjMiLCJ1c2VNZW1vMjciLCJ1c2VSZW1vdGlvbkNvbnRleHRzIiwiY29tcG9zaXRpb25NYW5hZ2VyQ3R4Iiwic2V0VGltZWxpbmVDb250ZXh0IiwiY2FuVXNlUmVtb3Rpb25Ib29rc0NvbnRleHQiLCJuYXRpdmVMYXllcnNDb250ZXh0IiwicHJlbG9hZENvbnRleHQiLCJyZXNvbHZlQ29tcG9zaXRpb25Db250ZXh0IiwicmVuZGVyQXNzZXRNYW5hZ2VyQ29udGV4dCIsInNlcXVlbmNlTWFuYWdlckNvbnRleHQiLCJidWZmZXJNYW5hZ2VyQ29udGV4dCIsImpzeDI2IiwiUmVtb3Rpb25Db250ZXh0UHJvdmlkZXIiLCJjb250ZXh0cyIsIkludGVybmFscyIsIlRpbWVsaW5lIiwiQ1NTVXRpbHMiLCJjYWxsIiwiYXJncyIsImdldE1hdGNoZXJzIiwiY2FjaGVkTWF0Y2hlcnMiLCJyZ2IiLCJyZ2JhIiwiaHNsIiwiaHNsYSIsImhleDMiLCJoZXg0IiwiaGV4NSIsImhleDYiLCJoZXg4IiwiUmVnRXhwIiwiTlVNQkVSIiwiUEVSQ0VOVEFHRSIsImh1ZTJyZ2IiLCJxIiwiaHNsVG9SZ2IiLCJnIiwiYjIiLCJwYXJzZTI1NSIsImludCIsInBhcnNlMzYwIiwicGFyc2VGbG9hdCIsInBhcnNlMSIsInBhcnNlUGVyY2VudGFnZSIsIm5vcm1hbGl6ZUNvbG9yIiwibWF0Y2hlcnMiLCJleGVjIiwiY29sb3JOYW1lcyIsInByb2Nlc3NDb2xvciIsIm5vcm1hbGl6ZWRDb2xvciIsInRyYW5zcGFyZW50IiwiYWxpY2VibHVlIiwiYW50aXF1ZXdoaXRlIiwiYXF1YSIsImFxdWFtYXJpbmUiLCJhenVyZSIsImJlaWdlIiwiYmlzcXVlIiwiYmxhY2siLCJibGFuY2hlZGFsbW9uZCIsImJsdWUiLCJibHVldmlvbGV0IiwiYnJvd24iLCJidXJseXdvb2QiLCJidXJudHNpZW5uYSIsImNhZGV0Ymx1ZSIsImNoYXJ0cmV1c2UiLCJjaG9jb2xhdGUiLCJjb3JhbCIsImNvcm5mbG93ZXJibHVlIiwiY29ybnNpbGsiLCJjcmltc29uIiwiY3lhbiIsImRhcmtibHVlIiwiZGFya2N5YW4iLCJkYXJrZ29sZGVucm9kIiwiZGFya2dyYXkiLCJkYXJrZ3JlZW4iLCJkYXJrZ3JleSIsImRhcmtraGFraSIsImRhcmttYWdlbnRhIiwiZGFya29saXZlZ3JlZW4iLCJkYXJrb3JhbmdlIiwiZGFya29yY2hpZCIsImRhcmtyZWQiLCJkYXJrc2FsbW9uIiwiZGFya3NlYWdyZWVuIiwiZGFya3NsYXRlYmx1ZSIsImRhcmtzbGF0ZWdyYXkiLCJkYXJrc2xhdGVncmV5IiwiZGFya3R1cnF1b2lzZSIsImRhcmt2aW9sZXQiLCJkZWVwcGluayIsImRlZXBza3libHVlIiwiZGltZ3JheSIsImRpbWdyZXkiLCJkb2RnZXJibHVlIiwiZmlyZWJyaWNrIiwiZmxvcmFsd2hpdGUiLCJmb3Jlc3RncmVlbiIsImZ1Y2hzaWEiLCJnYWluc2Jvcm8iLCJnaG9zdHdoaXRlIiwiZ29sZCIsImdvbGRlbnJvZCIsImdyYXkiLCJncmVlbiIsImdyZWVueWVsbG93IiwiZ3JleSIsImhvbmV5ZGV3IiwiaG90cGluayIsImluZGlhbnJlZCIsImluZGlnbyIsIml2b3J5Iiwia2hha2kiLCJsYXZlbmRlciIsImxhdmVuZGVyYmx1c2giLCJsYXduZ3JlZW4iLCJsZW1vbmNoaWZmb24iLCJsaWdodGJsdWUiLCJsaWdodGNvcmFsIiwibGlnaHRjeWFuIiwibGlnaHRnb2xkZW5yb2R5ZWxsb3ciLCJsaWdodGdyYXkiLCJsaWdodGdyZWVuIiwibGlnaHRncmV5IiwibGlnaHRwaW5rIiwibGlnaHRzYWxtb24iLCJsaWdodHNlYWdyZWVuIiwibGlnaHRza3libHVlIiwibGlnaHRzbGF0ZWdyYXkiLCJsaWdodHNsYXRlZ3JleSIsImxpZ2h0c3RlZWxibHVlIiwibGlnaHR5ZWxsb3ciLCJsaW1lIiwibGltZWdyZWVuIiwibGluZW4iLCJtYWdlbnRhIiwibWFyb29uIiwibWVkaXVtYXF1YW1hcmluZSIsIm1lZGl1bWJsdWUiLCJtZWRpdW1vcmNoaWQiLCJtZWRpdW1wdXJwbGUiLCJtZWRpdW1zZWFncmVlbiIsIm1lZGl1bXNsYXRlYmx1ZSIsIm1lZGl1bXNwcmluZ2dyZWVuIiwibWVkaXVtdHVycXVvaXNlIiwibWVkaXVtdmlvbGV0cmVkIiwibWlkbmlnaHRibHVlIiwibWludGNyZWFtIiwibWlzdHlyb3NlIiwibW9jY2FzaW4iLCJuYXZham93aGl0ZSIsIm5hdnkiLCJvbGRsYWNlIiwib2xpdmUiLCJvbGl2ZWRyYWIiLCJvcmFuZ2UiLCJvcmFuZ2VyZWQiLCJvcmNoaWQiLCJwYWxlZ29sZGVucm9kIiwicGFsZWdyZWVuIiwicGFsZXR1cnF1b2lzZSIsInBhbGV2aW9sZXRyZWQiLCJwYXBheWF3aGlwIiwicGVhY2hwdWZmIiwicGVydSIsInBpbmsiLCJwbHVtIiwicG93ZGVyYmx1ZSIsInB1cnBsZSIsInJlYmVjY2FwdXJwbGUiLCJyZWQiLCJyb3N5YnJvd24iLCJyb3lhbGJsdWUiLCJzYWRkbGVicm93biIsInNhbG1vbiIsInNhbmR5YnJvd24iLCJzZWFncmVlbiIsInNlYXNoZWxsIiwic2llbm5hIiwic2lsdmVyIiwic2t5Ymx1ZSIsInNsYXRlYmx1ZSIsInNsYXRlZ3JheSIsInNsYXRlZ3JleSIsInNub3ciLCJzcHJpbmdncmVlbiIsInN0ZWVsYmx1ZSIsInRhbiIsInRlYWwiLCJ0aGlzdGxlIiwidG9tYXRvIiwidHVycXVvaXNlIiwidmlvbGV0Iiwid2hlYXQiLCJ3aGl0ZSIsIndoaXRlc21va2UiLCJ5ZWxsb3ciLCJ5ZWxsb3dncmVlbiIsImMyIiwicmdiYUNvbG9yIiwiYWxwaGEiLCJpbnRlcnBvbGF0ZUNvbG9yc1JHQiIsImNvbG9ycyIsImEyIiwidW5yb3VuZGVkIiwiaW50ZXJwb2xhdGVDb2xvcnMiLCJwcm9jZXNzZWRPdXRwdXRSYW5nZSIsInZhbGlkYXRlRnJhbWUiLCJSYW5nZUVycm9yIiwiZ2V0T2ZmdGhyZWFkVmlkZW9Tb3VyY2UiLCJ0b25lTWFwcGVkIiwicmVtb3Rpb25fcHJveHlQb3J0IiwiQ2hpbGRyZW4iLCJmb3J3YXJkUmVmOCIsInVzZU1lbW8yOCIsIlJlYWN0MjQiLCJmbGF0dGVuQ2hpbGRyZW4iLCJjaGlsZHJlbkFycmF5IiwidG9BcnJheSIsImZsYXRDaGlsZHJlbiIsImNoaWxkIiwiRnJhZ21lbnQiLCJjb25jYXQiLCJSZWFjdDI1IiwiY3JlYXRlQ29udGV4dDE5IiwianN4MjciLCJJc0luc2lkZVNlcmllc0NvbnRleHQiLCJJc0luc2lkZVNlcmllc0NvbnRhaW5lciIsIklzTm90SW5zaWRlU2VyaWVzUHJvdmlkZXIiLCJ1c2VSZXF1aXJlVG9CZUluc2lkZVNlcmllcyIsImlzSW5zaWRlU2VyaWVzIiwianN4MjgiLCJTZXJpZXNTZXF1ZW5jZVJlZkZvcndhcmRpbmdGdW5jdGlvbiIsIl9yZWYiLCJTZXJpZXNTZXF1ZW5jZSIsIlNlcmllcyIsImNoaWxkcmVuVmFsdWUiLCJzdGFydEZyYW1lIiwiZmxhdHRlbmVkQ2hpbGRyZW4iLCJjYXN0ZWRDaGlsZCIsImRlYnVnSW5mbyIsImR1cmF0aW9uSW5GcmFtZXNQcm9wIiwiX2NoaWxkcmVuIiwicGFzc2VkUHJvcHMiLCJvZmZzZXQiLCJjdXJyZW50U3RhcnRGcmFtZSIsInZhbGlkYXRlU3ByaW5nRHVyYXRpb24iLCJkdXIiLCJhZHZhbmNlIiwiYW5pbWF0aW9uIiwibm93IiwidG9WYWx1ZSIsImxhc3RUaW1lc3RhbXAiLCJ2ZWxvY2l0eSIsImRlbHRhVGltZSIsImRhbXBpbmciLCJtIiwibWFzcyIsImsiLCJzdGlmZm5lc3MiLCJjYWNoZUtleSIsImFkdmFuY2VDYWNoZSIsInYwIiwieDAiLCJ6ZXRhIiwib21lZ2EwIiwib21lZ2ExIiwic2luMSIsImNvczEiLCJ1bmRlckRhbXBlZEVudmVsb3BlIiwidW5kZXJEYW1wZWRGcmFnMSIsInVuZGVyRGFtcGVkUG9zaXRpb24iLCJ1bmRlckRhbXBlZFZlbG9jaXR5IiwiY3JpdGljYWxseURhbXBlZEVudmVsb3BlIiwiY3JpdGljYWxseURhbXBlZFBvc2l0aW9uIiwiY3JpdGljYWxseURhbXBlZFZlbG9jaXR5IiwiYW5pbWF0aW9uTm9kZSIsInByZXZQb3NpdGlvbiIsInNwcmluZ0NhbGN1bGF0aW9uIiwidG8iLCJvdmVyc2hvb3RDbGFtcGluZyIsImNhbGN1bGF0aW9uQ2FjaGUiLCJmcmFtZUNsYW1wZWQiLCJ1bmV2ZW5SZXN0IiwiZGVmYXVsdFNwcmluZ0NvbmZpZyIsIm1lYXN1cmVTcHJpbmciLCJ0aHJlc2hvbGQiLCJjYWNoZSIsImhhcyIsImZpbmlzaGVkRnJhbWUiLCJjYWxjIiwiY2FsY0RpZmZlcmVuY2UiLCJzcHJpbmciLCJwYXNzZWRGcmFtZSIsInBhc3NlZER1cmF0aW9uSW5GcmFtZXMiLCJkdXJhdGlvblJlc3RUaHJlc2hvbGQiLCJkZWxheSIsInJldmVyc2UiLCJuZWVkc1RvQ2FsY3VsYXRlTmF0dXJhbER1cmF0aW9uIiwibmF0dXJhbER1cmF0aW9uIiwibmF0dXJhbER1cmF0aW9uR2V0dGVyIiwicmV2ZXJzZVByb2Nlc3NlZCIsImRlbGF5UHJvY2Vzc2VkIiwiZHVyYXRpb25Qcm9jZXNzZWQiLCJzcHIiLCJpbm5lcjIiLCJpbnRlcnBvbGF0ZWQiLCJSZWFjdDI3IiwiU3RpbGwiLCJ1c2VDYWxsYmFjazE0IiwidXNlQ2FsbGJhY2sxMyIsInVzZUNvbnRleHQyNyIsInVzZUVmZmVjdDIxIiwidXNlTGF5b3V0RWZmZWN0NiIsInVzZU1lbW8yOSIsInVzZVN0YXRlMTgiLCJqc3gyOSIsIk9mZnRocmVhZFZpZGVvRm9yUmVuZGVyaW5nIiwib25WaWRlb0ZyYW1lIiwidm9sdW1lUHJvcHNGcmFtZSIsImltYWdlU3JjIiwic2V0SW1hZ2VTcmMiLCJyZW1vdGlvbl92aWRlb0VuYWJsZWQiLCJleGVjdXRlIiwianNvbiIsImNsZWFuZWRVcEVycm9yTWVzc2FnZSIsImNhdXNlIiwib25FcnIiLCJpbWciLCJmb3J3YXJkUmVmOSIsInVzZUNvbnRleHQyOCIsInVzZUVmZmVjdDIzIiwidXNlSW1wZXJhdGl2ZUhhbmRsZTciLCJ1c2VNZW1vMzAiLCJ1c2VSZWYxMyIsInVzZVN0YXRlMTkiLCJ1c2VFZmZlY3QyMiIsInVzZUVtaXRWaWRlb0ZyYW1lIiwianN4MzAiLCJWaWRlb0ZvckRldmVsb3BtZW50UmVmRm9yd2FyZGluZ0Z1bmN0aW9uIiwidmlkZW9SZWYiLCJhY2NlcHRhYmxlVGltZVNoaWZ0IiwiY3Jvc3NPcmlnaW4iLCJlcnJvckhhbmRsZXIiLCJjb2RlIiwiY3Jvc3NPcmlnaW5WYWx1ZSIsInBsYXlzSW5saW5lIiwiZGlzYWJsZVJlbW90ZVBsYXliYWNrIiwiVmlkZW9Gb3JQcmV2aWV3IiwianN4MzEiLCJPZmZ0aHJlYWRWaWRlbyIsImltYWdlRm9ybWF0Iiwid2l0aG91dFRyYW5zcGFyZW50IiwiZm9yd2FyZFJlZjExIiwidXNlQ2FsbGJhY2sxNSIsInVzZUNvbnRleHQzMCIsImZvcndhcmRSZWYxMCIsInVzZUNvbnRleHQyOSIsInVzZUVmZmVjdDI0IiwidXNlSW1wZXJhdGl2ZUhhbmRsZTgiLCJ1c2VMYXlvdXRFZmZlY3Q3IiwidXNlTWVtbzMxIiwidXNlUmVmMTQiLCJyb3VuZFRvNkNvbW1hcyIsInNlZWtUb1RpbWUiLCJkZXNpcmVkVGltZSIsImNhbmNlbFNlZWtlZCIsIm1ldGFkYXRhIiwiZGlzcGxheUluIiwiZXhwZWN0ZWREaXNwbGF5VGltZSIsIndhaXRGb3JTZWVrZWRFdmVudCIsIm9uRG9uZSIsIndhaXQiLCJzZWVrVG9UaW1lTXVsdGlwbGVVbnRpbFJpZ2h0IiwiY3VycmVudENhbmNlbCIsImZpcnN0U2VlayIsInNlZWtlZFRvIiwic2lnbiIsIm5ld1NlZWsiLCJuZXdUaW1lIiwibmV3RGlmZmVyZW5jZSIsInRoaXJkU2VlayIsImpzeDMyIiwiVmlkZW9Gb3JSZW5kZXJpbmdGb3J3YXJkRnVuY3Rpb24iLCJsb2FkZWREYXRhSGFuZGxlciIsImVuZGVkSGFuZGxlciIsInNlZWsyIiwiVmlkZW9Gb3JSZW5kZXJpbmciLCJqc3gzMyIsIlZpZGVvRm9yd2FyZGluZ0Z1bmN0aW9uIiwiVmlkZW8iLCJFeHBlcmltZW50YWwiLCJwcm94eU9iaiIsIkNvbmZpZyIsInByb3AiLCJleGl0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/remotion/dist/esm/index.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/remotion/dist/esm/no-react.mjs":
/*!*****************************************************!*\
  !*** ./node_modules/remotion/dist/esm/no-react.mjs ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   NoReactInternals: () => (/* binding */ NoReactInternals),\n/* harmony export */   interpolate: () => (/* binding */ interpolate),\n/* harmony export */   random: () => (/* binding */ random)\n/* harmony export */ });\n// src/interpolate.ts\nfunction interpolateFunction(input, inputRange, outputRange, options) {\n  const { extrapolateLeft, extrapolateRight, easing } = options;\n  let result = input;\n  const [inputMin, inputMax] = inputRange;\n  const [outputMin, outputMax] = outputRange;\n  if (result < inputMin) {\n    if (extrapolateLeft === \"identity\") {\n      return result;\n    }\n    if (extrapolateLeft === \"clamp\") {\n      result = inputMin;\n    } else if (extrapolateLeft === \"wrap\") {\n      const range = inputMax - inputMin;\n      result = ((result - inputMin) % range + range) % range + inputMin;\n    } else if (extrapolateLeft === \"extend\") {\n    }\n  }\n  if (result > inputMax) {\n    if (extrapolateRight === \"identity\") {\n      return result;\n    }\n    if (extrapolateRight === \"clamp\") {\n      result = inputMax;\n    } else if (extrapolateRight === \"wrap\") {\n      const range = inputMax - inputMin;\n      result = ((result - inputMin) % range + range) % range + inputMin;\n    } else if (extrapolateRight === \"extend\") {\n    }\n  }\n  if (outputMin === outputMax) {\n    return outputMin;\n  }\n  result = (result - inputMin) / (inputMax - inputMin);\n  result = easing(result);\n  result = result * (outputMax - outputMin) + outputMin;\n  return result;\n}\nfunction findRange(input, inputRange) {\n  let i;\n  for (i = 1;i < inputRange.length - 1; ++i) {\n    if (inputRange[i] >= input) {\n      break;\n    }\n  }\n  return i - 1;\n}\nfunction checkValidInputRange(arr) {\n  for (let i = 1;i < arr.length; ++i) {\n    if (!(arr[i] > arr[i - 1])) {\n      throw new Error(`inputRange must be strictly monotonically increasing but got [${arr.join(\",\")}]`);\n    }\n  }\n}\nfunction checkInfiniteRange(name, arr) {\n  if (arr.length < 2) {\n    throw new Error(name + \" must have at least 2 elements\");\n  }\n  for (const element of arr) {\n    if (typeof element !== \"number\") {\n      throw new Error(`${name} must contain only numbers`);\n    }\n    if (!Number.isFinite(element)) {\n      throw new Error(`${name} must contain only finite numbers, but got [${arr.join(\",\")}]`);\n    }\n  }\n}\nfunction interpolate(input, inputRange, outputRange, options) {\n  if (typeof input === \"undefined\") {\n    throw new Error(\"input can not be undefined\");\n  }\n  if (typeof inputRange === \"undefined\") {\n    throw new Error(\"inputRange can not be undefined\");\n  }\n  if (typeof outputRange === \"undefined\") {\n    throw new Error(\"outputRange can not be undefined\");\n  }\n  if (inputRange.length !== outputRange.length) {\n    throw new Error(\"inputRange (\" + inputRange.length + \") and outputRange (\" + outputRange.length + \") must have the same length\");\n  }\n  checkInfiniteRange(\"inputRange\", inputRange);\n  checkInfiniteRange(\"outputRange\", outputRange);\n  checkValidInputRange(inputRange);\n  const easing = options?.easing ?? ((num) => num);\n  let extrapolateLeft = \"extend\";\n  if (options?.extrapolateLeft !== undefined) {\n    extrapolateLeft = options.extrapolateLeft;\n  }\n  let extrapolateRight = \"extend\";\n  if (options?.extrapolateRight !== undefined) {\n    extrapolateRight = options.extrapolateRight;\n  }\n  if (typeof input !== \"number\") {\n    throw new TypeError(\"Cannot interpolate an input which is not a number\");\n  }\n  const range = findRange(input, inputRange);\n  return interpolateFunction(input, [inputRange[range], inputRange[range + 1]], [outputRange[range], outputRange[range + 1]], {\n    easing,\n    extrapolateLeft,\n    extrapolateRight\n  });\n}\n// src/random.ts\nfunction mulberry32(a) {\n  let t = a + 1831565813;\n  t = Math.imul(t ^ t >>> 15, t | 1);\n  t ^= t + Math.imul(t ^ t >>> 7, t | 61);\n  return ((t ^ t >>> 14) >>> 0) / 4294967296;\n}\nfunction hashCode(str) {\n  let i = 0;\n  let chr = 0;\n  let hash = 0;\n  for (i = 0;i < str.length; i++) {\n    chr = str.charCodeAt(i);\n    hash = (hash << 5) - hash + chr;\n    hash |= 0;\n  }\n  return hash;\n}\nvar random = (seed, dummy) => {\n  if (dummy !== undefined) {\n    throw new TypeError(\"random() takes only one argument\");\n  }\n  if (seed === null) {\n    return Math.random();\n  }\n  if (typeof seed === \"string\") {\n    return mulberry32(hashCode(seed));\n  }\n  if (typeof seed === \"number\") {\n    return mulberry32(seed * 10000000000);\n  }\n  throw new Error(\"random() argument must be a number or a string\");\n};\n// src/truthy.ts\nfunction truthy(value) {\n  return Boolean(value);\n}\n\n// src/delay-render.ts\nif (typeof window !== \"undefined\") {\n  window.remotion_renderReady = false;\n}\nif (typeof window !== \"undefined\") {\n  window.remotion_delayRenderTimeouts = {};\n}\nvar DELAY_RENDER_CALLSTACK_TOKEN = \"The delayRender was called:\";\nvar DELAY_RENDER_RETRIES_LEFT = \"Retries left: \";\nvar DELAY_RENDER_RETRY_TOKEN = \"- Rendering the frame will be retried.\";\n\n// src/static-file.ts\nvar problematicCharacters = {\n  \"%3A\": \":\",\n  \"%2F\": \"/\",\n  \"%3F\": \"?\",\n  \"%23\": \"#\",\n  \"%5B\": \"[\",\n  \"%5D\": \"]\",\n  \"%40\": \"@\",\n  \"%21\": \"!\",\n  \"%24\": \"$\",\n  \"%26\": \"&\",\n  \"%27\": \"'\",\n  \"%28\": \"(\",\n  \"%29\": \")\",\n  \"%2A\": \"*\",\n  \"%2B\": \"+\",\n  \"%2C\": \",\",\n  \"%3B\": \";\"\n};\nvar didWarn = {};\nvar warnOnce = (message) => {\n  if (didWarn[message]) {\n    return;\n  }\n  console.warn(message);\n  didWarn[message] = true;\n};\nvar includesHexOfUnsafeChar = (path) => {\n  for (const key of Object.keys(problematicCharacters)) {\n    if (path.includes(key)) {\n      return { containsHex: true, hexCode: key };\n    }\n  }\n  return { containsHex: false };\n};\nvar trimLeadingSlash = (path) => {\n  if (path.startsWith(\"/\")) {\n    return trimLeadingSlash(path.substring(1));\n  }\n  return path;\n};\nvar inner = (path) => {\n  if (typeof window !== \"undefined\" && window.remotion_staticBase) {\n    if (path.startsWith(window.remotion_staticBase)) {\n      throw new Error(`The value \"${path}\" is already prefixed with the static base ${window.remotion_staticBase}. You don't need to call staticFile() on it.`);\n    }\n    return `${window.remotion_staticBase}/${trimLeadingSlash(path)}`;\n  }\n  return `/${trimLeadingSlash(path)}`;\n};\nvar encodeBySplitting = (path) => {\n  const splitBySlash = path.split(\"/\");\n  const encodedArray = splitBySlash.map((element) => {\n    return encodeURIComponent(element);\n  });\n  const merged = encodedArray.join(\"/\");\n  return merged;\n};\nvar staticFile = (path) => {\n  if (path.startsWith(\"http://\") || path.startsWith(\"https://\")) {\n    throw new TypeError(`staticFile() does not support remote URLs - got \"${path}\". Instead, pass the URL without wrapping it in staticFile(). See: https://remotion.dev/docs/staticfile-remote-urls`);\n  }\n  if (path.startsWith(\"..\") || path.startsWith(\"./\")) {\n    throw new TypeError(`staticFile() does not support relative paths - got \"${path}\". Instead, pass the name of a file that is inside the public/ folder. See: https://remotion.dev/docs/staticfile-relative-paths`);\n  }\n  if (path.startsWith(\"/Users\") || path.startsWith(\"/home\") || path.startsWith(\"/tmp\") || path.startsWith(\"/etc\") || path.startsWith(\"/opt\") || path.startsWith(\"/var\") || path.startsWith(\"C:\") || path.startsWith(\"D:\") || path.startsWith(\"E:\")) {\n    throw new TypeError(`staticFile() does not support absolute paths - got \"${path}\". Instead, pass the name of a file that is inside the public/ folder. See: https://remotion.dev/docs/staticfile-relative-paths`);\n  }\n  if (path.startsWith(\"public/\")) {\n    throw new TypeError(`Do not include the public/ prefix when using staticFile() - got \"${path}\". See: https://remotion.dev/docs/staticfile-relative-paths`);\n  }\n  const includesHex = includesHexOfUnsafeChar(path);\n  if (includesHex.containsHex) {\n    warnOnce(`WARNING: You seem to pass an already encoded path (path contains ${includesHex.hexCode}). Since Remotion 4.0, the encoding is done by staticFile() itself. You may want to remove a encodeURIComponent() wrapping.`);\n  }\n  const preprocessed = encodeBySplitting(path);\n  const preparsed = inner(preprocessed);\n  if (!preparsed.startsWith(\"/\")) {\n    return `/${preparsed}`;\n  }\n  return preparsed;\n};\n\n// src/input-props-serialization.ts\nvar DATE_TOKEN = \"remotion-date:\";\nvar FILE_TOKEN = \"remotion-file:\";\nvar serializeJSONWithDate = ({\n  data,\n  indent,\n  staticBase\n}) => {\n  let customDateUsed = false;\n  let customFileUsed = false;\n  let mapUsed = false;\n  let setUsed = false;\n  try {\n    const serializedString = JSON.stringify(data, function(key, value) {\n      const item = this[key];\n      if (item instanceof Date) {\n        customDateUsed = true;\n        return `${DATE_TOKEN}${item.toISOString()}`;\n      }\n      if (item instanceof Map) {\n        mapUsed = true;\n        return value;\n      }\n      if (item instanceof Set) {\n        setUsed = true;\n        return value;\n      }\n      if (typeof item === \"string\" && staticBase !== null && item.startsWith(staticBase)) {\n        customFileUsed = true;\n        return `${FILE_TOKEN}${item.replace(staticBase + \"/\", \"\")}`;\n      }\n      return value;\n    }, indent);\n    return { serializedString, customDateUsed, customFileUsed, mapUsed, setUsed };\n  } catch (err) {\n    throw new Error(\"Could not serialize the passed input props to JSON: \" + err.message);\n  }\n};\nvar deserializeJSONWithCustomFields = (data) => {\n  return JSON.parse(data, (_, value) => {\n    if (typeof value === \"string\" && value.startsWith(DATE_TOKEN)) {\n      return new Date(value.replace(DATE_TOKEN, \"\"));\n    }\n    if (typeof value === \"string\" && value.startsWith(FILE_TOKEN)) {\n      return staticFile(value.replace(FILE_TOKEN, \"\"));\n    }\n    return value;\n  });\n};\n\n// src/interpolate-colors.ts\nfunction call(...args) {\n  return \"\\\\(\\\\s*(\" + args.join(\")\\\\s*,\\\\s*(\") + \")\\\\s*\\\\)\";\n}\nfunction getMatchers() {\n  const cachedMatchers = {\n    rgb: undefined,\n    rgba: undefined,\n    hsl: undefined,\n    hsla: undefined,\n    hex3: undefined,\n    hex4: undefined,\n    hex5: undefined,\n    hex6: undefined,\n    hex8: undefined\n  };\n  if (cachedMatchers.rgb === undefined) {\n    cachedMatchers.rgb = new RegExp(\"rgb\" + call(NUMBER, NUMBER, NUMBER));\n    cachedMatchers.rgba = new RegExp(\"rgba\" + call(NUMBER, NUMBER, NUMBER, NUMBER));\n    cachedMatchers.hsl = new RegExp(\"hsl\" + call(NUMBER, PERCENTAGE, PERCENTAGE));\n    cachedMatchers.hsla = new RegExp(\"hsla\" + call(NUMBER, PERCENTAGE, PERCENTAGE, NUMBER));\n    cachedMatchers.hex3 = /^#([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/;\n    cachedMatchers.hex4 = /^#([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/;\n    cachedMatchers.hex6 = /^#([0-9a-fA-F]{6})$/;\n    cachedMatchers.hex8 = /^#([0-9a-fA-F]{8})$/;\n  }\n  return cachedMatchers;\n}\nfunction hue2rgb(p, q, t) {\n  if (t < 0) {\n    t += 1;\n  }\n  if (t > 1) {\n    t -= 1;\n  }\n  if (t < 1 / 6) {\n    return p + (q - p) * 6 * t;\n  }\n  if (t < 1 / 2) {\n    return q;\n  }\n  if (t < 2 / 3) {\n    return p + (q - p) * (2 / 3 - t) * 6;\n  }\n  return p;\n}\nfunction hslToRgb(h, s, l) {\n  const q = l < 0.5 ? l * (1 + s) : l + s - l * s;\n  const p = 2 * l - q;\n  const r = hue2rgb(p, q, h + 1 / 3);\n  const g = hue2rgb(p, q, h);\n  const b = hue2rgb(p, q, h - 1 / 3);\n  return Math.round(r * 255) << 24 | Math.round(g * 255) << 16 | Math.round(b * 255) << 8;\n}\nfunction parse255(str) {\n  const int = Number.parseInt(str, 10);\n  if (int < 0) {\n    return 0;\n  }\n  if (int > 255) {\n    return 255;\n  }\n  return int;\n}\nfunction parse360(str) {\n  const int = Number.parseFloat(str);\n  return (int % 360 + 360) % 360 / 360;\n}\nfunction parse1(str) {\n  const num = Number.parseFloat(str);\n  if (num < 0) {\n    return 0;\n  }\n  if (num > 1) {\n    return 255;\n  }\n  return Math.round(num * 255);\n}\nfunction parsePercentage(str) {\n  const int = Number.parseFloat(str);\n  if (int < 0) {\n    return 0;\n  }\n  if (int > 100) {\n    return 1;\n  }\n  return int / 100;\n}\nfunction normalizeColor(color) {\n  const matchers = getMatchers();\n  let match;\n  if (matchers.hex6) {\n    if (match = matchers.hex6.exec(color)) {\n      return Number.parseInt(match[1] + \"ff\", 16) >>> 0;\n    }\n  }\n  if (colorNames[color] !== undefined) {\n    return colorNames[color];\n  }\n  if (matchers.rgb) {\n    if (match = matchers.rgb.exec(color)) {\n      return (parse255(match[1]) << 24 | parse255(match[2]) << 16 | parse255(match[3]) << 8 | 255) >>> 0;\n    }\n  }\n  if (matchers.rgba) {\n    if (match = matchers.rgba.exec(color)) {\n      return (parse255(match[1]) << 24 | parse255(match[2]) << 16 | parse255(match[3]) << 8 | parse1(match[4])) >>> 0;\n    }\n  }\n  if (matchers.hex3) {\n    if (match = matchers.hex3.exec(color)) {\n      return Number.parseInt(match[1] + match[1] + match[2] + match[2] + match[3] + match[3] + \"ff\", 16) >>> 0;\n    }\n  }\n  if (matchers.hex8) {\n    if (match = matchers.hex8.exec(color)) {\n      return Number.parseInt(match[1], 16) >>> 0;\n    }\n  }\n  if (matchers.hex4) {\n    if (match = matchers.hex4.exec(color)) {\n      return Number.parseInt(match[1] + match[1] + match[2] + match[2] + match[3] + match[3] + match[4] + match[4], 16) >>> 0;\n    }\n  }\n  if (matchers.hsl) {\n    if (match = matchers.hsl.exec(color)) {\n      return (hslToRgb(parse360(match[1]), parsePercentage(match[2]), parsePercentage(match[3])) | 255) >>> 0;\n    }\n  }\n  if (matchers.hsla) {\n    if (match = matchers.hsla.exec(color)) {\n      return (hslToRgb(parse360(match[1]), parsePercentage(match[2]), parsePercentage(match[3])) | parse1(match[4])) >>> 0;\n    }\n  }\n  throw new Error(`invalid color string ${color} provided`);\n}\nfunction processColor(color) {\n  const normalizedColor = normalizeColor(color);\n  return (normalizedColor << 24 | normalizedColor >>> 8) >>> 0;\n}\nvar NUMBER = \"[-+]?\\\\d*\\\\.?\\\\d+\";\nvar PERCENTAGE = NUMBER + \"%\";\nvar colorNames = {\n  transparent: 0,\n  aliceblue: 4042850303,\n  antiquewhite: 4209760255,\n  aqua: 16777215,\n  aquamarine: 2147472639,\n  azure: 4043309055,\n  beige: 4126530815,\n  bisque: 4293182719,\n  black: 255,\n  blanchedalmond: 4293643775,\n  blue: 65535,\n  blueviolet: 2318131967,\n  brown: 2771004159,\n  burlywood: 3736635391,\n  burntsienna: 3934150143,\n  cadetblue: 1604231423,\n  chartreuse: 2147418367,\n  chocolate: 3530104575,\n  coral: 4286533887,\n  cornflowerblue: 1687547391,\n  cornsilk: 4294499583,\n  crimson: 3692313855,\n  cyan: 16777215,\n  darkblue: 35839,\n  darkcyan: 9145343,\n  darkgoldenrod: 3095792639,\n  darkgray: 2846468607,\n  darkgreen: 6553855,\n  darkgrey: 2846468607,\n  darkkhaki: 3182914559,\n  darkmagenta: 2332068863,\n  darkolivegreen: 1433087999,\n  darkorange: 4287365375,\n  darkorchid: 2570243327,\n  darkred: 2332033279,\n  darksalmon: 3918953215,\n  darkseagreen: 2411499519,\n  darkslateblue: 1211993087,\n  darkslategray: 793726975,\n  darkslategrey: 793726975,\n  darkturquoise: 13554175,\n  darkviolet: 2483082239,\n  deeppink: 4279538687,\n  deepskyblue: 12582911,\n  dimgray: 1768516095,\n  dimgrey: 1768516095,\n  dodgerblue: 512819199,\n  firebrick: 2988581631,\n  floralwhite: 4294635775,\n  forestgreen: 579543807,\n  fuchsia: 4278255615,\n  gainsboro: 3705462015,\n  ghostwhite: 4177068031,\n  gold: 4292280575,\n  goldenrod: 3668254975,\n  gray: 2155905279,\n  green: 8388863,\n  greenyellow: 2919182335,\n  grey: 2155905279,\n  honeydew: 4043305215,\n  hotpink: 4285117695,\n  indianred: 3445382399,\n  indigo: 1258324735,\n  ivory: 4294963455,\n  khaki: 4041641215,\n  lavender: 3873897215,\n  lavenderblush: 4293981695,\n  lawngreen: 2096890111,\n  lemonchiffon: 4294626815,\n  lightblue: 2916673279,\n  lightcoral: 4034953471,\n  lightcyan: 3774873599,\n  lightgoldenrodyellow: 4210742015,\n  lightgray: 3553874943,\n  lightgreen: 2431553791,\n  lightgrey: 3553874943,\n  lightpink: 4290167295,\n  lightsalmon: 4288707327,\n  lightseagreen: 548580095,\n  lightskyblue: 2278488831,\n  lightslategray: 2005441023,\n  lightslategrey: 2005441023,\n  lightsteelblue: 2965692159,\n  lightyellow: 4294959359,\n  lime: 16711935,\n  limegreen: 852308735,\n  linen: 4210091775,\n  magenta: 4278255615,\n  maroon: 2147483903,\n  mediumaquamarine: 1724754687,\n  mediumblue: 52735,\n  mediumorchid: 3126187007,\n  mediumpurple: 2473647103,\n  mediumseagreen: 1018393087,\n  mediumslateblue: 2070474495,\n  mediumspringgreen: 16423679,\n  mediumturquoise: 1221709055,\n  mediumvioletred: 3340076543,\n  midnightblue: 421097727,\n  mintcream: 4127193855,\n  mistyrose: 4293190143,\n  moccasin: 4293178879,\n  navajowhite: 4292783615,\n  navy: 33023,\n  oldlace: 4260751103,\n  olive: 2155872511,\n  olivedrab: 1804477439,\n  orange: 4289003775,\n  orangered: 4282712319,\n  orchid: 3664828159,\n  palegoldenrod: 4008225535,\n  palegreen: 2566625535,\n  paleturquoise: 2951671551,\n  palevioletred: 3681588223,\n  papayawhip: 4293907967,\n  peachpuff: 4292524543,\n  peru: 3448061951,\n  pink: 4290825215,\n  plum: 3718307327,\n  powderblue: 2967529215,\n  purple: 2147516671,\n  rebeccapurple: 1714657791,\n  red: 4278190335,\n  rosybrown: 3163525119,\n  royalblue: 1097458175,\n  saddlebrown: 2336560127,\n  salmon: 4202722047,\n  sandybrown: 4104413439,\n  seagreen: 780883967,\n  seashell: 4294307583,\n  sienna: 2689740287,\n  silver: 3233857791,\n  skyblue: 2278484991,\n  slateblue: 1784335871,\n  slategray: 1887473919,\n  slategrey: 1887473919,\n  snow: 4294638335,\n  springgreen: 16744447,\n  steelblue: 1182971135,\n  tan: 3535047935,\n  teal: 8421631,\n  thistle: 3636451583,\n  tomato: 4284696575,\n  turquoise: 1088475391,\n  violet: 4001558271,\n  wheat: 4125012991,\n  white: 4294967295,\n  whitesmoke: 4126537215,\n  yellow: 4294902015,\n  yellowgreen: 2597139199\n};\n\n// src/v5-flag.ts\nvar ENABLE_V5_BREAKING_CHANGES = false;\n\n// src/validate-frame.ts\nvar validateFrame = ({\n  allowFloats,\n  durationInFrames,\n  frame\n}) => {\n  if (typeof frame === \"undefined\") {\n    throw new TypeError(`Argument missing for parameter \"frame\"`);\n  }\n  if (typeof frame !== \"number\") {\n    throw new TypeError(`Argument passed for \"frame\" is not a number: ${frame}`);\n  }\n  if (!Number.isFinite(frame)) {\n    throw new RangeError(`Frame ${frame} is not finite`);\n  }\n  if (frame % 1 !== 0 && !allowFloats) {\n    throw new RangeError(`Argument for frame must be an integer, but got ${frame}`);\n  }\n  if (frame < 0 && frame < -durationInFrames) {\n    throw new RangeError(`Cannot use frame ${frame}: Duration of composition is ${durationInFrames}, therefore the lowest frame that can be rendered is ${-durationInFrames}`);\n  }\n  if (frame > durationInFrames - 1) {\n    throw new RangeError(`Cannot use frame ${frame}: Duration of composition is ${durationInFrames}, therefore the highest frame that can be rendered is ${durationInFrames - 1}`);\n  }\n};\n\n// src/validation/validate-default-props.ts\nvar validateDefaultAndInputProps = (defaultProps, name, compositionId) => {\n  if (!defaultProps) {\n    return;\n  }\n  if (typeof defaultProps !== \"object\") {\n    throw new Error(`\"${name}\" must be an object, but you passed a value of type ${typeof defaultProps}`);\n  }\n  if (Array.isArray(defaultProps)) {\n    throw new Error(`\"${name}\" must be an object, an array was passed ${compositionId ? `for composition \"${compositionId}\"` : \"\"}`);\n  }\n};\n\n// src/validation/validate-dimensions.ts\nfunction validateDimension(amount, nameOfProp, location) {\n  if (typeof amount !== \"number\") {\n    throw new Error(`The \"${nameOfProp}\" prop ${location} must be a number, but you passed a value of type ${typeof amount}`);\n  }\n  if (isNaN(amount)) {\n    throw new TypeError(`The \"${nameOfProp}\" prop ${location} must not be NaN, but is NaN.`);\n  }\n  if (!Number.isFinite(amount)) {\n    throw new TypeError(`The \"${nameOfProp}\" prop ${location} must be finite, but is ${amount}.`);\n  }\n  if (amount % 1 !== 0) {\n    throw new TypeError(`The \"${nameOfProp}\" prop ${location} must be an integer, but is ${amount}.`);\n  }\n  if (amount <= 0) {\n    throw new TypeError(`The \"${nameOfProp}\" prop ${location} must be positive, but got ${amount}.`);\n  }\n}\n\n// src/validation/validate-duration-in-frames.ts\nfunction validateDurationInFrames(durationInFrames, options) {\n  const { allowFloats, component } = options;\n  if (typeof durationInFrames === \"undefined\") {\n    throw new Error(`The \"durationInFrames\" prop ${component} is missing.`);\n  }\n  if (typeof durationInFrames !== \"number\") {\n    throw new Error(`The \"durationInFrames\" prop ${component} must be a number, but you passed a value of type ${typeof durationInFrames}`);\n  }\n  if (durationInFrames <= 0) {\n    throw new TypeError(`The \"durationInFrames\" prop ${component} must be positive, but got ${durationInFrames}.`);\n  }\n  if (!allowFloats && durationInFrames % 1 !== 0) {\n    throw new TypeError(`The \"durationInFrames\" prop ${component} must be an integer, but got ${durationInFrames}.`);\n  }\n  if (!Number.isFinite(durationInFrames)) {\n    throw new TypeError(`The \"durationInFrames\" prop ${component} must be finite, but got ${durationInFrames}.`);\n  }\n}\n\n// src/validation/validate-fps.ts\nfunction validateFps(fps, location, isGif) {\n  if (typeof fps !== \"number\") {\n    throw new Error(`\"fps\" must be a number, but you passed a value of type ${typeof fps} ${location}`);\n  }\n  if (!Number.isFinite(fps)) {\n    throw new Error(`\"fps\" must be a finite, but you passed ${fps} ${location}`);\n  }\n  if (isNaN(fps)) {\n    throw new Error(`\"fps\" must not be NaN, but got ${fps} ${location}`);\n  }\n  if (fps <= 0) {\n    throw new TypeError(`\"fps\" must be positive, but got ${fps} ${location}`);\n  }\n  if (isGif && fps > 50) {\n    throw new TypeError(`The FPS for a GIF cannot be higher than 50. Use the --every-nth-frame option to lower the FPS: https://remotion.dev/docs/render-as-gif`);\n  }\n}\n\n// src/video/get-current-time.ts\nvar getExpectedMediaFrameUncorrected = ({\n  frame,\n  playbackRate,\n  startFrom\n}) => {\n  return interpolate(frame, [-1, startFrom, startFrom + 1], [-1, startFrom, startFrom + playbackRate]);\n};\n\n// src/absolute-src.ts\nvar getAbsoluteSrc = (relativeSrc) => {\n  if (typeof window === \"undefined\") {\n    return relativeSrc;\n  }\n  return new URL(relativeSrc, window.origin).href;\n};\n\n// src/video/offthread-video-source.ts\nvar getOffthreadVideoSource = ({\n  src,\n  transparent,\n  currentTime,\n  toneMapped\n}) => {\n  return `http://localhost:${window.remotion_proxyPort}/proxy?src=${encodeURIComponent(getAbsoluteSrc(src))}&time=${encodeURIComponent(currentTime)}&transparent=${String(transparent)}&toneMapped=${String(toneMapped)}`;\n};\n\n// src/no-react.ts\nvar NoReactInternals = {\n  processColor,\n  truthy,\n  validateFps,\n  validateDimension,\n  validateDurationInFrames,\n  validateDefaultAndInputProps,\n  validateFrame,\n  serializeJSONWithDate,\n  bundleName: \"bundle.js\",\n  bundleMapName: \"bundle.js.map\",\n  deserializeJSONWithCustomFields,\n  DELAY_RENDER_CALLSTACK_TOKEN,\n  DELAY_RENDER_RETRY_TOKEN,\n  DELAY_RENDER_ATTEMPT_TOKEN: DELAY_RENDER_RETRIES_LEFT,\n  getOffthreadVideoSource,\n  getExpectedMediaFrameUncorrected,\n  ENABLE_V5_BREAKING_CHANGES,\n  MIN_NODE_VERSION: ENABLE_V5_BREAKING_CHANGES ? 18 : 16,\n  MIN_BUN_VERSION: ENABLE_V5_BREAKING_CHANGES ? \"1.1.3\" : \"1.0.3\",\n  colorNames,\n  DATE_TOKEN,\n  FILE_TOKEN\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVtb3Rpb24vZGlzdC9lc20vbm8tcmVhY3QubWpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFBO0FBQ0E7QUFDQSxVQUFVLDRDQUE0QztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSwyQkFBMkI7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsZ0JBQWdCO0FBQ2pDO0FBQ0EsdUZBQXVGLGNBQWM7QUFDckc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLE1BQU07QUFDL0I7QUFDQTtBQUNBLHlCQUF5QixNQUFNLDZDQUE2QyxjQUFjO0FBQzFGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGdCQUFnQjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsS0FBSyw2Q0FBNkMsMkJBQTJCO0FBQ2pIO0FBQ0EsY0FBYywyQkFBMkIsR0FBRyx1QkFBdUI7QUFDbkU7QUFDQSxhQUFhLHVCQUF1QjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0RUFBNEUsS0FBSztBQUNqRjtBQUNBO0FBQ0EsK0VBQStFLEtBQUs7QUFDcEY7QUFDQTtBQUNBLCtFQUErRSxLQUFLO0FBQ3BGO0FBQ0E7QUFDQSw0RkFBNEYsS0FBSztBQUNqRztBQUNBO0FBQ0E7QUFDQSxpRkFBaUYsb0JBQW9CO0FBQ3JHO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxVQUFVO0FBQ3pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsV0FBVyxFQUFFLG1CQUFtQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFdBQVcsRUFBRSxtQ0FBbUM7QUFDbEU7QUFDQTtBQUNBLEtBQUs7QUFDTCxhQUFhO0FBQ2IsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsRUFBRSxjQUFjLEVBQUUsY0FBYyxFQUFFO0FBQzVFLDBDQUEwQyxFQUFFLGNBQWMsRUFBRSxjQUFjLEVBQUUsY0FBYyxFQUFFO0FBQzVGLDBDQUEwQyxFQUFFO0FBQzVDLDBDQUEwQyxFQUFFO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLE9BQU87QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdFQUF3RSxNQUFNO0FBQzlFO0FBQ0E7QUFDQSxrQ0FBa0MsT0FBTztBQUN6QztBQUNBO0FBQ0EsMkVBQTJFLE1BQU07QUFDakY7QUFDQTtBQUNBLDZDQUE2QyxNQUFNLCtCQUErQixpQkFBaUIsdURBQXVELGtCQUFrQjtBQUM1SztBQUNBO0FBQ0EsNkNBQTZDLE1BQU0sK0JBQStCLGlCQUFpQix3REFBd0QscUJBQXFCO0FBQ2hMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLEtBQUssc0RBQXNELG9CQUFvQjtBQUN2RztBQUNBO0FBQ0Esd0JBQXdCLEtBQUssMkNBQTJDLG9DQUFvQyxjQUFjLFFBQVE7QUFDbEk7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsV0FBVyxTQUFTLFVBQVUsbURBQW1ELGNBQWM7QUFDM0g7QUFDQTtBQUNBLGdDQUFnQyxXQUFXLFNBQVMsVUFBVTtBQUM5RDtBQUNBO0FBQ0EsZ0NBQWdDLFdBQVcsU0FBUyxVQUFVLHlCQUF5QixPQUFPO0FBQzlGO0FBQ0E7QUFDQSxnQ0FBZ0MsV0FBVyxTQUFTLFVBQVUsNkJBQTZCLE9BQU87QUFDbEc7QUFDQTtBQUNBLGdDQUFnQyxXQUFXLFNBQVMsVUFBVSw0QkFBNEIsT0FBTztBQUNqRztBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVLHlCQUF5QjtBQUNuQztBQUNBLG1EQUFtRCxXQUFXO0FBQzlEO0FBQ0E7QUFDQSxtREFBbUQsV0FBVyxtREFBbUQsd0JBQXdCO0FBQ3pJO0FBQ0E7QUFDQSx1REFBdUQsV0FBVyw0QkFBNEIsaUJBQWlCO0FBQy9HO0FBQ0E7QUFDQSx1REFBdUQsV0FBVyw4QkFBOEIsaUJBQWlCO0FBQ2pIO0FBQ0E7QUFDQSx1REFBdUQsV0FBVywwQkFBMEIsaUJBQWlCO0FBQzdHO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsOEVBQThFLFlBQVksRUFBRSxTQUFTO0FBQ3JHO0FBQ0E7QUFDQSw4REFBOEQsS0FBSyxFQUFFLFNBQVM7QUFDOUU7QUFDQTtBQUNBLHNEQUFzRCxLQUFLLEVBQUUsU0FBUztBQUN0RTtBQUNBO0FBQ0EsMkRBQTJELEtBQUssRUFBRSxTQUFTO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCw2QkFBNkIsMEJBQTBCLGFBQWEsd0NBQXdDLFFBQVEsZ0NBQWdDLGVBQWUsb0JBQW9CLGNBQWMsbUJBQW1CO0FBQ3hOOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBS0UiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZW1vdGlvbi1jYXB0aW9ucy8uL25vZGVfbW9kdWxlcy9yZW1vdGlvbi9kaXN0L2VzbS9uby1yZWFjdC5tanM/ZjMzYyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzcmMvaW50ZXJwb2xhdGUudHNcbmZ1bmN0aW9uIGludGVycG9sYXRlRnVuY3Rpb24oaW5wdXQsIGlucHV0UmFuZ2UsIG91dHB1dFJhbmdlLCBvcHRpb25zKSB7XG4gIGNvbnN0IHsgZXh0cmFwb2xhdGVMZWZ0LCBleHRyYXBvbGF0ZVJpZ2h0LCBlYXNpbmcgfSA9IG9wdGlvbnM7XG4gIGxldCByZXN1bHQgPSBpbnB1dDtcbiAgY29uc3QgW2lucHV0TWluLCBpbnB1dE1heF0gPSBpbnB1dFJhbmdlO1xuICBjb25zdCBbb3V0cHV0TWluLCBvdXRwdXRNYXhdID0gb3V0cHV0UmFuZ2U7XG4gIGlmIChyZXN1bHQgPCBpbnB1dE1pbikge1xuICAgIGlmIChleHRyYXBvbGF0ZUxlZnQgPT09IFwiaWRlbnRpdHlcIikge1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgaWYgKGV4dHJhcG9sYXRlTGVmdCA9PT0gXCJjbGFtcFwiKSB7XG4gICAgICByZXN1bHQgPSBpbnB1dE1pbjtcbiAgICB9IGVsc2UgaWYgKGV4dHJhcG9sYXRlTGVmdCA9PT0gXCJ3cmFwXCIpIHtcbiAgICAgIGNvbnN0IHJhbmdlID0gaW5wdXRNYXggLSBpbnB1dE1pbjtcbiAgICAgIHJlc3VsdCA9ICgocmVzdWx0IC0gaW5wdXRNaW4pICUgcmFuZ2UgKyByYW5nZSkgJSByYW5nZSArIGlucHV0TWluO1xuICAgIH0gZWxzZSBpZiAoZXh0cmFwb2xhdGVMZWZ0ID09PSBcImV4dGVuZFwiKSB7XG4gICAgfVxuICB9XG4gIGlmIChyZXN1bHQgPiBpbnB1dE1heCkge1xuICAgIGlmIChleHRyYXBvbGF0ZVJpZ2h0ID09PSBcImlkZW50aXR5XCIpIHtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGlmIChleHRyYXBvbGF0ZVJpZ2h0ID09PSBcImNsYW1wXCIpIHtcbiAgICAgIHJlc3VsdCA9IGlucHV0TWF4O1xuICAgIH0gZWxzZSBpZiAoZXh0cmFwb2xhdGVSaWdodCA9PT0gXCJ3cmFwXCIpIHtcbiAgICAgIGNvbnN0IHJhbmdlID0gaW5wdXRNYXggLSBpbnB1dE1pbjtcbiAgICAgIHJlc3VsdCA9ICgocmVzdWx0IC0gaW5wdXRNaW4pICUgcmFuZ2UgKyByYW5nZSkgJSByYW5nZSArIGlucHV0TWluO1xuICAgIH0gZWxzZSBpZiAoZXh0cmFwb2xhdGVSaWdodCA9PT0gXCJleHRlbmRcIikge1xuICAgIH1cbiAgfVxuICBpZiAob3V0cHV0TWluID09PSBvdXRwdXRNYXgpIHtcbiAgICByZXR1cm4gb3V0cHV0TWluO1xuICB9XG4gIHJlc3VsdCA9IChyZXN1bHQgLSBpbnB1dE1pbikgLyAoaW5wdXRNYXggLSBpbnB1dE1pbik7XG4gIHJlc3VsdCA9IGVhc2luZyhyZXN1bHQpO1xuICByZXN1bHQgPSByZXN1bHQgKiAob3V0cHV0TWF4IC0gb3V0cHV0TWluKSArIG91dHB1dE1pbjtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGZpbmRSYW5nZShpbnB1dCwgaW5wdXRSYW5nZSkge1xuICBsZXQgaTtcbiAgZm9yIChpID0gMTtpIDwgaW5wdXRSYW5nZS5sZW5ndGggLSAxOyArK2kpIHtcbiAgICBpZiAoaW5wdXRSYW5nZVtpXSA+PSBpbnB1dCkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHJldHVybiBpIC0gMTtcbn1cbmZ1bmN0aW9uIGNoZWNrVmFsaWRJbnB1dFJhbmdlKGFycikge1xuICBmb3IgKGxldCBpID0gMTtpIDwgYXJyLmxlbmd0aDsgKytpKSB7XG4gICAgaWYgKCEoYXJyW2ldID4gYXJyW2kgLSAxXSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgaW5wdXRSYW5nZSBtdXN0IGJlIHN0cmljdGx5IG1vbm90b25pY2FsbHkgaW5jcmVhc2luZyBidXQgZ290IFske2Fyci5qb2luKFwiLFwiKX1dYCk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBjaGVja0luZmluaXRlUmFuZ2UobmFtZSwgYXJyKSB7XG4gIGlmIChhcnIubGVuZ3RoIDwgMikge1xuICAgIHRocm93IG5ldyBFcnJvcihuYW1lICsgXCIgbXVzdCBoYXZlIGF0IGxlYXN0IDIgZWxlbWVudHNcIik7XG4gIH1cbiAgZm9yIChjb25zdCBlbGVtZW50IG9mIGFycikge1xuICAgIGlmICh0eXBlb2YgZWxlbWVudCAhPT0gXCJudW1iZXJcIikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGAke25hbWV9IG11c3QgY29udGFpbiBvbmx5IG51bWJlcnNgKTtcbiAgICB9XG4gICAgaWYgKCFOdW1iZXIuaXNGaW5pdGUoZWxlbWVudCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgJHtuYW1lfSBtdXN0IGNvbnRhaW4gb25seSBmaW5pdGUgbnVtYmVycywgYnV0IGdvdCBbJHthcnIuam9pbihcIixcIil9XWApO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gaW50ZXJwb2xhdGUoaW5wdXQsIGlucHV0UmFuZ2UsIG91dHB1dFJhbmdlLCBvcHRpb25zKSB7XG4gIGlmICh0eXBlb2YgaW5wdXQgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnB1dCBjYW4gbm90IGJlIHVuZGVmaW5lZFwiKTtcbiAgfVxuICBpZiAodHlwZW9mIGlucHV0UmFuZ2UgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnB1dFJhbmdlIGNhbiBub3QgYmUgdW5kZWZpbmVkXCIpO1xuICB9XG4gIGlmICh0eXBlb2Ygb3V0cHV0UmFuZ2UgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJvdXRwdXRSYW5nZSBjYW4gbm90IGJlIHVuZGVmaW5lZFwiKTtcbiAgfVxuICBpZiAoaW5wdXRSYW5nZS5sZW5ndGggIT09IG91dHB1dFJhbmdlLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImlucHV0UmFuZ2UgKFwiICsgaW5wdXRSYW5nZS5sZW5ndGggKyBcIikgYW5kIG91dHB1dFJhbmdlIChcIiArIG91dHB1dFJhbmdlLmxlbmd0aCArIFwiKSBtdXN0IGhhdmUgdGhlIHNhbWUgbGVuZ3RoXCIpO1xuICB9XG4gIGNoZWNrSW5maW5pdGVSYW5nZShcImlucHV0UmFuZ2VcIiwgaW5wdXRSYW5nZSk7XG4gIGNoZWNrSW5maW5pdGVSYW5nZShcIm91dHB1dFJhbmdlXCIsIG91dHB1dFJhbmdlKTtcbiAgY2hlY2tWYWxpZElucHV0UmFuZ2UoaW5wdXRSYW5nZSk7XG4gIGNvbnN0IGVhc2luZyA9IG9wdGlvbnM/LmVhc2luZyA/PyAoKG51bSkgPT4gbnVtKTtcbiAgbGV0IGV4dHJhcG9sYXRlTGVmdCA9IFwiZXh0ZW5kXCI7XG4gIGlmIChvcHRpb25zPy5leHRyYXBvbGF0ZUxlZnQgIT09IHVuZGVmaW5lZCkge1xuICAgIGV4dHJhcG9sYXRlTGVmdCA9IG9wdGlvbnMuZXh0cmFwb2xhdGVMZWZ0O1xuICB9XG4gIGxldCBleHRyYXBvbGF0ZVJpZ2h0ID0gXCJleHRlbmRcIjtcbiAgaWYgKG9wdGlvbnM/LmV4dHJhcG9sYXRlUmlnaHQgIT09IHVuZGVmaW5lZCkge1xuICAgIGV4dHJhcG9sYXRlUmlnaHQgPSBvcHRpb25zLmV4dHJhcG9sYXRlUmlnaHQ7XG4gIH1cbiAgaWYgKHR5cGVvZiBpbnB1dCAhPT0gXCJudW1iZXJcIikge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgaW50ZXJwb2xhdGUgYW4gaW5wdXQgd2hpY2ggaXMgbm90IGEgbnVtYmVyXCIpO1xuICB9XG4gIGNvbnN0IHJhbmdlID0gZmluZFJhbmdlKGlucHV0LCBpbnB1dFJhbmdlKTtcbiAgcmV0dXJuIGludGVycG9sYXRlRnVuY3Rpb24oaW5wdXQsIFtpbnB1dFJhbmdlW3JhbmdlXSwgaW5wdXRSYW5nZVtyYW5nZSArIDFdXSwgW291dHB1dFJhbmdlW3JhbmdlXSwgb3V0cHV0UmFuZ2VbcmFuZ2UgKyAxXV0sIHtcbiAgICBlYXNpbmcsXG4gICAgZXh0cmFwb2xhdGVMZWZ0LFxuICAgIGV4dHJhcG9sYXRlUmlnaHRcbiAgfSk7XG59XG4vLyBzcmMvcmFuZG9tLnRzXG5mdW5jdGlvbiBtdWxiZXJyeTMyKGEpIHtcbiAgbGV0IHQgPSBhICsgMTgzMTU2NTgxMztcbiAgdCA9IE1hdGguaW11bCh0IF4gdCA+Pj4gMTUsIHQgfCAxKTtcbiAgdCBePSB0ICsgTWF0aC5pbXVsKHQgXiB0ID4+PiA3LCB0IHwgNjEpO1xuICByZXR1cm4gKCh0IF4gdCA+Pj4gMTQpID4+PiAwKSAvIDQyOTQ5NjcyOTY7XG59XG5mdW5jdGlvbiBoYXNoQ29kZShzdHIpIHtcbiAgbGV0IGkgPSAwO1xuICBsZXQgY2hyID0gMDtcbiAgbGV0IGhhc2ggPSAwO1xuICBmb3IgKGkgPSAwO2kgPCBzdHIubGVuZ3RoOyBpKyspIHtcbiAgICBjaHIgPSBzdHIuY2hhckNvZGVBdChpKTtcbiAgICBoYXNoID0gKGhhc2ggPDwgNSkgLSBoYXNoICsgY2hyO1xuICAgIGhhc2ggfD0gMDtcbiAgfVxuICByZXR1cm4gaGFzaDtcbn1cbnZhciByYW5kb20gPSAoc2VlZCwgZHVtbXkpID0+IHtcbiAgaWYgKGR1bW15ICE9PSB1bmRlZmluZWQpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwicmFuZG9tKCkgdGFrZXMgb25seSBvbmUgYXJndW1lbnRcIik7XG4gIH1cbiAgaWYgKHNlZWQgPT09IG51bGwpIHtcbiAgICByZXR1cm4gTWF0aC5yYW5kb20oKTtcbiAgfVxuICBpZiAodHlwZW9mIHNlZWQgPT09IFwic3RyaW5nXCIpIHtcbiAgICByZXR1cm4gbXVsYmVycnkzMihoYXNoQ29kZShzZWVkKSk7XG4gIH1cbiAgaWYgKHR5cGVvZiBzZWVkID09PSBcIm51bWJlclwiKSB7XG4gICAgcmV0dXJuIG11bGJlcnJ5MzIoc2VlZCAqIDEwMDAwMDAwMDAwKTtcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoXCJyYW5kb20oKSBhcmd1bWVudCBtdXN0IGJlIGEgbnVtYmVyIG9yIGEgc3RyaW5nXCIpO1xufTtcbi8vIHNyYy90cnV0aHkudHNcbmZ1bmN0aW9uIHRydXRoeSh2YWx1ZSkge1xuICByZXR1cm4gQm9vbGVhbih2YWx1ZSk7XG59XG5cbi8vIHNyYy9kZWxheS1yZW5kZXIudHNcbmlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gIHdpbmRvdy5yZW1vdGlvbl9yZW5kZXJSZWFkeSA9IGZhbHNlO1xufVxuaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgd2luZG93LnJlbW90aW9uX2RlbGF5UmVuZGVyVGltZW91dHMgPSB7fTtcbn1cbnZhciBERUxBWV9SRU5ERVJfQ0FMTFNUQUNLX1RPS0VOID0gXCJUaGUgZGVsYXlSZW5kZXIgd2FzIGNhbGxlZDpcIjtcbnZhciBERUxBWV9SRU5ERVJfUkVUUklFU19MRUZUID0gXCJSZXRyaWVzIGxlZnQ6IFwiO1xudmFyIERFTEFZX1JFTkRFUl9SRVRSWV9UT0tFTiA9IFwiLSBSZW5kZXJpbmcgdGhlIGZyYW1lIHdpbGwgYmUgcmV0cmllZC5cIjtcblxuLy8gc3JjL3N0YXRpYy1maWxlLnRzXG52YXIgcHJvYmxlbWF0aWNDaGFyYWN0ZXJzID0ge1xuICBcIiUzQVwiOiBcIjpcIixcbiAgXCIlMkZcIjogXCIvXCIsXG4gIFwiJTNGXCI6IFwiP1wiLFxuICBcIiUyM1wiOiBcIiNcIixcbiAgXCIlNUJcIjogXCJbXCIsXG4gIFwiJTVEXCI6IFwiXVwiLFxuICBcIiU0MFwiOiBcIkBcIixcbiAgXCIlMjFcIjogXCIhXCIsXG4gIFwiJTI0XCI6IFwiJFwiLFxuICBcIiUyNlwiOiBcIiZcIixcbiAgXCIlMjdcIjogXCInXCIsXG4gIFwiJTI4XCI6IFwiKFwiLFxuICBcIiUyOVwiOiBcIilcIixcbiAgXCIlMkFcIjogXCIqXCIsXG4gIFwiJTJCXCI6IFwiK1wiLFxuICBcIiUyQ1wiOiBcIixcIixcbiAgXCIlM0JcIjogXCI7XCJcbn07XG52YXIgZGlkV2FybiA9IHt9O1xudmFyIHdhcm5PbmNlID0gKG1lc3NhZ2UpID0+IHtcbiAgaWYgKGRpZFdhcm5bbWVzc2FnZV0pIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc29sZS53YXJuKG1lc3NhZ2UpO1xuICBkaWRXYXJuW21lc3NhZ2VdID0gdHJ1ZTtcbn07XG52YXIgaW5jbHVkZXNIZXhPZlVuc2FmZUNoYXIgPSAocGF0aCkgPT4ge1xuICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhwcm9ibGVtYXRpY0NoYXJhY3RlcnMpKSB7XG4gICAgaWYgKHBhdGguaW5jbHVkZXMoa2V5KSkge1xuICAgICAgcmV0dXJuIHsgY29udGFpbnNIZXg6IHRydWUsIGhleENvZGU6IGtleSB9O1xuICAgIH1cbiAgfVxuICByZXR1cm4geyBjb250YWluc0hleDogZmFsc2UgfTtcbn07XG52YXIgdHJpbUxlYWRpbmdTbGFzaCA9IChwYXRoKSA9PiB7XG4gIGlmIChwYXRoLnN0YXJ0c1dpdGgoXCIvXCIpKSB7XG4gICAgcmV0dXJuIHRyaW1MZWFkaW5nU2xhc2gocGF0aC5zdWJzdHJpbmcoMSkpO1xuICB9XG4gIHJldHVybiBwYXRoO1xufTtcbnZhciBpbm5lciA9IChwYXRoKSA9PiB7XG4gIGlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIHdpbmRvdy5yZW1vdGlvbl9zdGF0aWNCYXNlKSB7XG4gICAgaWYgKHBhdGguc3RhcnRzV2l0aCh3aW5kb3cucmVtb3Rpb25fc3RhdGljQmFzZSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVGhlIHZhbHVlIFwiJHtwYXRofVwiIGlzIGFscmVhZHkgcHJlZml4ZWQgd2l0aCB0aGUgc3RhdGljIGJhc2UgJHt3aW5kb3cucmVtb3Rpb25fc3RhdGljQmFzZX0uIFlvdSBkb24ndCBuZWVkIHRvIGNhbGwgc3RhdGljRmlsZSgpIG9uIGl0LmApO1xuICAgIH1cbiAgICByZXR1cm4gYCR7d2luZG93LnJlbW90aW9uX3N0YXRpY0Jhc2V9LyR7dHJpbUxlYWRpbmdTbGFzaChwYXRoKX1gO1xuICB9XG4gIHJldHVybiBgLyR7dHJpbUxlYWRpbmdTbGFzaChwYXRoKX1gO1xufTtcbnZhciBlbmNvZGVCeVNwbGl0dGluZyA9IChwYXRoKSA9PiB7XG4gIGNvbnN0IHNwbGl0QnlTbGFzaCA9IHBhdGguc3BsaXQoXCIvXCIpO1xuICBjb25zdCBlbmNvZGVkQXJyYXkgPSBzcGxpdEJ5U2xhc2gubWFwKChlbGVtZW50KSA9PiB7XG4gICAgcmV0dXJuIGVuY29kZVVSSUNvbXBvbmVudChlbGVtZW50KTtcbiAgfSk7XG4gIGNvbnN0IG1lcmdlZCA9IGVuY29kZWRBcnJheS5qb2luKFwiL1wiKTtcbiAgcmV0dXJuIG1lcmdlZDtcbn07XG52YXIgc3RhdGljRmlsZSA9IChwYXRoKSA9PiB7XG4gIGlmIChwYXRoLnN0YXJ0c1dpdGgoXCJodHRwOi8vXCIpIHx8IHBhdGguc3RhcnRzV2l0aChcImh0dHBzOi8vXCIpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgc3RhdGljRmlsZSgpIGRvZXMgbm90IHN1cHBvcnQgcmVtb3RlIFVSTHMgLSBnb3QgXCIke3BhdGh9XCIuIEluc3RlYWQsIHBhc3MgdGhlIFVSTCB3aXRob3V0IHdyYXBwaW5nIGl0IGluIHN0YXRpY0ZpbGUoKS4gU2VlOiBodHRwczovL3JlbW90aW9uLmRldi9kb2NzL3N0YXRpY2ZpbGUtcmVtb3RlLXVybHNgKTtcbiAgfVxuICBpZiAocGF0aC5zdGFydHNXaXRoKFwiLi5cIikgfHwgcGF0aC5zdGFydHNXaXRoKFwiLi9cIikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBzdGF0aWNGaWxlKCkgZG9lcyBub3Qgc3VwcG9ydCByZWxhdGl2ZSBwYXRocyAtIGdvdCBcIiR7cGF0aH1cIi4gSW5zdGVhZCwgcGFzcyB0aGUgbmFtZSBvZiBhIGZpbGUgdGhhdCBpcyBpbnNpZGUgdGhlIHB1YmxpYy8gZm9sZGVyLiBTZWU6IGh0dHBzOi8vcmVtb3Rpb24uZGV2L2RvY3Mvc3RhdGljZmlsZS1yZWxhdGl2ZS1wYXRoc2ApO1xuICB9XG4gIGlmIChwYXRoLnN0YXJ0c1dpdGgoXCIvVXNlcnNcIikgfHwgcGF0aC5zdGFydHNXaXRoKFwiL2hvbWVcIikgfHwgcGF0aC5zdGFydHNXaXRoKFwiL3RtcFwiKSB8fCBwYXRoLnN0YXJ0c1dpdGgoXCIvZXRjXCIpIHx8IHBhdGguc3RhcnRzV2l0aChcIi9vcHRcIikgfHwgcGF0aC5zdGFydHNXaXRoKFwiL3ZhclwiKSB8fCBwYXRoLnN0YXJ0c1dpdGgoXCJDOlwiKSB8fCBwYXRoLnN0YXJ0c1dpdGgoXCJEOlwiKSB8fCBwYXRoLnN0YXJ0c1dpdGgoXCJFOlwiKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYHN0YXRpY0ZpbGUoKSBkb2VzIG5vdCBzdXBwb3J0IGFic29sdXRlIHBhdGhzIC0gZ290IFwiJHtwYXRofVwiLiBJbnN0ZWFkLCBwYXNzIHRoZSBuYW1lIG9mIGEgZmlsZSB0aGF0IGlzIGluc2lkZSB0aGUgcHVibGljLyBmb2xkZXIuIFNlZTogaHR0cHM6Ly9yZW1vdGlvbi5kZXYvZG9jcy9zdGF0aWNmaWxlLXJlbGF0aXZlLXBhdGhzYCk7XG4gIH1cbiAgaWYgKHBhdGguc3RhcnRzV2l0aChcInB1YmxpYy9cIikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBEbyBub3QgaW5jbHVkZSB0aGUgcHVibGljLyBwcmVmaXggd2hlbiB1c2luZyBzdGF0aWNGaWxlKCkgLSBnb3QgXCIke3BhdGh9XCIuIFNlZTogaHR0cHM6Ly9yZW1vdGlvbi5kZXYvZG9jcy9zdGF0aWNmaWxlLXJlbGF0aXZlLXBhdGhzYCk7XG4gIH1cbiAgY29uc3QgaW5jbHVkZXNIZXggPSBpbmNsdWRlc0hleE9mVW5zYWZlQ2hhcihwYXRoKTtcbiAgaWYgKGluY2x1ZGVzSGV4LmNvbnRhaW5zSGV4KSB7XG4gICAgd2Fybk9uY2UoYFdBUk5JTkc6IFlvdSBzZWVtIHRvIHBhc3MgYW4gYWxyZWFkeSBlbmNvZGVkIHBhdGggKHBhdGggY29udGFpbnMgJHtpbmNsdWRlc0hleC5oZXhDb2RlfSkuIFNpbmNlIFJlbW90aW9uIDQuMCwgdGhlIGVuY29kaW5nIGlzIGRvbmUgYnkgc3RhdGljRmlsZSgpIGl0c2VsZi4gWW91IG1heSB3YW50IHRvIHJlbW92ZSBhIGVuY29kZVVSSUNvbXBvbmVudCgpIHdyYXBwaW5nLmApO1xuICB9XG4gIGNvbnN0IHByZXByb2Nlc3NlZCA9IGVuY29kZUJ5U3BsaXR0aW5nKHBhdGgpO1xuICBjb25zdCBwcmVwYXJzZWQgPSBpbm5lcihwcmVwcm9jZXNzZWQpO1xuICBpZiAoIXByZXBhcnNlZC5zdGFydHNXaXRoKFwiL1wiKSkge1xuICAgIHJldHVybiBgLyR7cHJlcGFyc2VkfWA7XG4gIH1cbiAgcmV0dXJuIHByZXBhcnNlZDtcbn07XG5cbi8vIHNyYy9pbnB1dC1wcm9wcy1zZXJpYWxpemF0aW9uLnRzXG52YXIgREFURV9UT0tFTiA9IFwicmVtb3Rpb24tZGF0ZTpcIjtcbnZhciBGSUxFX1RPS0VOID0gXCJyZW1vdGlvbi1maWxlOlwiO1xudmFyIHNlcmlhbGl6ZUpTT05XaXRoRGF0ZSA9ICh7XG4gIGRhdGEsXG4gIGluZGVudCxcbiAgc3RhdGljQmFzZVxufSkgPT4ge1xuICBsZXQgY3VzdG9tRGF0ZVVzZWQgPSBmYWxzZTtcbiAgbGV0IGN1c3RvbUZpbGVVc2VkID0gZmFsc2U7XG4gIGxldCBtYXBVc2VkID0gZmFsc2U7XG4gIGxldCBzZXRVc2VkID0gZmFsc2U7XG4gIHRyeSB7XG4gICAgY29uc3Qgc2VyaWFsaXplZFN0cmluZyA9IEpTT04uc3RyaW5naWZ5KGRhdGEsIGZ1bmN0aW9uKGtleSwgdmFsdWUpIHtcbiAgICAgIGNvbnN0IGl0ZW0gPSB0aGlzW2tleV07XG4gICAgICBpZiAoaXRlbSBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgICAgY3VzdG9tRGF0ZVVzZWQgPSB0cnVlO1xuICAgICAgICByZXR1cm4gYCR7REFURV9UT0tFTn0ke2l0ZW0udG9JU09TdHJpbmcoKX1gO1xuICAgICAgfVxuICAgICAgaWYgKGl0ZW0gaW5zdGFuY2VvZiBNYXApIHtcbiAgICAgICAgbWFwVXNlZCA9IHRydWU7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChpdGVtIGluc3RhbmNlb2YgU2V0KSB7XG4gICAgICAgIHNldFVzZWQgPSB0cnVlO1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIGl0ZW0gPT09IFwic3RyaW5nXCIgJiYgc3RhdGljQmFzZSAhPT0gbnVsbCAmJiBpdGVtLnN0YXJ0c1dpdGgoc3RhdGljQmFzZSkpIHtcbiAgICAgICAgY3VzdG9tRmlsZVVzZWQgPSB0cnVlO1xuICAgICAgICByZXR1cm4gYCR7RklMRV9UT0tFTn0ke2l0ZW0ucmVwbGFjZShzdGF0aWNCYXNlICsgXCIvXCIsIFwiXCIpfWA7XG4gICAgICB9XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfSwgaW5kZW50KTtcbiAgICByZXR1cm4geyBzZXJpYWxpemVkU3RyaW5nLCBjdXN0b21EYXRlVXNlZCwgY3VzdG9tRmlsZVVzZWQsIG1hcFVzZWQsIHNldFVzZWQgfTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiQ291bGQgbm90IHNlcmlhbGl6ZSB0aGUgcGFzc2VkIGlucHV0IHByb3BzIHRvIEpTT046IFwiICsgZXJyLm1lc3NhZ2UpO1xuICB9XG59O1xudmFyIGRlc2VyaWFsaXplSlNPTldpdGhDdXN0b21GaWVsZHMgPSAoZGF0YSkgPT4ge1xuICByZXR1cm4gSlNPTi5wYXJzZShkYXRhLCAoXywgdmFsdWUpID0+IHtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiICYmIHZhbHVlLnN0YXJ0c1dpdGgoREFURV9UT0tFTikpIHtcbiAgICAgIHJldHVybiBuZXcgRGF0ZSh2YWx1ZS5yZXBsYWNlKERBVEVfVE9LRU4sIFwiXCIpKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiAmJiB2YWx1ZS5zdGFydHNXaXRoKEZJTEVfVE9LRU4pKSB7XG4gICAgICByZXR1cm4gc3RhdGljRmlsZSh2YWx1ZS5yZXBsYWNlKEZJTEVfVE9LRU4sIFwiXCIpKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9KTtcbn07XG5cbi8vIHNyYy9pbnRlcnBvbGF0ZS1jb2xvcnMudHNcbmZ1bmN0aW9uIGNhbGwoLi4uYXJncykge1xuICByZXR1cm4gXCJcXFxcKFxcXFxzKihcIiArIGFyZ3Muam9pbihcIilcXFxccyosXFxcXHMqKFwiKSArIFwiKVxcXFxzKlxcXFwpXCI7XG59XG5mdW5jdGlvbiBnZXRNYXRjaGVycygpIHtcbiAgY29uc3QgY2FjaGVkTWF0Y2hlcnMgPSB7XG4gICAgcmdiOiB1bmRlZmluZWQsXG4gICAgcmdiYTogdW5kZWZpbmVkLFxuICAgIGhzbDogdW5kZWZpbmVkLFxuICAgIGhzbGE6IHVuZGVmaW5lZCxcbiAgICBoZXgzOiB1bmRlZmluZWQsXG4gICAgaGV4NDogdW5kZWZpbmVkLFxuICAgIGhleDU6IHVuZGVmaW5lZCxcbiAgICBoZXg2OiB1bmRlZmluZWQsXG4gICAgaGV4ODogdW5kZWZpbmVkXG4gIH07XG4gIGlmIChjYWNoZWRNYXRjaGVycy5yZ2IgPT09IHVuZGVmaW5lZCkge1xuICAgIGNhY2hlZE1hdGNoZXJzLnJnYiA9IG5ldyBSZWdFeHAoXCJyZ2JcIiArIGNhbGwoTlVNQkVSLCBOVU1CRVIsIE5VTUJFUikpO1xuICAgIGNhY2hlZE1hdGNoZXJzLnJnYmEgPSBuZXcgUmVnRXhwKFwicmdiYVwiICsgY2FsbChOVU1CRVIsIE5VTUJFUiwgTlVNQkVSLCBOVU1CRVIpKTtcbiAgICBjYWNoZWRNYXRjaGVycy5oc2wgPSBuZXcgUmVnRXhwKFwiaHNsXCIgKyBjYWxsKE5VTUJFUiwgUEVSQ0VOVEFHRSwgUEVSQ0VOVEFHRSkpO1xuICAgIGNhY2hlZE1hdGNoZXJzLmhzbGEgPSBuZXcgUmVnRXhwKFwiaHNsYVwiICsgY2FsbChOVU1CRVIsIFBFUkNFTlRBR0UsIFBFUkNFTlRBR0UsIE5VTUJFUikpO1xuICAgIGNhY2hlZE1hdGNoZXJzLmhleDMgPSAvXiMoWzAtOWEtZkEtRl17MX0pKFswLTlhLWZBLUZdezF9KShbMC05YS1mQS1GXXsxfSkkLztcbiAgICBjYWNoZWRNYXRjaGVycy5oZXg0ID0gL14jKFswLTlhLWZBLUZdezF9KShbMC05YS1mQS1GXXsxfSkoWzAtOWEtZkEtRl17MX0pKFswLTlhLWZBLUZdezF9KSQvO1xuICAgIGNhY2hlZE1hdGNoZXJzLmhleDYgPSAvXiMoWzAtOWEtZkEtRl17Nn0pJC87XG4gICAgY2FjaGVkTWF0Y2hlcnMuaGV4OCA9IC9eIyhbMC05YS1mQS1GXXs4fSkkLztcbiAgfVxuICByZXR1cm4gY2FjaGVkTWF0Y2hlcnM7XG59XG5mdW5jdGlvbiBodWUycmdiKHAsIHEsIHQpIHtcbiAgaWYgKHQgPCAwKSB7XG4gICAgdCArPSAxO1xuICB9XG4gIGlmICh0ID4gMSkge1xuICAgIHQgLT0gMTtcbiAgfVxuICBpZiAodCA8IDEgLyA2KSB7XG4gICAgcmV0dXJuIHAgKyAocSAtIHApICogNiAqIHQ7XG4gIH1cbiAgaWYgKHQgPCAxIC8gMikge1xuICAgIHJldHVybiBxO1xuICB9XG4gIGlmICh0IDwgMiAvIDMpIHtcbiAgICByZXR1cm4gcCArIChxIC0gcCkgKiAoMiAvIDMgLSB0KSAqIDY7XG4gIH1cbiAgcmV0dXJuIHA7XG59XG5mdW5jdGlvbiBoc2xUb1JnYihoLCBzLCBsKSB7XG4gIGNvbnN0IHEgPSBsIDwgMC41ID8gbCAqICgxICsgcykgOiBsICsgcyAtIGwgKiBzO1xuICBjb25zdCBwID0gMiAqIGwgLSBxO1xuICBjb25zdCByID0gaHVlMnJnYihwLCBxLCBoICsgMSAvIDMpO1xuICBjb25zdCBnID0gaHVlMnJnYihwLCBxLCBoKTtcbiAgY29uc3QgYiA9IGh1ZTJyZ2IocCwgcSwgaCAtIDEgLyAzKTtcbiAgcmV0dXJuIE1hdGgucm91bmQociAqIDI1NSkgPDwgMjQgfCBNYXRoLnJvdW5kKGcgKiAyNTUpIDw8IDE2IHwgTWF0aC5yb3VuZChiICogMjU1KSA8PCA4O1xufVxuZnVuY3Rpb24gcGFyc2UyNTUoc3RyKSB7XG4gIGNvbnN0IGludCA9IE51bWJlci5wYXJzZUludChzdHIsIDEwKTtcbiAgaWYgKGludCA8IDApIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuICBpZiAoaW50ID4gMjU1KSB7XG4gICAgcmV0dXJuIDI1NTtcbiAgfVxuICByZXR1cm4gaW50O1xufVxuZnVuY3Rpb24gcGFyc2UzNjAoc3RyKSB7XG4gIGNvbnN0IGludCA9IE51bWJlci5wYXJzZUZsb2F0KHN0cik7XG4gIHJldHVybiAoaW50ICUgMzYwICsgMzYwKSAlIDM2MCAvIDM2MDtcbn1cbmZ1bmN0aW9uIHBhcnNlMShzdHIpIHtcbiAgY29uc3QgbnVtID0gTnVtYmVyLnBhcnNlRmxvYXQoc3RyKTtcbiAgaWYgKG51bSA8IDApIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuICBpZiAobnVtID4gMSkge1xuICAgIHJldHVybiAyNTU7XG4gIH1cbiAgcmV0dXJuIE1hdGgucm91bmQobnVtICogMjU1KTtcbn1cbmZ1bmN0aW9uIHBhcnNlUGVyY2VudGFnZShzdHIpIHtcbiAgY29uc3QgaW50ID0gTnVtYmVyLnBhcnNlRmxvYXQoc3RyKTtcbiAgaWYgKGludCA8IDApIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuICBpZiAoaW50ID4gMTAwKSB7XG4gICAgcmV0dXJuIDE7XG4gIH1cbiAgcmV0dXJuIGludCAvIDEwMDtcbn1cbmZ1bmN0aW9uIG5vcm1hbGl6ZUNvbG9yKGNvbG9yKSB7XG4gIGNvbnN0IG1hdGNoZXJzID0gZ2V0TWF0Y2hlcnMoKTtcbiAgbGV0IG1hdGNoO1xuICBpZiAobWF0Y2hlcnMuaGV4Nikge1xuICAgIGlmIChtYXRjaCA9IG1hdGNoZXJzLmhleDYuZXhlYyhjb2xvcikpIHtcbiAgICAgIHJldHVybiBOdW1iZXIucGFyc2VJbnQobWF0Y2hbMV0gKyBcImZmXCIsIDE2KSA+Pj4gMDtcbiAgICB9XG4gIH1cbiAgaWYgKGNvbG9yTmFtZXNbY29sb3JdICE9PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gY29sb3JOYW1lc1tjb2xvcl07XG4gIH1cbiAgaWYgKG1hdGNoZXJzLnJnYikge1xuICAgIGlmIChtYXRjaCA9IG1hdGNoZXJzLnJnYi5leGVjKGNvbG9yKSkge1xuICAgICAgcmV0dXJuIChwYXJzZTI1NShtYXRjaFsxXSkgPDwgMjQgfCBwYXJzZTI1NShtYXRjaFsyXSkgPDwgMTYgfCBwYXJzZTI1NShtYXRjaFszXSkgPDwgOCB8IDI1NSkgPj4+IDA7XG4gICAgfVxuICB9XG4gIGlmIChtYXRjaGVycy5yZ2JhKSB7XG4gICAgaWYgKG1hdGNoID0gbWF0Y2hlcnMucmdiYS5leGVjKGNvbG9yKSkge1xuICAgICAgcmV0dXJuIChwYXJzZTI1NShtYXRjaFsxXSkgPDwgMjQgfCBwYXJzZTI1NShtYXRjaFsyXSkgPDwgMTYgfCBwYXJzZTI1NShtYXRjaFszXSkgPDwgOCB8IHBhcnNlMShtYXRjaFs0XSkpID4+PiAwO1xuICAgIH1cbiAgfVxuICBpZiAobWF0Y2hlcnMuaGV4Mykge1xuICAgIGlmIChtYXRjaCA9IG1hdGNoZXJzLmhleDMuZXhlYyhjb2xvcikpIHtcbiAgICAgIHJldHVybiBOdW1iZXIucGFyc2VJbnQobWF0Y2hbMV0gKyBtYXRjaFsxXSArIG1hdGNoWzJdICsgbWF0Y2hbMl0gKyBtYXRjaFszXSArIG1hdGNoWzNdICsgXCJmZlwiLCAxNikgPj4+IDA7XG4gICAgfVxuICB9XG4gIGlmIChtYXRjaGVycy5oZXg4KSB7XG4gICAgaWYgKG1hdGNoID0gbWF0Y2hlcnMuaGV4OC5leGVjKGNvbG9yKSkge1xuICAgICAgcmV0dXJuIE51bWJlci5wYXJzZUludChtYXRjaFsxXSwgMTYpID4+PiAwO1xuICAgIH1cbiAgfVxuICBpZiAobWF0Y2hlcnMuaGV4NCkge1xuICAgIGlmIChtYXRjaCA9IG1hdGNoZXJzLmhleDQuZXhlYyhjb2xvcikpIHtcbiAgICAgIHJldHVybiBOdW1iZXIucGFyc2VJbnQobWF0Y2hbMV0gKyBtYXRjaFsxXSArIG1hdGNoWzJdICsgbWF0Y2hbMl0gKyBtYXRjaFszXSArIG1hdGNoWzNdICsgbWF0Y2hbNF0gKyBtYXRjaFs0XSwgMTYpID4+PiAwO1xuICAgIH1cbiAgfVxuICBpZiAobWF0Y2hlcnMuaHNsKSB7XG4gICAgaWYgKG1hdGNoID0gbWF0Y2hlcnMuaHNsLmV4ZWMoY29sb3IpKSB7XG4gICAgICByZXR1cm4gKGhzbFRvUmdiKHBhcnNlMzYwKG1hdGNoWzFdKSwgcGFyc2VQZXJjZW50YWdlKG1hdGNoWzJdKSwgcGFyc2VQZXJjZW50YWdlKG1hdGNoWzNdKSkgfCAyNTUpID4+PiAwO1xuICAgIH1cbiAgfVxuICBpZiAobWF0Y2hlcnMuaHNsYSkge1xuICAgIGlmIChtYXRjaCA9IG1hdGNoZXJzLmhzbGEuZXhlYyhjb2xvcikpIHtcbiAgICAgIHJldHVybiAoaHNsVG9SZ2IocGFyc2UzNjAobWF0Y2hbMV0pLCBwYXJzZVBlcmNlbnRhZ2UobWF0Y2hbMl0pLCBwYXJzZVBlcmNlbnRhZ2UobWF0Y2hbM10pKSB8IHBhcnNlMShtYXRjaFs0XSkpID4+PiAwO1xuICAgIH1cbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgY29sb3Igc3RyaW5nICR7Y29sb3J9IHByb3ZpZGVkYCk7XG59XG5mdW5jdGlvbiBwcm9jZXNzQ29sb3IoY29sb3IpIHtcbiAgY29uc3Qgbm9ybWFsaXplZENvbG9yID0gbm9ybWFsaXplQ29sb3IoY29sb3IpO1xuICByZXR1cm4gKG5vcm1hbGl6ZWRDb2xvciA8PCAyNCB8IG5vcm1hbGl6ZWRDb2xvciA+Pj4gOCkgPj4+IDA7XG59XG52YXIgTlVNQkVSID0gXCJbLStdP1xcXFxkKlxcXFwuP1xcXFxkK1wiO1xudmFyIFBFUkNFTlRBR0UgPSBOVU1CRVIgKyBcIiVcIjtcbnZhciBjb2xvck5hbWVzID0ge1xuICB0cmFuc3BhcmVudDogMCxcbiAgYWxpY2VibHVlOiA0MDQyODUwMzAzLFxuICBhbnRpcXVld2hpdGU6IDQyMDk3NjAyNTUsXG4gIGFxdWE6IDE2Nzc3MjE1LFxuICBhcXVhbWFyaW5lOiAyMTQ3NDcyNjM5LFxuICBhenVyZTogNDA0MzMwOTA1NSxcbiAgYmVpZ2U6IDQxMjY1MzA4MTUsXG4gIGJpc3F1ZTogNDI5MzE4MjcxOSxcbiAgYmxhY2s6IDI1NSxcbiAgYmxhbmNoZWRhbG1vbmQ6IDQyOTM2NDM3NzUsXG4gIGJsdWU6IDY1NTM1LFxuICBibHVldmlvbGV0OiAyMzE4MTMxOTY3LFxuICBicm93bjogMjc3MTAwNDE1OSxcbiAgYnVybHl3b29kOiAzNzM2NjM1MzkxLFxuICBidXJudHNpZW5uYTogMzkzNDE1MDE0MyxcbiAgY2FkZXRibHVlOiAxNjA0MjMxNDIzLFxuICBjaGFydHJldXNlOiAyMTQ3NDE4MzY3LFxuICBjaG9jb2xhdGU6IDM1MzAxMDQ1NzUsXG4gIGNvcmFsOiA0Mjg2NTMzODg3LFxuICBjb3JuZmxvd2VyYmx1ZTogMTY4NzU0NzM5MSxcbiAgY29ybnNpbGs6IDQyOTQ0OTk1ODMsXG4gIGNyaW1zb246IDM2OTIzMTM4NTUsXG4gIGN5YW46IDE2Nzc3MjE1LFxuICBkYXJrYmx1ZTogMzU4MzksXG4gIGRhcmtjeWFuOiA5MTQ1MzQzLFxuICBkYXJrZ29sZGVucm9kOiAzMDk1NzkyNjM5LFxuICBkYXJrZ3JheTogMjg0NjQ2ODYwNyxcbiAgZGFya2dyZWVuOiA2NTUzODU1LFxuICBkYXJrZ3JleTogMjg0NjQ2ODYwNyxcbiAgZGFya2toYWtpOiAzMTgyOTE0NTU5LFxuICBkYXJrbWFnZW50YTogMjMzMjA2ODg2MyxcbiAgZGFya29saXZlZ3JlZW46IDE0MzMwODc5OTksXG4gIGRhcmtvcmFuZ2U6IDQyODczNjUzNzUsXG4gIGRhcmtvcmNoaWQ6IDI1NzAyNDMzMjcsXG4gIGRhcmtyZWQ6IDIzMzIwMzMyNzksXG4gIGRhcmtzYWxtb246IDM5MTg5NTMyMTUsXG4gIGRhcmtzZWFncmVlbjogMjQxMTQ5OTUxOSxcbiAgZGFya3NsYXRlYmx1ZTogMTIxMTk5MzA4NyxcbiAgZGFya3NsYXRlZ3JheTogNzkzNzI2OTc1LFxuICBkYXJrc2xhdGVncmV5OiA3OTM3MjY5NzUsXG4gIGRhcmt0dXJxdW9pc2U6IDEzNTU0MTc1LFxuICBkYXJrdmlvbGV0OiAyNDgzMDgyMjM5LFxuICBkZWVwcGluazogNDI3OTUzODY4NyxcbiAgZGVlcHNreWJsdWU6IDEyNTgyOTExLFxuICBkaW1ncmF5OiAxNzY4NTE2MDk1LFxuICBkaW1ncmV5OiAxNzY4NTE2MDk1LFxuICBkb2RnZXJibHVlOiA1MTI4MTkxOTksXG4gIGZpcmVicmljazogMjk4ODU4MTYzMSxcbiAgZmxvcmFsd2hpdGU6IDQyOTQ2MzU3NzUsXG4gIGZvcmVzdGdyZWVuOiA1Nzk1NDM4MDcsXG4gIGZ1Y2hzaWE6IDQyNzgyNTU2MTUsXG4gIGdhaW5zYm9ybzogMzcwNTQ2MjAxNSxcbiAgZ2hvc3R3aGl0ZTogNDE3NzA2ODAzMSxcbiAgZ29sZDogNDI5MjI4MDU3NSxcbiAgZ29sZGVucm9kOiAzNjY4MjU0OTc1LFxuICBncmF5OiAyMTU1OTA1Mjc5LFxuICBncmVlbjogODM4ODg2MyxcbiAgZ3JlZW55ZWxsb3c6IDI5MTkxODIzMzUsXG4gIGdyZXk6IDIxNTU5MDUyNzksXG4gIGhvbmV5ZGV3OiA0MDQzMzA1MjE1LFxuICBob3RwaW5rOiA0Mjg1MTE3Njk1LFxuICBpbmRpYW5yZWQ6IDM0NDUzODIzOTksXG4gIGluZGlnbzogMTI1ODMyNDczNSxcbiAgaXZvcnk6IDQyOTQ5NjM0NTUsXG4gIGtoYWtpOiA0MDQxNjQxMjE1LFxuICBsYXZlbmRlcjogMzg3Mzg5NzIxNSxcbiAgbGF2ZW5kZXJibHVzaDogNDI5Mzk4MTY5NSxcbiAgbGF3bmdyZWVuOiAyMDk2ODkwMTExLFxuICBsZW1vbmNoaWZmb246IDQyOTQ2MjY4MTUsXG4gIGxpZ2h0Ymx1ZTogMjkxNjY3MzI3OSxcbiAgbGlnaHRjb3JhbDogNDAzNDk1MzQ3MSxcbiAgbGlnaHRjeWFuOiAzNzc0ODczNTk5LFxuICBsaWdodGdvbGRlbnJvZHllbGxvdzogNDIxMDc0MjAxNSxcbiAgbGlnaHRncmF5OiAzNTUzODc0OTQzLFxuICBsaWdodGdyZWVuOiAyNDMxNTUzNzkxLFxuICBsaWdodGdyZXk6IDM1NTM4NzQ5NDMsXG4gIGxpZ2h0cGluazogNDI5MDE2NzI5NSxcbiAgbGlnaHRzYWxtb246IDQyODg3MDczMjcsXG4gIGxpZ2h0c2VhZ3JlZW46IDU0ODU4MDA5NSxcbiAgbGlnaHRza3libHVlOiAyMjc4NDg4ODMxLFxuICBsaWdodHNsYXRlZ3JheTogMjAwNTQ0MTAyMyxcbiAgbGlnaHRzbGF0ZWdyZXk6IDIwMDU0NDEwMjMsXG4gIGxpZ2h0c3RlZWxibHVlOiAyOTY1NjkyMTU5LFxuICBsaWdodHllbGxvdzogNDI5NDk1OTM1OSxcbiAgbGltZTogMTY3MTE5MzUsXG4gIGxpbWVncmVlbjogODUyMzA4NzM1LFxuICBsaW5lbjogNDIxMDA5MTc3NSxcbiAgbWFnZW50YTogNDI3ODI1NTYxNSxcbiAgbWFyb29uOiAyMTQ3NDgzOTAzLFxuICBtZWRpdW1hcXVhbWFyaW5lOiAxNzI0NzU0Njg3LFxuICBtZWRpdW1ibHVlOiA1MjczNSxcbiAgbWVkaXVtb3JjaGlkOiAzMTI2MTg3MDA3LFxuICBtZWRpdW1wdXJwbGU6IDI0NzM2NDcxMDMsXG4gIG1lZGl1bXNlYWdyZWVuOiAxMDE4MzkzMDg3LFxuICBtZWRpdW1zbGF0ZWJsdWU6IDIwNzA0NzQ0OTUsXG4gIG1lZGl1bXNwcmluZ2dyZWVuOiAxNjQyMzY3OSxcbiAgbWVkaXVtdHVycXVvaXNlOiAxMjIxNzA5MDU1LFxuICBtZWRpdW12aW9sZXRyZWQ6IDMzNDAwNzY1NDMsXG4gIG1pZG5pZ2h0Ymx1ZTogNDIxMDk3NzI3LFxuICBtaW50Y3JlYW06IDQxMjcxOTM4NTUsXG4gIG1pc3R5cm9zZTogNDI5MzE5MDE0MyxcbiAgbW9jY2FzaW46IDQyOTMxNzg4NzksXG4gIG5hdmFqb3doaXRlOiA0MjkyNzgzNjE1LFxuICBuYXZ5OiAzMzAyMyxcbiAgb2xkbGFjZTogNDI2MDc1MTEwMyxcbiAgb2xpdmU6IDIxNTU4NzI1MTEsXG4gIG9saXZlZHJhYjogMTgwNDQ3NzQzOSxcbiAgb3JhbmdlOiA0Mjg5MDAzNzc1LFxuICBvcmFuZ2VyZWQ6IDQyODI3MTIzMTksXG4gIG9yY2hpZDogMzY2NDgyODE1OSxcbiAgcGFsZWdvbGRlbnJvZDogNDAwODIyNTUzNSxcbiAgcGFsZWdyZWVuOiAyNTY2NjI1NTM1LFxuICBwYWxldHVycXVvaXNlOiAyOTUxNjcxNTUxLFxuICBwYWxldmlvbGV0cmVkOiAzNjgxNTg4MjIzLFxuICBwYXBheWF3aGlwOiA0MjkzOTA3OTY3LFxuICBwZWFjaHB1ZmY6IDQyOTI1MjQ1NDMsXG4gIHBlcnU6IDM0NDgwNjE5NTEsXG4gIHBpbms6IDQyOTA4MjUyMTUsXG4gIHBsdW06IDM3MTgzMDczMjcsXG4gIHBvd2RlcmJsdWU6IDI5Njc1MjkyMTUsXG4gIHB1cnBsZTogMjE0NzUxNjY3MSxcbiAgcmViZWNjYXB1cnBsZTogMTcxNDY1Nzc5MSxcbiAgcmVkOiA0Mjc4MTkwMzM1LFxuICByb3N5YnJvd246IDMxNjM1MjUxMTksXG4gIHJveWFsYmx1ZTogMTA5NzQ1ODE3NSxcbiAgc2FkZGxlYnJvd246IDIzMzY1NjAxMjcsXG4gIHNhbG1vbjogNDIwMjcyMjA0NyxcbiAgc2FuZHlicm93bjogNDEwNDQxMzQzOSxcbiAgc2VhZ3JlZW46IDc4MDg4Mzk2NyxcbiAgc2Vhc2hlbGw6IDQyOTQzMDc1ODMsXG4gIHNpZW5uYTogMjY4OTc0MDI4NyxcbiAgc2lsdmVyOiAzMjMzODU3NzkxLFxuICBza3libHVlOiAyMjc4NDg0OTkxLFxuICBzbGF0ZWJsdWU6IDE3ODQzMzU4NzEsXG4gIHNsYXRlZ3JheTogMTg4NzQ3MzkxOSxcbiAgc2xhdGVncmV5OiAxODg3NDczOTE5LFxuICBzbm93OiA0Mjk0NjM4MzM1LFxuICBzcHJpbmdncmVlbjogMTY3NDQ0NDcsXG4gIHN0ZWVsYmx1ZTogMTE4Mjk3MTEzNSxcbiAgdGFuOiAzNTM1MDQ3OTM1LFxuICB0ZWFsOiA4NDIxNjMxLFxuICB0aGlzdGxlOiAzNjM2NDUxNTgzLFxuICB0b21hdG86IDQyODQ2OTY1NzUsXG4gIHR1cnF1b2lzZTogMTA4ODQ3NTM5MSxcbiAgdmlvbGV0OiA0MDAxNTU4MjcxLFxuICB3aGVhdDogNDEyNTAxMjk5MSxcbiAgd2hpdGU6IDQyOTQ5NjcyOTUsXG4gIHdoaXRlc21va2U6IDQxMjY1MzcyMTUsXG4gIHllbGxvdzogNDI5NDkwMjAxNSxcbiAgeWVsbG93Z3JlZW46IDI1OTcxMzkxOTlcbn07XG5cbi8vIHNyYy92NS1mbGFnLnRzXG52YXIgRU5BQkxFX1Y1X0JSRUFLSU5HX0NIQU5HRVMgPSBmYWxzZTtcblxuLy8gc3JjL3ZhbGlkYXRlLWZyYW1lLnRzXG52YXIgdmFsaWRhdGVGcmFtZSA9ICh7XG4gIGFsbG93RmxvYXRzLFxuICBkdXJhdGlvbkluRnJhbWVzLFxuICBmcmFtZVxufSkgPT4ge1xuICBpZiAodHlwZW9mIGZyYW1lID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgQXJndW1lbnQgbWlzc2luZyBmb3IgcGFyYW1ldGVyIFwiZnJhbWVcImApO1xuICB9XG4gIGlmICh0eXBlb2YgZnJhbWUgIT09IFwibnVtYmVyXCIpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBBcmd1bWVudCBwYXNzZWQgZm9yIFwiZnJhbWVcIiBpcyBub3QgYSBudW1iZXI6ICR7ZnJhbWV9YCk7XG4gIH1cbiAgaWYgKCFOdW1iZXIuaXNGaW5pdGUoZnJhbWUpKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYEZyYW1lICR7ZnJhbWV9IGlzIG5vdCBmaW5pdGVgKTtcbiAgfVxuICBpZiAoZnJhbWUgJSAxICE9PSAwICYmICFhbGxvd0Zsb2F0cykge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGBBcmd1bWVudCBmb3IgZnJhbWUgbXVzdCBiZSBhbiBpbnRlZ2VyLCBidXQgZ290ICR7ZnJhbWV9YCk7XG4gIH1cbiAgaWYgKGZyYW1lIDwgMCAmJiBmcmFtZSA8IC1kdXJhdGlvbkluRnJhbWVzKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYENhbm5vdCB1c2UgZnJhbWUgJHtmcmFtZX06IER1cmF0aW9uIG9mIGNvbXBvc2l0aW9uIGlzICR7ZHVyYXRpb25JbkZyYW1lc30sIHRoZXJlZm9yZSB0aGUgbG93ZXN0IGZyYW1lIHRoYXQgY2FuIGJlIHJlbmRlcmVkIGlzICR7LWR1cmF0aW9uSW5GcmFtZXN9YCk7XG4gIH1cbiAgaWYgKGZyYW1lID4gZHVyYXRpb25JbkZyYW1lcyAtIDEpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgQ2Fubm90IHVzZSBmcmFtZSAke2ZyYW1lfTogRHVyYXRpb24gb2YgY29tcG9zaXRpb24gaXMgJHtkdXJhdGlvbkluRnJhbWVzfSwgdGhlcmVmb3JlIHRoZSBoaWdoZXN0IGZyYW1lIHRoYXQgY2FuIGJlIHJlbmRlcmVkIGlzICR7ZHVyYXRpb25JbkZyYW1lcyAtIDF9YCk7XG4gIH1cbn07XG5cbi8vIHNyYy92YWxpZGF0aW9uL3ZhbGlkYXRlLWRlZmF1bHQtcHJvcHMudHNcbnZhciB2YWxpZGF0ZURlZmF1bHRBbmRJbnB1dFByb3BzID0gKGRlZmF1bHRQcm9wcywgbmFtZSwgY29tcG9zaXRpb25JZCkgPT4ge1xuICBpZiAoIWRlZmF1bHRQcm9wcykge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAodHlwZW9mIGRlZmF1bHRQcm9wcyAhPT0gXCJvYmplY3RcIikge1xuICAgIHRocm93IG5ldyBFcnJvcihgXCIke25hbWV9XCIgbXVzdCBiZSBhbiBvYmplY3QsIGJ1dCB5b3UgcGFzc2VkIGEgdmFsdWUgb2YgdHlwZSAke3R5cGVvZiBkZWZhdWx0UHJvcHN9YCk7XG4gIH1cbiAgaWYgKEFycmF5LmlzQXJyYXkoZGVmYXVsdFByb3BzKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgXCIke25hbWV9XCIgbXVzdCBiZSBhbiBvYmplY3QsIGFuIGFycmF5IHdhcyBwYXNzZWQgJHtjb21wb3NpdGlvbklkID8gYGZvciBjb21wb3NpdGlvbiBcIiR7Y29tcG9zaXRpb25JZH1cImAgOiBcIlwifWApO1xuICB9XG59O1xuXG4vLyBzcmMvdmFsaWRhdGlvbi92YWxpZGF0ZS1kaW1lbnNpb25zLnRzXG5mdW5jdGlvbiB2YWxpZGF0ZURpbWVuc2lvbihhbW91bnQsIG5hbWVPZlByb3AsIGxvY2F0aW9uKSB7XG4gIGlmICh0eXBlb2YgYW1vdW50ICE9PSBcIm51bWJlclwiKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBUaGUgXCIke25hbWVPZlByb3B9XCIgcHJvcCAke2xvY2F0aW9ufSBtdXN0IGJlIGEgbnVtYmVyLCBidXQgeW91IHBhc3NlZCBhIHZhbHVlIG9mIHR5cGUgJHt0eXBlb2YgYW1vdW50fWApO1xuICB9XG4gIGlmIChpc05hTihhbW91bnQpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgVGhlIFwiJHtuYW1lT2ZQcm9wfVwiIHByb3AgJHtsb2NhdGlvbn0gbXVzdCBub3QgYmUgTmFOLCBidXQgaXMgTmFOLmApO1xuICB9XG4gIGlmICghTnVtYmVyLmlzRmluaXRlKGFtb3VudCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBUaGUgXCIke25hbWVPZlByb3B9XCIgcHJvcCAke2xvY2F0aW9ufSBtdXN0IGJlIGZpbml0ZSwgYnV0IGlzICR7YW1vdW50fS5gKTtcbiAgfVxuICBpZiAoYW1vdW50ICUgMSAhPT0gMCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFRoZSBcIiR7bmFtZU9mUHJvcH1cIiBwcm9wICR7bG9jYXRpb259IG11c3QgYmUgYW4gaW50ZWdlciwgYnV0IGlzICR7YW1vdW50fS5gKTtcbiAgfVxuICBpZiAoYW1vdW50IDw9IDApIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBUaGUgXCIke25hbWVPZlByb3B9XCIgcHJvcCAke2xvY2F0aW9ufSBtdXN0IGJlIHBvc2l0aXZlLCBidXQgZ290ICR7YW1vdW50fS5gKTtcbiAgfVxufVxuXG4vLyBzcmMvdmFsaWRhdGlvbi92YWxpZGF0ZS1kdXJhdGlvbi1pbi1mcmFtZXMudHNcbmZ1bmN0aW9uIHZhbGlkYXRlRHVyYXRpb25JbkZyYW1lcyhkdXJhdGlvbkluRnJhbWVzLCBvcHRpb25zKSB7XG4gIGNvbnN0IHsgYWxsb3dGbG9hdHMsIGNvbXBvbmVudCB9ID0gb3B0aW9ucztcbiAgaWYgKHR5cGVvZiBkdXJhdGlvbkluRnJhbWVzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBUaGUgXCJkdXJhdGlvbkluRnJhbWVzXCIgcHJvcCAke2NvbXBvbmVudH0gaXMgbWlzc2luZy5gKTtcbiAgfVxuICBpZiAodHlwZW9mIGR1cmF0aW9uSW5GcmFtZXMgIT09IFwibnVtYmVyXCIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFRoZSBcImR1cmF0aW9uSW5GcmFtZXNcIiBwcm9wICR7Y29tcG9uZW50fSBtdXN0IGJlIGEgbnVtYmVyLCBidXQgeW91IHBhc3NlZCBhIHZhbHVlIG9mIHR5cGUgJHt0eXBlb2YgZHVyYXRpb25JbkZyYW1lc31gKTtcbiAgfVxuICBpZiAoZHVyYXRpb25JbkZyYW1lcyA8PSAwKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgVGhlIFwiZHVyYXRpb25JbkZyYW1lc1wiIHByb3AgJHtjb21wb25lbnR9IG11c3QgYmUgcG9zaXRpdmUsIGJ1dCBnb3QgJHtkdXJhdGlvbkluRnJhbWVzfS5gKTtcbiAgfVxuICBpZiAoIWFsbG93RmxvYXRzICYmIGR1cmF0aW9uSW5GcmFtZXMgJSAxICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgVGhlIFwiZHVyYXRpb25JbkZyYW1lc1wiIHByb3AgJHtjb21wb25lbnR9IG11c3QgYmUgYW4gaW50ZWdlciwgYnV0IGdvdCAke2R1cmF0aW9uSW5GcmFtZXN9LmApO1xuICB9XG4gIGlmICghTnVtYmVyLmlzRmluaXRlKGR1cmF0aW9uSW5GcmFtZXMpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgVGhlIFwiZHVyYXRpb25JbkZyYW1lc1wiIHByb3AgJHtjb21wb25lbnR9IG11c3QgYmUgZmluaXRlLCBidXQgZ290ICR7ZHVyYXRpb25JbkZyYW1lc30uYCk7XG4gIH1cbn1cblxuLy8gc3JjL3ZhbGlkYXRpb24vdmFsaWRhdGUtZnBzLnRzXG5mdW5jdGlvbiB2YWxpZGF0ZUZwcyhmcHMsIGxvY2F0aW9uLCBpc0dpZikge1xuICBpZiAodHlwZW9mIGZwcyAhPT0gXCJudW1iZXJcIikge1xuICAgIHRocm93IG5ldyBFcnJvcihgXCJmcHNcIiBtdXN0IGJlIGEgbnVtYmVyLCBidXQgeW91IHBhc3NlZCBhIHZhbHVlIG9mIHR5cGUgJHt0eXBlb2YgZnBzfSAke2xvY2F0aW9ufWApO1xuICB9XG4gIGlmICghTnVtYmVyLmlzRmluaXRlKGZwcykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFwiZnBzXCIgbXVzdCBiZSBhIGZpbml0ZSwgYnV0IHlvdSBwYXNzZWQgJHtmcHN9ICR7bG9jYXRpb259YCk7XG4gIH1cbiAgaWYgKGlzTmFOKGZwcykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFwiZnBzXCIgbXVzdCBub3QgYmUgTmFOLCBidXQgZ290ICR7ZnBzfSAke2xvY2F0aW9ufWApO1xuICB9XG4gIGlmIChmcHMgPD0gMCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFwiZnBzXCIgbXVzdCBiZSBwb3NpdGl2ZSwgYnV0IGdvdCAke2Zwc30gJHtsb2NhdGlvbn1gKTtcbiAgfVxuICBpZiAoaXNHaWYgJiYgZnBzID4gNTApIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBUaGUgRlBTIGZvciBhIEdJRiBjYW5ub3QgYmUgaGlnaGVyIHRoYW4gNTAuIFVzZSB0aGUgLS1ldmVyeS1udGgtZnJhbWUgb3B0aW9uIHRvIGxvd2VyIHRoZSBGUFM6IGh0dHBzOi8vcmVtb3Rpb24uZGV2L2RvY3MvcmVuZGVyLWFzLWdpZmApO1xuICB9XG59XG5cbi8vIHNyYy92aWRlby9nZXQtY3VycmVudC10aW1lLnRzXG52YXIgZ2V0RXhwZWN0ZWRNZWRpYUZyYW1lVW5jb3JyZWN0ZWQgPSAoe1xuICBmcmFtZSxcbiAgcGxheWJhY2tSYXRlLFxuICBzdGFydEZyb21cbn0pID0+IHtcbiAgcmV0dXJuIGludGVycG9sYXRlKGZyYW1lLCBbLTEsIHN0YXJ0RnJvbSwgc3RhcnRGcm9tICsgMV0sIFstMSwgc3RhcnRGcm9tLCBzdGFydEZyb20gKyBwbGF5YmFja1JhdGVdKTtcbn07XG5cbi8vIHNyYy9hYnNvbHV0ZS1zcmMudHNcbnZhciBnZXRBYnNvbHV0ZVNyYyA9IChyZWxhdGl2ZVNyYykgPT4ge1xuICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHJldHVybiByZWxhdGl2ZVNyYztcbiAgfVxuICByZXR1cm4gbmV3IFVSTChyZWxhdGl2ZVNyYywgd2luZG93Lm9yaWdpbikuaHJlZjtcbn07XG5cbi8vIHNyYy92aWRlby9vZmZ0aHJlYWQtdmlkZW8tc291cmNlLnRzXG52YXIgZ2V0T2ZmdGhyZWFkVmlkZW9Tb3VyY2UgPSAoe1xuICBzcmMsXG4gIHRyYW5zcGFyZW50LFxuICBjdXJyZW50VGltZSxcbiAgdG9uZU1hcHBlZFxufSkgPT4ge1xuICByZXR1cm4gYGh0dHA6Ly9sb2NhbGhvc3Q6JHt3aW5kb3cucmVtb3Rpb25fcHJveHlQb3J0fS9wcm94eT9zcmM9JHtlbmNvZGVVUklDb21wb25lbnQoZ2V0QWJzb2x1dGVTcmMoc3JjKSl9JnRpbWU9JHtlbmNvZGVVUklDb21wb25lbnQoY3VycmVudFRpbWUpfSZ0cmFuc3BhcmVudD0ke1N0cmluZyh0cmFuc3BhcmVudCl9JnRvbmVNYXBwZWQ9JHtTdHJpbmcodG9uZU1hcHBlZCl9YDtcbn07XG5cbi8vIHNyYy9uby1yZWFjdC50c1xudmFyIE5vUmVhY3RJbnRlcm5hbHMgPSB7XG4gIHByb2Nlc3NDb2xvcixcbiAgdHJ1dGh5LFxuICB2YWxpZGF0ZUZwcyxcbiAgdmFsaWRhdGVEaW1lbnNpb24sXG4gIHZhbGlkYXRlRHVyYXRpb25JbkZyYW1lcyxcbiAgdmFsaWRhdGVEZWZhdWx0QW5kSW5wdXRQcm9wcyxcbiAgdmFsaWRhdGVGcmFtZSxcbiAgc2VyaWFsaXplSlNPTldpdGhEYXRlLFxuICBidW5kbGVOYW1lOiBcImJ1bmRsZS5qc1wiLFxuICBidW5kbGVNYXBOYW1lOiBcImJ1bmRsZS5qcy5tYXBcIixcbiAgZGVzZXJpYWxpemVKU09OV2l0aEN1c3RvbUZpZWxkcyxcbiAgREVMQVlfUkVOREVSX0NBTExTVEFDS19UT0tFTixcbiAgREVMQVlfUkVOREVSX1JFVFJZX1RPS0VOLFxuICBERUxBWV9SRU5ERVJfQVRURU1QVF9UT0tFTjogREVMQVlfUkVOREVSX1JFVFJJRVNfTEVGVCxcbiAgZ2V0T2ZmdGhyZWFkVmlkZW9Tb3VyY2UsXG4gIGdldEV4cGVjdGVkTWVkaWFGcmFtZVVuY29ycmVjdGVkLFxuICBFTkFCTEVfVjVfQlJFQUtJTkdfQ0hBTkdFUyxcbiAgTUlOX05PREVfVkVSU0lPTjogRU5BQkxFX1Y1X0JSRUFLSU5HX0NIQU5HRVMgPyAxOCA6IDE2LFxuICBNSU5fQlVOX1ZFUlNJT046IEVOQUJMRV9WNV9CUkVBS0lOR19DSEFOR0VTID8gXCIxLjEuM1wiIDogXCIxLjAuM1wiLFxuICBjb2xvck5hbWVzLFxuICBEQVRFX1RPS0VOLFxuICBGSUxFX1RPS0VOXG59O1xuZXhwb3J0IHtcbiAgcmFuZG9tLFxuICBpbnRlcnBvbGF0ZSxcbiAgTm9SZWFjdEludGVybmFsc1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/remotion/dist/esm/no-react.mjs\n");

/***/ })

};
;